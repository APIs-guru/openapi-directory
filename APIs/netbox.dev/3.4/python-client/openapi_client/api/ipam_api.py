# coding: utf-8

"""
    NetBox API

    API to access NetBox

    The version of the OpenAPI document: 3.4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.asn import ASN
from openapi_client.models.aggregate import Aggregate
from openapi_client.models.available_ip import AvailableIP
from openapi_client.models.available_prefix import AvailablePrefix
from openapi_client.models.available_vlan import AvailableVLAN
from openapi_client.models.fhrp_group import FHRPGroup
from openapi_client.models.fhrp_group_assignment import FHRPGroupAssignment
from openapi_client.models.ip_address import IPAddress
from openapi_client.models.ip_range import IPRange
from openapi_client.models.ipam_aggregates_list200_response import IpamAggregatesList200Response
from openapi_client.models.ipam_asns_list200_response import IpamAsnsList200Response
from openapi_client.models.ipam_fhrp_group_assignments_list200_response import IpamFhrpGroupAssignmentsList200Response
from openapi_client.models.ipam_fhrp_groups_list200_response import IpamFhrpGroupsList200Response
from openapi_client.models.ipam_ip_addresses_list200_response import IpamIpAddressesList200Response
from openapi_client.models.ipam_ip_ranges_list200_response import IpamIpRangesList200Response
from openapi_client.models.ipam_l2vpn_terminations_list200_response import IpamL2vpnTerminationsList200Response
from openapi_client.models.ipam_l2vpns_list200_response import IpamL2vpnsList200Response
from openapi_client.models.ipam_prefixes_list200_response import IpamPrefixesList200Response
from openapi_client.models.ipam_rirs_list200_response import IpamRirsList200Response
from openapi_client.models.ipam_roles_list200_response import IpamRolesList200Response
from openapi_client.models.ipam_route_targets_list200_response import IpamRouteTargetsList200Response
from openapi_client.models.ipam_service_templates_list200_response import IpamServiceTemplatesList200Response
from openapi_client.models.ipam_services_list200_response import IpamServicesList200Response
from openapi_client.models.ipam_vlan_groups_list200_response import IpamVlanGroupsList200Response
from openapi_client.models.ipam_vlans_list200_response import IpamVlansList200Response
from openapi_client.models.ipam_vrfs_list200_response import IpamVrfsList200Response
from openapi_client.models.l2_vpn import L2VPN
from openapi_client.models.l2_vpn_termination import L2VPNTermination
from openapi_client.models.prefix import Prefix
from openapi_client.models.prefix_length import PrefixLength
from openapi_client.models.rir import RIR
from openapi_client.models.role import Role
from openapi_client.models.route_target import RouteTarget
from openapi_client.models.service import Service
from openapi_client.models.service_template import ServiceTemplate
from openapi_client.models.vlan import VLAN
from openapi_client.models.vlan_group import VLANGroup
from openapi_client.models.vrf import VRF
from openapi_client.models.writable_asn import WritableASN
from openapi_client.models.writable_aggregate import WritableAggregate
from openapi_client.models.writable_available_ip import WritableAvailableIP
from openapi_client.models.writable_create_available_vlan import WritableCreateAvailableVLAN
from openapi_client.models.writable_fhrp_group_assignment import WritableFHRPGroupAssignment
from openapi_client.models.writable_ip_address import WritableIPAddress
from openapi_client.models.writable_ip_range import WritableIPRange
from openapi_client.models.writable_l2_vpn import WritableL2VPN
from openapi_client.models.writable_l2_vpn_termination import WritableL2VPNTermination
from openapi_client.models.writable_prefix import WritablePrefix
from openapi_client.models.writable_route_target import WritableRouteTarget
from openapi_client.models.writable_service import WritableService
from openapi_client.models.writable_service_template import WritableServiceTemplate
from openapi_client.models.writable_vlan import WritableVLAN
from openapi_client.models.writable_vrf import WritableVRF

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class IpamApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def ipam_aggregates_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_aggregates_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_aggregates_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_aggregates_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_aggregates_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_aggregates_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_aggregates_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/aggregates/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_aggregates_bulk_partial_update(
        self,
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Aggregate:
        """ipam_aggregates_bulk_partial_update

        

        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_bulk_partial_update_serialize(
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_aggregates_bulk_partial_update_with_http_info(
        self,
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Aggregate]:
        """ipam_aggregates_bulk_partial_update

        

        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_bulk_partial_update_serialize(
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_aggregates_bulk_partial_update_without_preload_content(
        self,
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_aggregates_bulk_partial_update

        

        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_bulk_partial_update_serialize(
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_aggregates_bulk_partial_update_serialize(
        self,
        writable_aggregate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_aggregate is not None:
            _body_params = writable_aggregate


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/aggregates/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_aggregates_bulk_update(
        self,
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Aggregate:
        """ipam_aggregates_bulk_update

        

        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_bulk_update_serialize(
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_aggregates_bulk_update_with_http_info(
        self,
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Aggregate]:
        """ipam_aggregates_bulk_update

        

        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_bulk_update_serialize(
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_aggregates_bulk_update_without_preload_content(
        self,
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_aggregates_bulk_update

        

        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_bulk_update_serialize(
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_aggregates_bulk_update_serialize(
        self,
        writable_aggregate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_aggregate is not None:
            _body_params = writable_aggregate


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/aggregates/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_aggregates_create(
        self,
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Aggregate:
        """ipam_aggregates_create

        

        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_create_serialize(
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_aggregates_create_with_http_info(
        self,
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Aggregate]:
        """ipam_aggregates_create

        

        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_create_serialize(
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_aggregates_create_without_preload_content(
        self,
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_aggregates_create

        

        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_create_serialize(
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_aggregates_create_serialize(
        self,
        writable_aggregate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_aggregate is not None:
            _body_params = writable_aggregate


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/aggregates/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_aggregates_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_aggregates_delete

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_aggregates_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_aggregates_delete

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_aggregates_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_aggregates_delete

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_aggregates_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/aggregates/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_aggregates_list(
        self,
        id: Optional[StrictStr] = None,
        date_added: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        prefix: Optional[StrictStr] = None,
        rir_id: Optional[StrictStr] = None,
        rir: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        date_added__n: Optional[StrictStr] = None,
        date_added__lte: Optional[StrictStr] = None,
        date_added__lt: Optional[StrictStr] = None,
        date_added__gte: Optional[StrictStr] = None,
        date_added__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        rir_id__n: Optional[StrictStr] = None,
        rir__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamAggregatesList200Response:
        """ipam_aggregates_list

        

        :param id: 
        :type id: str
        :param date_added: 
        :type date_added: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param family: 
        :type family: float
        :param prefix: 
        :type prefix: str
        :param rir_id: 
        :type rir_id: str
        :param rir: 
        :type rir: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param date_added__n: 
        :type date_added__n: str
        :param date_added__lte: 
        :type date_added__lte: str
        :param date_added__lt: 
        :type date_added__lt: str
        :param date_added__gte: 
        :type date_added__gte: str
        :param date_added__gt: 
        :type date_added__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param rir_id__n: 
        :type rir_id__n: str
        :param rir__n: 
        :type rir__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_list_serialize(
            id=id,
            date_added=date_added,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            family=family,
            prefix=prefix,
            rir_id=rir_id,
            rir=rir,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            date_added__n=date_added__n,
            date_added__lte=date_added__lte,
            date_added__lt=date_added__lt,
            date_added__gte=date_added__gte,
            date_added__gt=date_added__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            rir_id__n=rir_id__n,
            rir__n=rir__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamAggregatesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_aggregates_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        date_added: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        prefix: Optional[StrictStr] = None,
        rir_id: Optional[StrictStr] = None,
        rir: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        date_added__n: Optional[StrictStr] = None,
        date_added__lte: Optional[StrictStr] = None,
        date_added__lt: Optional[StrictStr] = None,
        date_added__gte: Optional[StrictStr] = None,
        date_added__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        rir_id__n: Optional[StrictStr] = None,
        rir__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamAggregatesList200Response]:
        """ipam_aggregates_list

        

        :param id: 
        :type id: str
        :param date_added: 
        :type date_added: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param family: 
        :type family: float
        :param prefix: 
        :type prefix: str
        :param rir_id: 
        :type rir_id: str
        :param rir: 
        :type rir: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param date_added__n: 
        :type date_added__n: str
        :param date_added__lte: 
        :type date_added__lte: str
        :param date_added__lt: 
        :type date_added__lt: str
        :param date_added__gte: 
        :type date_added__gte: str
        :param date_added__gt: 
        :type date_added__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param rir_id__n: 
        :type rir_id__n: str
        :param rir__n: 
        :type rir__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_list_serialize(
            id=id,
            date_added=date_added,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            family=family,
            prefix=prefix,
            rir_id=rir_id,
            rir=rir,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            date_added__n=date_added__n,
            date_added__lte=date_added__lte,
            date_added__lt=date_added__lt,
            date_added__gte=date_added__gte,
            date_added__gt=date_added__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            rir_id__n=rir_id__n,
            rir__n=rir__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamAggregatesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_aggregates_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        date_added: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        prefix: Optional[StrictStr] = None,
        rir_id: Optional[StrictStr] = None,
        rir: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        date_added__n: Optional[StrictStr] = None,
        date_added__lte: Optional[StrictStr] = None,
        date_added__lt: Optional[StrictStr] = None,
        date_added__gte: Optional[StrictStr] = None,
        date_added__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        rir_id__n: Optional[StrictStr] = None,
        rir__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_aggregates_list

        

        :param id: 
        :type id: str
        :param date_added: 
        :type date_added: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param family: 
        :type family: float
        :param prefix: 
        :type prefix: str
        :param rir_id: 
        :type rir_id: str
        :param rir: 
        :type rir: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param date_added__n: 
        :type date_added__n: str
        :param date_added__lte: 
        :type date_added__lte: str
        :param date_added__lt: 
        :type date_added__lt: str
        :param date_added__gte: 
        :type date_added__gte: str
        :param date_added__gt: 
        :type date_added__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param rir_id__n: 
        :type rir_id__n: str
        :param rir__n: 
        :type rir__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_list_serialize(
            id=id,
            date_added=date_added,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            family=family,
            prefix=prefix,
            rir_id=rir_id,
            rir=rir,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            date_added__n=date_added__n,
            date_added__lte=date_added__lte,
            date_added__lt=date_added__lt,
            date_added__gte=date_added__gte,
            date_added__gt=date_added__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            rir_id__n=rir_id__n,
            rir__n=rir__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamAggregatesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_aggregates_list_serialize(
        self,
        id,
        date_added,
        description,
        created,
        last_updated,
        q,
        tag,
        tenant_group_id,
        tenant_group,
        tenant_id,
        tenant,
        family,
        prefix,
        rir_id,
        rir,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        date_added__n,
        date_added__lte,
        date_added__lt,
        date_added__gte,
        date_added__gt,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        tenant_group_id__n,
        tenant_group__n,
        tenant_id__n,
        tenant__n,
        rir_id__n,
        rir__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if date_added is not None:
            
            _query_params.append(('date_added', date_added))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tenant_group_id is not None:
            
            _query_params.append(('tenant_group_id', tenant_group_id))
            
        if tenant_group is not None:
            
            _query_params.append(('tenant_group', tenant_group))
            
        if tenant_id is not None:
            
            _query_params.append(('tenant_id', tenant_id))
            
        if tenant is not None:
            
            _query_params.append(('tenant', tenant))
            
        if family is not None:
            
            _query_params.append(('family', family))
            
        if prefix is not None:
            
            _query_params.append(('prefix', prefix))
            
        if rir_id is not None:
            
            _query_params.append(('rir_id', rir_id))
            
        if rir is not None:
            
            _query_params.append(('rir', rir))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if date_added__n is not None:
            
            _query_params.append(('date_added__n', date_added__n))
            
        if date_added__lte is not None:
            
            _query_params.append(('date_added__lte', date_added__lte))
            
        if date_added__lt is not None:
            
            _query_params.append(('date_added__lt', date_added__lt))
            
        if date_added__gte is not None:
            
            _query_params.append(('date_added__gte', date_added__gte))
            
        if date_added__gt is not None:
            
            _query_params.append(('date_added__gt', date_added__gt))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if tenant_group_id__n is not None:
            
            _query_params.append(('tenant_group_id__n', tenant_group_id__n))
            
        if tenant_group__n is not None:
            
            _query_params.append(('tenant_group__n', tenant_group__n))
            
        if tenant_id__n is not None:
            
            _query_params.append(('tenant_id__n', tenant_id__n))
            
        if tenant__n is not None:
            
            _query_params.append(('tenant__n', tenant__n))
            
        if rir_id__n is not None:
            
            _query_params.append(('rir_id__n', rir_id__n))
            
        if rir__n is not None:
            
            _query_params.append(('rir__n', rir__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/aggregates/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_aggregates_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Aggregate:
        """ipam_aggregates_partial_update

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_partial_update_serialize(
            id=id,
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_aggregates_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Aggregate]:
        """ipam_aggregates_partial_update

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_partial_update_serialize(
            id=id,
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_aggregates_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_aggregates_partial_update

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_partial_update_serialize(
            id=id,
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_aggregates_partial_update_serialize(
        self,
        id,
        writable_aggregate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_aggregate is not None:
            _body_params = writable_aggregate


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/aggregates/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_aggregates_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Aggregate:
        """ipam_aggregates_read

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_aggregates_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Aggregate]:
        """ipam_aggregates_read

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_aggregates_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_aggregates_read

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_aggregates_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/aggregates/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_aggregates_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Aggregate:
        """ipam_aggregates_update

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_update_serialize(
            id=id,
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_aggregates_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Aggregate]:
        """ipam_aggregates_update

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_update_serialize(
            id=id,
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_aggregates_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this aggregate.")],
        writable_aggregate: WritableAggregate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_aggregates_update

        

        :param id: A unique integer value identifying this aggregate. (required)
        :type id: int
        :param writable_aggregate: (required)
        :type writable_aggregate: WritableAggregate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_aggregates_update_serialize(
            id=id,
            writable_aggregate=writable_aggregate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Aggregate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_aggregates_update_serialize(
        self,
        id,
        writable_aggregate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_aggregate is not None:
            _body_params = writable_aggregate


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/aggregates/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_asns_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_asns_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_asns_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_asns_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_asns_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_asns_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_asns_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/asns/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_asns_bulk_partial_update(
        self,
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ASN:
        """ipam_asns_bulk_partial_update

        

        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_bulk_partial_update_serialize(
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_asns_bulk_partial_update_with_http_info(
        self,
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ASN]:
        """ipam_asns_bulk_partial_update

        

        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_bulk_partial_update_serialize(
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_asns_bulk_partial_update_without_preload_content(
        self,
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_asns_bulk_partial_update

        

        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_bulk_partial_update_serialize(
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_asns_bulk_partial_update_serialize(
        self,
        writable_asn,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_asn is not None:
            _body_params = writable_asn


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/asns/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_asns_bulk_update(
        self,
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ASN:
        """ipam_asns_bulk_update

        

        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_bulk_update_serialize(
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_asns_bulk_update_with_http_info(
        self,
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ASN]:
        """ipam_asns_bulk_update

        

        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_bulk_update_serialize(
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_asns_bulk_update_without_preload_content(
        self,
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_asns_bulk_update

        

        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_bulk_update_serialize(
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_asns_bulk_update_serialize(
        self,
        writable_asn,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_asn is not None:
            _body_params = writable_asn


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/asns/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_asns_create(
        self,
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ASN:
        """ipam_asns_create

        

        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_create_serialize(
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_asns_create_with_http_info(
        self,
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ASN]:
        """ipam_asns_create

        

        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_create_serialize(
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_asns_create_without_preload_content(
        self,
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_asns_create

        

        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_create_serialize(
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_asns_create_serialize(
        self,
        writable_asn,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_asn is not None:
            _body_params = writable_asn


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/asns/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_asns_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_asns_delete

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_asns_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_asns_delete

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_asns_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_asns_delete

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_asns_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/asns/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_asns_list(
        self,
        id: Optional[StrictStr] = None,
        asn: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        rir_id: Optional[StrictStr] = None,
        rir: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        asn__n: Optional[StrictStr] = None,
        asn__lte: Optional[StrictStr] = None,
        asn__lt: Optional[StrictStr] = None,
        asn__gte: Optional[StrictStr] = None,
        asn__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        rir_id__n: Optional[StrictStr] = None,
        rir__n: Optional[StrictStr] = None,
        site_id__n: Optional[StrictStr] = None,
        site__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamAsnsList200Response:
        """ipam_asns_list

        

        :param id: 
        :type id: str
        :param asn: 
        :type asn: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param rir_id: 
        :type rir_id: str
        :param rir: 
        :type rir: str
        :param site_id: 
        :type site_id: str
        :param site: 
        :type site: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param asn__n: 
        :type asn__n: str
        :param asn__lte: 
        :type asn__lte: str
        :param asn__lt: 
        :type asn__lt: str
        :param asn__gte: 
        :type asn__gte: str
        :param asn__gt: 
        :type asn__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param rir_id__n: 
        :type rir_id__n: str
        :param rir__n: 
        :type rir__n: str
        :param site_id__n: 
        :type site_id__n: str
        :param site__n: 
        :type site__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_list_serialize(
            id=id,
            asn=asn,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            rir_id=rir_id,
            rir=rir,
            site_id=site_id,
            site=site,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            asn__n=asn__n,
            asn__lte=asn__lte,
            asn__lt=asn__lt,
            asn__gte=asn__gte,
            asn__gt=asn__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            rir_id__n=rir_id__n,
            rir__n=rir__n,
            site_id__n=site_id__n,
            site__n=site__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamAsnsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_asns_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        asn: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        rir_id: Optional[StrictStr] = None,
        rir: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        asn__n: Optional[StrictStr] = None,
        asn__lte: Optional[StrictStr] = None,
        asn__lt: Optional[StrictStr] = None,
        asn__gte: Optional[StrictStr] = None,
        asn__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        rir_id__n: Optional[StrictStr] = None,
        rir__n: Optional[StrictStr] = None,
        site_id__n: Optional[StrictStr] = None,
        site__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamAsnsList200Response]:
        """ipam_asns_list

        

        :param id: 
        :type id: str
        :param asn: 
        :type asn: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param rir_id: 
        :type rir_id: str
        :param rir: 
        :type rir: str
        :param site_id: 
        :type site_id: str
        :param site: 
        :type site: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param asn__n: 
        :type asn__n: str
        :param asn__lte: 
        :type asn__lte: str
        :param asn__lt: 
        :type asn__lt: str
        :param asn__gte: 
        :type asn__gte: str
        :param asn__gt: 
        :type asn__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param rir_id__n: 
        :type rir_id__n: str
        :param rir__n: 
        :type rir__n: str
        :param site_id__n: 
        :type site_id__n: str
        :param site__n: 
        :type site__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_list_serialize(
            id=id,
            asn=asn,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            rir_id=rir_id,
            rir=rir,
            site_id=site_id,
            site=site,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            asn__n=asn__n,
            asn__lte=asn__lte,
            asn__lt=asn__lt,
            asn__gte=asn__gte,
            asn__gt=asn__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            rir_id__n=rir_id__n,
            rir__n=rir__n,
            site_id__n=site_id__n,
            site__n=site__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamAsnsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_asns_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        asn: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        rir_id: Optional[StrictStr] = None,
        rir: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        asn__n: Optional[StrictStr] = None,
        asn__lte: Optional[StrictStr] = None,
        asn__lt: Optional[StrictStr] = None,
        asn__gte: Optional[StrictStr] = None,
        asn__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        rir_id__n: Optional[StrictStr] = None,
        rir__n: Optional[StrictStr] = None,
        site_id__n: Optional[StrictStr] = None,
        site__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_asns_list

        

        :param id: 
        :type id: str
        :param asn: 
        :type asn: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param rir_id: 
        :type rir_id: str
        :param rir: 
        :type rir: str
        :param site_id: 
        :type site_id: str
        :param site: 
        :type site: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param asn__n: 
        :type asn__n: str
        :param asn__lte: 
        :type asn__lte: str
        :param asn__lt: 
        :type asn__lt: str
        :param asn__gte: 
        :type asn__gte: str
        :param asn__gt: 
        :type asn__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param rir_id__n: 
        :type rir_id__n: str
        :param rir__n: 
        :type rir__n: str
        :param site_id__n: 
        :type site_id__n: str
        :param site__n: 
        :type site__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_list_serialize(
            id=id,
            asn=asn,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            rir_id=rir_id,
            rir=rir,
            site_id=site_id,
            site=site,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            asn__n=asn__n,
            asn__lte=asn__lte,
            asn__lt=asn__lt,
            asn__gte=asn__gte,
            asn__gt=asn__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            rir_id__n=rir_id__n,
            rir__n=rir__n,
            site_id__n=site_id__n,
            site__n=site__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamAsnsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_asns_list_serialize(
        self,
        id,
        asn,
        description,
        created,
        last_updated,
        q,
        tag,
        tenant_group_id,
        tenant_group,
        tenant_id,
        tenant,
        rir_id,
        rir,
        site_id,
        site,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        asn__n,
        asn__lte,
        asn__lt,
        asn__gte,
        asn__gt,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        tenant_group_id__n,
        tenant_group__n,
        tenant_id__n,
        tenant__n,
        rir_id__n,
        rir__n,
        site_id__n,
        site__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if asn is not None:
            
            _query_params.append(('asn', asn))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tenant_group_id is not None:
            
            _query_params.append(('tenant_group_id', tenant_group_id))
            
        if tenant_group is not None:
            
            _query_params.append(('tenant_group', tenant_group))
            
        if tenant_id is not None:
            
            _query_params.append(('tenant_id', tenant_id))
            
        if tenant is not None:
            
            _query_params.append(('tenant', tenant))
            
        if rir_id is not None:
            
            _query_params.append(('rir_id', rir_id))
            
        if rir is not None:
            
            _query_params.append(('rir', rir))
            
        if site_id is not None:
            
            _query_params.append(('site_id', site_id))
            
        if site is not None:
            
            _query_params.append(('site', site))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if asn__n is not None:
            
            _query_params.append(('asn__n', asn__n))
            
        if asn__lte is not None:
            
            _query_params.append(('asn__lte', asn__lte))
            
        if asn__lt is not None:
            
            _query_params.append(('asn__lt', asn__lt))
            
        if asn__gte is not None:
            
            _query_params.append(('asn__gte', asn__gte))
            
        if asn__gt is not None:
            
            _query_params.append(('asn__gt', asn__gt))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if tenant_group_id__n is not None:
            
            _query_params.append(('tenant_group_id__n', tenant_group_id__n))
            
        if tenant_group__n is not None:
            
            _query_params.append(('tenant_group__n', tenant_group__n))
            
        if tenant_id__n is not None:
            
            _query_params.append(('tenant_id__n', tenant_id__n))
            
        if tenant__n is not None:
            
            _query_params.append(('tenant__n', tenant__n))
            
        if rir_id__n is not None:
            
            _query_params.append(('rir_id__n', rir_id__n))
            
        if rir__n is not None:
            
            _query_params.append(('rir__n', rir__n))
            
        if site_id__n is not None:
            
            _query_params.append(('site_id__n', site_id__n))
            
        if site__n is not None:
            
            _query_params.append(('site__n', site__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/asns/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_asns_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ASN:
        """ipam_asns_partial_update

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_partial_update_serialize(
            id=id,
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_asns_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ASN]:
        """ipam_asns_partial_update

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_partial_update_serialize(
            id=id,
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_asns_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_asns_partial_update

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_partial_update_serialize(
            id=id,
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_asns_partial_update_serialize(
        self,
        id,
        writable_asn,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_asn is not None:
            _body_params = writable_asn


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/asns/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_asns_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ASN:
        """ipam_asns_read

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_asns_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ASN]:
        """ipam_asns_read

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_asns_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_asns_read

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_asns_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/asns/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_asns_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ASN:
        """ipam_asns_update

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_update_serialize(
            id=id,
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_asns_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ASN]:
        """ipam_asns_update

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_update_serialize(
            id=id,
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_asns_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this ASN.")],
        writable_asn: WritableASN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_asns_update

        

        :param id: A unique integer value identifying this ASN. (required)
        :type id: int
        :param writable_asn: (required)
        :type writable_asn: WritableASN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_asns_update_serialize(
            id=id,
            writable_asn=writable_asn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ASN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_asns_update_serialize(
        self,
        id,
        writable_asn,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_asn is not None:
            _body_params = writable_asn


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/asns/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_group_assignments_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_fhrp_group_assignments_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_group_assignments_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_fhrp_group_assignments_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_group_assignments_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_group_assignments_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_group_assignments_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/fhrp-group-assignments/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_group_assignments_bulk_partial_update(
        self,
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroupAssignment:
        """ipam_fhrp_group_assignments_bulk_partial_update

        

        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_bulk_partial_update_serialize(
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_group_assignments_bulk_partial_update_with_http_info(
        self,
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroupAssignment]:
        """ipam_fhrp_group_assignments_bulk_partial_update

        

        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_bulk_partial_update_serialize(
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_group_assignments_bulk_partial_update_without_preload_content(
        self,
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_group_assignments_bulk_partial_update

        

        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_bulk_partial_update_serialize(
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_group_assignments_bulk_partial_update_serialize(
        self,
        writable_fhrp_group_assignment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_fhrp_group_assignment is not None:
            _body_params = writable_fhrp_group_assignment


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/fhrp-group-assignments/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_group_assignments_bulk_update(
        self,
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroupAssignment:
        """ipam_fhrp_group_assignments_bulk_update

        

        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_bulk_update_serialize(
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_group_assignments_bulk_update_with_http_info(
        self,
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroupAssignment]:
        """ipam_fhrp_group_assignments_bulk_update

        

        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_bulk_update_serialize(
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_group_assignments_bulk_update_without_preload_content(
        self,
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_group_assignments_bulk_update

        

        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_bulk_update_serialize(
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_group_assignments_bulk_update_serialize(
        self,
        writable_fhrp_group_assignment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_fhrp_group_assignment is not None:
            _body_params = writable_fhrp_group_assignment


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/fhrp-group-assignments/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_group_assignments_create(
        self,
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroupAssignment:
        """ipam_fhrp_group_assignments_create

        

        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_create_serialize(
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_group_assignments_create_with_http_info(
        self,
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroupAssignment]:
        """ipam_fhrp_group_assignments_create

        

        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_create_serialize(
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_group_assignments_create_without_preload_content(
        self,
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_group_assignments_create

        

        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_create_serialize(
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_group_assignments_create_serialize(
        self,
        writable_fhrp_group_assignment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_fhrp_group_assignment is not None:
            _body_params = writable_fhrp_group_assignment


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/fhrp-group-assignments/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_group_assignments_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_fhrp_group_assignments_delete

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_group_assignments_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_fhrp_group_assignments_delete

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_group_assignments_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_group_assignments_delete

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_group_assignments_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/fhrp-group-assignments/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_group_assignments_list(
        self,
        id: Optional[StrictStr] = None,
        group_id: Optional[StrictStr] = None,
        interface_type: Optional[StrictStr] = None,
        interface_id: Optional[StrictStr] = None,
        priority: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        group_id__n: Optional[StrictStr] = None,
        interface_type__n: Optional[StrictStr] = None,
        interface_id__n: Optional[StrictStr] = None,
        interface_id__lte: Optional[StrictStr] = None,
        interface_id__lt: Optional[StrictStr] = None,
        interface_id__gte: Optional[StrictStr] = None,
        interface_id__gt: Optional[StrictStr] = None,
        priority__n: Optional[StrictStr] = None,
        priority__lte: Optional[StrictStr] = None,
        priority__lt: Optional[StrictStr] = None,
        priority__gte: Optional[StrictStr] = None,
        priority__gt: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamFhrpGroupAssignmentsList200Response:
        """ipam_fhrp_group_assignments_list

        

        :param id: 
        :type id: str
        :param group_id: 
        :type group_id: str
        :param interface_type: 
        :type interface_type: str
        :param interface_id: 
        :type interface_id: str
        :param priority: 
        :type priority: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param device: 
        :type device: str
        :param device_id: 
        :type device_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param group_id__n: 
        :type group_id__n: str
        :param interface_type__n: 
        :type interface_type__n: str
        :param interface_id__n: 
        :type interface_id__n: str
        :param interface_id__lte: 
        :type interface_id__lte: str
        :param interface_id__lt: 
        :type interface_id__lt: str
        :param interface_id__gte: 
        :type interface_id__gte: str
        :param interface_id__gt: 
        :type interface_id__gt: str
        :param priority__n: 
        :type priority__n: str
        :param priority__lte: 
        :type priority__lte: str
        :param priority__lt: 
        :type priority__lt: str
        :param priority__gte: 
        :type priority__gte: str
        :param priority__gt: 
        :type priority__gt: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_list_serialize(
            id=id,
            group_id=group_id,
            interface_type=interface_type,
            interface_id=interface_id,
            priority=priority,
            created=created,
            last_updated=last_updated,
            device=device,
            device_id=device_id,
            virtual_machine=virtual_machine,
            virtual_machine_id=virtual_machine_id,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            group_id__n=group_id__n,
            interface_type__n=interface_type__n,
            interface_id__n=interface_id__n,
            interface_id__lte=interface_id__lte,
            interface_id__lt=interface_id__lt,
            interface_id__gte=interface_id__gte,
            interface_id__gt=interface_id__gt,
            priority__n=priority__n,
            priority__lte=priority__lte,
            priority__lt=priority__lt,
            priority__gte=priority__gte,
            priority__gt=priority__gt,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamFhrpGroupAssignmentsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_group_assignments_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        group_id: Optional[StrictStr] = None,
        interface_type: Optional[StrictStr] = None,
        interface_id: Optional[StrictStr] = None,
        priority: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        group_id__n: Optional[StrictStr] = None,
        interface_type__n: Optional[StrictStr] = None,
        interface_id__n: Optional[StrictStr] = None,
        interface_id__lte: Optional[StrictStr] = None,
        interface_id__lt: Optional[StrictStr] = None,
        interface_id__gte: Optional[StrictStr] = None,
        interface_id__gt: Optional[StrictStr] = None,
        priority__n: Optional[StrictStr] = None,
        priority__lte: Optional[StrictStr] = None,
        priority__lt: Optional[StrictStr] = None,
        priority__gte: Optional[StrictStr] = None,
        priority__gt: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamFhrpGroupAssignmentsList200Response]:
        """ipam_fhrp_group_assignments_list

        

        :param id: 
        :type id: str
        :param group_id: 
        :type group_id: str
        :param interface_type: 
        :type interface_type: str
        :param interface_id: 
        :type interface_id: str
        :param priority: 
        :type priority: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param device: 
        :type device: str
        :param device_id: 
        :type device_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param group_id__n: 
        :type group_id__n: str
        :param interface_type__n: 
        :type interface_type__n: str
        :param interface_id__n: 
        :type interface_id__n: str
        :param interface_id__lte: 
        :type interface_id__lte: str
        :param interface_id__lt: 
        :type interface_id__lt: str
        :param interface_id__gte: 
        :type interface_id__gte: str
        :param interface_id__gt: 
        :type interface_id__gt: str
        :param priority__n: 
        :type priority__n: str
        :param priority__lte: 
        :type priority__lte: str
        :param priority__lt: 
        :type priority__lt: str
        :param priority__gte: 
        :type priority__gte: str
        :param priority__gt: 
        :type priority__gt: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_list_serialize(
            id=id,
            group_id=group_id,
            interface_type=interface_type,
            interface_id=interface_id,
            priority=priority,
            created=created,
            last_updated=last_updated,
            device=device,
            device_id=device_id,
            virtual_machine=virtual_machine,
            virtual_machine_id=virtual_machine_id,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            group_id__n=group_id__n,
            interface_type__n=interface_type__n,
            interface_id__n=interface_id__n,
            interface_id__lte=interface_id__lte,
            interface_id__lt=interface_id__lt,
            interface_id__gte=interface_id__gte,
            interface_id__gt=interface_id__gt,
            priority__n=priority__n,
            priority__lte=priority__lte,
            priority__lt=priority__lt,
            priority__gte=priority__gte,
            priority__gt=priority__gt,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamFhrpGroupAssignmentsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_group_assignments_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        group_id: Optional[StrictStr] = None,
        interface_type: Optional[StrictStr] = None,
        interface_id: Optional[StrictStr] = None,
        priority: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        group_id__n: Optional[StrictStr] = None,
        interface_type__n: Optional[StrictStr] = None,
        interface_id__n: Optional[StrictStr] = None,
        interface_id__lte: Optional[StrictStr] = None,
        interface_id__lt: Optional[StrictStr] = None,
        interface_id__gte: Optional[StrictStr] = None,
        interface_id__gt: Optional[StrictStr] = None,
        priority__n: Optional[StrictStr] = None,
        priority__lte: Optional[StrictStr] = None,
        priority__lt: Optional[StrictStr] = None,
        priority__gte: Optional[StrictStr] = None,
        priority__gt: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_group_assignments_list

        

        :param id: 
        :type id: str
        :param group_id: 
        :type group_id: str
        :param interface_type: 
        :type interface_type: str
        :param interface_id: 
        :type interface_id: str
        :param priority: 
        :type priority: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param device: 
        :type device: str
        :param device_id: 
        :type device_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param group_id__n: 
        :type group_id__n: str
        :param interface_type__n: 
        :type interface_type__n: str
        :param interface_id__n: 
        :type interface_id__n: str
        :param interface_id__lte: 
        :type interface_id__lte: str
        :param interface_id__lt: 
        :type interface_id__lt: str
        :param interface_id__gte: 
        :type interface_id__gte: str
        :param interface_id__gt: 
        :type interface_id__gt: str
        :param priority__n: 
        :type priority__n: str
        :param priority__lte: 
        :type priority__lte: str
        :param priority__lt: 
        :type priority__lt: str
        :param priority__gte: 
        :type priority__gte: str
        :param priority__gt: 
        :type priority__gt: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_list_serialize(
            id=id,
            group_id=group_id,
            interface_type=interface_type,
            interface_id=interface_id,
            priority=priority,
            created=created,
            last_updated=last_updated,
            device=device,
            device_id=device_id,
            virtual_machine=virtual_machine,
            virtual_machine_id=virtual_machine_id,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            group_id__n=group_id__n,
            interface_type__n=interface_type__n,
            interface_id__n=interface_id__n,
            interface_id__lte=interface_id__lte,
            interface_id__lt=interface_id__lt,
            interface_id__gte=interface_id__gte,
            interface_id__gt=interface_id__gt,
            priority__n=priority__n,
            priority__lte=priority__lte,
            priority__lt=priority__lt,
            priority__gte=priority__gte,
            priority__gt=priority__gt,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamFhrpGroupAssignmentsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_group_assignments_list_serialize(
        self,
        id,
        group_id,
        interface_type,
        interface_id,
        priority,
        created,
        last_updated,
        device,
        device_id,
        virtual_machine,
        virtual_machine_id,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        group_id__n,
        interface_type__n,
        interface_id__n,
        interface_id__lte,
        interface_id__lt,
        interface_id__gte,
        interface_id__gt,
        priority__n,
        priority__lte,
        priority__lt,
        priority__gte,
        priority__gt,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if group_id is not None:
            
            _query_params.append(('group_id', group_id))
            
        if interface_type is not None:
            
            _query_params.append(('interface_type', interface_type))
            
        if interface_id is not None:
            
            _query_params.append(('interface_id', interface_id))
            
        if priority is not None:
            
            _query_params.append(('priority', priority))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if device is not None:
            
            _query_params.append(('device', device))
            
        if device_id is not None:
            
            _query_params.append(('device_id', device_id))
            
        if virtual_machine is not None:
            
            _query_params.append(('virtual_machine', virtual_machine))
            
        if virtual_machine_id is not None:
            
            _query_params.append(('virtual_machine_id', virtual_machine_id))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if group_id__n is not None:
            
            _query_params.append(('group_id__n', group_id__n))
            
        if interface_type__n is not None:
            
            _query_params.append(('interface_type__n', interface_type__n))
            
        if interface_id__n is not None:
            
            _query_params.append(('interface_id__n', interface_id__n))
            
        if interface_id__lte is not None:
            
            _query_params.append(('interface_id__lte', interface_id__lte))
            
        if interface_id__lt is not None:
            
            _query_params.append(('interface_id__lt', interface_id__lt))
            
        if interface_id__gte is not None:
            
            _query_params.append(('interface_id__gte', interface_id__gte))
            
        if interface_id__gt is not None:
            
            _query_params.append(('interface_id__gt', interface_id__gt))
            
        if priority__n is not None:
            
            _query_params.append(('priority__n', priority__n))
            
        if priority__lte is not None:
            
            _query_params.append(('priority__lte', priority__lte))
            
        if priority__lt is not None:
            
            _query_params.append(('priority__lt', priority__lt))
            
        if priority__gte is not None:
            
            _query_params.append(('priority__gte', priority__gte))
            
        if priority__gt is not None:
            
            _query_params.append(('priority__gt', priority__gt))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/fhrp-group-assignments/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_group_assignments_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroupAssignment:
        """ipam_fhrp_group_assignments_partial_update

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_partial_update_serialize(
            id=id,
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_group_assignments_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroupAssignment]:
        """ipam_fhrp_group_assignments_partial_update

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_partial_update_serialize(
            id=id,
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_group_assignments_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_group_assignments_partial_update

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_partial_update_serialize(
            id=id,
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_group_assignments_partial_update_serialize(
        self,
        id,
        writable_fhrp_group_assignment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_fhrp_group_assignment is not None:
            _body_params = writable_fhrp_group_assignment


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/fhrp-group-assignments/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_group_assignments_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroupAssignment:
        """ipam_fhrp_group_assignments_read

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_group_assignments_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroupAssignment]:
        """ipam_fhrp_group_assignments_read

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_group_assignments_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_group_assignments_read

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_group_assignments_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/fhrp-group-assignments/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_group_assignments_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroupAssignment:
        """ipam_fhrp_group_assignments_update

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_update_serialize(
            id=id,
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_group_assignments_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroupAssignment]:
        """ipam_fhrp_group_assignments_update

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_update_serialize(
            id=id,
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_group_assignments_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group assignment.")],
        writable_fhrp_group_assignment: WritableFHRPGroupAssignment,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_group_assignments_update

        

        :param id: A unique integer value identifying this FHRP group assignment. (required)
        :type id: int
        :param writable_fhrp_group_assignment: (required)
        :type writable_fhrp_group_assignment: WritableFHRPGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_group_assignments_update_serialize(
            id=id,
            writable_fhrp_group_assignment=writable_fhrp_group_assignment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroupAssignment",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_group_assignments_update_serialize(
        self,
        id,
        writable_fhrp_group_assignment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_fhrp_group_assignment is not None:
            _body_params = writable_fhrp_group_assignment


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/fhrp-group-assignments/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_groups_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_fhrp_groups_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_groups_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_fhrp_groups_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_groups_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_groups_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_groups_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/fhrp-groups/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_groups_bulk_partial_update(
        self,
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroup:
        """ipam_fhrp_groups_bulk_partial_update

        

        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_bulk_partial_update_serialize(
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_groups_bulk_partial_update_with_http_info(
        self,
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroup]:
        """ipam_fhrp_groups_bulk_partial_update

        

        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_bulk_partial_update_serialize(
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_groups_bulk_partial_update_without_preload_content(
        self,
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_groups_bulk_partial_update

        

        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_bulk_partial_update_serialize(
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_groups_bulk_partial_update_serialize(
        self,
        fhrp_group,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if fhrp_group is not None:
            _body_params = fhrp_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/fhrp-groups/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_groups_bulk_update(
        self,
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroup:
        """ipam_fhrp_groups_bulk_update

        

        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_bulk_update_serialize(
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_groups_bulk_update_with_http_info(
        self,
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroup]:
        """ipam_fhrp_groups_bulk_update

        

        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_bulk_update_serialize(
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_groups_bulk_update_without_preload_content(
        self,
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_groups_bulk_update

        

        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_bulk_update_serialize(
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_groups_bulk_update_serialize(
        self,
        fhrp_group,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if fhrp_group is not None:
            _body_params = fhrp_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/fhrp-groups/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_groups_create(
        self,
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroup:
        """ipam_fhrp_groups_create

        

        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_create_serialize(
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_groups_create_with_http_info(
        self,
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroup]:
        """ipam_fhrp_groups_create

        

        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_create_serialize(
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_groups_create_without_preload_content(
        self,
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_groups_create

        

        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_create_serialize(
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_groups_create_serialize(
        self,
        fhrp_group,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if fhrp_group is not None:
            _body_params = fhrp_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/fhrp-groups/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_groups_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_fhrp_groups_delete

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_groups_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_fhrp_groups_delete

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_groups_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_groups_delete

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_groups_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/fhrp-groups/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_groups_list(
        self,
        id: Optional[StrictStr] = None,
        group_id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        auth_key: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        protocol: Optional[StrictStr] = None,
        auth_type: Optional[StrictStr] = None,
        related_ip: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        group_id__n: Optional[StrictStr] = None,
        group_id__lte: Optional[StrictStr] = None,
        group_id__lt: Optional[StrictStr] = None,
        group_id__gte: Optional[StrictStr] = None,
        group_id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        auth_key__n: Optional[StrictStr] = None,
        auth_key__ic: Optional[StrictStr] = None,
        auth_key__nic: Optional[StrictStr] = None,
        auth_key__iew: Optional[StrictStr] = None,
        auth_key__niew: Optional[StrictStr] = None,
        auth_key__isw: Optional[StrictStr] = None,
        auth_key__nisw: Optional[StrictStr] = None,
        auth_key__ie: Optional[StrictStr] = None,
        auth_key__nie: Optional[StrictStr] = None,
        auth_key__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        protocol__n: Optional[StrictStr] = None,
        auth_type__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamFhrpGroupsList200Response:
        """ipam_fhrp_groups_list

        

        :param id: 
        :type id: str
        :param group_id: 
        :type group_id: str
        :param name: 
        :type name: str
        :param auth_key: 
        :type auth_key: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param protocol: 
        :type protocol: str
        :param auth_type: 
        :type auth_type: str
        :param related_ip: 
        :type related_ip: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param group_id__n: 
        :type group_id__n: str
        :param group_id__lte: 
        :type group_id__lte: str
        :param group_id__lt: 
        :type group_id__lt: str
        :param group_id__gte: 
        :type group_id__gte: str
        :param group_id__gt: 
        :type group_id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param auth_key__n: 
        :type auth_key__n: str
        :param auth_key__ic: 
        :type auth_key__ic: str
        :param auth_key__nic: 
        :type auth_key__nic: str
        :param auth_key__iew: 
        :type auth_key__iew: str
        :param auth_key__niew: 
        :type auth_key__niew: str
        :param auth_key__isw: 
        :type auth_key__isw: str
        :param auth_key__nisw: 
        :type auth_key__nisw: str
        :param auth_key__ie: 
        :type auth_key__ie: str
        :param auth_key__nie: 
        :type auth_key__nie: str
        :param auth_key__empty: 
        :type auth_key__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param protocol__n: 
        :type protocol__n: str
        :param auth_type__n: 
        :type auth_type__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_list_serialize(
            id=id,
            group_id=group_id,
            name=name,
            auth_key=auth_key,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            protocol=protocol,
            auth_type=auth_type,
            related_ip=related_ip,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            group_id__n=group_id__n,
            group_id__lte=group_id__lte,
            group_id__lt=group_id__lt,
            group_id__gte=group_id__gte,
            group_id__gt=group_id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            auth_key__n=auth_key__n,
            auth_key__ic=auth_key__ic,
            auth_key__nic=auth_key__nic,
            auth_key__iew=auth_key__iew,
            auth_key__niew=auth_key__niew,
            auth_key__isw=auth_key__isw,
            auth_key__nisw=auth_key__nisw,
            auth_key__ie=auth_key__ie,
            auth_key__nie=auth_key__nie,
            auth_key__empty=auth_key__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            protocol__n=protocol__n,
            auth_type__n=auth_type__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamFhrpGroupsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_groups_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        group_id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        auth_key: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        protocol: Optional[StrictStr] = None,
        auth_type: Optional[StrictStr] = None,
        related_ip: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        group_id__n: Optional[StrictStr] = None,
        group_id__lte: Optional[StrictStr] = None,
        group_id__lt: Optional[StrictStr] = None,
        group_id__gte: Optional[StrictStr] = None,
        group_id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        auth_key__n: Optional[StrictStr] = None,
        auth_key__ic: Optional[StrictStr] = None,
        auth_key__nic: Optional[StrictStr] = None,
        auth_key__iew: Optional[StrictStr] = None,
        auth_key__niew: Optional[StrictStr] = None,
        auth_key__isw: Optional[StrictStr] = None,
        auth_key__nisw: Optional[StrictStr] = None,
        auth_key__ie: Optional[StrictStr] = None,
        auth_key__nie: Optional[StrictStr] = None,
        auth_key__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        protocol__n: Optional[StrictStr] = None,
        auth_type__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamFhrpGroupsList200Response]:
        """ipam_fhrp_groups_list

        

        :param id: 
        :type id: str
        :param group_id: 
        :type group_id: str
        :param name: 
        :type name: str
        :param auth_key: 
        :type auth_key: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param protocol: 
        :type protocol: str
        :param auth_type: 
        :type auth_type: str
        :param related_ip: 
        :type related_ip: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param group_id__n: 
        :type group_id__n: str
        :param group_id__lte: 
        :type group_id__lte: str
        :param group_id__lt: 
        :type group_id__lt: str
        :param group_id__gte: 
        :type group_id__gte: str
        :param group_id__gt: 
        :type group_id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param auth_key__n: 
        :type auth_key__n: str
        :param auth_key__ic: 
        :type auth_key__ic: str
        :param auth_key__nic: 
        :type auth_key__nic: str
        :param auth_key__iew: 
        :type auth_key__iew: str
        :param auth_key__niew: 
        :type auth_key__niew: str
        :param auth_key__isw: 
        :type auth_key__isw: str
        :param auth_key__nisw: 
        :type auth_key__nisw: str
        :param auth_key__ie: 
        :type auth_key__ie: str
        :param auth_key__nie: 
        :type auth_key__nie: str
        :param auth_key__empty: 
        :type auth_key__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param protocol__n: 
        :type protocol__n: str
        :param auth_type__n: 
        :type auth_type__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_list_serialize(
            id=id,
            group_id=group_id,
            name=name,
            auth_key=auth_key,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            protocol=protocol,
            auth_type=auth_type,
            related_ip=related_ip,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            group_id__n=group_id__n,
            group_id__lte=group_id__lte,
            group_id__lt=group_id__lt,
            group_id__gte=group_id__gte,
            group_id__gt=group_id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            auth_key__n=auth_key__n,
            auth_key__ic=auth_key__ic,
            auth_key__nic=auth_key__nic,
            auth_key__iew=auth_key__iew,
            auth_key__niew=auth_key__niew,
            auth_key__isw=auth_key__isw,
            auth_key__nisw=auth_key__nisw,
            auth_key__ie=auth_key__ie,
            auth_key__nie=auth_key__nie,
            auth_key__empty=auth_key__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            protocol__n=protocol__n,
            auth_type__n=auth_type__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamFhrpGroupsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_groups_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        group_id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        auth_key: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        protocol: Optional[StrictStr] = None,
        auth_type: Optional[StrictStr] = None,
        related_ip: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        group_id__n: Optional[StrictStr] = None,
        group_id__lte: Optional[StrictStr] = None,
        group_id__lt: Optional[StrictStr] = None,
        group_id__gte: Optional[StrictStr] = None,
        group_id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        auth_key__n: Optional[StrictStr] = None,
        auth_key__ic: Optional[StrictStr] = None,
        auth_key__nic: Optional[StrictStr] = None,
        auth_key__iew: Optional[StrictStr] = None,
        auth_key__niew: Optional[StrictStr] = None,
        auth_key__isw: Optional[StrictStr] = None,
        auth_key__nisw: Optional[StrictStr] = None,
        auth_key__ie: Optional[StrictStr] = None,
        auth_key__nie: Optional[StrictStr] = None,
        auth_key__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        protocol__n: Optional[StrictStr] = None,
        auth_type__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_groups_list

        

        :param id: 
        :type id: str
        :param group_id: 
        :type group_id: str
        :param name: 
        :type name: str
        :param auth_key: 
        :type auth_key: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param protocol: 
        :type protocol: str
        :param auth_type: 
        :type auth_type: str
        :param related_ip: 
        :type related_ip: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param group_id__n: 
        :type group_id__n: str
        :param group_id__lte: 
        :type group_id__lte: str
        :param group_id__lt: 
        :type group_id__lt: str
        :param group_id__gte: 
        :type group_id__gte: str
        :param group_id__gt: 
        :type group_id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param auth_key__n: 
        :type auth_key__n: str
        :param auth_key__ic: 
        :type auth_key__ic: str
        :param auth_key__nic: 
        :type auth_key__nic: str
        :param auth_key__iew: 
        :type auth_key__iew: str
        :param auth_key__niew: 
        :type auth_key__niew: str
        :param auth_key__isw: 
        :type auth_key__isw: str
        :param auth_key__nisw: 
        :type auth_key__nisw: str
        :param auth_key__ie: 
        :type auth_key__ie: str
        :param auth_key__nie: 
        :type auth_key__nie: str
        :param auth_key__empty: 
        :type auth_key__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param protocol__n: 
        :type protocol__n: str
        :param auth_type__n: 
        :type auth_type__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_list_serialize(
            id=id,
            group_id=group_id,
            name=name,
            auth_key=auth_key,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            protocol=protocol,
            auth_type=auth_type,
            related_ip=related_ip,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            group_id__n=group_id__n,
            group_id__lte=group_id__lte,
            group_id__lt=group_id__lt,
            group_id__gte=group_id__gte,
            group_id__gt=group_id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            auth_key__n=auth_key__n,
            auth_key__ic=auth_key__ic,
            auth_key__nic=auth_key__nic,
            auth_key__iew=auth_key__iew,
            auth_key__niew=auth_key__niew,
            auth_key__isw=auth_key__isw,
            auth_key__nisw=auth_key__nisw,
            auth_key__ie=auth_key__ie,
            auth_key__nie=auth_key__nie,
            auth_key__empty=auth_key__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            protocol__n=protocol__n,
            auth_type__n=auth_type__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamFhrpGroupsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_groups_list_serialize(
        self,
        id,
        group_id,
        name,
        auth_key,
        created,
        last_updated,
        q,
        tag,
        protocol,
        auth_type,
        related_ip,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        group_id__n,
        group_id__lte,
        group_id__lt,
        group_id__gte,
        group_id__gt,
        name__n,
        name__ic,
        name__nic,
        name__iew,
        name__niew,
        name__isw,
        name__nisw,
        name__ie,
        name__nie,
        name__empty,
        auth_key__n,
        auth_key__ic,
        auth_key__nic,
        auth_key__iew,
        auth_key__niew,
        auth_key__isw,
        auth_key__nisw,
        auth_key__ie,
        auth_key__nie,
        auth_key__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        protocol__n,
        auth_type__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if group_id is not None:
            
            _query_params.append(('group_id', group_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if auth_key is not None:
            
            _query_params.append(('auth_key', auth_key))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if protocol is not None:
            
            _query_params.append(('protocol', protocol))
            
        if auth_type is not None:
            
            _query_params.append(('auth_type', auth_type))
            
        if related_ip is not None:
            
            _query_params.append(('related_ip', related_ip))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if group_id__n is not None:
            
            _query_params.append(('group_id__n', group_id__n))
            
        if group_id__lte is not None:
            
            _query_params.append(('group_id__lte', group_id__lte))
            
        if group_id__lt is not None:
            
            _query_params.append(('group_id__lt', group_id__lt))
            
        if group_id__gte is not None:
            
            _query_params.append(('group_id__gte', group_id__gte))
            
        if group_id__gt is not None:
            
            _query_params.append(('group_id__gt', group_id__gt))
            
        if name__n is not None:
            
            _query_params.append(('name__n', name__n))
            
        if name__ic is not None:
            
            _query_params.append(('name__ic', name__ic))
            
        if name__nic is not None:
            
            _query_params.append(('name__nic', name__nic))
            
        if name__iew is not None:
            
            _query_params.append(('name__iew', name__iew))
            
        if name__niew is not None:
            
            _query_params.append(('name__niew', name__niew))
            
        if name__isw is not None:
            
            _query_params.append(('name__isw', name__isw))
            
        if name__nisw is not None:
            
            _query_params.append(('name__nisw', name__nisw))
            
        if name__ie is not None:
            
            _query_params.append(('name__ie', name__ie))
            
        if name__nie is not None:
            
            _query_params.append(('name__nie', name__nie))
            
        if name__empty is not None:
            
            _query_params.append(('name__empty', name__empty))
            
        if auth_key__n is not None:
            
            _query_params.append(('auth_key__n', auth_key__n))
            
        if auth_key__ic is not None:
            
            _query_params.append(('auth_key__ic', auth_key__ic))
            
        if auth_key__nic is not None:
            
            _query_params.append(('auth_key__nic', auth_key__nic))
            
        if auth_key__iew is not None:
            
            _query_params.append(('auth_key__iew', auth_key__iew))
            
        if auth_key__niew is not None:
            
            _query_params.append(('auth_key__niew', auth_key__niew))
            
        if auth_key__isw is not None:
            
            _query_params.append(('auth_key__isw', auth_key__isw))
            
        if auth_key__nisw is not None:
            
            _query_params.append(('auth_key__nisw', auth_key__nisw))
            
        if auth_key__ie is not None:
            
            _query_params.append(('auth_key__ie', auth_key__ie))
            
        if auth_key__nie is not None:
            
            _query_params.append(('auth_key__nie', auth_key__nie))
            
        if auth_key__empty is not None:
            
            _query_params.append(('auth_key__empty', auth_key__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if protocol__n is not None:
            
            _query_params.append(('protocol__n', protocol__n))
            
        if auth_type__n is not None:
            
            _query_params.append(('auth_type__n', auth_type__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/fhrp-groups/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_groups_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroup:
        """ipam_fhrp_groups_partial_update

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_partial_update_serialize(
            id=id,
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_groups_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroup]:
        """ipam_fhrp_groups_partial_update

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_partial_update_serialize(
            id=id,
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_groups_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_groups_partial_update

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_partial_update_serialize(
            id=id,
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_groups_partial_update_serialize(
        self,
        id,
        fhrp_group,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if fhrp_group is not None:
            _body_params = fhrp_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/fhrp-groups/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_groups_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroup:
        """ipam_fhrp_groups_read

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_groups_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroup]:
        """ipam_fhrp_groups_read

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_groups_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_groups_read

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_groups_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/fhrp-groups/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_fhrp_groups_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FHRPGroup:
        """ipam_fhrp_groups_update

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_update_serialize(
            id=id,
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_fhrp_groups_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FHRPGroup]:
        """ipam_fhrp_groups_update

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_update_serialize(
            id=id,
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_fhrp_groups_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this FHRP group.")],
        fhrp_group: FHRPGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_fhrp_groups_update

        

        :param id: A unique integer value identifying this FHRP group. (required)
        :type id: int
        :param fhrp_group: (required)
        :type fhrp_group: FHRPGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_fhrp_groups_update_serialize(
            id=id,
            fhrp_group=fhrp_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FHRPGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_fhrp_groups_update_serialize(
        self,
        id,
        fhrp_group,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if fhrp_group is not None:
            _body_params = fhrp_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/fhrp-groups/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_addresses_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_ip_addresses_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_addresses_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_ip_addresses_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_addresses_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_addresses_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_addresses_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/ip-addresses/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_addresses_bulk_partial_update(
        self,
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPAddress:
        """ipam_ip_addresses_bulk_partial_update

        

        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_bulk_partial_update_serialize(
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_addresses_bulk_partial_update_with_http_info(
        self,
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPAddress]:
        """ipam_ip_addresses_bulk_partial_update

        

        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_bulk_partial_update_serialize(
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_addresses_bulk_partial_update_without_preload_content(
        self,
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_addresses_bulk_partial_update

        

        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_bulk_partial_update_serialize(
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_addresses_bulk_partial_update_serialize(
        self,
        writable_ip_address,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_ip_address is not None:
            _body_params = writable_ip_address


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/ip-addresses/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_addresses_bulk_update(
        self,
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPAddress:
        """ipam_ip_addresses_bulk_update

        

        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_bulk_update_serialize(
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_addresses_bulk_update_with_http_info(
        self,
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPAddress]:
        """ipam_ip_addresses_bulk_update

        

        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_bulk_update_serialize(
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_addresses_bulk_update_without_preload_content(
        self,
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_addresses_bulk_update

        

        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_bulk_update_serialize(
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_addresses_bulk_update_serialize(
        self,
        writable_ip_address,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_ip_address is not None:
            _body_params = writable_ip_address


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/ip-addresses/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_addresses_create(
        self,
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPAddress:
        """ipam_ip_addresses_create

        

        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_create_serialize(
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_addresses_create_with_http_info(
        self,
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPAddress]:
        """ipam_ip_addresses_create

        

        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_create_serialize(
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_addresses_create_without_preload_content(
        self,
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_addresses_create

        

        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_create_serialize(
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_addresses_create_serialize(
        self,
        writable_ip_address,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_ip_address is not None:
            _body_params = writable_ip_address


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/ip-addresses/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_addresses_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_ip_addresses_delete

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_addresses_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_ip_addresses_delete

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_addresses_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_addresses_delete

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_addresses_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/ip-addresses/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_addresses_list(
        self,
        id: Optional[StrictStr] = None,
        dns_name: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        parent: Optional[StrictStr] = None,
        address: Optional[StrictStr] = None,
        mask_length: Optional[Union[StrictFloat, StrictInt]] = None,
        vrf_id: Optional[StrictStr] = None,
        vrf: Optional[StrictStr] = None,
        present_in_vrf_id: Optional[StrictStr] = None,
        present_in_vrf: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        interface: Optional[StrictStr] = None,
        interface_id: Optional[StrictStr] = None,
        vminterface: Optional[StrictStr] = None,
        vminterface_id: Optional[StrictStr] = None,
        fhrpgroup_id: Optional[StrictStr] = None,
        assigned_to_interface: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        dns_name__n: Optional[StrictStr] = None,
        dns_name__ic: Optional[StrictStr] = None,
        dns_name__nic: Optional[StrictStr] = None,
        dns_name__iew: Optional[StrictStr] = None,
        dns_name__niew: Optional[StrictStr] = None,
        dns_name__isw: Optional[StrictStr] = None,
        dns_name__nisw: Optional[StrictStr] = None,
        dns_name__ie: Optional[StrictStr] = None,
        dns_name__nie: Optional[StrictStr] = None,
        dns_name__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        vrf_id__n: Optional[StrictStr] = None,
        vrf__n: Optional[StrictStr] = None,
        interface__n: Optional[StrictStr] = None,
        interface_id__n: Optional[StrictStr] = None,
        vminterface__n: Optional[StrictStr] = None,
        vminterface_id__n: Optional[StrictStr] = None,
        fhrpgroup_id__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamIpAddressesList200Response:
        """ipam_ip_addresses_list

        

        :param id: 
        :type id: str
        :param dns_name: 
        :type dns_name: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param family: 
        :type family: float
        :param parent: 
        :type parent: str
        :param address: 
        :type address: str
        :param mask_length: 
        :type mask_length: float
        :param vrf_id: 
        :type vrf_id: str
        :param vrf: 
        :type vrf: str
        :param present_in_vrf_id: 
        :type present_in_vrf_id: str
        :param present_in_vrf: 
        :type present_in_vrf: str
        :param device: 
        :type device: str
        :param device_id: 
        :type device_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param interface: 
        :type interface: str
        :param interface_id: 
        :type interface_id: str
        :param vminterface: 
        :type vminterface: str
        :param vminterface_id: 
        :type vminterface_id: str
        :param fhrpgroup_id: 
        :type fhrpgroup_id: str
        :param assigned_to_interface: 
        :type assigned_to_interface: str
        :param status: 
        :type status: str
        :param role: 
        :type role: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param dns_name__n: 
        :type dns_name__n: str
        :param dns_name__ic: 
        :type dns_name__ic: str
        :param dns_name__nic: 
        :type dns_name__nic: str
        :param dns_name__iew: 
        :type dns_name__iew: str
        :param dns_name__niew: 
        :type dns_name__niew: str
        :param dns_name__isw: 
        :type dns_name__isw: str
        :param dns_name__nisw: 
        :type dns_name__nisw: str
        :param dns_name__ie: 
        :type dns_name__ie: str
        :param dns_name__nie: 
        :type dns_name__nie: str
        :param dns_name__empty: 
        :type dns_name__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param vrf_id__n: 
        :type vrf_id__n: str
        :param vrf__n: 
        :type vrf__n: str
        :param interface__n: 
        :type interface__n: str
        :param interface_id__n: 
        :type interface_id__n: str
        :param vminterface__n: 
        :type vminterface__n: str
        :param vminterface_id__n: 
        :type vminterface_id__n: str
        :param fhrpgroup_id__n: 
        :type fhrpgroup_id__n: str
        :param status__n: 
        :type status__n: str
        :param role__n: 
        :type role__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_list_serialize(
            id=id,
            dns_name=dns_name,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            family=family,
            parent=parent,
            address=address,
            mask_length=mask_length,
            vrf_id=vrf_id,
            vrf=vrf,
            present_in_vrf_id=present_in_vrf_id,
            present_in_vrf=present_in_vrf,
            device=device,
            device_id=device_id,
            virtual_machine=virtual_machine,
            virtual_machine_id=virtual_machine_id,
            interface=interface,
            interface_id=interface_id,
            vminterface=vminterface,
            vminterface_id=vminterface_id,
            fhrpgroup_id=fhrpgroup_id,
            assigned_to_interface=assigned_to_interface,
            status=status,
            role=role,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            dns_name__n=dns_name__n,
            dns_name__ic=dns_name__ic,
            dns_name__nic=dns_name__nic,
            dns_name__iew=dns_name__iew,
            dns_name__niew=dns_name__niew,
            dns_name__isw=dns_name__isw,
            dns_name__nisw=dns_name__nisw,
            dns_name__ie=dns_name__ie,
            dns_name__nie=dns_name__nie,
            dns_name__empty=dns_name__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            vrf_id__n=vrf_id__n,
            vrf__n=vrf__n,
            interface__n=interface__n,
            interface_id__n=interface_id__n,
            vminterface__n=vminterface__n,
            vminterface_id__n=vminterface_id__n,
            fhrpgroup_id__n=fhrpgroup_id__n,
            status__n=status__n,
            role__n=role__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamIpAddressesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_addresses_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        dns_name: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        parent: Optional[StrictStr] = None,
        address: Optional[StrictStr] = None,
        mask_length: Optional[Union[StrictFloat, StrictInt]] = None,
        vrf_id: Optional[StrictStr] = None,
        vrf: Optional[StrictStr] = None,
        present_in_vrf_id: Optional[StrictStr] = None,
        present_in_vrf: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        interface: Optional[StrictStr] = None,
        interface_id: Optional[StrictStr] = None,
        vminterface: Optional[StrictStr] = None,
        vminterface_id: Optional[StrictStr] = None,
        fhrpgroup_id: Optional[StrictStr] = None,
        assigned_to_interface: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        dns_name__n: Optional[StrictStr] = None,
        dns_name__ic: Optional[StrictStr] = None,
        dns_name__nic: Optional[StrictStr] = None,
        dns_name__iew: Optional[StrictStr] = None,
        dns_name__niew: Optional[StrictStr] = None,
        dns_name__isw: Optional[StrictStr] = None,
        dns_name__nisw: Optional[StrictStr] = None,
        dns_name__ie: Optional[StrictStr] = None,
        dns_name__nie: Optional[StrictStr] = None,
        dns_name__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        vrf_id__n: Optional[StrictStr] = None,
        vrf__n: Optional[StrictStr] = None,
        interface__n: Optional[StrictStr] = None,
        interface_id__n: Optional[StrictStr] = None,
        vminterface__n: Optional[StrictStr] = None,
        vminterface_id__n: Optional[StrictStr] = None,
        fhrpgroup_id__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamIpAddressesList200Response]:
        """ipam_ip_addresses_list

        

        :param id: 
        :type id: str
        :param dns_name: 
        :type dns_name: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param family: 
        :type family: float
        :param parent: 
        :type parent: str
        :param address: 
        :type address: str
        :param mask_length: 
        :type mask_length: float
        :param vrf_id: 
        :type vrf_id: str
        :param vrf: 
        :type vrf: str
        :param present_in_vrf_id: 
        :type present_in_vrf_id: str
        :param present_in_vrf: 
        :type present_in_vrf: str
        :param device: 
        :type device: str
        :param device_id: 
        :type device_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param interface: 
        :type interface: str
        :param interface_id: 
        :type interface_id: str
        :param vminterface: 
        :type vminterface: str
        :param vminterface_id: 
        :type vminterface_id: str
        :param fhrpgroup_id: 
        :type fhrpgroup_id: str
        :param assigned_to_interface: 
        :type assigned_to_interface: str
        :param status: 
        :type status: str
        :param role: 
        :type role: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param dns_name__n: 
        :type dns_name__n: str
        :param dns_name__ic: 
        :type dns_name__ic: str
        :param dns_name__nic: 
        :type dns_name__nic: str
        :param dns_name__iew: 
        :type dns_name__iew: str
        :param dns_name__niew: 
        :type dns_name__niew: str
        :param dns_name__isw: 
        :type dns_name__isw: str
        :param dns_name__nisw: 
        :type dns_name__nisw: str
        :param dns_name__ie: 
        :type dns_name__ie: str
        :param dns_name__nie: 
        :type dns_name__nie: str
        :param dns_name__empty: 
        :type dns_name__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param vrf_id__n: 
        :type vrf_id__n: str
        :param vrf__n: 
        :type vrf__n: str
        :param interface__n: 
        :type interface__n: str
        :param interface_id__n: 
        :type interface_id__n: str
        :param vminterface__n: 
        :type vminterface__n: str
        :param vminterface_id__n: 
        :type vminterface_id__n: str
        :param fhrpgroup_id__n: 
        :type fhrpgroup_id__n: str
        :param status__n: 
        :type status__n: str
        :param role__n: 
        :type role__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_list_serialize(
            id=id,
            dns_name=dns_name,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            family=family,
            parent=parent,
            address=address,
            mask_length=mask_length,
            vrf_id=vrf_id,
            vrf=vrf,
            present_in_vrf_id=present_in_vrf_id,
            present_in_vrf=present_in_vrf,
            device=device,
            device_id=device_id,
            virtual_machine=virtual_machine,
            virtual_machine_id=virtual_machine_id,
            interface=interface,
            interface_id=interface_id,
            vminterface=vminterface,
            vminterface_id=vminterface_id,
            fhrpgroup_id=fhrpgroup_id,
            assigned_to_interface=assigned_to_interface,
            status=status,
            role=role,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            dns_name__n=dns_name__n,
            dns_name__ic=dns_name__ic,
            dns_name__nic=dns_name__nic,
            dns_name__iew=dns_name__iew,
            dns_name__niew=dns_name__niew,
            dns_name__isw=dns_name__isw,
            dns_name__nisw=dns_name__nisw,
            dns_name__ie=dns_name__ie,
            dns_name__nie=dns_name__nie,
            dns_name__empty=dns_name__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            vrf_id__n=vrf_id__n,
            vrf__n=vrf__n,
            interface__n=interface__n,
            interface_id__n=interface_id__n,
            vminterface__n=vminterface__n,
            vminterface_id__n=vminterface_id__n,
            fhrpgroup_id__n=fhrpgroup_id__n,
            status__n=status__n,
            role__n=role__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamIpAddressesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_addresses_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        dns_name: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        parent: Optional[StrictStr] = None,
        address: Optional[StrictStr] = None,
        mask_length: Optional[Union[StrictFloat, StrictInt]] = None,
        vrf_id: Optional[StrictStr] = None,
        vrf: Optional[StrictStr] = None,
        present_in_vrf_id: Optional[StrictStr] = None,
        present_in_vrf: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        interface: Optional[StrictStr] = None,
        interface_id: Optional[StrictStr] = None,
        vminterface: Optional[StrictStr] = None,
        vminterface_id: Optional[StrictStr] = None,
        fhrpgroup_id: Optional[StrictStr] = None,
        assigned_to_interface: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        dns_name__n: Optional[StrictStr] = None,
        dns_name__ic: Optional[StrictStr] = None,
        dns_name__nic: Optional[StrictStr] = None,
        dns_name__iew: Optional[StrictStr] = None,
        dns_name__niew: Optional[StrictStr] = None,
        dns_name__isw: Optional[StrictStr] = None,
        dns_name__nisw: Optional[StrictStr] = None,
        dns_name__ie: Optional[StrictStr] = None,
        dns_name__nie: Optional[StrictStr] = None,
        dns_name__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        vrf_id__n: Optional[StrictStr] = None,
        vrf__n: Optional[StrictStr] = None,
        interface__n: Optional[StrictStr] = None,
        interface_id__n: Optional[StrictStr] = None,
        vminterface__n: Optional[StrictStr] = None,
        vminterface_id__n: Optional[StrictStr] = None,
        fhrpgroup_id__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_addresses_list

        

        :param id: 
        :type id: str
        :param dns_name: 
        :type dns_name: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param family: 
        :type family: float
        :param parent: 
        :type parent: str
        :param address: 
        :type address: str
        :param mask_length: 
        :type mask_length: float
        :param vrf_id: 
        :type vrf_id: str
        :param vrf: 
        :type vrf: str
        :param present_in_vrf_id: 
        :type present_in_vrf_id: str
        :param present_in_vrf: 
        :type present_in_vrf: str
        :param device: 
        :type device: str
        :param device_id: 
        :type device_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param interface: 
        :type interface: str
        :param interface_id: 
        :type interface_id: str
        :param vminterface: 
        :type vminterface: str
        :param vminterface_id: 
        :type vminterface_id: str
        :param fhrpgroup_id: 
        :type fhrpgroup_id: str
        :param assigned_to_interface: 
        :type assigned_to_interface: str
        :param status: 
        :type status: str
        :param role: 
        :type role: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param dns_name__n: 
        :type dns_name__n: str
        :param dns_name__ic: 
        :type dns_name__ic: str
        :param dns_name__nic: 
        :type dns_name__nic: str
        :param dns_name__iew: 
        :type dns_name__iew: str
        :param dns_name__niew: 
        :type dns_name__niew: str
        :param dns_name__isw: 
        :type dns_name__isw: str
        :param dns_name__nisw: 
        :type dns_name__nisw: str
        :param dns_name__ie: 
        :type dns_name__ie: str
        :param dns_name__nie: 
        :type dns_name__nie: str
        :param dns_name__empty: 
        :type dns_name__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param vrf_id__n: 
        :type vrf_id__n: str
        :param vrf__n: 
        :type vrf__n: str
        :param interface__n: 
        :type interface__n: str
        :param interface_id__n: 
        :type interface_id__n: str
        :param vminterface__n: 
        :type vminterface__n: str
        :param vminterface_id__n: 
        :type vminterface_id__n: str
        :param fhrpgroup_id__n: 
        :type fhrpgroup_id__n: str
        :param status__n: 
        :type status__n: str
        :param role__n: 
        :type role__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_list_serialize(
            id=id,
            dns_name=dns_name,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            family=family,
            parent=parent,
            address=address,
            mask_length=mask_length,
            vrf_id=vrf_id,
            vrf=vrf,
            present_in_vrf_id=present_in_vrf_id,
            present_in_vrf=present_in_vrf,
            device=device,
            device_id=device_id,
            virtual_machine=virtual_machine,
            virtual_machine_id=virtual_machine_id,
            interface=interface,
            interface_id=interface_id,
            vminterface=vminterface,
            vminterface_id=vminterface_id,
            fhrpgroup_id=fhrpgroup_id,
            assigned_to_interface=assigned_to_interface,
            status=status,
            role=role,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            dns_name__n=dns_name__n,
            dns_name__ic=dns_name__ic,
            dns_name__nic=dns_name__nic,
            dns_name__iew=dns_name__iew,
            dns_name__niew=dns_name__niew,
            dns_name__isw=dns_name__isw,
            dns_name__nisw=dns_name__nisw,
            dns_name__ie=dns_name__ie,
            dns_name__nie=dns_name__nie,
            dns_name__empty=dns_name__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            vrf_id__n=vrf_id__n,
            vrf__n=vrf__n,
            interface__n=interface__n,
            interface_id__n=interface_id__n,
            vminterface__n=vminterface__n,
            vminterface_id__n=vminterface_id__n,
            fhrpgroup_id__n=fhrpgroup_id__n,
            status__n=status__n,
            role__n=role__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamIpAddressesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_addresses_list_serialize(
        self,
        id,
        dns_name,
        description,
        created,
        last_updated,
        q,
        tag,
        tenant_group_id,
        tenant_group,
        tenant_id,
        tenant,
        family,
        parent,
        address,
        mask_length,
        vrf_id,
        vrf,
        present_in_vrf_id,
        present_in_vrf,
        device,
        device_id,
        virtual_machine,
        virtual_machine_id,
        interface,
        interface_id,
        vminterface,
        vminterface_id,
        fhrpgroup_id,
        assigned_to_interface,
        status,
        role,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        dns_name__n,
        dns_name__ic,
        dns_name__nic,
        dns_name__iew,
        dns_name__niew,
        dns_name__isw,
        dns_name__nisw,
        dns_name__ie,
        dns_name__nie,
        dns_name__empty,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        tenant_group_id__n,
        tenant_group__n,
        tenant_id__n,
        tenant__n,
        vrf_id__n,
        vrf__n,
        interface__n,
        interface_id__n,
        vminterface__n,
        vminterface_id__n,
        fhrpgroup_id__n,
        status__n,
        role__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if dns_name is not None:
            
            _query_params.append(('dns_name', dns_name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tenant_group_id is not None:
            
            _query_params.append(('tenant_group_id', tenant_group_id))
            
        if tenant_group is not None:
            
            _query_params.append(('tenant_group', tenant_group))
            
        if tenant_id is not None:
            
            _query_params.append(('tenant_id', tenant_id))
            
        if tenant is not None:
            
            _query_params.append(('tenant', tenant))
            
        if family is not None:
            
            _query_params.append(('family', family))
            
        if parent is not None:
            
            _query_params.append(('parent', parent))
            
        if address is not None:
            
            _query_params.append(('address', address))
            
        if mask_length is not None:
            
            _query_params.append(('mask_length', mask_length))
            
        if vrf_id is not None:
            
            _query_params.append(('vrf_id', vrf_id))
            
        if vrf is not None:
            
            _query_params.append(('vrf', vrf))
            
        if present_in_vrf_id is not None:
            
            _query_params.append(('present_in_vrf_id', present_in_vrf_id))
            
        if present_in_vrf is not None:
            
            _query_params.append(('present_in_vrf', present_in_vrf))
            
        if device is not None:
            
            _query_params.append(('device', device))
            
        if device_id is not None:
            
            _query_params.append(('device_id', device_id))
            
        if virtual_machine is not None:
            
            _query_params.append(('virtual_machine', virtual_machine))
            
        if virtual_machine_id is not None:
            
            _query_params.append(('virtual_machine_id', virtual_machine_id))
            
        if interface is not None:
            
            _query_params.append(('interface', interface))
            
        if interface_id is not None:
            
            _query_params.append(('interface_id', interface_id))
            
        if vminterface is not None:
            
            _query_params.append(('vminterface', vminterface))
            
        if vminterface_id is not None:
            
            _query_params.append(('vminterface_id', vminterface_id))
            
        if fhrpgroup_id is not None:
            
            _query_params.append(('fhrpgroup_id', fhrpgroup_id))
            
        if assigned_to_interface is not None:
            
            _query_params.append(('assigned_to_interface', assigned_to_interface))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if role is not None:
            
            _query_params.append(('role', role))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if dns_name__n is not None:
            
            _query_params.append(('dns_name__n', dns_name__n))
            
        if dns_name__ic is not None:
            
            _query_params.append(('dns_name__ic', dns_name__ic))
            
        if dns_name__nic is not None:
            
            _query_params.append(('dns_name__nic', dns_name__nic))
            
        if dns_name__iew is not None:
            
            _query_params.append(('dns_name__iew', dns_name__iew))
            
        if dns_name__niew is not None:
            
            _query_params.append(('dns_name__niew', dns_name__niew))
            
        if dns_name__isw is not None:
            
            _query_params.append(('dns_name__isw', dns_name__isw))
            
        if dns_name__nisw is not None:
            
            _query_params.append(('dns_name__nisw', dns_name__nisw))
            
        if dns_name__ie is not None:
            
            _query_params.append(('dns_name__ie', dns_name__ie))
            
        if dns_name__nie is not None:
            
            _query_params.append(('dns_name__nie', dns_name__nie))
            
        if dns_name__empty is not None:
            
            _query_params.append(('dns_name__empty', dns_name__empty))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if tenant_group_id__n is not None:
            
            _query_params.append(('tenant_group_id__n', tenant_group_id__n))
            
        if tenant_group__n is not None:
            
            _query_params.append(('tenant_group__n', tenant_group__n))
            
        if tenant_id__n is not None:
            
            _query_params.append(('tenant_id__n', tenant_id__n))
            
        if tenant__n is not None:
            
            _query_params.append(('tenant__n', tenant__n))
            
        if vrf_id__n is not None:
            
            _query_params.append(('vrf_id__n', vrf_id__n))
            
        if vrf__n is not None:
            
            _query_params.append(('vrf__n', vrf__n))
            
        if interface__n is not None:
            
            _query_params.append(('interface__n', interface__n))
            
        if interface_id__n is not None:
            
            _query_params.append(('interface_id__n', interface_id__n))
            
        if vminterface__n is not None:
            
            _query_params.append(('vminterface__n', vminterface__n))
            
        if vminterface_id__n is not None:
            
            _query_params.append(('vminterface_id__n', vminterface_id__n))
            
        if fhrpgroup_id__n is not None:
            
            _query_params.append(('fhrpgroup_id__n', fhrpgroup_id__n))
            
        if status__n is not None:
            
            _query_params.append(('status__n', status__n))
            
        if role__n is not None:
            
            _query_params.append(('role__n', role__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/ip-addresses/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_addresses_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPAddress:
        """ipam_ip_addresses_partial_update

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_partial_update_serialize(
            id=id,
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_addresses_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPAddress]:
        """ipam_ip_addresses_partial_update

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_partial_update_serialize(
            id=id,
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_addresses_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_addresses_partial_update

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_partial_update_serialize(
            id=id,
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_addresses_partial_update_serialize(
        self,
        id,
        writable_ip_address,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_ip_address is not None:
            _body_params = writable_ip_address


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/ip-addresses/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_addresses_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPAddress:
        """ipam_ip_addresses_read

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_addresses_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPAddress]:
        """ipam_ip_addresses_read

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_addresses_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_addresses_read

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_addresses_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/ip-addresses/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_addresses_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPAddress:
        """ipam_ip_addresses_update

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_update_serialize(
            id=id,
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_addresses_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPAddress]:
        """ipam_ip_addresses_update

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_update_serialize(
            id=id,
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_addresses_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_ip_address: WritableIPAddress,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_addresses_update

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_ip_address: (required)
        :type writable_ip_address: WritableIPAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_addresses_update_serialize(
            id=id,
            writable_ip_address=writable_ip_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPAddress",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_addresses_update_serialize(
        self,
        id,
        writable_ip_address,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_ip_address is not None:
            _body_params = writable_ip_address


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/ip-addresses/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_available_ips_create(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_available_ip: WritableAvailableIP,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[IPAddress]:
        """ipam_ip_ranges_available_ips_create

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_available_ip: (required)
        :type writable_available_ip: WritableAvailableIP
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_available_ips_create_serialize(
            id=id,
            writable_available_ip=writable_available_ip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[IPAddress]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_available_ips_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_available_ip: WritableAvailableIP,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[IPAddress]]:
        """ipam_ip_ranges_available_ips_create

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_available_ip: (required)
        :type writable_available_ip: WritableAvailableIP
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_available_ips_create_serialize(
            id=id,
            writable_available_ip=writable_available_ip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[IPAddress]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_available_ips_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_available_ip: WritableAvailableIP,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_available_ips_create

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_available_ip: (required)
        :type writable_available_ip: WritableAvailableIP
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_available_ips_create_serialize(
            id=id,
            writable_available_ip=writable_available_ip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[IPAddress]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_available_ips_create_serialize(
        self,
        id,
        writable_available_ip,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_available_ip is not None:
            _body_params = writable_available_ip


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/ip-ranges/{id}/available-ips/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_available_ips_list(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AvailableIP]:
        """ipam_ip_ranges_available_ips_list

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_available_ips_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailableIP]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_available_ips_list_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AvailableIP]]:
        """ipam_ip_ranges_available_ips_list

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_available_ips_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailableIP]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_available_ips_list_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_available_ips_list

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_available_ips_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailableIP]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_available_ips_list_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/ip-ranges/{id}/available-ips/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_ip_ranges_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_ip_ranges_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/ip-ranges/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_bulk_partial_update(
        self,
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPRange:
        """ipam_ip_ranges_bulk_partial_update

        

        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_bulk_partial_update_serialize(
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_bulk_partial_update_with_http_info(
        self,
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPRange]:
        """ipam_ip_ranges_bulk_partial_update

        

        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_bulk_partial_update_serialize(
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_bulk_partial_update_without_preload_content(
        self,
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_bulk_partial_update

        

        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_bulk_partial_update_serialize(
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_bulk_partial_update_serialize(
        self,
        writable_ip_range,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_ip_range is not None:
            _body_params = writable_ip_range


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/ip-ranges/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_bulk_update(
        self,
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPRange:
        """ipam_ip_ranges_bulk_update

        

        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_bulk_update_serialize(
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_bulk_update_with_http_info(
        self,
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPRange]:
        """ipam_ip_ranges_bulk_update

        

        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_bulk_update_serialize(
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_bulk_update_without_preload_content(
        self,
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_bulk_update

        

        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_bulk_update_serialize(
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_bulk_update_serialize(
        self,
        writable_ip_range,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_ip_range is not None:
            _body_params = writable_ip_range


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/ip-ranges/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_create(
        self,
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPRange:
        """ipam_ip_ranges_create

        

        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_create_serialize(
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_create_with_http_info(
        self,
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPRange]:
        """ipam_ip_ranges_create

        

        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_create_serialize(
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_create_without_preload_content(
        self,
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_create

        

        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_create_serialize(
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_create_serialize(
        self,
        writable_ip_range,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_ip_range is not None:
            _body_params = writable_ip_range


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/ip-ranges/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_ip_ranges_delete

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_ip_ranges_delete

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_delete

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/ip-ranges/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_list(
        self,
        id: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        start_address: Optional[StrictStr] = None,
        end_address: Optional[StrictStr] = None,
        contains: Optional[StrictStr] = None,
        vrf_id: Optional[StrictStr] = None,
        vrf: Optional[StrictStr] = None,
        role_id: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        vrf_id__n: Optional[StrictStr] = None,
        vrf__n: Optional[StrictStr] = None,
        role_id__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamIpRangesList200Response:
        """ipam_ip_ranges_list

        

        :param id: 
        :type id: str
        :param description: 
        :type description: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param family: 
        :type family: float
        :param start_address: 
        :type start_address: str
        :param end_address: 
        :type end_address: str
        :param contains: 
        :type contains: str
        :param vrf_id: 
        :type vrf_id: str
        :param vrf: 
        :type vrf: str
        :param role_id: 
        :type role_id: str
        :param role: 
        :type role: str
        :param status: 
        :type status: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param vrf_id__n: 
        :type vrf_id__n: str
        :param vrf__n: 
        :type vrf__n: str
        :param role_id__n: 
        :type role_id__n: str
        :param role__n: 
        :type role__n: str
        :param status__n: 
        :type status__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_list_serialize(
            id=id,
            description=description,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            family=family,
            start_address=start_address,
            end_address=end_address,
            contains=contains,
            vrf_id=vrf_id,
            vrf=vrf,
            role_id=role_id,
            role=role,
            status=status,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            vrf_id__n=vrf_id__n,
            vrf__n=vrf__n,
            role_id__n=role_id__n,
            role__n=role__n,
            status__n=status__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamIpRangesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        start_address: Optional[StrictStr] = None,
        end_address: Optional[StrictStr] = None,
        contains: Optional[StrictStr] = None,
        vrf_id: Optional[StrictStr] = None,
        vrf: Optional[StrictStr] = None,
        role_id: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        vrf_id__n: Optional[StrictStr] = None,
        vrf__n: Optional[StrictStr] = None,
        role_id__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamIpRangesList200Response]:
        """ipam_ip_ranges_list

        

        :param id: 
        :type id: str
        :param description: 
        :type description: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param family: 
        :type family: float
        :param start_address: 
        :type start_address: str
        :param end_address: 
        :type end_address: str
        :param contains: 
        :type contains: str
        :param vrf_id: 
        :type vrf_id: str
        :param vrf: 
        :type vrf: str
        :param role_id: 
        :type role_id: str
        :param role: 
        :type role: str
        :param status: 
        :type status: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param vrf_id__n: 
        :type vrf_id__n: str
        :param vrf__n: 
        :type vrf__n: str
        :param role_id__n: 
        :type role_id__n: str
        :param role__n: 
        :type role__n: str
        :param status__n: 
        :type status__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_list_serialize(
            id=id,
            description=description,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            family=family,
            start_address=start_address,
            end_address=end_address,
            contains=contains,
            vrf_id=vrf_id,
            vrf=vrf,
            role_id=role_id,
            role=role,
            status=status,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            vrf_id__n=vrf_id__n,
            vrf__n=vrf__n,
            role_id__n=role_id__n,
            role__n=role__n,
            status__n=status__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamIpRangesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        start_address: Optional[StrictStr] = None,
        end_address: Optional[StrictStr] = None,
        contains: Optional[StrictStr] = None,
        vrf_id: Optional[StrictStr] = None,
        vrf: Optional[StrictStr] = None,
        role_id: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        vrf_id__n: Optional[StrictStr] = None,
        vrf__n: Optional[StrictStr] = None,
        role_id__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_list

        

        :param id: 
        :type id: str
        :param description: 
        :type description: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param family: 
        :type family: float
        :param start_address: 
        :type start_address: str
        :param end_address: 
        :type end_address: str
        :param contains: 
        :type contains: str
        :param vrf_id: 
        :type vrf_id: str
        :param vrf: 
        :type vrf: str
        :param role_id: 
        :type role_id: str
        :param role: 
        :type role: str
        :param status: 
        :type status: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param vrf_id__n: 
        :type vrf_id__n: str
        :param vrf__n: 
        :type vrf__n: str
        :param role_id__n: 
        :type role_id__n: str
        :param role__n: 
        :type role__n: str
        :param status__n: 
        :type status__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_list_serialize(
            id=id,
            description=description,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            family=family,
            start_address=start_address,
            end_address=end_address,
            contains=contains,
            vrf_id=vrf_id,
            vrf=vrf,
            role_id=role_id,
            role=role,
            status=status,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            vrf_id__n=vrf_id__n,
            vrf__n=vrf__n,
            role_id__n=role_id__n,
            role__n=role__n,
            status__n=status__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamIpRangesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_list_serialize(
        self,
        id,
        description,
        tenant_group_id,
        tenant_group,
        tenant_id,
        tenant,
        created,
        last_updated,
        q,
        tag,
        family,
        start_address,
        end_address,
        contains,
        vrf_id,
        vrf,
        role_id,
        role,
        status,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        tenant_group_id__n,
        tenant_group__n,
        tenant_id__n,
        tenant__n,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        vrf_id__n,
        vrf__n,
        role_id__n,
        role__n,
        status__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if tenant_group_id is not None:
            
            _query_params.append(('tenant_group_id', tenant_group_id))
            
        if tenant_group is not None:
            
            _query_params.append(('tenant_group', tenant_group))
            
        if tenant_id is not None:
            
            _query_params.append(('tenant_id', tenant_id))
            
        if tenant is not None:
            
            _query_params.append(('tenant', tenant))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if family is not None:
            
            _query_params.append(('family', family))
            
        if start_address is not None:
            
            _query_params.append(('start_address', start_address))
            
        if end_address is not None:
            
            _query_params.append(('end_address', end_address))
            
        if contains is not None:
            
            _query_params.append(('contains', contains))
            
        if vrf_id is not None:
            
            _query_params.append(('vrf_id', vrf_id))
            
        if vrf is not None:
            
            _query_params.append(('vrf', vrf))
            
        if role_id is not None:
            
            _query_params.append(('role_id', role_id))
            
        if role is not None:
            
            _query_params.append(('role', role))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if tenant_group_id__n is not None:
            
            _query_params.append(('tenant_group_id__n', tenant_group_id__n))
            
        if tenant_group__n is not None:
            
            _query_params.append(('tenant_group__n', tenant_group__n))
            
        if tenant_id__n is not None:
            
            _query_params.append(('tenant_id__n', tenant_id__n))
            
        if tenant__n is not None:
            
            _query_params.append(('tenant__n', tenant__n))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if vrf_id__n is not None:
            
            _query_params.append(('vrf_id__n', vrf_id__n))
            
        if vrf__n is not None:
            
            _query_params.append(('vrf__n', vrf__n))
            
        if role_id__n is not None:
            
            _query_params.append(('role_id__n', role_id__n))
            
        if role__n is not None:
            
            _query_params.append(('role__n', role__n))
            
        if status__n is not None:
            
            _query_params.append(('status__n', status__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/ip-ranges/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPRange:
        """ipam_ip_ranges_partial_update

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_partial_update_serialize(
            id=id,
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPRange]:
        """ipam_ip_ranges_partial_update

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_partial_update_serialize(
            id=id,
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_partial_update

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_partial_update_serialize(
            id=id,
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_partial_update_serialize(
        self,
        id,
        writable_ip_range,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_ip_range is not None:
            _body_params = writable_ip_range


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/ip-ranges/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPRange:
        """ipam_ip_ranges_read

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPRange]:
        """ipam_ip_ranges_read

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_read

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/ip-ranges/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_ip_ranges_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IPRange:
        """ipam_ip_ranges_update

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_update_serialize(
            id=id,
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_ip_ranges_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IPRange]:
        """ipam_ip_ranges_update

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_update_serialize(
            id=id,
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_ip_ranges_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP range.")],
        writable_ip_range: WritableIPRange,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_ip_ranges_update

        

        :param id: A unique integer value identifying this IP range. (required)
        :type id: int
        :param writable_ip_range: (required)
        :type writable_ip_range: WritableIPRange
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_ip_ranges_update_serialize(
            id=id,
            writable_ip_range=writable_ip_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IPRange",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_ip_ranges_update_serialize(
        self,
        id,
        writable_ip_range,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_ip_range is not None:
            _body_params = writable_ip_range


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/ip-ranges/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpn_terminations_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_l2vpn_terminations_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpn_terminations_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_l2vpn_terminations_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpn_terminations_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpn_terminations_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpn_terminations_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/l2vpn-terminations/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpn_terminations_bulk_partial_update(
        self,
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPNTermination:
        """ipam_l2vpn_terminations_bulk_partial_update

        

        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_bulk_partial_update_serialize(
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpn_terminations_bulk_partial_update_with_http_info(
        self,
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPNTermination]:
        """ipam_l2vpn_terminations_bulk_partial_update

        

        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_bulk_partial_update_serialize(
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpn_terminations_bulk_partial_update_without_preload_content(
        self,
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpn_terminations_bulk_partial_update

        

        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_bulk_partial_update_serialize(
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpn_terminations_bulk_partial_update_serialize(
        self,
        writable_l2_vpn_termination,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_l2_vpn_termination is not None:
            _body_params = writable_l2_vpn_termination


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/l2vpn-terminations/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpn_terminations_bulk_update(
        self,
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPNTermination:
        """ipam_l2vpn_terminations_bulk_update

        

        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_bulk_update_serialize(
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpn_terminations_bulk_update_with_http_info(
        self,
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPNTermination]:
        """ipam_l2vpn_terminations_bulk_update

        

        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_bulk_update_serialize(
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpn_terminations_bulk_update_without_preload_content(
        self,
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpn_terminations_bulk_update

        

        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_bulk_update_serialize(
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpn_terminations_bulk_update_serialize(
        self,
        writable_l2_vpn_termination,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_l2_vpn_termination is not None:
            _body_params = writable_l2_vpn_termination


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/l2vpn-terminations/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpn_terminations_create(
        self,
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPNTermination:
        """ipam_l2vpn_terminations_create

        

        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_create_serialize(
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpn_terminations_create_with_http_info(
        self,
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPNTermination]:
        """ipam_l2vpn_terminations_create

        

        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_create_serialize(
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpn_terminations_create_without_preload_content(
        self,
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpn_terminations_create

        

        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_create_serialize(
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpn_terminations_create_serialize(
        self,
        writable_l2_vpn_termination,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_l2_vpn_termination is not None:
            _body_params = writable_l2_vpn_termination


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/l2vpn-terminations/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpn_terminations_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_l2vpn_terminations_delete

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpn_terminations_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_l2vpn_terminations_delete

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpn_terminations_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpn_terminations_delete

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpn_terminations_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/l2vpn-terminations/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpn_terminations_list(
        self,
        id: Optional[StrictStr] = None,
        assigned_object_type_id: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        l2vpn_id: Optional[StrictStr] = None,
        l2vpn: Optional[StrictStr] = None,
        region: Optional[StrictStr] = None,
        region_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        interface: Optional[StrictStr] = None,
        interface_id: Optional[StrictStr] = None,
        vminterface: Optional[StrictStr] = None,
        vminterface_id: Optional[StrictStr] = None,
        vlan: Optional[StrictStr] = None,
        vlan_vid: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_id: Optional[StrictStr] = None,
        assigned_object_type: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        assigned_object_type_id__n: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        l2vpn_id__n: Optional[StrictStr] = None,
        l2vpn__n: Optional[StrictStr] = None,
        device__n: Optional[StrictStr] = None,
        device_id__n: Optional[StrictStr] = None,
        virtual_machine__n: Optional[StrictStr] = None,
        virtual_machine_id__n: Optional[StrictStr] = None,
        interface__n: Optional[StrictStr] = None,
        interface_id__n: Optional[StrictStr] = None,
        vminterface__n: Optional[StrictStr] = None,
        vminterface_id__n: Optional[StrictStr] = None,
        vlan__n: Optional[StrictStr] = None,
        vlan_vid__n: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lt: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gt: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_id__n: Optional[StrictStr] = None,
        assigned_object_type__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamL2vpnTerminationsList200Response:
        """ipam_l2vpn_terminations_list

        

        :param id: 
        :type id: str
        :param assigned_object_type_id: 
        :type assigned_object_type_id: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param l2vpn_id: 
        :type l2vpn_id: str
        :param l2vpn: 
        :type l2vpn: str
        :param region: 
        :type region: str
        :param region_id: 
        :type region_id: str
        :param site: 
        :type site: str
        :param site_id: 
        :type site_id: str
        :param device: 
        :type device: str
        :param device_id: 
        :type device_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param interface: 
        :type interface: str
        :param interface_id: 
        :type interface_id: str
        :param vminterface: 
        :type vminterface: str
        :param vminterface_id: 
        :type vminterface_id: str
        :param vlan: 
        :type vlan: str
        :param vlan_vid: 
        :type vlan_vid: float
        :param vlan_id: 
        :type vlan_id: str
        :param assigned_object_type: 
        :type assigned_object_type: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param assigned_object_type_id__n: 
        :type assigned_object_type_id__n: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param l2vpn_id__n: 
        :type l2vpn_id__n: str
        :param l2vpn__n: 
        :type l2vpn__n: str
        :param device__n: 
        :type device__n: str
        :param device_id__n: 
        :type device_id__n: str
        :param virtual_machine__n: 
        :type virtual_machine__n: str
        :param virtual_machine_id__n: 
        :type virtual_machine_id__n: str
        :param interface__n: 
        :type interface__n: str
        :param interface_id__n: 
        :type interface_id__n: str
        :param vminterface__n: 
        :type vminterface__n: str
        :param vminterface_id__n: 
        :type vminterface_id__n: str
        :param vlan__n: 
        :type vlan__n: str
        :param vlan_vid__n: 
        :type vlan_vid__n: float
        :param vlan_vid__lte: 
        :type vlan_vid__lte: float
        :param vlan_vid__lt: 
        :type vlan_vid__lt: float
        :param vlan_vid__gte: 
        :type vlan_vid__gte: float
        :param vlan_vid__gt: 
        :type vlan_vid__gt: float
        :param vlan_id__n: 
        :type vlan_id__n: str
        :param assigned_object_type__n: 
        :type assigned_object_type__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_list_serialize(
            id=id,
            assigned_object_type_id=assigned_object_type_id,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            l2vpn_id=l2vpn_id,
            l2vpn=l2vpn,
            region=region,
            region_id=region_id,
            site=site,
            site_id=site_id,
            device=device,
            device_id=device_id,
            virtual_machine=virtual_machine,
            virtual_machine_id=virtual_machine_id,
            interface=interface,
            interface_id=interface_id,
            vminterface=vminterface,
            vminterface_id=vminterface_id,
            vlan=vlan,
            vlan_vid=vlan_vid,
            vlan_id=vlan_id,
            assigned_object_type=assigned_object_type,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            assigned_object_type_id__n=assigned_object_type_id__n,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            l2vpn_id__n=l2vpn_id__n,
            l2vpn__n=l2vpn__n,
            device__n=device__n,
            device_id__n=device_id__n,
            virtual_machine__n=virtual_machine__n,
            virtual_machine_id__n=virtual_machine_id__n,
            interface__n=interface__n,
            interface_id__n=interface_id__n,
            vminterface__n=vminterface__n,
            vminterface_id__n=vminterface_id__n,
            vlan__n=vlan__n,
            vlan_vid__n=vlan_vid__n,
            vlan_vid__lte=vlan_vid__lte,
            vlan_vid__lt=vlan_vid__lt,
            vlan_vid__gte=vlan_vid__gte,
            vlan_vid__gt=vlan_vid__gt,
            vlan_id__n=vlan_id__n,
            assigned_object_type__n=assigned_object_type__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamL2vpnTerminationsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpn_terminations_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        assigned_object_type_id: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        l2vpn_id: Optional[StrictStr] = None,
        l2vpn: Optional[StrictStr] = None,
        region: Optional[StrictStr] = None,
        region_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        interface: Optional[StrictStr] = None,
        interface_id: Optional[StrictStr] = None,
        vminterface: Optional[StrictStr] = None,
        vminterface_id: Optional[StrictStr] = None,
        vlan: Optional[StrictStr] = None,
        vlan_vid: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_id: Optional[StrictStr] = None,
        assigned_object_type: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        assigned_object_type_id__n: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        l2vpn_id__n: Optional[StrictStr] = None,
        l2vpn__n: Optional[StrictStr] = None,
        device__n: Optional[StrictStr] = None,
        device_id__n: Optional[StrictStr] = None,
        virtual_machine__n: Optional[StrictStr] = None,
        virtual_machine_id__n: Optional[StrictStr] = None,
        interface__n: Optional[StrictStr] = None,
        interface_id__n: Optional[StrictStr] = None,
        vminterface__n: Optional[StrictStr] = None,
        vminterface_id__n: Optional[StrictStr] = None,
        vlan__n: Optional[StrictStr] = None,
        vlan_vid__n: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lt: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gt: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_id__n: Optional[StrictStr] = None,
        assigned_object_type__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamL2vpnTerminationsList200Response]:
        """ipam_l2vpn_terminations_list

        

        :param id: 
        :type id: str
        :param assigned_object_type_id: 
        :type assigned_object_type_id: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param l2vpn_id: 
        :type l2vpn_id: str
        :param l2vpn: 
        :type l2vpn: str
        :param region: 
        :type region: str
        :param region_id: 
        :type region_id: str
        :param site: 
        :type site: str
        :param site_id: 
        :type site_id: str
        :param device: 
        :type device: str
        :param device_id: 
        :type device_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param interface: 
        :type interface: str
        :param interface_id: 
        :type interface_id: str
        :param vminterface: 
        :type vminterface: str
        :param vminterface_id: 
        :type vminterface_id: str
        :param vlan: 
        :type vlan: str
        :param vlan_vid: 
        :type vlan_vid: float
        :param vlan_id: 
        :type vlan_id: str
        :param assigned_object_type: 
        :type assigned_object_type: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param assigned_object_type_id__n: 
        :type assigned_object_type_id__n: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param l2vpn_id__n: 
        :type l2vpn_id__n: str
        :param l2vpn__n: 
        :type l2vpn__n: str
        :param device__n: 
        :type device__n: str
        :param device_id__n: 
        :type device_id__n: str
        :param virtual_machine__n: 
        :type virtual_machine__n: str
        :param virtual_machine_id__n: 
        :type virtual_machine_id__n: str
        :param interface__n: 
        :type interface__n: str
        :param interface_id__n: 
        :type interface_id__n: str
        :param vminterface__n: 
        :type vminterface__n: str
        :param vminterface_id__n: 
        :type vminterface_id__n: str
        :param vlan__n: 
        :type vlan__n: str
        :param vlan_vid__n: 
        :type vlan_vid__n: float
        :param vlan_vid__lte: 
        :type vlan_vid__lte: float
        :param vlan_vid__lt: 
        :type vlan_vid__lt: float
        :param vlan_vid__gte: 
        :type vlan_vid__gte: float
        :param vlan_vid__gt: 
        :type vlan_vid__gt: float
        :param vlan_id__n: 
        :type vlan_id__n: str
        :param assigned_object_type__n: 
        :type assigned_object_type__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_list_serialize(
            id=id,
            assigned_object_type_id=assigned_object_type_id,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            l2vpn_id=l2vpn_id,
            l2vpn=l2vpn,
            region=region,
            region_id=region_id,
            site=site,
            site_id=site_id,
            device=device,
            device_id=device_id,
            virtual_machine=virtual_machine,
            virtual_machine_id=virtual_machine_id,
            interface=interface,
            interface_id=interface_id,
            vminterface=vminterface,
            vminterface_id=vminterface_id,
            vlan=vlan,
            vlan_vid=vlan_vid,
            vlan_id=vlan_id,
            assigned_object_type=assigned_object_type,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            assigned_object_type_id__n=assigned_object_type_id__n,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            l2vpn_id__n=l2vpn_id__n,
            l2vpn__n=l2vpn__n,
            device__n=device__n,
            device_id__n=device_id__n,
            virtual_machine__n=virtual_machine__n,
            virtual_machine_id__n=virtual_machine_id__n,
            interface__n=interface__n,
            interface_id__n=interface_id__n,
            vminterface__n=vminterface__n,
            vminterface_id__n=vminterface_id__n,
            vlan__n=vlan__n,
            vlan_vid__n=vlan_vid__n,
            vlan_vid__lte=vlan_vid__lte,
            vlan_vid__lt=vlan_vid__lt,
            vlan_vid__gte=vlan_vid__gte,
            vlan_vid__gt=vlan_vid__gt,
            vlan_id__n=vlan_id__n,
            assigned_object_type__n=assigned_object_type__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamL2vpnTerminationsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpn_terminations_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        assigned_object_type_id: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        l2vpn_id: Optional[StrictStr] = None,
        l2vpn: Optional[StrictStr] = None,
        region: Optional[StrictStr] = None,
        region_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        interface: Optional[StrictStr] = None,
        interface_id: Optional[StrictStr] = None,
        vminterface: Optional[StrictStr] = None,
        vminterface_id: Optional[StrictStr] = None,
        vlan: Optional[StrictStr] = None,
        vlan_vid: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_id: Optional[StrictStr] = None,
        assigned_object_type: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        assigned_object_type_id__n: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        l2vpn_id__n: Optional[StrictStr] = None,
        l2vpn__n: Optional[StrictStr] = None,
        device__n: Optional[StrictStr] = None,
        device_id__n: Optional[StrictStr] = None,
        virtual_machine__n: Optional[StrictStr] = None,
        virtual_machine_id__n: Optional[StrictStr] = None,
        interface__n: Optional[StrictStr] = None,
        interface_id__n: Optional[StrictStr] = None,
        vminterface__n: Optional[StrictStr] = None,
        vminterface_id__n: Optional[StrictStr] = None,
        vlan__n: Optional[StrictStr] = None,
        vlan_vid__n: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lt: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gt: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_id__n: Optional[StrictStr] = None,
        assigned_object_type__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpn_terminations_list

        

        :param id: 
        :type id: str
        :param assigned_object_type_id: 
        :type assigned_object_type_id: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param l2vpn_id: 
        :type l2vpn_id: str
        :param l2vpn: 
        :type l2vpn: str
        :param region: 
        :type region: str
        :param region_id: 
        :type region_id: str
        :param site: 
        :type site: str
        :param site_id: 
        :type site_id: str
        :param device: 
        :type device: str
        :param device_id: 
        :type device_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param interface: 
        :type interface: str
        :param interface_id: 
        :type interface_id: str
        :param vminterface: 
        :type vminterface: str
        :param vminterface_id: 
        :type vminterface_id: str
        :param vlan: 
        :type vlan: str
        :param vlan_vid: 
        :type vlan_vid: float
        :param vlan_id: 
        :type vlan_id: str
        :param assigned_object_type: 
        :type assigned_object_type: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param assigned_object_type_id__n: 
        :type assigned_object_type_id__n: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param l2vpn_id__n: 
        :type l2vpn_id__n: str
        :param l2vpn__n: 
        :type l2vpn__n: str
        :param device__n: 
        :type device__n: str
        :param device_id__n: 
        :type device_id__n: str
        :param virtual_machine__n: 
        :type virtual_machine__n: str
        :param virtual_machine_id__n: 
        :type virtual_machine_id__n: str
        :param interface__n: 
        :type interface__n: str
        :param interface_id__n: 
        :type interface_id__n: str
        :param vminterface__n: 
        :type vminterface__n: str
        :param vminterface_id__n: 
        :type vminterface_id__n: str
        :param vlan__n: 
        :type vlan__n: str
        :param vlan_vid__n: 
        :type vlan_vid__n: float
        :param vlan_vid__lte: 
        :type vlan_vid__lte: float
        :param vlan_vid__lt: 
        :type vlan_vid__lt: float
        :param vlan_vid__gte: 
        :type vlan_vid__gte: float
        :param vlan_vid__gt: 
        :type vlan_vid__gt: float
        :param vlan_id__n: 
        :type vlan_id__n: str
        :param assigned_object_type__n: 
        :type assigned_object_type__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_list_serialize(
            id=id,
            assigned_object_type_id=assigned_object_type_id,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            l2vpn_id=l2vpn_id,
            l2vpn=l2vpn,
            region=region,
            region_id=region_id,
            site=site,
            site_id=site_id,
            device=device,
            device_id=device_id,
            virtual_machine=virtual_machine,
            virtual_machine_id=virtual_machine_id,
            interface=interface,
            interface_id=interface_id,
            vminterface=vminterface,
            vminterface_id=vminterface_id,
            vlan=vlan,
            vlan_vid=vlan_vid,
            vlan_id=vlan_id,
            assigned_object_type=assigned_object_type,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            assigned_object_type_id__n=assigned_object_type_id__n,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            l2vpn_id__n=l2vpn_id__n,
            l2vpn__n=l2vpn__n,
            device__n=device__n,
            device_id__n=device_id__n,
            virtual_machine__n=virtual_machine__n,
            virtual_machine_id__n=virtual_machine_id__n,
            interface__n=interface__n,
            interface_id__n=interface_id__n,
            vminterface__n=vminterface__n,
            vminterface_id__n=vminterface_id__n,
            vlan__n=vlan__n,
            vlan_vid__n=vlan_vid__n,
            vlan_vid__lte=vlan_vid__lte,
            vlan_vid__lt=vlan_vid__lt,
            vlan_vid__gte=vlan_vid__gte,
            vlan_vid__gt=vlan_vid__gt,
            vlan_id__n=vlan_id__n,
            assigned_object_type__n=assigned_object_type__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamL2vpnTerminationsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpn_terminations_list_serialize(
        self,
        id,
        assigned_object_type_id,
        created,
        last_updated,
        q,
        tag,
        l2vpn_id,
        l2vpn,
        region,
        region_id,
        site,
        site_id,
        device,
        device_id,
        virtual_machine,
        virtual_machine_id,
        interface,
        interface_id,
        vminterface,
        vminterface_id,
        vlan,
        vlan_vid,
        vlan_id,
        assigned_object_type,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        assigned_object_type_id__n,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        l2vpn_id__n,
        l2vpn__n,
        device__n,
        device_id__n,
        virtual_machine__n,
        virtual_machine_id__n,
        interface__n,
        interface_id__n,
        vminterface__n,
        vminterface_id__n,
        vlan__n,
        vlan_vid__n,
        vlan_vid__lte,
        vlan_vid__lt,
        vlan_vid__gte,
        vlan_vid__gt,
        vlan_id__n,
        assigned_object_type__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if assigned_object_type_id is not None:
            
            _query_params.append(('assigned_object_type_id', assigned_object_type_id))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if l2vpn_id is not None:
            
            _query_params.append(('l2vpn_id', l2vpn_id))
            
        if l2vpn is not None:
            
            _query_params.append(('l2vpn', l2vpn))
            
        if region is not None:
            
            _query_params.append(('region', region))
            
        if region_id is not None:
            
            _query_params.append(('region_id', region_id))
            
        if site is not None:
            
            _query_params.append(('site', site))
            
        if site_id is not None:
            
            _query_params.append(('site_id', site_id))
            
        if device is not None:
            
            _query_params.append(('device', device))
            
        if device_id is not None:
            
            _query_params.append(('device_id', device_id))
            
        if virtual_machine is not None:
            
            _query_params.append(('virtual_machine', virtual_machine))
            
        if virtual_machine_id is not None:
            
            _query_params.append(('virtual_machine_id', virtual_machine_id))
            
        if interface is not None:
            
            _query_params.append(('interface', interface))
            
        if interface_id is not None:
            
            _query_params.append(('interface_id', interface_id))
            
        if vminterface is not None:
            
            _query_params.append(('vminterface', vminterface))
            
        if vminterface_id is not None:
            
            _query_params.append(('vminterface_id', vminterface_id))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if vlan_vid is not None:
            
            _query_params.append(('vlan_vid', vlan_vid))
            
        if vlan_id is not None:
            
            _query_params.append(('vlan_id', vlan_id))
            
        if assigned_object_type is not None:
            
            _query_params.append(('assigned_object_type', assigned_object_type))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if assigned_object_type_id__n is not None:
            
            _query_params.append(('assigned_object_type_id__n', assigned_object_type_id__n))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if l2vpn_id__n is not None:
            
            _query_params.append(('l2vpn_id__n', l2vpn_id__n))
            
        if l2vpn__n is not None:
            
            _query_params.append(('l2vpn__n', l2vpn__n))
            
        if device__n is not None:
            
            _query_params.append(('device__n', device__n))
            
        if device_id__n is not None:
            
            _query_params.append(('device_id__n', device_id__n))
            
        if virtual_machine__n is not None:
            
            _query_params.append(('virtual_machine__n', virtual_machine__n))
            
        if virtual_machine_id__n is not None:
            
            _query_params.append(('virtual_machine_id__n', virtual_machine_id__n))
            
        if interface__n is not None:
            
            _query_params.append(('interface__n', interface__n))
            
        if interface_id__n is not None:
            
            _query_params.append(('interface_id__n', interface_id__n))
            
        if vminterface__n is not None:
            
            _query_params.append(('vminterface__n', vminterface__n))
            
        if vminterface_id__n is not None:
            
            _query_params.append(('vminterface_id__n', vminterface_id__n))
            
        if vlan__n is not None:
            
            _query_params.append(('vlan__n', vlan__n))
            
        if vlan_vid__n is not None:
            
            _query_params.append(('vlan_vid__n', vlan_vid__n))
            
        if vlan_vid__lte is not None:
            
            _query_params.append(('vlan_vid__lte', vlan_vid__lte))
            
        if vlan_vid__lt is not None:
            
            _query_params.append(('vlan_vid__lt', vlan_vid__lt))
            
        if vlan_vid__gte is not None:
            
            _query_params.append(('vlan_vid__gte', vlan_vid__gte))
            
        if vlan_vid__gt is not None:
            
            _query_params.append(('vlan_vid__gt', vlan_vid__gt))
            
        if vlan_id__n is not None:
            
            _query_params.append(('vlan_id__n', vlan_id__n))
            
        if assigned_object_type__n is not None:
            
            _query_params.append(('assigned_object_type__n', assigned_object_type__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/l2vpn-terminations/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpn_terminations_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPNTermination:
        """ipam_l2vpn_terminations_partial_update

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_partial_update_serialize(
            id=id,
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpn_terminations_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPNTermination]:
        """ipam_l2vpn_terminations_partial_update

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_partial_update_serialize(
            id=id,
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpn_terminations_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpn_terminations_partial_update

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_partial_update_serialize(
            id=id,
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpn_terminations_partial_update_serialize(
        self,
        id,
        writable_l2_vpn_termination,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_l2_vpn_termination is not None:
            _body_params = writable_l2_vpn_termination


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/l2vpn-terminations/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpn_terminations_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPNTermination:
        """ipam_l2vpn_terminations_read

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpn_terminations_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPNTermination]:
        """ipam_l2vpn_terminations_read

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpn_terminations_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpn_terminations_read

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpn_terminations_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/l2vpn-terminations/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpn_terminations_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPNTermination:
        """ipam_l2vpn_terminations_update

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_update_serialize(
            id=id,
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpn_terminations_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPNTermination]:
        """ipam_l2vpn_terminations_update

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_update_serialize(
            id=id,
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpn_terminations_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN termination.")],
        writable_l2_vpn_termination: WritableL2VPNTermination,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpn_terminations_update

        

        :param id: A unique integer value identifying this L2VPN termination. (required)
        :type id: int
        :param writable_l2_vpn_termination: (required)
        :type writable_l2_vpn_termination: WritableL2VPNTermination
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpn_terminations_update_serialize(
            id=id,
            writable_l2_vpn_termination=writable_l2_vpn_termination,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPNTermination",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpn_terminations_update_serialize(
        self,
        id,
        writable_l2_vpn_termination,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_l2_vpn_termination is not None:
            _body_params = writable_l2_vpn_termination


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/l2vpn-terminations/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpns_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_l2vpns_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpns_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_l2vpns_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpns_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpns_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpns_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/l2vpns/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpns_bulk_partial_update(
        self,
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPN:
        """ipam_l2vpns_bulk_partial_update

        

        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_bulk_partial_update_serialize(
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpns_bulk_partial_update_with_http_info(
        self,
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPN]:
        """ipam_l2vpns_bulk_partial_update

        

        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_bulk_partial_update_serialize(
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpns_bulk_partial_update_without_preload_content(
        self,
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpns_bulk_partial_update

        

        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_bulk_partial_update_serialize(
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpns_bulk_partial_update_serialize(
        self,
        writable_l2_vpn,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_l2_vpn is not None:
            _body_params = writable_l2_vpn


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/l2vpns/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpns_bulk_update(
        self,
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPN:
        """ipam_l2vpns_bulk_update

        

        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_bulk_update_serialize(
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpns_bulk_update_with_http_info(
        self,
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPN]:
        """ipam_l2vpns_bulk_update

        

        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_bulk_update_serialize(
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpns_bulk_update_without_preload_content(
        self,
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpns_bulk_update

        

        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_bulk_update_serialize(
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpns_bulk_update_serialize(
        self,
        writable_l2_vpn,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_l2_vpn is not None:
            _body_params = writable_l2_vpn


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/l2vpns/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpns_create(
        self,
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPN:
        """ipam_l2vpns_create

        

        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_create_serialize(
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpns_create_with_http_info(
        self,
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPN]:
        """ipam_l2vpns_create

        

        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_create_serialize(
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpns_create_without_preload_content(
        self,
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpns_create

        

        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_create_serialize(
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpns_create_serialize(
        self,
        writable_l2_vpn,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_l2_vpn is not None:
            _body_params = writable_l2_vpn


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/l2vpns/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpns_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_l2vpns_delete

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpns_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_l2vpns_delete

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpns_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpns_delete

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpns_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/l2vpns/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpns_list(
        self,
        id: Optional[StrictStr] = None,
        identifier: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        type: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        import_target_id: Optional[StrictStr] = None,
        import_target: Optional[StrictStr] = None,
        export_target_id: Optional[StrictStr] = None,
        export_target: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        identifier__n: Optional[StrictStr] = None,
        identifier__lte: Optional[StrictStr] = None,
        identifier__lt: Optional[StrictStr] = None,
        identifier__gte: Optional[StrictStr] = None,
        identifier__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        type__n: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        import_target_id__n: Optional[StrictStr] = None,
        import_target__n: Optional[StrictStr] = None,
        export_target_id__n: Optional[StrictStr] = None,
        export_target__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamL2vpnsList200Response:
        """ipam_l2vpns_list

        

        :param id: 
        :type id: str
        :param identifier: 
        :type identifier: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param type: 
        :type type: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param import_target_id: 
        :type import_target_id: str
        :param import_target: 
        :type import_target: str
        :param export_target_id: 
        :type export_target_id: str
        :param export_target: 
        :type export_target: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param identifier__n: 
        :type identifier__n: str
        :param identifier__lte: 
        :type identifier__lte: str
        :param identifier__lt: 
        :type identifier__lt: str
        :param identifier__gte: 
        :type identifier__gte: str
        :param identifier__gt: 
        :type identifier__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param type__n: 
        :type type__n: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param import_target_id__n: 
        :type import_target_id__n: str
        :param import_target__n: 
        :type import_target__n: str
        :param export_target_id__n: 
        :type export_target_id__n: str
        :param export_target__n: 
        :type export_target__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_list_serialize(
            id=id,
            identifier=identifier,
            name=name,
            slug=slug,
            type=type,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            import_target_id=import_target_id,
            import_target=import_target,
            export_target_id=export_target_id,
            export_target=export_target,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            identifier__n=identifier__n,
            identifier__lte=identifier__lte,
            identifier__lt=identifier__lt,
            identifier__gte=identifier__gte,
            identifier__gt=identifier__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            type__n=type__n,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            import_target_id__n=import_target_id__n,
            import_target__n=import_target__n,
            export_target_id__n=export_target_id__n,
            export_target__n=export_target__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamL2vpnsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpns_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        identifier: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        type: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        import_target_id: Optional[StrictStr] = None,
        import_target: Optional[StrictStr] = None,
        export_target_id: Optional[StrictStr] = None,
        export_target: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        identifier__n: Optional[StrictStr] = None,
        identifier__lte: Optional[StrictStr] = None,
        identifier__lt: Optional[StrictStr] = None,
        identifier__gte: Optional[StrictStr] = None,
        identifier__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        type__n: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        import_target_id__n: Optional[StrictStr] = None,
        import_target__n: Optional[StrictStr] = None,
        export_target_id__n: Optional[StrictStr] = None,
        export_target__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamL2vpnsList200Response]:
        """ipam_l2vpns_list

        

        :param id: 
        :type id: str
        :param identifier: 
        :type identifier: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param type: 
        :type type: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param import_target_id: 
        :type import_target_id: str
        :param import_target: 
        :type import_target: str
        :param export_target_id: 
        :type export_target_id: str
        :param export_target: 
        :type export_target: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param identifier__n: 
        :type identifier__n: str
        :param identifier__lte: 
        :type identifier__lte: str
        :param identifier__lt: 
        :type identifier__lt: str
        :param identifier__gte: 
        :type identifier__gte: str
        :param identifier__gt: 
        :type identifier__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param type__n: 
        :type type__n: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param import_target_id__n: 
        :type import_target_id__n: str
        :param import_target__n: 
        :type import_target__n: str
        :param export_target_id__n: 
        :type export_target_id__n: str
        :param export_target__n: 
        :type export_target__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_list_serialize(
            id=id,
            identifier=identifier,
            name=name,
            slug=slug,
            type=type,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            import_target_id=import_target_id,
            import_target=import_target,
            export_target_id=export_target_id,
            export_target=export_target,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            identifier__n=identifier__n,
            identifier__lte=identifier__lte,
            identifier__lt=identifier__lt,
            identifier__gte=identifier__gte,
            identifier__gt=identifier__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            type__n=type__n,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            import_target_id__n=import_target_id__n,
            import_target__n=import_target__n,
            export_target_id__n=export_target_id__n,
            export_target__n=export_target__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamL2vpnsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpns_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        identifier: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        type: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        import_target_id: Optional[StrictStr] = None,
        import_target: Optional[StrictStr] = None,
        export_target_id: Optional[StrictStr] = None,
        export_target: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        identifier__n: Optional[StrictStr] = None,
        identifier__lte: Optional[StrictStr] = None,
        identifier__lt: Optional[StrictStr] = None,
        identifier__gte: Optional[StrictStr] = None,
        identifier__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        type__n: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        import_target_id__n: Optional[StrictStr] = None,
        import_target__n: Optional[StrictStr] = None,
        export_target_id__n: Optional[StrictStr] = None,
        export_target__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpns_list

        

        :param id: 
        :type id: str
        :param identifier: 
        :type identifier: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param type: 
        :type type: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param import_target_id: 
        :type import_target_id: str
        :param import_target: 
        :type import_target: str
        :param export_target_id: 
        :type export_target_id: str
        :param export_target: 
        :type export_target: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param identifier__n: 
        :type identifier__n: str
        :param identifier__lte: 
        :type identifier__lte: str
        :param identifier__lt: 
        :type identifier__lt: str
        :param identifier__gte: 
        :type identifier__gte: str
        :param identifier__gt: 
        :type identifier__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param type__n: 
        :type type__n: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param import_target_id__n: 
        :type import_target_id__n: str
        :param import_target__n: 
        :type import_target__n: str
        :param export_target_id__n: 
        :type export_target_id__n: str
        :param export_target__n: 
        :type export_target__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_list_serialize(
            id=id,
            identifier=identifier,
            name=name,
            slug=slug,
            type=type,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            import_target_id=import_target_id,
            import_target=import_target,
            export_target_id=export_target_id,
            export_target=export_target,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            identifier__n=identifier__n,
            identifier__lte=identifier__lte,
            identifier__lt=identifier__lt,
            identifier__gte=identifier__gte,
            identifier__gt=identifier__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            type__n=type__n,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            import_target_id__n=import_target_id__n,
            import_target__n=import_target__n,
            export_target_id__n=export_target_id__n,
            export_target__n=export_target__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamL2vpnsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpns_list_serialize(
        self,
        id,
        identifier,
        name,
        slug,
        type,
        description,
        created,
        last_updated,
        q,
        tag,
        tenant_group_id,
        tenant_group,
        tenant_id,
        tenant,
        import_target_id,
        import_target,
        export_target_id,
        export_target,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        identifier__n,
        identifier__lte,
        identifier__lt,
        identifier__gte,
        identifier__gt,
        name__n,
        name__ic,
        name__nic,
        name__iew,
        name__niew,
        name__isw,
        name__nisw,
        name__ie,
        name__nie,
        name__empty,
        slug__n,
        slug__ic,
        slug__nic,
        slug__iew,
        slug__niew,
        slug__isw,
        slug__nisw,
        slug__ie,
        slug__nie,
        slug__empty,
        type__n,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        tenant_group_id__n,
        tenant_group__n,
        tenant_id__n,
        tenant__n,
        import_target_id__n,
        import_target__n,
        export_target_id__n,
        export_target__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if identifier is not None:
            
            _query_params.append(('identifier', identifier))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if slug is not None:
            
            _query_params.append(('slug', slug))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tenant_group_id is not None:
            
            _query_params.append(('tenant_group_id', tenant_group_id))
            
        if tenant_group is not None:
            
            _query_params.append(('tenant_group', tenant_group))
            
        if tenant_id is not None:
            
            _query_params.append(('tenant_id', tenant_id))
            
        if tenant is not None:
            
            _query_params.append(('tenant', tenant))
            
        if import_target_id is not None:
            
            _query_params.append(('import_target_id', import_target_id))
            
        if import_target is not None:
            
            _query_params.append(('import_target', import_target))
            
        if export_target_id is not None:
            
            _query_params.append(('export_target_id', export_target_id))
            
        if export_target is not None:
            
            _query_params.append(('export_target', export_target))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if identifier__n is not None:
            
            _query_params.append(('identifier__n', identifier__n))
            
        if identifier__lte is not None:
            
            _query_params.append(('identifier__lte', identifier__lte))
            
        if identifier__lt is not None:
            
            _query_params.append(('identifier__lt', identifier__lt))
            
        if identifier__gte is not None:
            
            _query_params.append(('identifier__gte', identifier__gte))
            
        if identifier__gt is not None:
            
            _query_params.append(('identifier__gt', identifier__gt))
            
        if name__n is not None:
            
            _query_params.append(('name__n', name__n))
            
        if name__ic is not None:
            
            _query_params.append(('name__ic', name__ic))
            
        if name__nic is not None:
            
            _query_params.append(('name__nic', name__nic))
            
        if name__iew is not None:
            
            _query_params.append(('name__iew', name__iew))
            
        if name__niew is not None:
            
            _query_params.append(('name__niew', name__niew))
            
        if name__isw is not None:
            
            _query_params.append(('name__isw', name__isw))
            
        if name__nisw is not None:
            
            _query_params.append(('name__nisw', name__nisw))
            
        if name__ie is not None:
            
            _query_params.append(('name__ie', name__ie))
            
        if name__nie is not None:
            
            _query_params.append(('name__nie', name__nie))
            
        if name__empty is not None:
            
            _query_params.append(('name__empty', name__empty))
            
        if slug__n is not None:
            
            _query_params.append(('slug__n', slug__n))
            
        if slug__ic is not None:
            
            _query_params.append(('slug__ic', slug__ic))
            
        if slug__nic is not None:
            
            _query_params.append(('slug__nic', slug__nic))
            
        if slug__iew is not None:
            
            _query_params.append(('slug__iew', slug__iew))
            
        if slug__niew is not None:
            
            _query_params.append(('slug__niew', slug__niew))
            
        if slug__isw is not None:
            
            _query_params.append(('slug__isw', slug__isw))
            
        if slug__nisw is not None:
            
            _query_params.append(('slug__nisw', slug__nisw))
            
        if slug__ie is not None:
            
            _query_params.append(('slug__ie', slug__ie))
            
        if slug__nie is not None:
            
            _query_params.append(('slug__nie', slug__nie))
            
        if slug__empty is not None:
            
            _query_params.append(('slug__empty', slug__empty))
            
        if type__n is not None:
            
            _query_params.append(('type__n', type__n))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if tenant_group_id__n is not None:
            
            _query_params.append(('tenant_group_id__n', tenant_group_id__n))
            
        if tenant_group__n is not None:
            
            _query_params.append(('tenant_group__n', tenant_group__n))
            
        if tenant_id__n is not None:
            
            _query_params.append(('tenant_id__n', tenant_id__n))
            
        if tenant__n is not None:
            
            _query_params.append(('tenant__n', tenant__n))
            
        if import_target_id__n is not None:
            
            _query_params.append(('import_target_id__n', import_target_id__n))
            
        if import_target__n is not None:
            
            _query_params.append(('import_target__n', import_target__n))
            
        if export_target_id__n is not None:
            
            _query_params.append(('export_target_id__n', export_target_id__n))
            
        if export_target__n is not None:
            
            _query_params.append(('export_target__n', export_target__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/l2vpns/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpns_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPN:
        """ipam_l2vpns_partial_update

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_partial_update_serialize(
            id=id,
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpns_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPN]:
        """ipam_l2vpns_partial_update

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_partial_update_serialize(
            id=id,
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpns_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpns_partial_update

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_partial_update_serialize(
            id=id,
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpns_partial_update_serialize(
        self,
        id,
        writable_l2_vpn,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_l2_vpn is not None:
            _body_params = writable_l2_vpn


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/l2vpns/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpns_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPN:
        """ipam_l2vpns_read

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpns_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPN]:
        """ipam_l2vpns_read

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpns_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpns_read

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpns_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/l2vpns/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_l2vpns_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L2VPN:
        """ipam_l2vpns_update

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_update_serialize(
            id=id,
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_l2vpns_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L2VPN]:
        """ipam_l2vpns_update

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_update_serialize(
            id=id,
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_l2vpns_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this L2VPN.")],
        writable_l2_vpn: WritableL2VPN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_l2vpns_update

        

        :param id: A unique integer value identifying this L2VPN. (required)
        :type id: int
        :param writable_l2_vpn: (required)
        :type writable_l2_vpn: WritableL2VPN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_l2vpns_update_serialize(
            id=id,
            writable_l2_vpn=writable_l2_vpn,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L2VPN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_l2vpns_update_serialize(
        self,
        id,
        writable_l2_vpn,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_l2_vpn is not None:
            _body_params = writable_l2_vpn


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/l2vpns/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_available_ips_create(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_available_ip: WritableAvailableIP,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[IPAddress]:
        """ipam_prefixes_available_ips_create

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_available_ip: (required)
        :type writable_available_ip: WritableAvailableIP
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_ips_create_serialize(
            id=id,
            writable_available_ip=writable_available_ip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[IPAddress]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_available_ips_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_available_ip: WritableAvailableIP,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[IPAddress]]:
        """ipam_prefixes_available_ips_create

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_available_ip: (required)
        :type writable_available_ip: WritableAvailableIP
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_ips_create_serialize(
            id=id,
            writable_available_ip=writable_available_ip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[IPAddress]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_available_ips_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        writable_available_ip: WritableAvailableIP,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_available_ips_create

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param writable_available_ip: (required)
        :type writable_available_ip: WritableAvailableIP
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_ips_create_serialize(
            id=id,
            writable_available_ip=writable_available_ip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[IPAddress]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_available_ips_create_serialize(
        self,
        id,
        writable_available_ip,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_available_ip is not None:
            _body_params = writable_available_ip


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/prefixes/{id}/available-ips/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_available_ips_list(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AvailableIP]:
        """ipam_prefixes_available_ips_list

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_ips_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailableIP]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_available_ips_list_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AvailableIP]]:
        """ipam_prefixes_available_ips_list

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_ips_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailableIP]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_available_ips_list_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this IP address.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_available_ips_list

        

        :param id: A unique integer value identifying this IP address. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_ips_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailableIP]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_available_ips_list_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/prefixes/{id}/available-ips/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_available_prefixes_create(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        prefix_length: PrefixLength,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Prefix]:
        """ipam_prefixes_available_prefixes_create

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param prefix_length: (required)
        :type prefix_length: PrefixLength
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_prefixes_create_serialize(
            id=id,
            prefix_length=prefix_length,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[Prefix]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_available_prefixes_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        prefix_length: PrefixLength,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Prefix]]:
        """ipam_prefixes_available_prefixes_create

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param prefix_length: (required)
        :type prefix_length: PrefixLength
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_prefixes_create_serialize(
            id=id,
            prefix_length=prefix_length,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[Prefix]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_available_prefixes_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        prefix_length: PrefixLength,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_available_prefixes_create

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param prefix_length: (required)
        :type prefix_length: PrefixLength
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_prefixes_create_serialize(
            id=id,
            prefix_length=prefix_length,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[Prefix]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_available_prefixes_create_serialize(
        self,
        id,
        prefix_length,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if prefix_length is not None:
            _body_params = prefix_length


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/prefixes/{id}/available-prefixes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_available_prefixes_list(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AvailablePrefix]:
        """ipam_prefixes_available_prefixes_list

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_prefixes_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailablePrefix]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_available_prefixes_list_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AvailablePrefix]]:
        """ipam_prefixes_available_prefixes_list

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_prefixes_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailablePrefix]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_available_prefixes_list_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_available_prefixes_list

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_available_prefixes_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailablePrefix]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_available_prefixes_list_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/prefixes/{id}/available-prefixes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_prefixes_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_prefixes_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/prefixes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_bulk_partial_update(
        self,
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Prefix:
        """ipam_prefixes_bulk_partial_update

        

        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_bulk_partial_update_serialize(
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_bulk_partial_update_with_http_info(
        self,
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Prefix]:
        """ipam_prefixes_bulk_partial_update

        

        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_bulk_partial_update_serialize(
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_bulk_partial_update_without_preload_content(
        self,
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_bulk_partial_update

        

        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_bulk_partial_update_serialize(
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_bulk_partial_update_serialize(
        self,
        writable_prefix,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_prefix is not None:
            _body_params = writable_prefix


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/prefixes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_bulk_update(
        self,
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Prefix:
        """ipam_prefixes_bulk_update

        

        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_bulk_update_serialize(
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_bulk_update_with_http_info(
        self,
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Prefix]:
        """ipam_prefixes_bulk_update

        

        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_bulk_update_serialize(
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_bulk_update_without_preload_content(
        self,
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_bulk_update

        

        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_bulk_update_serialize(
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_bulk_update_serialize(
        self,
        writable_prefix,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_prefix is not None:
            _body_params = writable_prefix


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/prefixes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_create(
        self,
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Prefix:
        """ipam_prefixes_create

        

        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_create_serialize(
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_create_with_http_info(
        self,
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Prefix]:
        """ipam_prefixes_create

        

        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_create_serialize(
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_create_without_preload_content(
        self,
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_create

        

        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_create_serialize(
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_create_serialize(
        self,
        writable_prefix,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_prefix is not None:
            _body_params = writable_prefix


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/prefixes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_prefixes_delete

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_prefixes_delete

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_delete

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/prefixes/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_list(
        self,
        id: Optional[StrictStr] = None,
        is_pool: Optional[StrictStr] = None,
        mark_utilized: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        prefix: Optional[StrictStr] = None,
        within: Optional[StrictStr] = None,
        within_include: Optional[StrictStr] = None,
        contains: Optional[StrictStr] = None,
        depth: Optional[StrictStr] = None,
        children: Optional[StrictStr] = None,
        mask_length: Optional[StrictStr] = None,
        mask_length__gte: Optional[Union[StrictFloat, StrictInt]] = None,
        mask_length__lte: Optional[Union[StrictFloat, StrictInt]] = None,
        vrf_id: Optional[StrictStr] = None,
        vrf: Optional[StrictStr] = None,
        present_in_vrf_id: Optional[StrictStr] = None,
        present_in_vrf: Optional[StrictStr] = None,
        region_id: Optional[StrictStr] = None,
        region: Optional[StrictStr] = None,
        site_group_id: Optional[StrictStr] = None,
        site_group: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        vlan_id: Optional[StrictStr] = None,
        vlan_vid: Optional[Union[StrictFloat, StrictInt]] = None,
        role_id: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        depth__n: Optional[StrictStr] = None,
        depth__lte: Optional[StrictStr] = None,
        depth__lt: Optional[StrictStr] = None,
        depth__gte: Optional[StrictStr] = None,
        depth__gt: Optional[StrictStr] = None,
        children__n: Optional[StrictStr] = None,
        children__lte: Optional[StrictStr] = None,
        children__lt: Optional[StrictStr] = None,
        children__gte: Optional[StrictStr] = None,
        children__gt: Optional[StrictStr] = None,
        vrf_id__n: Optional[StrictStr] = None,
        vrf__n: Optional[StrictStr] = None,
        region_id__n: Optional[StrictStr] = None,
        region__n: Optional[StrictStr] = None,
        site_group_id__n: Optional[StrictStr] = None,
        site_group__n: Optional[StrictStr] = None,
        site_id__n: Optional[StrictStr] = None,
        site__n: Optional[StrictStr] = None,
        vlan_id__n: Optional[StrictStr] = None,
        vlan_vid__n: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lt: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gt: Optional[Union[StrictFloat, StrictInt]] = None,
        role_id__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamPrefixesList200Response:
        """ipam_prefixes_list

        

        :param id: 
        :type id: str
        :param is_pool: 
        :type is_pool: str
        :param mark_utilized: 
        :type mark_utilized: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param family: 
        :type family: float
        :param prefix: 
        :type prefix: str
        :param within: 
        :type within: str
        :param within_include: 
        :type within_include: str
        :param contains: 
        :type contains: str
        :param depth: 
        :type depth: str
        :param children: 
        :type children: str
        :param mask_length: 
        :type mask_length: str
        :param mask_length__gte: 
        :type mask_length__gte: float
        :param mask_length__lte: 
        :type mask_length__lte: float
        :param vrf_id: 
        :type vrf_id: str
        :param vrf: 
        :type vrf: str
        :param present_in_vrf_id: 
        :type present_in_vrf_id: str
        :param present_in_vrf: 
        :type present_in_vrf: str
        :param region_id: 
        :type region_id: str
        :param region: 
        :type region: str
        :param site_group_id: 
        :type site_group_id: str
        :param site_group: 
        :type site_group: str
        :param site_id: 
        :type site_id: str
        :param site: 
        :type site: str
        :param vlan_id: 
        :type vlan_id: str
        :param vlan_vid: 
        :type vlan_vid: float
        :param role_id: 
        :type role_id: str
        :param role: 
        :type role: str
        :param status: 
        :type status: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param depth__n: 
        :type depth__n: str
        :param depth__lte: 
        :type depth__lte: str
        :param depth__lt: 
        :type depth__lt: str
        :param depth__gte: 
        :type depth__gte: str
        :param depth__gt: 
        :type depth__gt: str
        :param children__n: 
        :type children__n: str
        :param children__lte: 
        :type children__lte: str
        :param children__lt: 
        :type children__lt: str
        :param children__gte: 
        :type children__gte: str
        :param children__gt: 
        :type children__gt: str
        :param vrf_id__n: 
        :type vrf_id__n: str
        :param vrf__n: 
        :type vrf__n: str
        :param region_id__n: 
        :type region_id__n: str
        :param region__n: 
        :type region__n: str
        :param site_group_id__n: 
        :type site_group_id__n: str
        :param site_group__n: 
        :type site_group__n: str
        :param site_id__n: 
        :type site_id__n: str
        :param site__n: 
        :type site__n: str
        :param vlan_id__n: 
        :type vlan_id__n: str
        :param vlan_vid__n: 
        :type vlan_vid__n: float
        :param vlan_vid__lte: 
        :type vlan_vid__lte: float
        :param vlan_vid__lt: 
        :type vlan_vid__lt: float
        :param vlan_vid__gte: 
        :type vlan_vid__gte: float
        :param vlan_vid__gt: 
        :type vlan_vid__gt: float
        :param role_id__n: 
        :type role_id__n: str
        :param role__n: 
        :type role__n: str
        :param status__n: 
        :type status__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_list_serialize(
            id=id,
            is_pool=is_pool,
            mark_utilized=mark_utilized,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            family=family,
            prefix=prefix,
            within=within,
            within_include=within_include,
            contains=contains,
            depth=depth,
            children=children,
            mask_length=mask_length,
            mask_length__gte=mask_length__gte,
            mask_length__lte=mask_length__lte,
            vrf_id=vrf_id,
            vrf=vrf,
            present_in_vrf_id=present_in_vrf_id,
            present_in_vrf=present_in_vrf,
            region_id=region_id,
            region=region,
            site_group_id=site_group_id,
            site_group=site_group,
            site_id=site_id,
            site=site,
            vlan_id=vlan_id,
            vlan_vid=vlan_vid,
            role_id=role_id,
            role=role,
            status=status,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            depth__n=depth__n,
            depth__lte=depth__lte,
            depth__lt=depth__lt,
            depth__gte=depth__gte,
            depth__gt=depth__gt,
            children__n=children__n,
            children__lte=children__lte,
            children__lt=children__lt,
            children__gte=children__gte,
            children__gt=children__gt,
            vrf_id__n=vrf_id__n,
            vrf__n=vrf__n,
            region_id__n=region_id__n,
            region__n=region__n,
            site_group_id__n=site_group_id__n,
            site_group__n=site_group__n,
            site_id__n=site_id__n,
            site__n=site__n,
            vlan_id__n=vlan_id__n,
            vlan_vid__n=vlan_vid__n,
            vlan_vid__lte=vlan_vid__lte,
            vlan_vid__lt=vlan_vid__lt,
            vlan_vid__gte=vlan_vid__gte,
            vlan_vid__gt=vlan_vid__gt,
            role_id__n=role_id__n,
            role__n=role__n,
            status__n=status__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamPrefixesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        is_pool: Optional[StrictStr] = None,
        mark_utilized: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        prefix: Optional[StrictStr] = None,
        within: Optional[StrictStr] = None,
        within_include: Optional[StrictStr] = None,
        contains: Optional[StrictStr] = None,
        depth: Optional[StrictStr] = None,
        children: Optional[StrictStr] = None,
        mask_length: Optional[StrictStr] = None,
        mask_length__gte: Optional[Union[StrictFloat, StrictInt]] = None,
        mask_length__lte: Optional[Union[StrictFloat, StrictInt]] = None,
        vrf_id: Optional[StrictStr] = None,
        vrf: Optional[StrictStr] = None,
        present_in_vrf_id: Optional[StrictStr] = None,
        present_in_vrf: Optional[StrictStr] = None,
        region_id: Optional[StrictStr] = None,
        region: Optional[StrictStr] = None,
        site_group_id: Optional[StrictStr] = None,
        site_group: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        vlan_id: Optional[StrictStr] = None,
        vlan_vid: Optional[Union[StrictFloat, StrictInt]] = None,
        role_id: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        depth__n: Optional[StrictStr] = None,
        depth__lte: Optional[StrictStr] = None,
        depth__lt: Optional[StrictStr] = None,
        depth__gte: Optional[StrictStr] = None,
        depth__gt: Optional[StrictStr] = None,
        children__n: Optional[StrictStr] = None,
        children__lte: Optional[StrictStr] = None,
        children__lt: Optional[StrictStr] = None,
        children__gte: Optional[StrictStr] = None,
        children__gt: Optional[StrictStr] = None,
        vrf_id__n: Optional[StrictStr] = None,
        vrf__n: Optional[StrictStr] = None,
        region_id__n: Optional[StrictStr] = None,
        region__n: Optional[StrictStr] = None,
        site_group_id__n: Optional[StrictStr] = None,
        site_group__n: Optional[StrictStr] = None,
        site_id__n: Optional[StrictStr] = None,
        site__n: Optional[StrictStr] = None,
        vlan_id__n: Optional[StrictStr] = None,
        vlan_vid__n: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lt: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gt: Optional[Union[StrictFloat, StrictInt]] = None,
        role_id__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamPrefixesList200Response]:
        """ipam_prefixes_list

        

        :param id: 
        :type id: str
        :param is_pool: 
        :type is_pool: str
        :param mark_utilized: 
        :type mark_utilized: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param family: 
        :type family: float
        :param prefix: 
        :type prefix: str
        :param within: 
        :type within: str
        :param within_include: 
        :type within_include: str
        :param contains: 
        :type contains: str
        :param depth: 
        :type depth: str
        :param children: 
        :type children: str
        :param mask_length: 
        :type mask_length: str
        :param mask_length__gte: 
        :type mask_length__gte: float
        :param mask_length__lte: 
        :type mask_length__lte: float
        :param vrf_id: 
        :type vrf_id: str
        :param vrf: 
        :type vrf: str
        :param present_in_vrf_id: 
        :type present_in_vrf_id: str
        :param present_in_vrf: 
        :type present_in_vrf: str
        :param region_id: 
        :type region_id: str
        :param region: 
        :type region: str
        :param site_group_id: 
        :type site_group_id: str
        :param site_group: 
        :type site_group: str
        :param site_id: 
        :type site_id: str
        :param site: 
        :type site: str
        :param vlan_id: 
        :type vlan_id: str
        :param vlan_vid: 
        :type vlan_vid: float
        :param role_id: 
        :type role_id: str
        :param role: 
        :type role: str
        :param status: 
        :type status: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param depth__n: 
        :type depth__n: str
        :param depth__lte: 
        :type depth__lte: str
        :param depth__lt: 
        :type depth__lt: str
        :param depth__gte: 
        :type depth__gte: str
        :param depth__gt: 
        :type depth__gt: str
        :param children__n: 
        :type children__n: str
        :param children__lte: 
        :type children__lte: str
        :param children__lt: 
        :type children__lt: str
        :param children__gte: 
        :type children__gte: str
        :param children__gt: 
        :type children__gt: str
        :param vrf_id__n: 
        :type vrf_id__n: str
        :param vrf__n: 
        :type vrf__n: str
        :param region_id__n: 
        :type region_id__n: str
        :param region__n: 
        :type region__n: str
        :param site_group_id__n: 
        :type site_group_id__n: str
        :param site_group__n: 
        :type site_group__n: str
        :param site_id__n: 
        :type site_id__n: str
        :param site__n: 
        :type site__n: str
        :param vlan_id__n: 
        :type vlan_id__n: str
        :param vlan_vid__n: 
        :type vlan_vid__n: float
        :param vlan_vid__lte: 
        :type vlan_vid__lte: float
        :param vlan_vid__lt: 
        :type vlan_vid__lt: float
        :param vlan_vid__gte: 
        :type vlan_vid__gte: float
        :param vlan_vid__gt: 
        :type vlan_vid__gt: float
        :param role_id__n: 
        :type role_id__n: str
        :param role__n: 
        :type role__n: str
        :param status__n: 
        :type status__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_list_serialize(
            id=id,
            is_pool=is_pool,
            mark_utilized=mark_utilized,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            family=family,
            prefix=prefix,
            within=within,
            within_include=within_include,
            contains=contains,
            depth=depth,
            children=children,
            mask_length=mask_length,
            mask_length__gte=mask_length__gte,
            mask_length__lte=mask_length__lte,
            vrf_id=vrf_id,
            vrf=vrf,
            present_in_vrf_id=present_in_vrf_id,
            present_in_vrf=present_in_vrf,
            region_id=region_id,
            region=region,
            site_group_id=site_group_id,
            site_group=site_group,
            site_id=site_id,
            site=site,
            vlan_id=vlan_id,
            vlan_vid=vlan_vid,
            role_id=role_id,
            role=role,
            status=status,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            depth__n=depth__n,
            depth__lte=depth__lte,
            depth__lt=depth__lt,
            depth__gte=depth__gte,
            depth__gt=depth__gt,
            children__n=children__n,
            children__lte=children__lte,
            children__lt=children__lt,
            children__gte=children__gte,
            children__gt=children__gt,
            vrf_id__n=vrf_id__n,
            vrf__n=vrf__n,
            region_id__n=region_id__n,
            region__n=region__n,
            site_group_id__n=site_group_id__n,
            site_group__n=site_group__n,
            site_id__n=site_id__n,
            site__n=site__n,
            vlan_id__n=vlan_id__n,
            vlan_vid__n=vlan_vid__n,
            vlan_vid__lte=vlan_vid__lte,
            vlan_vid__lt=vlan_vid__lt,
            vlan_vid__gte=vlan_vid__gte,
            vlan_vid__gt=vlan_vid__gt,
            role_id__n=role_id__n,
            role__n=role__n,
            status__n=status__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamPrefixesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        is_pool: Optional[StrictStr] = None,
        mark_utilized: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        family: Optional[Union[StrictFloat, StrictInt]] = None,
        prefix: Optional[StrictStr] = None,
        within: Optional[StrictStr] = None,
        within_include: Optional[StrictStr] = None,
        contains: Optional[StrictStr] = None,
        depth: Optional[StrictStr] = None,
        children: Optional[StrictStr] = None,
        mask_length: Optional[StrictStr] = None,
        mask_length__gte: Optional[Union[StrictFloat, StrictInt]] = None,
        mask_length__lte: Optional[Union[StrictFloat, StrictInt]] = None,
        vrf_id: Optional[StrictStr] = None,
        vrf: Optional[StrictStr] = None,
        present_in_vrf_id: Optional[StrictStr] = None,
        present_in_vrf: Optional[StrictStr] = None,
        region_id: Optional[StrictStr] = None,
        region: Optional[StrictStr] = None,
        site_group_id: Optional[StrictStr] = None,
        site_group: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        vlan_id: Optional[StrictStr] = None,
        vlan_vid: Optional[Union[StrictFloat, StrictInt]] = None,
        role_id: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        depth__n: Optional[StrictStr] = None,
        depth__lte: Optional[StrictStr] = None,
        depth__lt: Optional[StrictStr] = None,
        depth__gte: Optional[StrictStr] = None,
        depth__gt: Optional[StrictStr] = None,
        children__n: Optional[StrictStr] = None,
        children__lte: Optional[StrictStr] = None,
        children__lt: Optional[StrictStr] = None,
        children__gte: Optional[StrictStr] = None,
        children__gt: Optional[StrictStr] = None,
        vrf_id__n: Optional[StrictStr] = None,
        vrf__n: Optional[StrictStr] = None,
        region_id__n: Optional[StrictStr] = None,
        region__n: Optional[StrictStr] = None,
        site_group_id__n: Optional[StrictStr] = None,
        site_group__n: Optional[StrictStr] = None,
        site_id__n: Optional[StrictStr] = None,
        site__n: Optional[StrictStr] = None,
        vlan_id__n: Optional[StrictStr] = None,
        vlan_vid__n: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__lt: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gte: Optional[Union[StrictFloat, StrictInt]] = None,
        vlan_vid__gt: Optional[Union[StrictFloat, StrictInt]] = None,
        role_id__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_list

        

        :param id: 
        :type id: str
        :param is_pool: 
        :type is_pool: str
        :param mark_utilized: 
        :type mark_utilized: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param family: 
        :type family: float
        :param prefix: 
        :type prefix: str
        :param within: 
        :type within: str
        :param within_include: 
        :type within_include: str
        :param contains: 
        :type contains: str
        :param depth: 
        :type depth: str
        :param children: 
        :type children: str
        :param mask_length: 
        :type mask_length: str
        :param mask_length__gte: 
        :type mask_length__gte: float
        :param mask_length__lte: 
        :type mask_length__lte: float
        :param vrf_id: 
        :type vrf_id: str
        :param vrf: 
        :type vrf: str
        :param present_in_vrf_id: 
        :type present_in_vrf_id: str
        :param present_in_vrf: 
        :type present_in_vrf: str
        :param region_id: 
        :type region_id: str
        :param region: 
        :type region: str
        :param site_group_id: 
        :type site_group_id: str
        :param site_group: 
        :type site_group: str
        :param site_id: 
        :type site_id: str
        :param site: 
        :type site: str
        :param vlan_id: 
        :type vlan_id: str
        :param vlan_vid: 
        :type vlan_vid: float
        :param role_id: 
        :type role_id: str
        :param role: 
        :type role: str
        :param status: 
        :type status: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param depth__n: 
        :type depth__n: str
        :param depth__lte: 
        :type depth__lte: str
        :param depth__lt: 
        :type depth__lt: str
        :param depth__gte: 
        :type depth__gte: str
        :param depth__gt: 
        :type depth__gt: str
        :param children__n: 
        :type children__n: str
        :param children__lte: 
        :type children__lte: str
        :param children__lt: 
        :type children__lt: str
        :param children__gte: 
        :type children__gte: str
        :param children__gt: 
        :type children__gt: str
        :param vrf_id__n: 
        :type vrf_id__n: str
        :param vrf__n: 
        :type vrf__n: str
        :param region_id__n: 
        :type region_id__n: str
        :param region__n: 
        :type region__n: str
        :param site_group_id__n: 
        :type site_group_id__n: str
        :param site_group__n: 
        :type site_group__n: str
        :param site_id__n: 
        :type site_id__n: str
        :param site__n: 
        :type site__n: str
        :param vlan_id__n: 
        :type vlan_id__n: str
        :param vlan_vid__n: 
        :type vlan_vid__n: float
        :param vlan_vid__lte: 
        :type vlan_vid__lte: float
        :param vlan_vid__lt: 
        :type vlan_vid__lt: float
        :param vlan_vid__gte: 
        :type vlan_vid__gte: float
        :param vlan_vid__gt: 
        :type vlan_vid__gt: float
        :param role_id__n: 
        :type role_id__n: str
        :param role__n: 
        :type role__n: str
        :param status__n: 
        :type status__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_list_serialize(
            id=id,
            is_pool=is_pool,
            mark_utilized=mark_utilized,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            family=family,
            prefix=prefix,
            within=within,
            within_include=within_include,
            contains=contains,
            depth=depth,
            children=children,
            mask_length=mask_length,
            mask_length__gte=mask_length__gte,
            mask_length__lte=mask_length__lte,
            vrf_id=vrf_id,
            vrf=vrf,
            present_in_vrf_id=present_in_vrf_id,
            present_in_vrf=present_in_vrf,
            region_id=region_id,
            region=region,
            site_group_id=site_group_id,
            site_group=site_group,
            site_id=site_id,
            site=site,
            vlan_id=vlan_id,
            vlan_vid=vlan_vid,
            role_id=role_id,
            role=role,
            status=status,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            depth__n=depth__n,
            depth__lte=depth__lte,
            depth__lt=depth__lt,
            depth__gte=depth__gte,
            depth__gt=depth__gt,
            children__n=children__n,
            children__lte=children__lte,
            children__lt=children__lt,
            children__gte=children__gte,
            children__gt=children__gt,
            vrf_id__n=vrf_id__n,
            vrf__n=vrf__n,
            region_id__n=region_id__n,
            region__n=region__n,
            site_group_id__n=site_group_id__n,
            site_group__n=site_group__n,
            site_id__n=site_id__n,
            site__n=site__n,
            vlan_id__n=vlan_id__n,
            vlan_vid__n=vlan_vid__n,
            vlan_vid__lte=vlan_vid__lte,
            vlan_vid__lt=vlan_vid__lt,
            vlan_vid__gte=vlan_vid__gte,
            vlan_vid__gt=vlan_vid__gt,
            role_id__n=role_id__n,
            role__n=role__n,
            status__n=status__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamPrefixesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_list_serialize(
        self,
        id,
        is_pool,
        mark_utilized,
        description,
        created,
        last_updated,
        q,
        tag,
        tenant_group_id,
        tenant_group,
        tenant_id,
        tenant,
        family,
        prefix,
        within,
        within_include,
        contains,
        depth,
        children,
        mask_length,
        mask_length__gte,
        mask_length__lte,
        vrf_id,
        vrf,
        present_in_vrf_id,
        present_in_vrf,
        region_id,
        region,
        site_group_id,
        site_group,
        site_id,
        site,
        vlan_id,
        vlan_vid,
        role_id,
        role,
        status,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        tenant_group_id__n,
        tenant_group__n,
        tenant_id__n,
        tenant__n,
        depth__n,
        depth__lte,
        depth__lt,
        depth__gte,
        depth__gt,
        children__n,
        children__lte,
        children__lt,
        children__gte,
        children__gt,
        vrf_id__n,
        vrf__n,
        region_id__n,
        region__n,
        site_group_id__n,
        site_group__n,
        site_id__n,
        site__n,
        vlan_id__n,
        vlan_vid__n,
        vlan_vid__lte,
        vlan_vid__lt,
        vlan_vid__gte,
        vlan_vid__gt,
        role_id__n,
        role__n,
        status__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if is_pool is not None:
            
            _query_params.append(('is_pool', is_pool))
            
        if mark_utilized is not None:
            
            _query_params.append(('mark_utilized', mark_utilized))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tenant_group_id is not None:
            
            _query_params.append(('tenant_group_id', tenant_group_id))
            
        if tenant_group is not None:
            
            _query_params.append(('tenant_group', tenant_group))
            
        if tenant_id is not None:
            
            _query_params.append(('tenant_id', tenant_id))
            
        if tenant is not None:
            
            _query_params.append(('tenant', tenant))
            
        if family is not None:
            
            _query_params.append(('family', family))
            
        if prefix is not None:
            
            _query_params.append(('prefix', prefix))
            
        if within is not None:
            
            _query_params.append(('within', within))
            
        if within_include is not None:
            
            _query_params.append(('within_include', within_include))
            
        if contains is not None:
            
            _query_params.append(('contains', contains))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if children is not None:
            
            _query_params.append(('children', children))
            
        if mask_length is not None:
            
            _query_params.append(('mask_length', mask_length))
            
        if mask_length__gte is not None:
            
            _query_params.append(('mask_length__gte', mask_length__gte))
            
        if mask_length__lte is not None:
            
            _query_params.append(('mask_length__lte', mask_length__lte))
            
        if vrf_id is not None:
            
            _query_params.append(('vrf_id', vrf_id))
            
        if vrf is not None:
            
            _query_params.append(('vrf', vrf))
            
        if present_in_vrf_id is not None:
            
            _query_params.append(('present_in_vrf_id', present_in_vrf_id))
            
        if present_in_vrf is not None:
            
            _query_params.append(('present_in_vrf', present_in_vrf))
            
        if region_id is not None:
            
            _query_params.append(('region_id', region_id))
            
        if region is not None:
            
            _query_params.append(('region', region))
            
        if site_group_id is not None:
            
            _query_params.append(('site_group_id', site_group_id))
            
        if site_group is not None:
            
            _query_params.append(('site_group', site_group))
            
        if site_id is not None:
            
            _query_params.append(('site_id', site_id))
            
        if site is not None:
            
            _query_params.append(('site', site))
            
        if vlan_id is not None:
            
            _query_params.append(('vlan_id', vlan_id))
            
        if vlan_vid is not None:
            
            _query_params.append(('vlan_vid', vlan_vid))
            
        if role_id is not None:
            
            _query_params.append(('role_id', role_id))
            
        if role is not None:
            
            _query_params.append(('role', role))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if tenant_group_id__n is not None:
            
            _query_params.append(('tenant_group_id__n', tenant_group_id__n))
            
        if tenant_group__n is not None:
            
            _query_params.append(('tenant_group__n', tenant_group__n))
            
        if tenant_id__n is not None:
            
            _query_params.append(('tenant_id__n', tenant_id__n))
            
        if tenant__n is not None:
            
            _query_params.append(('tenant__n', tenant__n))
            
        if depth__n is not None:
            
            _query_params.append(('depth__n', depth__n))
            
        if depth__lte is not None:
            
            _query_params.append(('depth__lte', depth__lte))
            
        if depth__lt is not None:
            
            _query_params.append(('depth__lt', depth__lt))
            
        if depth__gte is not None:
            
            _query_params.append(('depth__gte', depth__gte))
            
        if depth__gt is not None:
            
            _query_params.append(('depth__gt', depth__gt))
            
        if children__n is not None:
            
            _query_params.append(('children__n', children__n))
            
        if children__lte is not None:
            
            _query_params.append(('children__lte', children__lte))
            
        if children__lt is not None:
            
            _query_params.append(('children__lt', children__lt))
            
        if children__gte is not None:
            
            _query_params.append(('children__gte', children__gte))
            
        if children__gt is not None:
            
            _query_params.append(('children__gt', children__gt))
            
        if vrf_id__n is not None:
            
            _query_params.append(('vrf_id__n', vrf_id__n))
            
        if vrf__n is not None:
            
            _query_params.append(('vrf__n', vrf__n))
            
        if region_id__n is not None:
            
            _query_params.append(('region_id__n', region_id__n))
            
        if region__n is not None:
            
            _query_params.append(('region__n', region__n))
            
        if site_group_id__n is not None:
            
            _query_params.append(('site_group_id__n', site_group_id__n))
            
        if site_group__n is not None:
            
            _query_params.append(('site_group__n', site_group__n))
            
        if site_id__n is not None:
            
            _query_params.append(('site_id__n', site_id__n))
            
        if site__n is not None:
            
            _query_params.append(('site__n', site__n))
            
        if vlan_id__n is not None:
            
            _query_params.append(('vlan_id__n', vlan_id__n))
            
        if vlan_vid__n is not None:
            
            _query_params.append(('vlan_vid__n', vlan_vid__n))
            
        if vlan_vid__lte is not None:
            
            _query_params.append(('vlan_vid__lte', vlan_vid__lte))
            
        if vlan_vid__lt is not None:
            
            _query_params.append(('vlan_vid__lt', vlan_vid__lt))
            
        if vlan_vid__gte is not None:
            
            _query_params.append(('vlan_vid__gte', vlan_vid__gte))
            
        if vlan_vid__gt is not None:
            
            _query_params.append(('vlan_vid__gt', vlan_vid__gt))
            
        if role_id__n is not None:
            
            _query_params.append(('role_id__n', role_id__n))
            
        if role__n is not None:
            
            _query_params.append(('role__n', role__n))
            
        if status__n is not None:
            
            _query_params.append(('status__n', status__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/prefixes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Prefix:
        """ipam_prefixes_partial_update

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_partial_update_serialize(
            id=id,
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Prefix]:
        """ipam_prefixes_partial_update

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_partial_update_serialize(
            id=id,
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_partial_update

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_partial_update_serialize(
            id=id,
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_partial_update_serialize(
        self,
        id,
        writable_prefix,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_prefix is not None:
            _body_params = writable_prefix


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/prefixes/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Prefix:
        """ipam_prefixes_read

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Prefix]:
        """ipam_prefixes_read

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_read

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/prefixes/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_prefixes_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Prefix:
        """ipam_prefixes_update

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_update_serialize(
            id=id,
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_prefixes_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Prefix]:
        """ipam_prefixes_update

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_update_serialize(
            id=id,
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_prefixes_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this prefix.")],
        writable_prefix: WritablePrefix,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_prefixes_update

        

        :param id: A unique integer value identifying this prefix. (required)
        :type id: int
        :param writable_prefix: (required)
        :type writable_prefix: WritablePrefix
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_prefixes_update_serialize(
            id=id,
            writable_prefix=writable_prefix,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Prefix",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_prefixes_update_serialize(
        self,
        id,
        writable_prefix,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_prefix is not None:
            _body_params = writable_prefix


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/prefixes/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_rirs_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_rirs_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_rirs_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_rirs_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_rirs_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_rirs_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_rirs_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/rirs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_rirs_bulk_partial_update(
        self,
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RIR:
        """ipam_rirs_bulk_partial_update

        

        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_bulk_partial_update_serialize(
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_rirs_bulk_partial_update_with_http_info(
        self,
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RIR]:
        """ipam_rirs_bulk_partial_update

        

        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_bulk_partial_update_serialize(
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_rirs_bulk_partial_update_without_preload_content(
        self,
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_rirs_bulk_partial_update

        

        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_bulk_partial_update_serialize(
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_rirs_bulk_partial_update_serialize(
        self,
        rir,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if rir is not None:
            _body_params = rir


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/rirs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_rirs_bulk_update(
        self,
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RIR:
        """ipam_rirs_bulk_update

        

        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_bulk_update_serialize(
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_rirs_bulk_update_with_http_info(
        self,
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RIR]:
        """ipam_rirs_bulk_update

        

        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_bulk_update_serialize(
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_rirs_bulk_update_without_preload_content(
        self,
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_rirs_bulk_update

        

        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_bulk_update_serialize(
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_rirs_bulk_update_serialize(
        self,
        rir,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if rir is not None:
            _body_params = rir


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/rirs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_rirs_create(
        self,
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RIR:
        """ipam_rirs_create

        

        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_create_serialize(
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_rirs_create_with_http_info(
        self,
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RIR]:
        """ipam_rirs_create

        

        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_create_serialize(
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_rirs_create_without_preload_content(
        self,
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_rirs_create

        

        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_create_serialize(
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_rirs_create_serialize(
        self,
        rir,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if rir is not None:
            _body_params = rir


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/rirs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_rirs_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_rirs_delete

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_rirs_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_rirs_delete

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_rirs_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_rirs_delete

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_rirs_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/rirs/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_rirs_list(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        is_private: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamRirsList200Response:
        """ipam_rirs_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param is_private: 
        :type is_private: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_list_serialize(
            id=id,
            name=name,
            slug=slug,
            is_private=is_private,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamRirsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_rirs_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        is_private: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamRirsList200Response]:
        """ipam_rirs_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param is_private: 
        :type is_private: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_list_serialize(
            id=id,
            name=name,
            slug=slug,
            is_private=is_private,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamRirsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_rirs_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        is_private: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_rirs_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param is_private: 
        :type is_private: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_list_serialize(
            id=id,
            name=name,
            slug=slug,
            is_private=is_private,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamRirsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_rirs_list_serialize(
        self,
        id,
        name,
        slug,
        is_private,
        description,
        created,
        last_updated,
        q,
        tag,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        name__n,
        name__ic,
        name__nic,
        name__iew,
        name__niew,
        name__isw,
        name__nisw,
        name__ie,
        name__nie,
        name__empty,
        slug__n,
        slug__ic,
        slug__nic,
        slug__iew,
        slug__niew,
        slug__isw,
        slug__nisw,
        slug__ie,
        slug__nie,
        slug__empty,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if slug is not None:
            
            _query_params.append(('slug', slug))
            
        if is_private is not None:
            
            _query_params.append(('is_private', is_private))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if name__n is not None:
            
            _query_params.append(('name__n', name__n))
            
        if name__ic is not None:
            
            _query_params.append(('name__ic', name__ic))
            
        if name__nic is not None:
            
            _query_params.append(('name__nic', name__nic))
            
        if name__iew is not None:
            
            _query_params.append(('name__iew', name__iew))
            
        if name__niew is not None:
            
            _query_params.append(('name__niew', name__niew))
            
        if name__isw is not None:
            
            _query_params.append(('name__isw', name__isw))
            
        if name__nisw is not None:
            
            _query_params.append(('name__nisw', name__nisw))
            
        if name__ie is not None:
            
            _query_params.append(('name__ie', name__ie))
            
        if name__nie is not None:
            
            _query_params.append(('name__nie', name__nie))
            
        if name__empty is not None:
            
            _query_params.append(('name__empty', name__empty))
            
        if slug__n is not None:
            
            _query_params.append(('slug__n', slug__n))
            
        if slug__ic is not None:
            
            _query_params.append(('slug__ic', slug__ic))
            
        if slug__nic is not None:
            
            _query_params.append(('slug__nic', slug__nic))
            
        if slug__iew is not None:
            
            _query_params.append(('slug__iew', slug__iew))
            
        if slug__niew is not None:
            
            _query_params.append(('slug__niew', slug__niew))
            
        if slug__isw is not None:
            
            _query_params.append(('slug__isw', slug__isw))
            
        if slug__nisw is not None:
            
            _query_params.append(('slug__nisw', slug__nisw))
            
        if slug__ie is not None:
            
            _query_params.append(('slug__ie', slug__ie))
            
        if slug__nie is not None:
            
            _query_params.append(('slug__nie', slug__nie))
            
        if slug__empty is not None:
            
            _query_params.append(('slug__empty', slug__empty))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/rirs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_rirs_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RIR:
        """ipam_rirs_partial_update

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_partial_update_serialize(
            id=id,
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_rirs_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RIR]:
        """ipam_rirs_partial_update

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_partial_update_serialize(
            id=id,
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_rirs_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_rirs_partial_update

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_partial_update_serialize(
            id=id,
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_rirs_partial_update_serialize(
        self,
        id,
        rir,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if rir is not None:
            _body_params = rir


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/rirs/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_rirs_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RIR:
        """ipam_rirs_read

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_rirs_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RIR]:
        """ipam_rirs_read

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_rirs_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_rirs_read

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_rirs_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/rirs/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_rirs_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RIR:
        """ipam_rirs_update

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_update_serialize(
            id=id,
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_rirs_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RIR]:
        """ipam_rirs_update

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_update_serialize(
            id=id,
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_rirs_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this RIR.")],
        rir: RIR,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_rirs_update

        

        :param id: A unique integer value identifying this RIR. (required)
        :type id: int
        :param rir: (required)
        :type rir: RIR
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_rirs_update_serialize(
            id=id,
            rir=rir,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RIR",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_rirs_update_serialize(
        self,
        id,
        rir,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if rir is not None:
            _body_params = rir


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/rirs/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_roles_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_roles_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_roles_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_roles_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_roles_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_roles_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_roles_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/roles/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_roles_bulk_partial_update(
        self,
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Role:
        """ipam_roles_bulk_partial_update

        

        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_bulk_partial_update_serialize(
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_roles_bulk_partial_update_with_http_info(
        self,
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Role]:
        """ipam_roles_bulk_partial_update

        

        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_bulk_partial_update_serialize(
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_roles_bulk_partial_update_without_preload_content(
        self,
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_roles_bulk_partial_update

        

        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_bulk_partial_update_serialize(
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_roles_bulk_partial_update_serialize(
        self,
        role,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if role is not None:
            _body_params = role


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/roles/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_roles_bulk_update(
        self,
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Role:
        """ipam_roles_bulk_update

        

        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_bulk_update_serialize(
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_roles_bulk_update_with_http_info(
        self,
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Role]:
        """ipam_roles_bulk_update

        

        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_bulk_update_serialize(
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_roles_bulk_update_without_preload_content(
        self,
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_roles_bulk_update

        

        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_bulk_update_serialize(
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_roles_bulk_update_serialize(
        self,
        role,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if role is not None:
            _body_params = role


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/roles/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_roles_create(
        self,
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Role:
        """ipam_roles_create

        

        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_create_serialize(
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_roles_create_with_http_info(
        self,
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Role]:
        """ipam_roles_create

        

        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_create_serialize(
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_roles_create_without_preload_content(
        self,
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_roles_create

        

        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_create_serialize(
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_roles_create_serialize(
        self,
        role,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if role is not None:
            _body_params = role


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/roles/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_roles_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_roles_delete

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_roles_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_roles_delete

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_roles_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_roles_delete

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_roles_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/roles/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_roles_list(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamRolesList200Response:
        """ipam_roles_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_list_serialize(
            id=id,
            name=name,
            slug=slug,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamRolesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_roles_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamRolesList200Response]:
        """ipam_roles_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_list_serialize(
            id=id,
            name=name,
            slug=slug,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamRolesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_roles_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_roles_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_list_serialize(
            id=id,
            name=name,
            slug=slug,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamRolesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_roles_list_serialize(
        self,
        id,
        name,
        slug,
        description,
        created,
        last_updated,
        q,
        tag,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        name__n,
        name__ic,
        name__nic,
        name__iew,
        name__niew,
        name__isw,
        name__nisw,
        name__ie,
        name__nie,
        name__empty,
        slug__n,
        slug__ic,
        slug__nic,
        slug__iew,
        slug__niew,
        slug__isw,
        slug__nisw,
        slug__ie,
        slug__nie,
        slug__empty,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if slug is not None:
            
            _query_params.append(('slug', slug))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if name__n is not None:
            
            _query_params.append(('name__n', name__n))
            
        if name__ic is not None:
            
            _query_params.append(('name__ic', name__ic))
            
        if name__nic is not None:
            
            _query_params.append(('name__nic', name__nic))
            
        if name__iew is not None:
            
            _query_params.append(('name__iew', name__iew))
            
        if name__niew is not None:
            
            _query_params.append(('name__niew', name__niew))
            
        if name__isw is not None:
            
            _query_params.append(('name__isw', name__isw))
            
        if name__nisw is not None:
            
            _query_params.append(('name__nisw', name__nisw))
            
        if name__ie is not None:
            
            _query_params.append(('name__ie', name__ie))
            
        if name__nie is not None:
            
            _query_params.append(('name__nie', name__nie))
            
        if name__empty is not None:
            
            _query_params.append(('name__empty', name__empty))
            
        if slug__n is not None:
            
            _query_params.append(('slug__n', slug__n))
            
        if slug__ic is not None:
            
            _query_params.append(('slug__ic', slug__ic))
            
        if slug__nic is not None:
            
            _query_params.append(('slug__nic', slug__nic))
            
        if slug__iew is not None:
            
            _query_params.append(('slug__iew', slug__iew))
            
        if slug__niew is not None:
            
            _query_params.append(('slug__niew', slug__niew))
            
        if slug__isw is not None:
            
            _query_params.append(('slug__isw', slug__isw))
            
        if slug__nisw is not None:
            
            _query_params.append(('slug__nisw', slug__nisw))
            
        if slug__ie is not None:
            
            _query_params.append(('slug__ie', slug__ie))
            
        if slug__nie is not None:
            
            _query_params.append(('slug__nie', slug__nie))
            
        if slug__empty is not None:
            
            _query_params.append(('slug__empty', slug__empty))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/roles/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_roles_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Role:
        """ipam_roles_partial_update

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_partial_update_serialize(
            id=id,
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_roles_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Role]:
        """ipam_roles_partial_update

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_partial_update_serialize(
            id=id,
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_roles_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_roles_partial_update

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_partial_update_serialize(
            id=id,
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_roles_partial_update_serialize(
        self,
        id,
        role,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if role is not None:
            _body_params = role


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/roles/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_roles_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Role:
        """ipam_roles_read

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_roles_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Role]:
        """ipam_roles_read

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_roles_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_roles_read

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_roles_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/roles/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_roles_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Role:
        """ipam_roles_update

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_update_serialize(
            id=id,
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_roles_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Role]:
        """ipam_roles_update

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_update_serialize(
            id=id,
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_roles_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this role.")],
        role: Role,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_roles_update

        

        :param id: A unique integer value identifying this role. (required)
        :type id: int
        :param role: (required)
        :type role: Role
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_roles_update_serialize(
            id=id,
            role=role,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Role",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_roles_update_serialize(
        self,
        id,
        role,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if role is not None:
            _body_params = role


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/roles/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_route_targets_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_route_targets_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_route_targets_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_route_targets_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_route_targets_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_route_targets_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_route_targets_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/route-targets/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_route_targets_bulk_partial_update(
        self,
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RouteTarget:
        """ipam_route_targets_bulk_partial_update

        

        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_bulk_partial_update_serialize(
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_route_targets_bulk_partial_update_with_http_info(
        self,
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RouteTarget]:
        """ipam_route_targets_bulk_partial_update

        

        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_bulk_partial_update_serialize(
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_route_targets_bulk_partial_update_without_preload_content(
        self,
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_route_targets_bulk_partial_update

        

        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_bulk_partial_update_serialize(
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_route_targets_bulk_partial_update_serialize(
        self,
        writable_route_target,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_route_target is not None:
            _body_params = writable_route_target


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/route-targets/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_route_targets_bulk_update(
        self,
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RouteTarget:
        """ipam_route_targets_bulk_update

        

        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_bulk_update_serialize(
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_route_targets_bulk_update_with_http_info(
        self,
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RouteTarget]:
        """ipam_route_targets_bulk_update

        

        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_bulk_update_serialize(
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_route_targets_bulk_update_without_preload_content(
        self,
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_route_targets_bulk_update

        

        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_bulk_update_serialize(
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_route_targets_bulk_update_serialize(
        self,
        writable_route_target,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_route_target is not None:
            _body_params = writable_route_target


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/route-targets/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_route_targets_create(
        self,
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RouteTarget:
        """ipam_route_targets_create

        

        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_create_serialize(
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_route_targets_create_with_http_info(
        self,
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RouteTarget]:
        """ipam_route_targets_create

        

        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_create_serialize(
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_route_targets_create_without_preload_content(
        self,
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_route_targets_create

        

        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_create_serialize(
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_route_targets_create_serialize(
        self,
        writable_route_target,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_route_target is not None:
            _body_params = writable_route_target


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/route-targets/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_route_targets_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_route_targets_delete

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_route_targets_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_route_targets_delete

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_route_targets_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_route_targets_delete

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_route_targets_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/route-targets/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_route_targets_list(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        importing_vrf_id: Optional[StrictStr] = None,
        importing_vrf: Optional[StrictStr] = None,
        exporting_vrf_id: Optional[StrictStr] = None,
        exporting_vrf: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        importing_vrf_id__n: Optional[StrictStr] = None,
        importing_vrf__n: Optional[StrictStr] = None,
        exporting_vrf_id__n: Optional[StrictStr] = None,
        exporting_vrf__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamRouteTargetsList200Response:
        """ipam_route_targets_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param importing_vrf_id: 
        :type importing_vrf_id: str
        :param importing_vrf: 
        :type importing_vrf: str
        :param exporting_vrf_id: 
        :type exporting_vrf_id: str
        :param exporting_vrf: 
        :type exporting_vrf: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param importing_vrf_id__n: 
        :type importing_vrf_id__n: str
        :param importing_vrf__n: 
        :type importing_vrf__n: str
        :param exporting_vrf_id__n: 
        :type exporting_vrf_id__n: str
        :param exporting_vrf__n: 
        :type exporting_vrf__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_list_serialize(
            id=id,
            name=name,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            importing_vrf_id=importing_vrf_id,
            importing_vrf=importing_vrf,
            exporting_vrf_id=exporting_vrf_id,
            exporting_vrf=exporting_vrf,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            importing_vrf_id__n=importing_vrf_id__n,
            importing_vrf__n=importing_vrf__n,
            exporting_vrf_id__n=exporting_vrf_id__n,
            exporting_vrf__n=exporting_vrf__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamRouteTargetsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_route_targets_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        importing_vrf_id: Optional[StrictStr] = None,
        importing_vrf: Optional[StrictStr] = None,
        exporting_vrf_id: Optional[StrictStr] = None,
        exporting_vrf: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        importing_vrf_id__n: Optional[StrictStr] = None,
        importing_vrf__n: Optional[StrictStr] = None,
        exporting_vrf_id__n: Optional[StrictStr] = None,
        exporting_vrf__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamRouteTargetsList200Response]:
        """ipam_route_targets_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param importing_vrf_id: 
        :type importing_vrf_id: str
        :param importing_vrf: 
        :type importing_vrf: str
        :param exporting_vrf_id: 
        :type exporting_vrf_id: str
        :param exporting_vrf: 
        :type exporting_vrf: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param importing_vrf_id__n: 
        :type importing_vrf_id__n: str
        :param importing_vrf__n: 
        :type importing_vrf__n: str
        :param exporting_vrf_id__n: 
        :type exporting_vrf_id__n: str
        :param exporting_vrf__n: 
        :type exporting_vrf__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_list_serialize(
            id=id,
            name=name,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            importing_vrf_id=importing_vrf_id,
            importing_vrf=importing_vrf,
            exporting_vrf_id=exporting_vrf_id,
            exporting_vrf=exporting_vrf,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            importing_vrf_id__n=importing_vrf_id__n,
            importing_vrf__n=importing_vrf__n,
            exporting_vrf_id__n=exporting_vrf_id__n,
            exporting_vrf__n=exporting_vrf__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamRouteTargetsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_route_targets_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        importing_vrf_id: Optional[StrictStr] = None,
        importing_vrf: Optional[StrictStr] = None,
        exporting_vrf_id: Optional[StrictStr] = None,
        exporting_vrf: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        importing_vrf_id__n: Optional[StrictStr] = None,
        importing_vrf__n: Optional[StrictStr] = None,
        exporting_vrf_id__n: Optional[StrictStr] = None,
        exporting_vrf__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_route_targets_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param importing_vrf_id: 
        :type importing_vrf_id: str
        :param importing_vrf: 
        :type importing_vrf: str
        :param exporting_vrf_id: 
        :type exporting_vrf_id: str
        :param exporting_vrf: 
        :type exporting_vrf: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param importing_vrf_id__n: 
        :type importing_vrf_id__n: str
        :param importing_vrf__n: 
        :type importing_vrf__n: str
        :param exporting_vrf_id__n: 
        :type exporting_vrf_id__n: str
        :param exporting_vrf__n: 
        :type exporting_vrf__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_list_serialize(
            id=id,
            name=name,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            importing_vrf_id=importing_vrf_id,
            importing_vrf=importing_vrf,
            exporting_vrf_id=exporting_vrf_id,
            exporting_vrf=exporting_vrf,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            importing_vrf_id__n=importing_vrf_id__n,
            importing_vrf__n=importing_vrf__n,
            exporting_vrf_id__n=exporting_vrf_id__n,
            exporting_vrf__n=exporting_vrf__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamRouteTargetsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_route_targets_list_serialize(
        self,
        id,
        name,
        description,
        created,
        last_updated,
        q,
        tag,
        tenant_group_id,
        tenant_group,
        tenant_id,
        tenant,
        importing_vrf_id,
        importing_vrf,
        exporting_vrf_id,
        exporting_vrf,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        name__n,
        name__ic,
        name__nic,
        name__iew,
        name__niew,
        name__isw,
        name__nisw,
        name__ie,
        name__nie,
        name__empty,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        tenant_group_id__n,
        tenant_group__n,
        tenant_id__n,
        tenant__n,
        importing_vrf_id__n,
        importing_vrf__n,
        exporting_vrf_id__n,
        exporting_vrf__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tenant_group_id is not None:
            
            _query_params.append(('tenant_group_id', tenant_group_id))
            
        if tenant_group is not None:
            
            _query_params.append(('tenant_group', tenant_group))
            
        if tenant_id is not None:
            
            _query_params.append(('tenant_id', tenant_id))
            
        if tenant is not None:
            
            _query_params.append(('tenant', tenant))
            
        if importing_vrf_id is not None:
            
            _query_params.append(('importing_vrf_id', importing_vrf_id))
            
        if importing_vrf is not None:
            
            _query_params.append(('importing_vrf', importing_vrf))
            
        if exporting_vrf_id is not None:
            
            _query_params.append(('exporting_vrf_id', exporting_vrf_id))
            
        if exporting_vrf is not None:
            
            _query_params.append(('exporting_vrf', exporting_vrf))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if name__n is not None:
            
            _query_params.append(('name__n', name__n))
            
        if name__ic is not None:
            
            _query_params.append(('name__ic', name__ic))
            
        if name__nic is not None:
            
            _query_params.append(('name__nic', name__nic))
            
        if name__iew is not None:
            
            _query_params.append(('name__iew', name__iew))
            
        if name__niew is not None:
            
            _query_params.append(('name__niew', name__niew))
            
        if name__isw is not None:
            
            _query_params.append(('name__isw', name__isw))
            
        if name__nisw is not None:
            
            _query_params.append(('name__nisw', name__nisw))
            
        if name__ie is not None:
            
            _query_params.append(('name__ie', name__ie))
            
        if name__nie is not None:
            
            _query_params.append(('name__nie', name__nie))
            
        if name__empty is not None:
            
            _query_params.append(('name__empty', name__empty))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if tenant_group_id__n is not None:
            
            _query_params.append(('tenant_group_id__n', tenant_group_id__n))
            
        if tenant_group__n is not None:
            
            _query_params.append(('tenant_group__n', tenant_group__n))
            
        if tenant_id__n is not None:
            
            _query_params.append(('tenant_id__n', tenant_id__n))
            
        if tenant__n is not None:
            
            _query_params.append(('tenant__n', tenant__n))
            
        if importing_vrf_id__n is not None:
            
            _query_params.append(('importing_vrf_id__n', importing_vrf_id__n))
            
        if importing_vrf__n is not None:
            
            _query_params.append(('importing_vrf__n', importing_vrf__n))
            
        if exporting_vrf_id__n is not None:
            
            _query_params.append(('exporting_vrf_id__n', exporting_vrf_id__n))
            
        if exporting_vrf__n is not None:
            
            _query_params.append(('exporting_vrf__n', exporting_vrf__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/route-targets/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_route_targets_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RouteTarget:
        """ipam_route_targets_partial_update

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_partial_update_serialize(
            id=id,
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_route_targets_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RouteTarget]:
        """ipam_route_targets_partial_update

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_partial_update_serialize(
            id=id,
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_route_targets_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_route_targets_partial_update

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_partial_update_serialize(
            id=id,
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_route_targets_partial_update_serialize(
        self,
        id,
        writable_route_target,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_route_target is not None:
            _body_params = writable_route_target


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/route-targets/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_route_targets_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RouteTarget:
        """ipam_route_targets_read

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_route_targets_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RouteTarget]:
        """ipam_route_targets_read

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_route_targets_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_route_targets_read

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_route_targets_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/route-targets/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_route_targets_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RouteTarget:
        """ipam_route_targets_update

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_update_serialize(
            id=id,
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_route_targets_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RouteTarget]:
        """ipam_route_targets_update

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_update_serialize(
            id=id,
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_route_targets_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this route target.")],
        writable_route_target: WritableRouteTarget,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_route_targets_update

        

        :param id: A unique integer value identifying this route target. (required)
        :type id: int
        :param writable_route_target: (required)
        :type writable_route_target: WritableRouteTarget
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_route_targets_update_serialize(
            id=id,
            writable_route_target=writable_route_target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RouteTarget",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_route_targets_update_serialize(
        self,
        id,
        writable_route_target,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_route_target is not None:
            _body_params = writable_route_target


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/route-targets/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_service_templates_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_service_templates_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_service_templates_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_service_templates_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_service_templates_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_service_templates_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_service_templates_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/service-templates/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_service_templates_bulk_partial_update(
        self,
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ServiceTemplate:
        """ipam_service_templates_bulk_partial_update

        

        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_bulk_partial_update_serialize(
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_service_templates_bulk_partial_update_with_http_info(
        self,
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ServiceTemplate]:
        """ipam_service_templates_bulk_partial_update

        

        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_bulk_partial_update_serialize(
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_service_templates_bulk_partial_update_without_preload_content(
        self,
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_service_templates_bulk_partial_update

        

        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_bulk_partial_update_serialize(
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_service_templates_bulk_partial_update_serialize(
        self,
        writable_service_template,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_service_template is not None:
            _body_params = writable_service_template


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/service-templates/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_service_templates_bulk_update(
        self,
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ServiceTemplate:
        """ipam_service_templates_bulk_update

        

        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_bulk_update_serialize(
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_service_templates_bulk_update_with_http_info(
        self,
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ServiceTemplate]:
        """ipam_service_templates_bulk_update

        

        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_bulk_update_serialize(
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_service_templates_bulk_update_without_preload_content(
        self,
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_service_templates_bulk_update

        

        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_bulk_update_serialize(
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_service_templates_bulk_update_serialize(
        self,
        writable_service_template,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_service_template is not None:
            _body_params = writable_service_template


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/service-templates/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_service_templates_create(
        self,
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ServiceTemplate:
        """ipam_service_templates_create

        

        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_create_serialize(
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_service_templates_create_with_http_info(
        self,
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ServiceTemplate]:
        """ipam_service_templates_create

        

        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_create_serialize(
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_service_templates_create_without_preload_content(
        self,
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_service_templates_create

        

        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_create_serialize(
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_service_templates_create_serialize(
        self,
        writable_service_template,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_service_template is not None:
            _body_params = writable_service_template


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/service-templates/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_service_templates_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_service_templates_delete

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_service_templates_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_service_templates_delete

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_service_templates_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_service_templates_delete

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_service_templates_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/service-templates/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_service_templates_list(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        protocol: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        port: Optional[Union[StrictFloat, StrictInt]] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        protocol__n: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamServiceTemplatesList200Response:
        """ipam_service_templates_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param protocol: 
        :type protocol: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param port: 
        :type port: float
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param protocol__n: 
        :type protocol__n: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_list_serialize(
            id=id,
            name=name,
            protocol=protocol,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            port=port,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            protocol__n=protocol__n,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamServiceTemplatesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_service_templates_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        protocol: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        port: Optional[Union[StrictFloat, StrictInt]] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        protocol__n: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamServiceTemplatesList200Response]:
        """ipam_service_templates_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param protocol: 
        :type protocol: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param port: 
        :type port: float
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param protocol__n: 
        :type protocol__n: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_list_serialize(
            id=id,
            name=name,
            protocol=protocol,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            port=port,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            protocol__n=protocol__n,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamServiceTemplatesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_service_templates_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        protocol: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        port: Optional[Union[StrictFloat, StrictInt]] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        protocol__n: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_service_templates_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param protocol: 
        :type protocol: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param port: 
        :type port: float
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param protocol__n: 
        :type protocol__n: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_list_serialize(
            id=id,
            name=name,
            protocol=protocol,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            port=port,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            protocol__n=protocol__n,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamServiceTemplatesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_service_templates_list_serialize(
        self,
        id,
        name,
        protocol,
        created,
        last_updated,
        q,
        tag,
        port,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        name__n,
        name__ic,
        name__nic,
        name__iew,
        name__niew,
        name__isw,
        name__nisw,
        name__ie,
        name__nie,
        name__empty,
        protocol__n,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if protocol is not None:
            
            _query_params.append(('protocol', protocol))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if port is not None:
            
            _query_params.append(('port', port))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if name__n is not None:
            
            _query_params.append(('name__n', name__n))
            
        if name__ic is not None:
            
            _query_params.append(('name__ic', name__ic))
            
        if name__nic is not None:
            
            _query_params.append(('name__nic', name__nic))
            
        if name__iew is not None:
            
            _query_params.append(('name__iew', name__iew))
            
        if name__niew is not None:
            
            _query_params.append(('name__niew', name__niew))
            
        if name__isw is not None:
            
            _query_params.append(('name__isw', name__isw))
            
        if name__nisw is not None:
            
            _query_params.append(('name__nisw', name__nisw))
            
        if name__ie is not None:
            
            _query_params.append(('name__ie', name__ie))
            
        if name__nie is not None:
            
            _query_params.append(('name__nie', name__nie))
            
        if name__empty is not None:
            
            _query_params.append(('name__empty', name__empty))
            
        if protocol__n is not None:
            
            _query_params.append(('protocol__n', protocol__n))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/service-templates/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_service_templates_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ServiceTemplate:
        """ipam_service_templates_partial_update

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_partial_update_serialize(
            id=id,
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_service_templates_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ServiceTemplate]:
        """ipam_service_templates_partial_update

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_partial_update_serialize(
            id=id,
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_service_templates_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_service_templates_partial_update

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_partial_update_serialize(
            id=id,
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_service_templates_partial_update_serialize(
        self,
        id,
        writable_service_template,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_service_template is not None:
            _body_params = writable_service_template


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/service-templates/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_service_templates_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ServiceTemplate:
        """ipam_service_templates_read

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_service_templates_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ServiceTemplate]:
        """ipam_service_templates_read

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_service_templates_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_service_templates_read

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_service_templates_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/service-templates/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_service_templates_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ServiceTemplate:
        """ipam_service_templates_update

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_update_serialize(
            id=id,
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_service_templates_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ServiceTemplate]:
        """ipam_service_templates_update

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_update_serialize(
            id=id,
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_service_templates_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service template.")],
        writable_service_template: WritableServiceTemplate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_service_templates_update

        

        :param id: A unique integer value identifying this service template. (required)
        :type id: int
        :param writable_service_template: (required)
        :type writable_service_template: WritableServiceTemplate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_service_templates_update_serialize(
            id=id,
            writable_service_template=writable_service_template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ServiceTemplate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_service_templates_update_serialize(
        self,
        id,
        writable_service_template,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_service_template is not None:
            _body_params = writable_service_template


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/service-templates/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_services_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_services_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_services_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_services_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_services_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_services_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_services_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/services/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_services_bulk_partial_update(
        self,
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Service:
        """ipam_services_bulk_partial_update

        

        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_bulk_partial_update_serialize(
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_services_bulk_partial_update_with_http_info(
        self,
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Service]:
        """ipam_services_bulk_partial_update

        

        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_bulk_partial_update_serialize(
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_services_bulk_partial_update_without_preload_content(
        self,
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_services_bulk_partial_update

        

        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_bulk_partial_update_serialize(
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_services_bulk_partial_update_serialize(
        self,
        writable_service,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_service is not None:
            _body_params = writable_service


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/services/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_services_bulk_update(
        self,
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Service:
        """ipam_services_bulk_update

        

        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_bulk_update_serialize(
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_services_bulk_update_with_http_info(
        self,
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Service]:
        """ipam_services_bulk_update

        

        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_bulk_update_serialize(
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_services_bulk_update_without_preload_content(
        self,
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_services_bulk_update

        

        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_bulk_update_serialize(
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_services_bulk_update_serialize(
        self,
        writable_service,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_service is not None:
            _body_params = writable_service


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/services/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_services_create(
        self,
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Service:
        """ipam_services_create

        

        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_create_serialize(
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_services_create_with_http_info(
        self,
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Service]:
        """ipam_services_create

        

        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_create_serialize(
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_services_create_without_preload_content(
        self,
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_services_create

        

        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_create_serialize(
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_services_create_serialize(
        self,
        writable_service,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_service is not None:
            _body_params = writable_service


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/services/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_services_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_services_delete

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_services_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_services_delete

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_services_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_services_delete

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_services_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/services/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_services_list(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        protocol: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        ipaddress_id: Optional[StrictStr] = None,
        ipaddress: Optional[StrictStr] = None,
        port: Optional[Union[StrictFloat, StrictInt]] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        protocol__n: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        device_id__n: Optional[StrictStr] = None,
        device__n: Optional[StrictStr] = None,
        virtual_machine_id__n: Optional[StrictStr] = None,
        virtual_machine__n: Optional[StrictStr] = None,
        ipaddress_id__n: Optional[StrictStr] = None,
        ipaddress__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamServicesList200Response:
        """ipam_services_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param protocol: 
        :type protocol: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param device_id: 
        :type device_id: str
        :param device: 
        :type device: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param ipaddress_id: 
        :type ipaddress_id: str
        :param ipaddress: 
        :type ipaddress: str
        :param port: 
        :type port: float
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param protocol__n: 
        :type protocol__n: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param device_id__n: 
        :type device_id__n: str
        :param device__n: 
        :type device__n: str
        :param virtual_machine_id__n: 
        :type virtual_machine_id__n: str
        :param virtual_machine__n: 
        :type virtual_machine__n: str
        :param ipaddress_id__n: 
        :type ipaddress_id__n: str
        :param ipaddress__n: 
        :type ipaddress__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_list_serialize(
            id=id,
            name=name,
            protocol=protocol,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            device_id=device_id,
            device=device,
            virtual_machine_id=virtual_machine_id,
            virtual_machine=virtual_machine,
            ipaddress_id=ipaddress_id,
            ipaddress=ipaddress,
            port=port,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            protocol__n=protocol__n,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            device_id__n=device_id__n,
            device__n=device__n,
            virtual_machine_id__n=virtual_machine_id__n,
            virtual_machine__n=virtual_machine__n,
            ipaddress_id__n=ipaddress_id__n,
            ipaddress__n=ipaddress__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamServicesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_services_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        protocol: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        ipaddress_id: Optional[StrictStr] = None,
        ipaddress: Optional[StrictStr] = None,
        port: Optional[Union[StrictFloat, StrictInt]] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        protocol__n: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        device_id__n: Optional[StrictStr] = None,
        device__n: Optional[StrictStr] = None,
        virtual_machine_id__n: Optional[StrictStr] = None,
        virtual_machine__n: Optional[StrictStr] = None,
        ipaddress_id__n: Optional[StrictStr] = None,
        ipaddress__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamServicesList200Response]:
        """ipam_services_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param protocol: 
        :type protocol: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param device_id: 
        :type device_id: str
        :param device: 
        :type device: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param ipaddress_id: 
        :type ipaddress_id: str
        :param ipaddress: 
        :type ipaddress: str
        :param port: 
        :type port: float
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param protocol__n: 
        :type protocol__n: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param device_id__n: 
        :type device_id__n: str
        :param device__n: 
        :type device__n: str
        :param virtual_machine_id__n: 
        :type virtual_machine_id__n: str
        :param virtual_machine__n: 
        :type virtual_machine__n: str
        :param ipaddress_id__n: 
        :type ipaddress_id__n: str
        :param ipaddress__n: 
        :type ipaddress__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_list_serialize(
            id=id,
            name=name,
            protocol=protocol,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            device_id=device_id,
            device=device,
            virtual_machine_id=virtual_machine_id,
            virtual_machine=virtual_machine,
            ipaddress_id=ipaddress_id,
            ipaddress=ipaddress,
            port=port,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            protocol__n=protocol__n,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            device_id__n=device_id__n,
            device__n=device__n,
            virtual_machine_id__n=virtual_machine_id__n,
            virtual_machine__n=virtual_machine__n,
            ipaddress_id__n=ipaddress_id__n,
            ipaddress__n=ipaddress__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamServicesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_services_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        protocol: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        device_id: Optional[StrictStr] = None,
        device: Optional[StrictStr] = None,
        virtual_machine_id: Optional[StrictStr] = None,
        virtual_machine: Optional[StrictStr] = None,
        ipaddress_id: Optional[StrictStr] = None,
        ipaddress: Optional[StrictStr] = None,
        port: Optional[Union[StrictFloat, StrictInt]] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        protocol__n: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        device_id__n: Optional[StrictStr] = None,
        device__n: Optional[StrictStr] = None,
        virtual_machine_id__n: Optional[StrictStr] = None,
        virtual_machine__n: Optional[StrictStr] = None,
        ipaddress_id__n: Optional[StrictStr] = None,
        ipaddress__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_services_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param protocol: 
        :type protocol: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param device_id: 
        :type device_id: str
        :param device: 
        :type device: str
        :param virtual_machine_id: 
        :type virtual_machine_id: str
        :param virtual_machine: 
        :type virtual_machine: str
        :param ipaddress_id: 
        :type ipaddress_id: str
        :param ipaddress: 
        :type ipaddress: str
        :param port: 
        :type port: float
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param protocol__n: 
        :type protocol__n: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param device_id__n: 
        :type device_id__n: str
        :param device__n: 
        :type device__n: str
        :param virtual_machine_id__n: 
        :type virtual_machine_id__n: str
        :param virtual_machine__n: 
        :type virtual_machine__n: str
        :param ipaddress_id__n: 
        :type ipaddress_id__n: str
        :param ipaddress__n: 
        :type ipaddress__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_list_serialize(
            id=id,
            name=name,
            protocol=protocol,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            device_id=device_id,
            device=device,
            virtual_machine_id=virtual_machine_id,
            virtual_machine=virtual_machine,
            ipaddress_id=ipaddress_id,
            ipaddress=ipaddress,
            port=port,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            protocol__n=protocol__n,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            device_id__n=device_id__n,
            device__n=device__n,
            virtual_machine_id__n=virtual_machine_id__n,
            virtual_machine__n=virtual_machine__n,
            ipaddress_id__n=ipaddress_id__n,
            ipaddress__n=ipaddress__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamServicesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_services_list_serialize(
        self,
        id,
        name,
        protocol,
        description,
        created,
        last_updated,
        q,
        tag,
        device_id,
        device,
        virtual_machine_id,
        virtual_machine,
        ipaddress_id,
        ipaddress,
        port,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        name__n,
        name__ic,
        name__nic,
        name__iew,
        name__niew,
        name__isw,
        name__nisw,
        name__ie,
        name__nie,
        name__empty,
        protocol__n,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        device_id__n,
        device__n,
        virtual_machine_id__n,
        virtual_machine__n,
        ipaddress_id__n,
        ipaddress__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if protocol is not None:
            
            _query_params.append(('protocol', protocol))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if device_id is not None:
            
            _query_params.append(('device_id', device_id))
            
        if device is not None:
            
            _query_params.append(('device', device))
            
        if virtual_machine_id is not None:
            
            _query_params.append(('virtual_machine_id', virtual_machine_id))
            
        if virtual_machine is not None:
            
            _query_params.append(('virtual_machine', virtual_machine))
            
        if ipaddress_id is not None:
            
            _query_params.append(('ipaddress_id', ipaddress_id))
            
        if ipaddress is not None:
            
            _query_params.append(('ipaddress', ipaddress))
            
        if port is not None:
            
            _query_params.append(('port', port))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if name__n is not None:
            
            _query_params.append(('name__n', name__n))
            
        if name__ic is not None:
            
            _query_params.append(('name__ic', name__ic))
            
        if name__nic is not None:
            
            _query_params.append(('name__nic', name__nic))
            
        if name__iew is not None:
            
            _query_params.append(('name__iew', name__iew))
            
        if name__niew is not None:
            
            _query_params.append(('name__niew', name__niew))
            
        if name__isw is not None:
            
            _query_params.append(('name__isw', name__isw))
            
        if name__nisw is not None:
            
            _query_params.append(('name__nisw', name__nisw))
            
        if name__ie is not None:
            
            _query_params.append(('name__ie', name__ie))
            
        if name__nie is not None:
            
            _query_params.append(('name__nie', name__nie))
            
        if name__empty is not None:
            
            _query_params.append(('name__empty', name__empty))
            
        if protocol__n is not None:
            
            _query_params.append(('protocol__n', protocol__n))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if device_id__n is not None:
            
            _query_params.append(('device_id__n', device_id__n))
            
        if device__n is not None:
            
            _query_params.append(('device__n', device__n))
            
        if virtual_machine_id__n is not None:
            
            _query_params.append(('virtual_machine_id__n', virtual_machine_id__n))
            
        if virtual_machine__n is not None:
            
            _query_params.append(('virtual_machine__n', virtual_machine__n))
            
        if ipaddress_id__n is not None:
            
            _query_params.append(('ipaddress_id__n', ipaddress_id__n))
            
        if ipaddress__n is not None:
            
            _query_params.append(('ipaddress__n', ipaddress__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/services/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_services_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Service:
        """ipam_services_partial_update

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_partial_update_serialize(
            id=id,
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_services_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Service]:
        """ipam_services_partial_update

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_partial_update_serialize(
            id=id,
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_services_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_services_partial_update

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_partial_update_serialize(
            id=id,
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_services_partial_update_serialize(
        self,
        id,
        writable_service,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_service is not None:
            _body_params = writable_service


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/services/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_services_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Service:
        """ipam_services_read

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_services_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Service]:
        """ipam_services_read

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_services_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_services_read

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_services_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/services/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_services_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Service:
        """ipam_services_update

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_update_serialize(
            id=id,
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_services_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Service]:
        """ipam_services_update

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_update_serialize(
            id=id,
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_services_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this service.")],
        writable_service: WritableService,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_services_update

        

        :param id: A unique integer value identifying this service. (required)
        :type id: int
        :param writable_service: (required)
        :type writable_service: WritableService
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_services_update_serialize(
            id=id,
            writable_service=writable_service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Service",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_services_update_serialize(
        self,
        id,
        writable_service,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_service is not None:
            _body_params = writable_service


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/services/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_available_vlans_create(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        writable_create_available_vlan: WritableCreateAvailableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[VLAN]:
        """ipam_vlan_groups_available_vlans_create

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param writable_create_available_vlan: (required)
        :type writable_create_available_vlan: WritableCreateAvailableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_available_vlans_create_serialize(
            id=id,
            writable_create_available_vlan=writable_create_available_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[VLAN]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_available_vlans_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        writable_create_available_vlan: WritableCreateAvailableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[VLAN]]:
        """ipam_vlan_groups_available_vlans_create

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param writable_create_available_vlan: (required)
        :type writable_create_available_vlan: WritableCreateAvailableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_available_vlans_create_serialize(
            id=id,
            writable_create_available_vlan=writable_create_available_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[VLAN]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_available_vlans_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        writable_create_available_vlan: WritableCreateAvailableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_available_vlans_create

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param writable_create_available_vlan: (required)
        :type writable_create_available_vlan: WritableCreateAvailableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_available_vlans_create_serialize(
            id=id,
            writable_create_available_vlan=writable_create_available_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "List[VLAN]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_available_vlans_create_serialize(
        self,
        id,
        writable_create_available_vlan,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_create_available_vlan is not None:
            _body_params = writable_create_available_vlan


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/vlan-groups/{id}/available-vlans/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_available_vlans_list(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AvailableVLAN]:
        """ipam_vlan_groups_available_vlans_list

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_available_vlans_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailableVLAN]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_available_vlans_list_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AvailableVLAN]]:
        """ipam_vlan_groups_available_vlans_list

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_available_vlans_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailableVLAN]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_available_vlans_list_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_available_vlans_list

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_available_vlans_list_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AvailableVLAN]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_available_vlans_list_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/vlan-groups/{id}/available-vlans/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_vlan_groups_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_vlan_groups_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/vlan-groups/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_bulk_partial_update(
        self,
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLANGroup:
        """ipam_vlan_groups_bulk_partial_update

        

        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_bulk_partial_update_serialize(
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_bulk_partial_update_with_http_info(
        self,
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLANGroup]:
        """ipam_vlan_groups_bulk_partial_update

        

        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_bulk_partial_update_serialize(
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_bulk_partial_update_without_preload_content(
        self,
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_bulk_partial_update

        

        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_bulk_partial_update_serialize(
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_bulk_partial_update_serialize(
        self,
        vlan_group,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if vlan_group is not None:
            _body_params = vlan_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/vlan-groups/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_bulk_update(
        self,
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLANGroup:
        """ipam_vlan_groups_bulk_update

        

        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_bulk_update_serialize(
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_bulk_update_with_http_info(
        self,
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLANGroup]:
        """ipam_vlan_groups_bulk_update

        

        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_bulk_update_serialize(
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_bulk_update_without_preload_content(
        self,
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_bulk_update

        

        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_bulk_update_serialize(
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_bulk_update_serialize(
        self,
        vlan_group,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if vlan_group is not None:
            _body_params = vlan_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/vlan-groups/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_create(
        self,
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLANGroup:
        """ipam_vlan_groups_create

        

        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_create_serialize(
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_create_with_http_info(
        self,
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLANGroup]:
        """ipam_vlan_groups_create

        

        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_create_serialize(
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_create_without_preload_content(
        self,
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_create

        

        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_create_serialize(
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_create_serialize(
        self,
        vlan_group,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if vlan_group is not None:
            _body_params = vlan_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/vlan-groups/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_vlan_groups_delete

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_vlan_groups_delete

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_delete

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/vlan-groups/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_list(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        min_vid: Optional[StrictStr] = None,
        max_vid: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        scope_id: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        scope_type: Optional[StrictStr] = None,
        region: Optional[Union[StrictFloat, StrictInt]] = None,
        sitegroup: Optional[Union[StrictFloat, StrictInt]] = None,
        site: Optional[Union[StrictFloat, StrictInt]] = None,
        location: Optional[Union[StrictFloat, StrictInt]] = None,
        rack: Optional[Union[StrictFloat, StrictInt]] = None,
        clustergroup: Optional[Union[StrictFloat, StrictInt]] = None,
        cluster: Optional[Union[StrictFloat, StrictInt]] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        min_vid__n: Optional[StrictStr] = None,
        min_vid__lte: Optional[StrictStr] = None,
        min_vid__lt: Optional[StrictStr] = None,
        min_vid__gte: Optional[StrictStr] = None,
        min_vid__gt: Optional[StrictStr] = None,
        max_vid__n: Optional[StrictStr] = None,
        max_vid__lte: Optional[StrictStr] = None,
        max_vid__lt: Optional[StrictStr] = None,
        max_vid__gte: Optional[StrictStr] = None,
        max_vid__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        scope_id__n: Optional[StrictStr] = None,
        scope_id__lte: Optional[StrictStr] = None,
        scope_id__lt: Optional[StrictStr] = None,
        scope_id__gte: Optional[StrictStr] = None,
        scope_id__gt: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        scope_type__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamVlanGroupsList200Response:
        """ipam_vlan_groups_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param min_vid: 
        :type min_vid: str
        :param max_vid: 
        :type max_vid: str
        :param description: 
        :type description: str
        :param scope_id: 
        :type scope_id: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param scope_type: 
        :type scope_type: str
        :param region: 
        :type region: float
        :param sitegroup: 
        :type sitegroup: float
        :param site: 
        :type site: float
        :param location: 
        :type location: float
        :param rack: 
        :type rack: float
        :param clustergroup: 
        :type clustergroup: float
        :param cluster: 
        :type cluster: float
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param min_vid__n: 
        :type min_vid__n: str
        :param min_vid__lte: 
        :type min_vid__lte: str
        :param min_vid__lt: 
        :type min_vid__lt: str
        :param min_vid__gte: 
        :type min_vid__gte: str
        :param min_vid__gt: 
        :type min_vid__gt: str
        :param max_vid__n: 
        :type max_vid__n: str
        :param max_vid__lte: 
        :type max_vid__lte: str
        :param max_vid__lt: 
        :type max_vid__lt: str
        :param max_vid__gte: 
        :type max_vid__gte: str
        :param max_vid__gt: 
        :type max_vid__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param scope_id__n: 
        :type scope_id__n: str
        :param scope_id__lte: 
        :type scope_id__lte: str
        :param scope_id__lt: 
        :type scope_id__lt: str
        :param scope_id__gte: 
        :type scope_id__gte: str
        :param scope_id__gt: 
        :type scope_id__gt: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param scope_type__n: 
        :type scope_type__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_list_serialize(
            id=id,
            name=name,
            slug=slug,
            min_vid=min_vid,
            max_vid=max_vid,
            description=description,
            scope_id=scope_id,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            scope_type=scope_type,
            region=region,
            sitegroup=sitegroup,
            site=site,
            location=location,
            rack=rack,
            clustergroup=clustergroup,
            cluster=cluster,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            min_vid__n=min_vid__n,
            min_vid__lte=min_vid__lte,
            min_vid__lt=min_vid__lt,
            min_vid__gte=min_vid__gte,
            min_vid__gt=min_vid__gt,
            max_vid__n=max_vid__n,
            max_vid__lte=max_vid__lte,
            max_vid__lt=max_vid__lt,
            max_vid__gte=max_vid__gte,
            max_vid__gt=max_vid__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            scope_id__n=scope_id__n,
            scope_id__lte=scope_id__lte,
            scope_id__lt=scope_id__lt,
            scope_id__gte=scope_id__gte,
            scope_id__gt=scope_id__gt,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            scope_type__n=scope_type__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamVlanGroupsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        min_vid: Optional[StrictStr] = None,
        max_vid: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        scope_id: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        scope_type: Optional[StrictStr] = None,
        region: Optional[Union[StrictFloat, StrictInt]] = None,
        sitegroup: Optional[Union[StrictFloat, StrictInt]] = None,
        site: Optional[Union[StrictFloat, StrictInt]] = None,
        location: Optional[Union[StrictFloat, StrictInt]] = None,
        rack: Optional[Union[StrictFloat, StrictInt]] = None,
        clustergroup: Optional[Union[StrictFloat, StrictInt]] = None,
        cluster: Optional[Union[StrictFloat, StrictInt]] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        min_vid__n: Optional[StrictStr] = None,
        min_vid__lte: Optional[StrictStr] = None,
        min_vid__lt: Optional[StrictStr] = None,
        min_vid__gte: Optional[StrictStr] = None,
        min_vid__gt: Optional[StrictStr] = None,
        max_vid__n: Optional[StrictStr] = None,
        max_vid__lte: Optional[StrictStr] = None,
        max_vid__lt: Optional[StrictStr] = None,
        max_vid__gte: Optional[StrictStr] = None,
        max_vid__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        scope_id__n: Optional[StrictStr] = None,
        scope_id__lte: Optional[StrictStr] = None,
        scope_id__lt: Optional[StrictStr] = None,
        scope_id__gte: Optional[StrictStr] = None,
        scope_id__gt: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        scope_type__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamVlanGroupsList200Response]:
        """ipam_vlan_groups_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param min_vid: 
        :type min_vid: str
        :param max_vid: 
        :type max_vid: str
        :param description: 
        :type description: str
        :param scope_id: 
        :type scope_id: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param scope_type: 
        :type scope_type: str
        :param region: 
        :type region: float
        :param sitegroup: 
        :type sitegroup: float
        :param site: 
        :type site: float
        :param location: 
        :type location: float
        :param rack: 
        :type rack: float
        :param clustergroup: 
        :type clustergroup: float
        :param cluster: 
        :type cluster: float
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param min_vid__n: 
        :type min_vid__n: str
        :param min_vid__lte: 
        :type min_vid__lte: str
        :param min_vid__lt: 
        :type min_vid__lt: str
        :param min_vid__gte: 
        :type min_vid__gte: str
        :param min_vid__gt: 
        :type min_vid__gt: str
        :param max_vid__n: 
        :type max_vid__n: str
        :param max_vid__lte: 
        :type max_vid__lte: str
        :param max_vid__lt: 
        :type max_vid__lt: str
        :param max_vid__gte: 
        :type max_vid__gte: str
        :param max_vid__gt: 
        :type max_vid__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param scope_id__n: 
        :type scope_id__n: str
        :param scope_id__lte: 
        :type scope_id__lte: str
        :param scope_id__lt: 
        :type scope_id__lt: str
        :param scope_id__gte: 
        :type scope_id__gte: str
        :param scope_id__gt: 
        :type scope_id__gt: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param scope_type__n: 
        :type scope_type__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_list_serialize(
            id=id,
            name=name,
            slug=slug,
            min_vid=min_vid,
            max_vid=max_vid,
            description=description,
            scope_id=scope_id,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            scope_type=scope_type,
            region=region,
            sitegroup=sitegroup,
            site=site,
            location=location,
            rack=rack,
            clustergroup=clustergroup,
            cluster=cluster,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            min_vid__n=min_vid__n,
            min_vid__lte=min_vid__lte,
            min_vid__lt=min_vid__lt,
            min_vid__gte=min_vid__gte,
            min_vid__gt=min_vid__gt,
            max_vid__n=max_vid__n,
            max_vid__lte=max_vid__lte,
            max_vid__lt=max_vid__lt,
            max_vid__gte=max_vid__gte,
            max_vid__gt=max_vid__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            scope_id__n=scope_id__n,
            scope_id__lte=scope_id__lte,
            scope_id__lt=scope_id__lt,
            scope_id__gte=scope_id__gte,
            scope_id__gt=scope_id__gt,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            scope_type__n=scope_type__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamVlanGroupsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        slug: Optional[StrictStr] = None,
        min_vid: Optional[StrictStr] = None,
        max_vid: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        scope_id: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        scope_type: Optional[StrictStr] = None,
        region: Optional[Union[StrictFloat, StrictInt]] = None,
        sitegroup: Optional[Union[StrictFloat, StrictInt]] = None,
        site: Optional[Union[StrictFloat, StrictInt]] = None,
        location: Optional[Union[StrictFloat, StrictInt]] = None,
        rack: Optional[Union[StrictFloat, StrictInt]] = None,
        clustergroup: Optional[Union[StrictFloat, StrictInt]] = None,
        cluster: Optional[Union[StrictFloat, StrictInt]] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        slug__n: Optional[StrictStr] = None,
        slug__ic: Optional[StrictStr] = None,
        slug__nic: Optional[StrictStr] = None,
        slug__iew: Optional[StrictStr] = None,
        slug__niew: Optional[StrictStr] = None,
        slug__isw: Optional[StrictStr] = None,
        slug__nisw: Optional[StrictStr] = None,
        slug__ie: Optional[StrictStr] = None,
        slug__nie: Optional[StrictStr] = None,
        slug__empty: Optional[StrictStr] = None,
        min_vid__n: Optional[StrictStr] = None,
        min_vid__lte: Optional[StrictStr] = None,
        min_vid__lt: Optional[StrictStr] = None,
        min_vid__gte: Optional[StrictStr] = None,
        min_vid__gt: Optional[StrictStr] = None,
        max_vid__n: Optional[StrictStr] = None,
        max_vid__lte: Optional[StrictStr] = None,
        max_vid__lt: Optional[StrictStr] = None,
        max_vid__gte: Optional[StrictStr] = None,
        max_vid__gt: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        scope_id__n: Optional[StrictStr] = None,
        scope_id__lte: Optional[StrictStr] = None,
        scope_id__lt: Optional[StrictStr] = None,
        scope_id__gte: Optional[StrictStr] = None,
        scope_id__gt: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        scope_type__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param slug: 
        :type slug: str
        :param min_vid: 
        :type min_vid: str
        :param max_vid: 
        :type max_vid: str
        :param description: 
        :type description: str
        :param scope_id: 
        :type scope_id: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param scope_type: 
        :type scope_type: str
        :param region: 
        :type region: float
        :param sitegroup: 
        :type sitegroup: float
        :param site: 
        :type site: float
        :param location: 
        :type location: float
        :param rack: 
        :type rack: float
        :param clustergroup: 
        :type clustergroup: float
        :param cluster: 
        :type cluster: float
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param slug__n: 
        :type slug__n: str
        :param slug__ic: 
        :type slug__ic: str
        :param slug__nic: 
        :type slug__nic: str
        :param slug__iew: 
        :type slug__iew: str
        :param slug__niew: 
        :type slug__niew: str
        :param slug__isw: 
        :type slug__isw: str
        :param slug__nisw: 
        :type slug__nisw: str
        :param slug__ie: 
        :type slug__ie: str
        :param slug__nie: 
        :type slug__nie: str
        :param slug__empty: 
        :type slug__empty: str
        :param min_vid__n: 
        :type min_vid__n: str
        :param min_vid__lte: 
        :type min_vid__lte: str
        :param min_vid__lt: 
        :type min_vid__lt: str
        :param min_vid__gte: 
        :type min_vid__gte: str
        :param min_vid__gt: 
        :type min_vid__gt: str
        :param max_vid__n: 
        :type max_vid__n: str
        :param max_vid__lte: 
        :type max_vid__lte: str
        :param max_vid__lt: 
        :type max_vid__lt: str
        :param max_vid__gte: 
        :type max_vid__gte: str
        :param max_vid__gt: 
        :type max_vid__gt: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param scope_id__n: 
        :type scope_id__n: str
        :param scope_id__lte: 
        :type scope_id__lte: str
        :param scope_id__lt: 
        :type scope_id__lt: str
        :param scope_id__gte: 
        :type scope_id__gte: str
        :param scope_id__gt: 
        :type scope_id__gt: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param scope_type__n: 
        :type scope_type__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_list_serialize(
            id=id,
            name=name,
            slug=slug,
            min_vid=min_vid,
            max_vid=max_vid,
            description=description,
            scope_id=scope_id,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            scope_type=scope_type,
            region=region,
            sitegroup=sitegroup,
            site=site,
            location=location,
            rack=rack,
            clustergroup=clustergroup,
            cluster=cluster,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            slug__n=slug__n,
            slug__ic=slug__ic,
            slug__nic=slug__nic,
            slug__iew=slug__iew,
            slug__niew=slug__niew,
            slug__isw=slug__isw,
            slug__nisw=slug__nisw,
            slug__ie=slug__ie,
            slug__nie=slug__nie,
            slug__empty=slug__empty,
            min_vid__n=min_vid__n,
            min_vid__lte=min_vid__lte,
            min_vid__lt=min_vid__lt,
            min_vid__gte=min_vid__gte,
            min_vid__gt=min_vid__gt,
            max_vid__n=max_vid__n,
            max_vid__lte=max_vid__lte,
            max_vid__lt=max_vid__lt,
            max_vid__gte=max_vid__gte,
            max_vid__gt=max_vid__gt,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            scope_id__n=scope_id__n,
            scope_id__lte=scope_id__lte,
            scope_id__lt=scope_id__lt,
            scope_id__gte=scope_id__gte,
            scope_id__gt=scope_id__gt,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            scope_type__n=scope_type__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamVlanGroupsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_list_serialize(
        self,
        id,
        name,
        slug,
        min_vid,
        max_vid,
        description,
        scope_id,
        created,
        last_updated,
        q,
        tag,
        scope_type,
        region,
        sitegroup,
        site,
        location,
        rack,
        clustergroup,
        cluster,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        name__n,
        name__ic,
        name__nic,
        name__iew,
        name__niew,
        name__isw,
        name__nisw,
        name__ie,
        name__nie,
        name__empty,
        slug__n,
        slug__ic,
        slug__nic,
        slug__iew,
        slug__niew,
        slug__isw,
        slug__nisw,
        slug__ie,
        slug__nie,
        slug__empty,
        min_vid__n,
        min_vid__lte,
        min_vid__lt,
        min_vid__gte,
        min_vid__gt,
        max_vid__n,
        max_vid__lte,
        max_vid__lt,
        max_vid__gte,
        max_vid__gt,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        scope_id__n,
        scope_id__lte,
        scope_id__lt,
        scope_id__gte,
        scope_id__gt,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        scope_type__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if slug is not None:
            
            _query_params.append(('slug', slug))
            
        if min_vid is not None:
            
            _query_params.append(('min_vid', min_vid))
            
        if max_vid is not None:
            
            _query_params.append(('max_vid', max_vid))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if scope_id is not None:
            
            _query_params.append(('scope_id', scope_id))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if scope_type is not None:
            
            _query_params.append(('scope_type', scope_type))
            
        if region is not None:
            
            _query_params.append(('region', region))
            
        if sitegroup is not None:
            
            _query_params.append(('sitegroup', sitegroup))
            
        if site is not None:
            
            _query_params.append(('site', site))
            
        if location is not None:
            
            _query_params.append(('location', location))
            
        if rack is not None:
            
            _query_params.append(('rack', rack))
            
        if clustergroup is not None:
            
            _query_params.append(('clustergroup', clustergroup))
            
        if cluster is not None:
            
            _query_params.append(('cluster', cluster))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if name__n is not None:
            
            _query_params.append(('name__n', name__n))
            
        if name__ic is not None:
            
            _query_params.append(('name__ic', name__ic))
            
        if name__nic is not None:
            
            _query_params.append(('name__nic', name__nic))
            
        if name__iew is not None:
            
            _query_params.append(('name__iew', name__iew))
            
        if name__niew is not None:
            
            _query_params.append(('name__niew', name__niew))
            
        if name__isw is not None:
            
            _query_params.append(('name__isw', name__isw))
            
        if name__nisw is not None:
            
            _query_params.append(('name__nisw', name__nisw))
            
        if name__ie is not None:
            
            _query_params.append(('name__ie', name__ie))
            
        if name__nie is not None:
            
            _query_params.append(('name__nie', name__nie))
            
        if name__empty is not None:
            
            _query_params.append(('name__empty', name__empty))
            
        if slug__n is not None:
            
            _query_params.append(('slug__n', slug__n))
            
        if slug__ic is not None:
            
            _query_params.append(('slug__ic', slug__ic))
            
        if slug__nic is not None:
            
            _query_params.append(('slug__nic', slug__nic))
            
        if slug__iew is not None:
            
            _query_params.append(('slug__iew', slug__iew))
            
        if slug__niew is not None:
            
            _query_params.append(('slug__niew', slug__niew))
            
        if slug__isw is not None:
            
            _query_params.append(('slug__isw', slug__isw))
            
        if slug__nisw is not None:
            
            _query_params.append(('slug__nisw', slug__nisw))
            
        if slug__ie is not None:
            
            _query_params.append(('slug__ie', slug__ie))
            
        if slug__nie is not None:
            
            _query_params.append(('slug__nie', slug__nie))
            
        if slug__empty is not None:
            
            _query_params.append(('slug__empty', slug__empty))
            
        if min_vid__n is not None:
            
            _query_params.append(('min_vid__n', min_vid__n))
            
        if min_vid__lte is not None:
            
            _query_params.append(('min_vid__lte', min_vid__lte))
            
        if min_vid__lt is not None:
            
            _query_params.append(('min_vid__lt', min_vid__lt))
            
        if min_vid__gte is not None:
            
            _query_params.append(('min_vid__gte', min_vid__gte))
            
        if min_vid__gt is not None:
            
            _query_params.append(('min_vid__gt', min_vid__gt))
            
        if max_vid__n is not None:
            
            _query_params.append(('max_vid__n', max_vid__n))
            
        if max_vid__lte is not None:
            
            _query_params.append(('max_vid__lte', max_vid__lte))
            
        if max_vid__lt is not None:
            
            _query_params.append(('max_vid__lt', max_vid__lt))
            
        if max_vid__gte is not None:
            
            _query_params.append(('max_vid__gte', max_vid__gte))
            
        if max_vid__gt is not None:
            
            _query_params.append(('max_vid__gt', max_vid__gt))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if scope_id__n is not None:
            
            _query_params.append(('scope_id__n', scope_id__n))
            
        if scope_id__lte is not None:
            
            _query_params.append(('scope_id__lte', scope_id__lte))
            
        if scope_id__lt is not None:
            
            _query_params.append(('scope_id__lt', scope_id__lt))
            
        if scope_id__gte is not None:
            
            _query_params.append(('scope_id__gte', scope_id__gte))
            
        if scope_id__gt is not None:
            
            _query_params.append(('scope_id__gt', scope_id__gt))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if scope_type__n is not None:
            
            _query_params.append(('scope_type__n', scope_type__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/vlan-groups/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLANGroup:
        """ipam_vlan_groups_partial_update

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_partial_update_serialize(
            id=id,
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLANGroup]:
        """ipam_vlan_groups_partial_update

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_partial_update_serialize(
            id=id,
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_partial_update

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_partial_update_serialize(
            id=id,
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_partial_update_serialize(
        self,
        id,
        vlan_group,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if vlan_group is not None:
            _body_params = vlan_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/vlan-groups/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLANGroup:
        """ipam_vlan_groups_read

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLANGroup]:
        """ipam_vlan_groups_read

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_read

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/vlan-groups/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlan_groups_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLANGroup:
        """ipam_vlan_groups_update

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_update_serialize(
            id=id,
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlan_groups_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLANGroup]:
        """ipam_vlan_groups_update

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_update_serialize(
            id=id,
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlan_groups_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN group.")],
        vlan_group: VLANGroup,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlan_groups_update

        

        :param id: A unique integer value identifying this VLAN group. (required)
        :type id: int
        :param vlan_group: (required)
        :type vlan_group: VLANGroup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlan_groups_update_serialize(
            id=id,
            vlan_group=vlan_group,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLANGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlan_groups_update_serialize(
        self,
        id,
        vlan_group,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if vlan_group is not None:
            _body_params = vlan_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/vlan-groups/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlans_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_vlans_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlans_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_vlans_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlans_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlans_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlans_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/vlans/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlans_bulk_partial_update(
        self,
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLAN:
        """ipam_vlans_bulk_partial_update

        

        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_bulk_partial_update_serialize(
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlans_bulk_partial_update_with_http_info(
        self,
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLAN]:
        """ipam_vlans_bulk_partial_update

        

        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_bulk_partial_update_serialize(
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlans_bulk_partial_update_without_preload_content(
        self,
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlans_bulk_partial_update

        

        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_bulk_partial_update_serialize(
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlans_bulk_partial_update_serialize(
        self,
        writable_vlan,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_vlan is not None:
            _body_params = writable_vlan


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/vlans/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlans_bulk_update(
        self,
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLAN:
        """ipam_vlans_bulk_update

        

        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_bulk_update_serialize(
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlans_bulk_update_with_http_info(
        self,
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLAN]:
        """ipam_vlans_bulk_update

        

        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_bulk_update_serialize(
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlans_bulk_update_without_preload_content(
        self,
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlans_bulk_update

        

        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_bulk_update_serialize(
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlans_bulk_update_serialize(
        self,
        writable_vlan,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_vlan is not None:
            _body_params = writable_vlan


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/vlans/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlans_create(
        self,
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLAN:
        """ipam_vlans_create

        

        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_create_serialize(
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlans_create_with_http_info(
        self,
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLAN]:
        """ipam_vlans_create

        

        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_create_serialize(
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlans_create_without_preload_content(
        self,
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlans_create

        

        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_create_serialize(
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlans_create_serialize(
        self,
        writable_vlan,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_vlan is not None:
            _body_params = writable_vlan


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/vlans/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlans_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_vlans_delete

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlans_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_vlans_delete

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlans_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlans_delete

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlans_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/vlans/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlans_list(
        self,
        id: Optional[StrictStr] = None,
        vid: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        region_id: Optional[StrictStr] = None,
        region: Optional[StrictStr] = None,
        site_group_id: Optional[StrictStr] = None,
        site_group: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        group_id: Optional[StrictStr] = None,
        group: Optional[StrictStr] = None,
        role_id: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        available_on_device: Optional[StrictStr] = None,
        available_on_virtualmachine: Optional[StrictStr] = None,
        l2vpn_id: Optional[StrictStr] = None,
        l2vpn: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        vid__n: Optional[StrictStr] = None,
        vid__lte: Optional[StrictStr] = None,
        vid__lt: Optional[StrictStr] = None,
        vid__gte: Optional[StrictStr] = None,
        vid__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        region_id__n: Optional[StrictStr] = None,
        region__n: Optional[StrictStr] = None,
        site_group_id__n: Optional[StrictStr] = None,
        site_group__n: Optional[StrictStr] = None,
        site_id__n: Optional[StrictStr] = None,
        site__n: Optional[StrictStr] = None,
        group_id__n: Optional[StrictStr] = None,
        group__n: Optional[StrictStr] = None,
        role_id__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        l2vpn_id__n: Optional[StrictStr] = None,
        l2vpn__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamVlansList200Response:
        """ipam_vlans_list

        

        :param id: 
        :type id: str
        :param vid: 
        :type vid: str
        :param name: 
        :type name: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param region_id: 
        :type region_id: str
        :param region: 
        :type region: str
        :param site_group_id: 
        :type site_group_id: str
        :param site_group: 
        :type site_group: str
        :param site_id: 
        :type site_id: str
        :param site: 
        :type site: str
        :param group_id: 
        :type group_id: str
        :param group: 
        :type group: str
        :param role_id: 
        :type role_id: str
        :param role: 
        :type role: str
        :param status: 
        :type status: str
        :param available_on_device: 
        :type available_on_device: str
        :param available_on_virtualmachine: 
        :type available_on_virtualmachine: str
        :param l2vpn_id: 
        :type l2vpn_id: str
        :param l2vpn: 
        :type l2vpn: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param vid__n: 
        :type vid__n: str
        :param vid__lte: 
        :type vid__lte: str
        :param vid__lt: 
        :type vid__lt: str
        :param vid__gte: 
        :type vid__gte: str
        :param vid__gt: 
        :type vid__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param region_id__n: 
        :type region_id__n: str
        :param region__n: 
        :type region__n: str
        :param site_group_id__n: 
        :type site_group_id__n: str
        :param site_group__n: 
        :type site_group__n: str
        :param site_id__n: 
        :type site_id__n: str
        :param site__n: 
        :type site__n: str
        :param group_id__n: 
        :type group_id__n: str
        :param group__n: 
        :type group__n: str
        :param role_id__n: 
        :type role_id__n: str
        :param role__n: 
        :type role__n: str
        :param status__n: 
        :type status__n: str
        :param l2vpn_id__n: 
        :type l2vpn_id__n: str
        :param l2vpn__n: 
        :type l2vpn__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_list_serialize(
            id=id,
            vid=vid,
            name=name,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            region_id=region_id,
            region=region,
            site_group_id=site_group_id,
            site_group=site_group,
            site_id=site_id,
            site=site,
            group_id=group_id,
            group=group,
            role_id=role_id,
            role=role,
            status=status,
            available_on_device=available_on_device,
            available_on_virtualmachine=available_on_virtualmachine,
            l2vpn_id=l2vpn_id,
            l2vpn=l2vpn,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            vid__n=vid__n,
            vid__lte=vid__lte,
            vid__lt=vid__lt,
            vid__gte=vid__gte,
            vid__gt=vid__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            region_id__n=region_id__n,
            region__n=region__n,
            site_group_id__n=site_group_id__n,
            site_group__n=site_group__n,
            site_id__n=site_id__n,
            site__n=site__n,
            group_id__n=group_id__n,
            group__n=group__n,
            role_id__n=role_id__n,
            role__n=role__n,
            status__n=status__n,
            l2vpn_id__n=l2vpn_id__n,
            l2vpn__n=l2vpn__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamVlansList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlans_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        vid: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        region_id: Optional[StrictStr] = None,
        region: Optional[StrictStr] = None,
        site_group_id: Optional[StrictStr] = None,
        site_group: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        group_id: Optional[StrictStr] = None,
        group: Optional[StrictStr] = None,
        role_id: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        available_on_device: Optional[StrictStr] = None,
        available_on_virtualmachine: Optional[StrictStr] = None,
        l2vpn_id: Optional[StrictStr] = None,
        l2vpn: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        vid__n: Optional[StrictStr] = None,
        vid__lte: Optional[StrictStr] = None,
        vid__lt: Optional[StrictStr] = None,
        vid__gte: Optional[StrictStr] = None,
        vid__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        region_id__n: Optional[StrictStr] = None,
        region__n: Optional[StrictStr] = None,
        site_group_id__n: Optional[StrictStr] = None,
        site_group__n: Optional[StrictStr] = None,
        site_id__n: Optional[StrictStr] = None,
        site__n: Optional[StrictStr] = None,
        group_id__n: Optional[StrictStr] = None,
        group__n: Optional[StrictStr] = None,
        role_id__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        l2vpn_id__n: Optional[StrictStr] = None,
        l2vpn__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamVlansList200Response]:
        """ipam_vlans_list

        

        :param id: 
        :type id: str
        :param vid: 
        :type vid: str
        :param name: 
        :type name: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param region_id: 
        :type region_id: str
        :param region: 
        :type region: str
        :param site_group_id: 
        :type site_group_id: str
        :param site_group: 
        :type site_group: str
        :param site_id: 
        :type site_id: str
        :param site: 
        :type site: str
        :param group_id: 
        :type group_id: str
        :param group: 
        :type group: str
        :param role_id: 
        :type role_id: str
        :param role: 
        :type role: str
        :param status: 
        :type status: str
        :param available_on_device: 
        :type available_on_device: str
        :param available_on_virtualmachine: 
        :type available_on_virtualmachine: str
        :param l2vpn_id: 
        :type l2vpn_id: str
        :param l2vpn: 
        :type l2vpn: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param vid__n: 
        :type vid__n: str
        :param vid__lte: 
        :type vid__lte: str
        :param vid__lt: 
        :type vid__lt: str
        :param vid__gte: 
        :type vid__gte: str
        :param vid__gt: 
        :type vid__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param region_id__n: 
        :type region_id__n: str
        :param region__n: 
        :type region__n: str
        :param site_group_id__n: 
        :type site_group_id__n: str
        :param site_group__n: 
        :type site_group__n: str
        :param site_id__n: 
        :type site_id__n: str
        :param site__n: 
        :type site__n: str
        :param group_id__n: 
        :type group_id__n: str
        :param group__n: 
        :type group__n: str
        :param role_id__n: 
        :type role_id__n: str
        :param role__n: 
        :type role__n: str
        :param status__n: 
        :type status__n: str
        :param l2vpn_id__n: 
        :type l2vpn_id__n: str
        :param l2vpn__n: 
        :type l2vpn__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_list_serialize(
            id=id,
            vid=vid,
            name=name,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            region_id=region_id,
            region=region,
            site_group_id=site_group_id,
            site_group=site_group,
            site_id=site_id,
            site=site,
            group_id=group_id,
            group=group,
            role_id=role_id,
            role=role,
            status=status,
            available_on_device=available_on_device,
            available_on_virtualmachine=available_on_virtualmachine,
            l2vpn_id=l2vpn_id,
            l2vpn=l2vpn,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            vid__n=vid__n,
            vid__lte=vid__lte,
            vid__lt=vid__lt,
            vid__gte=vid__gte,
            vid__gt=vid__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            region_id__n=region_id__n,
            region__n=region__n,
            site_group_id__n=site_group_id__n,
            site_group__n=site_group__n,
            site_id__n=site_id__n,
            site__n=site__n,
            group_id__n=group_id__n,
            group__n=group__n,
            role_id__n=role_id__n,
            role__n=role__n,
            status__n=status__n,
            l2vpn_id__n=l2vpn_id__n,
            l2vpn__n=l2vpn__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamVlansList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlans_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        vid: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        region_id: Optional[StrictStr] = None,
        region: Optional[StrictStr] = None,
        site_group_id: Optional[StrictStr] = None,
        site_group: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        site: Optional[StrictStr] = None,
        group_id: Optional[StrictStr] = None,
        group: Optional[StrictStr] = None,
        role_id: Optional[StrictStr] = None,
        role: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        available_on_device: Optional[StrictStr] = None,
        available_on_virtualmachine: Optional[StrictStr] = None,
        l2vpn_id: Optional[StrictStr] = None,
        l2vpn: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        vid__n: Optional[StrictStr] = None,
        vid__lte: Optional[StrictStr] = None,
        vid__lt: Optional[StrictStr] = None,
        vid__gte: Optional[StrictStr] = None,
        vid__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        region_id__n: Optional[StrictStr] = None,
        region__n: Optional[StrictStr] = None,
        site_group_id__n: Optional[StrictStr] = None,
        site_group__n: Optional[StrictStr] = None,
        site_id__n: Optional[StrictStr] = None,
        site__n: Optional[StrictStr] = None,
        group_id__n: Optional[StrictStr] = None,
        group__n: Optional[StrictStr] = None,
        role_id__n: Optional[StrictStr] = None,
        role__n: Optional[StrictStr] = None,
        status__n: Optional[StrictStr] = None,
        l2vpn_id__n: Optional[StrictStr] = None,
        l2vpn__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlans_list

        

        :param id: 
        :type id: str
        :param vid: 
        :type vid: str
        :param name: 
        :type name: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param region_id: 
        :type region_id: str
        :param region: 
        :type region: str
        :param site_group_id: 
        :type site_group_id: str
        :param site_group: 
        :type site_group: str
        :param site_id: 
        :type site_id: str
        :param site: 
        :type site: str
        :param group_id: 
        :type group_id: str
        :param group: 
        :type group: str
        :param role_id: 
        :type role_id: str
        :param role: 
        :type role: str
        :param status: 
        :type status: str
        :param available_on_device: 
        :type available_on_device: str
        :param available_on_virtualmachine: 
        :type available_on_virtualmachine: str
        :param l2vpn_id: 
        :type l2vpn_id: str
        :param l2vpn: 
        :type l2vpn: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param vid__n: 
        :type vid__n: str
        :param vid__lte: 
        :type vid__lte: str
        :param vid__lt: 
        :type vid__lt: str
        :param vid__gte: 
        :type vid__gte: str
        :param vid__gt: 
        :type vid__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param region_id__n: 
        :type region_id__n: str
        :param region__n: 
        :type region__n: str
        :param site_group_id__n: 
        :type site_group_id__n: str
        :param site_group__n: 
        :type site_group__n: str
        :param site_id__n: 
        :type site_id__n: str
        :param site__n: 
        :type site__n: str
        :param group_id__n: 
        :type group_id__n: str
        :param group__n: 
        :type group__n: str
        :param role_id__n: 
        :type role_id__n: str
        :param role__n: 
        :type role__n: str
        :param status__n: 
        :type status__n: str
        :param l2vpn_id__n: 
        :type l2vpn_id__n: str
        :param l2vpn__n: 
        :type l2vpn__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_list_serialize(
            id=id,
            vid=vid,
            name=name,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            region_id=region_id,
            region=region,
            site_group_id=site_group_id,
            site_group=site_group,
            site_id=site_id,
            site=site,
            group_id=group_id,
            group=group,
            role_id=role_id,
            role=role,
            status=status,
            available_on_device=available_on_device,
            available_on_virtualmachine=available_on_virtualmachine,
            l2vpn_id=l2vpn_id,
            l2vpn=l2vpn,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            vid__n=vid__n,
            vid__lte=vid__lte,
            vid__lt=vid__lt,
            vid__gte=vid__gte,
            vid__gt=vid__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            region_id__n=region_id__n,
            region__n=region__n,
            site_group_id__n=site_group_id__n,
            site_group__n=site_group__n,
            site_id__n=site_id__n,
            site__n=site__n,
            group_id__n=group_id__n,
            group__n=group__n,
            role_id__n=role_id__n,
            role__n=role__n,
            status__n=status__n,
            l2vpn_id__n=l2vpn_id__n,
            l2vpn__n=l2vpn__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamVlansList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlans_list_serialize(
        self,
        id,
        vid,
        name,
        description,
        created,
        last_updated,
        q,
        tag,
        tenant_group_id,
        tenant_group,
        tenant_id,
        tenant,
        region_id,
        region,
        site_group_id,
        site_group,
        site_id,
        site,
        group_id,
        group,
        role_id,
        role,
        status,
        available_on_device,
        available_on_virtualmachine,
        l2vpn_id,
        l2vpn,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        vid__n,
        vid__lte,
        vid__lt,
        vid__gte,
        vid__gt,
        name__n,
        name__ic,
        name__nic,
        name__iew,
        name__niew,
        name__isw,
        name__nisw,
        name__ie,
        name__nie,
        name__empty,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        tenant_group_id__n,
        tenant_group__n,
        tenant_id__n,
        tenant__n,
        region_id__n,
        region__n,
        site_group_id__n,
        site_group__n,
        site_id__n,
        site__n,
        group_id__n,
        group__n,
        role_id__n,
        role__n,
        status__n,
        l2vpn_id__n,
        l2vpn__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if vid is not None:
            
            _query_params.append(('vid', vid))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tenant_group_id is not None:
            
            _query_params.append(('tenant_group_id', tenant_group_id))
            
        if tenant_group is not None:
            
            _query_params.append(('tenant_group', tenant_group))
            
        if tenant_id is not None:
            
            _query_params.append(('tenant_id', tenant_id))
            
        if tenant is not None:
            
            _query_params.append(('tenant', tenant))
            
        if region_id is not None:
            
            _query_params.append(('region_id', region_id))
            
        if region is not None:
            
            _query_params.append(('region', region))
            
        if site_group_id is not None:
            
            _query_params.append(('site_group_id', site_group_id))
            
        if site_group is not None:
            
            _query_params.append(('site_group', site_group))
            
        if site_id is not None:
            
            _query_params.append(('site_id', site_id))
            
        if site is not None:
            
            _query_params.append(('site', site))
            
        if group_id is not None:
            
            _query_params.append(('group_id', group_id))
            
        if group is not None:
            
            _query_params.append(('group', group))
            
        if role_id is not None:
            
            _query_params.append(('role_id', role_id))
            
        if role is not None:
            
            _query_params.append(('role', role))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if available_on_device is not None:
            
            _query_params.append(('available_on_device', available_on_device))
            
        if available_on_virtualmachine is not None:
            
            _query_params.append(('available_on_virtualmachine', available_on_virtualmachine))
            
        if l2vpn_id is not None:
            
            _query_params.append(('l2vpn_id', l2vpn_id))
            
        if l2vpn is not None:
            
            _query_params.append(('l2vpn', l2vpn))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if vid__n is not None:
            
            _query_params.append(('vid__n', vid__n))
            
        if vid__lte is not None:
            
            _query_params.append(('vid__lte', vid__lte))
            
        if vid__lt is not None:
            
            _query_params.append(('vid__lt', vid__lt))
            
        if vid__gte is not None:
            
            _query_params.append(('vid__gte', vid__gte))
            
        if vid__gt is not None:
            
            _query_params.append(('vid__gt', vid__gt))
            
        if name__n is not None:
            
            _query_params.append(('name__n', name__n))
            
        if name__ic is not None:
            
            _query_params.append(('name__ic', name__ic))
            
        if name__nic is not None:
            
            _query_params.append(('name__nic', name__nic))
            
        if name__iew is not None:
            
            _query_params.append(('name__iew', name__iew))
            
        if name__niew is not None:
            
            _query_params.append(('name__niew', name__niew))
            
        if name__isw is not None:
            
            _query_params.append(('name__isw', name__isw))
            
        if name__nisw is not None:
            
            _query_params.append(('name__nisw', name__nisw))
            
        if name__ie is not None:
            
            _query_params.append(('name__ie', name__ie))
            
        if name__nie is not None:
            
            _query_params.append(('name__nie', name__nie))
            
        if name__empty is not None:
            
            _query_params.append(('name__empty', name__empty))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if tenant_group_id__n is not None:
            
            _query_params.append(('tenant_group_id__n', tenant_group_id__n))
            
        if tenant_group__n is not None:
            
            _query_params.append(('tenant_group__n', tenant_group__n))
            
        if tenant_id__n is not None:
            
            _query_params.append(('tenant_id__n', tenant_id__n))
            
        if tenant__n is not None:
            
            _query_params.append(('tenant__n', tenant__n))
            
        if region_id__n is not None:
            
            _query_params.append(('region_id__n', region_id__n))
            
        if region__n is not None:
            
            _query_params.append(('region__n', region__n))
            
        if site_group_id__n is not None:
            
            _query_params.append(('site_group_id__n', site_group_id__n))
            
        if site_group__n is not None:
            
            _query_params.append(('site_group__n', site_group__n))
            
        if site_id__n is not None:
            
            _query_params.append(('site_id__n', site_id__n))
            
        if site__n is not None:
            
            _query_params.append(('site__n', site__n))
            
        if group_id__n is not None:
            
            _query_params.append(('group_id__n', group_id__n))
            
        if group__n is not None:
            
            _query_params.append(('group__n', group__n))
            
        if role_id__n is not None:
            
            _query_params.append(('role_id__n', role_id__n))
            
        if role__n is not None:
            
            _query_params.append(('role__n', role__n))
            
        if status__n is not None:
            
            _query_params.append(('status__n', status__n))
            
        if l2vpn_id__n is not None:
            
            _query_params.append(('l2vpn_id__n', l2vpn_id__n))
            
        if l2vpn__n is not None:
            
            _query_params.append(('l2vpn__n', l2vpn__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/vlans/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlans_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLAN:
        """ipam_vlans_partial_update

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_partial_update_serialize(
            id=id,
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlans_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLAN]:
        """ipam_vlans_partial_update

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_partial_update_serialize(
            id=id,
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlans_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlans_partial_update

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_partial_update_serialize(
            id=id,
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlans_partial_update_serialize(
        self,
        id,
        writable_vlan,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_vlan is not None:
            _body_params = writable_vlan


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/vlans/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlans_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLAN:
        """ipam_vlans_read

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlans_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLAN]:
        """ipam_vlans_read

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlans_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlans_read

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlans_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/vlans/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vlans_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VLAN:
        """ipam_vlans_update

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_update_serialize(
            id=id,
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vlans_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VLAN]:
        """ipam_vlans_update

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_update_serialize(
            id=id,
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vlans_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VLAN.")],
        writable_vlan: WritableVLAN,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vlans_update

        

        :param id: A unique integer value identifying this VLAN. (required)
        :type id: int
        :param writable_vlan: (required)
        :type writable_vlan: WritableVLAN
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vlans_update_serialize(
            id=id,
            writable_vlan=writable_vlan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VLAN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vlans_update_serialize(
        self,
        id,
        writable_vlan,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_vlan is not None:
            _body_params = writable_vlan


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/vlans/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vrfs_bulk_delete(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_vrfs_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vrfs_bulk_delete_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_vrfs_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vrfs_bulk_delete_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vrfs_bulk_delete

        

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_bulk_delete_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vrfs_bulk_delete_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/vrfs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vrfs_bulk_partial_update(
        self,
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VRF:
        """ipam_vrfs_bulk_partial_update

        

        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_bulk_partial_update_serialize(
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vrfs_bulk_partial_update_with_http_info(
        self,
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VRF]:
        """ipam_vrfs_bulk_partial_update

        

        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_bulk_partial_update_serialize(
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vrfs_bulk_partial_update_without_preload_content(
        self,
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vrfs_bulk_partial_update

        

        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_bulk_partial_update_serialize(
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vrfs_bulk_partial_update_serialize(
        self,
        writable_vrf,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_vrf is not None:
            _body_params = writable_vrf


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/vrfs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vrfs_bulk_update(
        self,
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VRF:
        """ipam_vrfs_bulk_update

        

        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_bulk_update_serialize(
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vrfs_bulk_update_with_http_info(
        self,
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VRF]:
        """ipam_vrfs_bulk_update

        

        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_bulk_update_serialize(
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vrfs_bulk_update_without_preload_content(
        self,
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vrfs_bulk_update

        

        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_bulk_update_serialize(
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vrfs_bulk_update_serialize(
        self,
        writable_vrf,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_vrf is not None:
            _body_params = writable_vrf


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/vrfs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vrfs_create(
        self,
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VRF:
        """ipam_vrfs_create

        

        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_create_serialize(
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vrfs_create_with_http_info(
        self,
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VRF]:
        """ipam_vrfs_create

        

        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_create_serialize(
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vrfs_create_without_preload_content(
        self,
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vrfs_create

        

        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_create_serialize(
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vrfs_create_serialize(
        self,
        writable_vrf,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_vrf is not None:
            _body_params = writable_vrf


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ipam/vrfs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vrfs_delete(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """ipam_vrfs_delete

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vrfs_delete_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """ipam_vrfs_delete

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vrfs_delete_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vrfs_delete

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vrfs_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/ipam/vrfs/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vrfs_list(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        rd: Optional[StrictStr] = None,
        enforce_unique: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        import_target_id: Optional[StrictStr] = None,
        import_target: Optional[StrictStr] = None,
        export_target_id: Optional[StrictStr] = None,
        export_target: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        rd__n: Optional[StrictStr] = None,
        rd__ic: Optional[StrictStr] = None,
        rd__nic: Optional[StrictStr] = None,
        rd__iew: Optional[StrictStr] = None,
        rd__niew: Optional[StrictStr] = None,
        rd__isw: Optional[StrictStr] = None,
        rd__nisw: Optional[StrictStr] = None,
        rd__ie: Optional[StrictStr] = None,
        rd__nie: Optional[StrictStr] = None,
        rd__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        import_target_id__n: Optional[StrictStr] = None,
        import_target__n: Optional[StrictStr] = None,
        export_target_id__n: Optional[StrictStr] = None,
        export_target__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IpamVrfsList200Response:
        """ipam_vrfs_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param rd: 
        :type rd: str
        :param enforce_unique: 
        :type enforce_unique: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param import_target_id: 
        :type import_target_id: str
        :param import_target: 
        :type import_target: str
        :param export_target_id: 
        :type export_target_id: str
        :param export_target: 
        :type export_target: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param rd__n: 
        :type rd__n: str
        :param rd__ic: 
        :type rd__ic: str
        :param rd__nic: 
        :type rd__nic: str
        :param rd__iew: 
        :type rd__iew: str
        :param rd__niew: 
        :type rd__niew: str
        :param rd__isw: 
        :type rd__isw: str
        :param rd__nisw: 
        :type rd__nisw: str
        :param rd__ie: 
        :type rd__ie: str
        :param rd__nie: 
        :type rd__nie: str
        :param rd__empty: 
        :type rd__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param import_target_id__n: 
        :type import_target_id__n: str
        :param import_target__n: 
        :type import_target__n: str
        :param export_target_id__n: 
        :type export_target_id__n: str
        :param export_target__n: 
        :type export_target__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_list_serialize(
            id=id,
            name=name,
            rd=rd,
            enforce_unique=enforce_unique,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            import_target_id=import_target_id,
            import_target=import_target,
            export_target_id=export_target_id,
            export_target=export_target,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            rd__n=rd__n,
            rd__ic=rd__ic,
            rd__nic=rd__nic,
            rd__iew=rd__iew,
            rd__niew=rd__niew,
            rd__isw=rd__isw,
            rd__nisw=rd__nisw,
            rd__ie=rd__ie,
            rd__nie=rd__nie,
            rd__empty=rd__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            import_target_id__n=import_target_id__n,
            import_target__n=import_target__n,
            export_target_id__n=export_target_id__n,
            export_target__n=export_target__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamVrfsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vrfs_list_with_http_info(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        rd: Optional[StrictStr] = None,
        enforce_unique: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        import_target_id: Optional[StrictStr] = None,
        import_target: Optional[StrictStr] = None,
        export_target_id: Optional[StrictStr] = None,
        export_target: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        rd__n: Optional[StrictStr] = None,
        rd__ic: Optional[StrictStr] = None,
        rd__nic: Optional[StrictStr] = None,
        rd__iew: Optional[StrictStr] = None,
        rd__niew: Optional[StrictStr] = None,
        rd__isw: Optional[StrictStr] = None,
        rd__nisw: Optional[StrictStr] = None,
        rd__ie: Optional[StrictStr] = None,
        rd__nie: Optional[StrictStr] = None,
        rd__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        import_target_id__n: Optional[StrictStr] = None,
        import_target__n: Optional[StrictStr] = None,
        export_target_id__n: Optional[StrictStr] = None,
        export_target__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IpamVrfsList200Response]:
        """ipam_vrfs_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param rd: 
        :type rd: str
        :param enforce_unique: 
        :type enforce_unique: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param import_target_id: 
        :type import_target_id: str
        :param import_target: 
        :type import_target: str
        :param export_target_id: 
        :type export_target_id: str
        :param export_target: 
        :type export_target: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param rd__n: 
        :type rd__n: str
        :param rd__ic: 
        :type rd__ic: str
        :param rd__nic: 
        :type rd__nic: str
        :param rd__iew: 
        :type rd__iew: str
        :param rd__niew: 
        :type rd__niew: str
        :param rd__isw: 
        :type rd__isw: str
        :param rd__nisw: 
        :type rd__nisw: str
        :param rd__ie: 
        :type rd__ie: str
        :param rd__nie: 
        :type rd__nie: str
        :param rd__empty: 
        :type rd__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param import_target_id__n: 
        :type import_target_id__n: str
        :param import_target__n: 
        :type import_target__n: str
        :param export_target_id__n: 
        :type export_target_id__n: str
        :param export_target__n: 
        :type export_target__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_list_serialize(
            id=id,
            name=name,
            rd=rd,
            enforce_unique=enforce_unique,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            import_target_id=import_target_id,
            import_target=import_target,
            export_target_id=export_target_id,
            export_target=export_target,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            rd__n=rd__n,
            rd__ic=rd__ic,
            rd__nic=rd__nic,
            rd__iew=rd__iew,
            rd__niew=rd__niew,
            rd__isw=rd__isw,
            rd__nisw=rd__nisw,
            rd__ie=rd__ie,
            rd__nie=rd__nie,
            rd__empty=rd__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            import_target_id__n=import_target_id__n,
            import_target__n=import_target__n,
            export_target_id__n=export_target_id__n,
            export_target__n=export_target__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamVrfsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vrfs_list_without_preload_content(
        self,
        id: Optional[StrictStr] = None,
        name: Optional[StrictStr] = None,
        rd: Optional[StrictStr] = None,
        enforce_unique: Optional[StrictStr] = None,
        description: Optional[StrictStr] = None,
        created: Optional[StrictStr] = None,
        last_updated: Optional[StrictStr] = None,
        q: Optional[StrictStr] = None,
        tag: Optional[StrictStr] = None,
        tenant_group_id: Optional[StrictStr] = None,
        tenant_group: Optional[StrictStr] = None,
        tenant_id: Optional[StrictStr] = None,
        tenant: Optional[StrictStr] = None,
        import_target_id: Optional[StrictStr] = None,
        import_target: Optional[StrictStr] = None,
        export_target_id: Optional[StrictStr] = None,
        export_target: Optional[StrictStr] = None,
        id__n: Optional[StrictStr] = None,
        id__lte: Optional[StrictStr] = None,
        id__lt: Optional[StrictStr] = None,
        id__gte: Optional[StrictStr] = None,
        id__gt: Optional[StrictStr] = None,
        name__n: Optional[StrictStr] = None,
        name__ic: Optional[StrictStr] = None,
        name__nic: Optional[StrictStr] = None,
        name__iew: Optional[StrictStr] = None,
        name__niew: Optional[StrictStr] = None,
        name__isw: Optional[StrictStr] = None,
        name__nisw: Optional[StrictStr] = None,
        name__ie: Optional[StrictStr] = None,
        name__nie: Optional[StrictStr] = None,
        name__empty: Optional[StrictStr] = None,
        rd__n: Optional[StrictStr] = None,
        rd__ic: Optional[StrictStr] = None,
        rd__nic: Optional[StrictStr] = None,
        rd__iew: Optional[StrictStr] = None,
        rd__niew: Optional[StrictStr] = None,
        rd__isw: Optional[StrictStr] = None,
        rd__nisw: Optional[StrictStr] = None,
        rd__ie: Optional[StrictStr] = None,
        rd__nie: Optional[StrictStr] = None,
        rd__empty: Optional[StrictStr] = None,
        description__n: Optional[StrictStr] = None,
        description__ic: Optional[StrictStr] = None,
        description__nic: Optional[StrictStr] = None,
        description__iew: Optional[StrictStr] = None,
        description__niew: Optional[StrictStr] = None,
        description__isw: Optional[StrictStr] = None,
        description__nisw: Optional[StrictStr] = None,
        description__ie: Optional[StrictStr] = None,
        description__nie: Optional[StrictStr] = None,
        description__empty: Optional[StrictStr] = None,
        created__n: Optional[StrictStr] = None,
        created__lte: Optional[StrictStr] = None,
        created__lt: Optional[StrictStr] = None,
        created__gte: Optional[StrictStr] = None,
        created__gt: Optional[StrictStr] = None,
        last_updated__n: Optional[StrictStr] = None,
        last_updated__lte: Optional[StrictStr] = None,
        last_updated__lt: Optional[StrictStr] = None,
        last_updated__gte: Optional[StrictStr] = None,
        last_updated__gt: Optional[StrictStr] = None,
        tag__n: Optional[StrictStr] = None,
        tenant_group_id__n: Optional[StrictStr] = None,
        tenant_group__n: Optional[StrictStr] = None,
        tenant_id__n: Optional[StrictStr] = None,
        tenant__n: Optional[StrictStr] = None,
        import_target_id__n: Optional[StrictStr] = None,
        import_target__n: Optional[StrictStr] = None,
        export_target_id__n: Optional[StrictStr] = None,
        export_target__n: Optional[StrictStr] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Which field to use when ordering the results.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results to return per page.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The initial index from which to return the results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vrfs_list

        

        :param id: 
        :type id: str
        :param name: 
        :type name: str
        :param rd: 
        :type rd: str
        :param enforce_unique: 
        :type enforce_unique: str
        :param description: 
        :type description: str
        :param created: 
        :type created: str
        :param last_updated: 
        :type last_updated: str
        :param q: 
        :type q: str
        :param tag: 
        :type tag: str
        :param tenant_group_id: 
        :type tenant_group_id: str
        :param tenant_group: 
        :type tenant_group: str
        :param tenant_id: 
        :type tenant_id: str
        :param tenant: 
        :type tenant: str
        :param import_target_id: 
        :type import_target_id: str
        :param import_target: 
        :type import_target: str
        :param export_target_id: 
        :type export_target_id: str
        :param export_target: 
        :type export_target: str
        :param id__n: 
        :type id__n: str
        :param id__lte: 
        :type id__lte: str
        :param id__lt: 
        :type id__lt: str
        :param id__gte: 
        :type id__gte: str
        :param id__gt: 
        :type id__gt: str
        :param name__n: 
        :type name__n: str
        :param name__ic: 
        :type name__ic: str
        :param name__nic: 
        :type name__nic: str
        :param name__iew: 
        :type name__iew: str
        :param name__niew: 
        :type name__niew: str
        :param name__isw: 
        :type name__isw: str
        :param name__nisw: 
        :type name__nisw: str
        :param name__ie: 
        :type name__ie: str
        :param name__nie: 
        :type name__nie: str
        :param name__empty: 
        :type name__empty: str
        :param rd__n: 
        :type rd__n: str
        :param rd__ic: 
        :type rd__ic: str
        :param rd__nic: 
        :type rd__nic: str
        :param rd__iew: 
        :type rd__iew: str
        :param rd__niew: 
        :type rd__niew: str
        :param rd__isw: 
        :type rd__isw: str
        :param rd__nisw: 
        :type rd__nisw: str
        :param rd__ie: 
        :type rd__ie: str
        :param rd__nie: 
        :type rd__nie: str
        :param rd__empty: 
        :type rd__empty: str
        :param description__n: 
        :type description__n: str
        :param description__ic: 
        :type description__ic: str
        :param description__nic: 
        :type description__nic: str
        :param description__iew: 
        :type description__iew: str
        :param description__niew: 
        :type description__niew: str
        :param description__isw: 
        :type description__isw: str
        :param description__nisw: 
        :type description__nisw: str
        :param description__ie: 
        :type description__ie: str
        :param description__nie: 
        :type description__nie: str
        :param description__empty: 
        :type description__empty: str
        :param created__n: 
        :type created__n: str
        :param created__lte: 
        :type created__lte: str
        :param created__lt: 
        :type created__lt: str
        :param created__gte: 
        :type created__gte: str
        :param created__gt: 
        :type created__gt: str
        :param last_updated__n: 
        :type last_updated__n: str
        :param last_updated__lte: 
        :type last_updated__lte: str
        :param last_updated__lt: 
        :type last_updated__lt: str
        :param last_updated__gte: 
        :type last_updated__gte: str
        :param last_updated__gt: 
        :type last_updated__gt: str
        :param tag__n: 
        :type tag__n: str
        :param tenant_group_id__n: 
        :type tenant_group_id__n: str
        :param tenant_group__n: 
        :type tenant_group__n: str
        :param tenant_id__n: 
        :type tenant_id__n: str
        :param tenant__n: 
        :type tenant__n: str
        :param import_target_id__n: 
        :type import_target_id__n: str
        :param import_target__n: 
        :type import_target__n: str
        :param export_target_id__n: 
        :type export_target_id__n: str
        :param export_target__n: 
        :type export_target__n: str
        :param ordering: Which field to use when ordering the results.
        :type ordering: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_list_serialize(
            id=id,
            name=name,
            rd=rd,
            enforce_unique=enforce_unique,
            description=description,
            created=created,
            last_updated=last_updated,
            q=q,
            tag=tag,
            tenant_group_id=tenant_group_id,
            tenant_group=tenant_group,
            tenant_id=tenant_id,
            tenant=tenant,
            import_target_id=import_target_id,
            import_target=import_target,
            export_target_id=export_target_id,
            export_target=export_target,
            id__n=id__n,
            id__lte=id__lte,
            id__lt=id__lt,
            id__gte=id__gte,
            id__gt=id__gt,
            name__n=name__n,
            name__ic=name__ic,
            name__nic=name__nic,
            name__iew=name__iew,
            name__niew=name__niew,
            name__isw=name__isw,
            name__nisw=name__nisw,
            name__ie=name__ie,
            name__nie=name__nie,
            name__empty=name__empty,
            rd__n=rd__n,
            rd__ic=rd__ic,
            rd__nic=rd__nic,
            rd__iew=rd__iew,
            rd__niew=rd__niew,
            rd__isw=rd__isw,
            rd__nisw=rd__nisw,
            rd__ie=rd__ie,
            rd__nie=rd__nie,
            rd__empty=rd__empty,
            description__n=description__n,
            description__ic=description__ic,
            description__nic=description__nic,
            description__iew=description__iew,
            description__niew=description__niew,
            description__isw=description__isw,
            description__nisw=description__nisw,
            description__ie=description__ie,
            description__nie=description__nie,
            description__empty=description__empty,
            created__n=created__n,
            created__lte=created__lte,
            created__lt=created__lt,
            created__gte=created__gte,
            created__gt=created__gt,
            last_updated__n=last_updated__n,
            last_updated__lte=last_updated__lte,
            last_updated__lt=last_updated__lt,
            last_updated__gte=last_updated__gte,
            last_updated__gt=last_updated__gt,
            tag__n=tag__n,
            tenant_group_id__n=tenant_group_id__n,
            tenant_group__n=tenant_group__n,
            tenant_id__n=tenant_id__n,
            tenant__n=tenant__n,
            import_target_id__n=import_target_id__n,
            import_target__n=import_target__n,
            export_target_id__n=export_target_id__n,
            export_target__n=export_target__n,
            ordering=ordering,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IpamVrfsList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vrfs_list_serialize(
        self,
        id,
        name,
        rd,
        enforce_unique,
        description,
        created,
        last_updated,
        q,
        tag,
        tenant_group_id,
        tenant_group,
        tenant_id,
        tenant,
        import_target_id,
        import_target,
        export_target_id,
        export_target,
        id__n,
        id__lte,
        id__lt,
        id__gte,
        id__gt,
        name__n,
        name__ic,
        name__nic,
        name__iew,
        name__niew,
        name__isw,
        name__nisw,
        name__ie,
        name__nie,
        name__empty,
        rd__n,
        rd__ic,
        rd__nic,
        rd__iew,
        rd__niew,
        rd__isw,
        rd__nisw,
        rd__ie,
        rd__nie,
        rd__empty,
        description__n,
        description__ic,
        description__nic,
        description__iew,
        description__niew,
        description__isw,
        description__nisw,
        description__ie,
        description__nie,
        description__empty,
        created__n,
        created__lte,
        created__lt,
        created__gte,
        created__gt,
        last_updated__n,
        last_updated__lte,
        last_updated__lt,
        last_updated__gte,
        last_updated__gt,
        tag__n,
        tenant_group_id__n,
        tenant_group__n,
        tenant_id__n,
        tenant__n,
        import_target_id__n,
        import_target__n,
        export_target_id__n,
        export_target__n,
        ordering,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if rd is not None:
            
            _query_params.append(('rd', rd))
            
        if enforce_unique is not None:
            
            _query_params.append(('enforce_unique', enforce_unique))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if created is not None:
            
            _query_params.append(('created', created))
            
        if last_updated is not None:
            
            _query_params.append(('last_updated', last_updated))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tenant_group_id is not None:
            
            _query_params.append(('tenant_group_id', tenant_group_id))
            
        if tenant_group is not None:
            
            _query_params.append(('tenant_group', tenant_group))
            
        if tenant_id is not None:
            
            _query_params.append(('tenant_id', tenant_id))
            
        if tenant is not None:
            
            _query_params.append(('tenant', tenant))
            
        if import_target_id is not None:
            
            _query_params.append(('import_target_id', import_target_id))
            
        if import_target is not None:
            
            _query_params.append(('import_target', import_target))
            
        if export_target_id is not None:
            
            _query_params.append(('export_target_id', export_target_id))
            
        if export_target is not None:
            
            _query_params.append(('export_target', export_target))
            
        if id__n is not None:
            
            _query_params.append(('id__n', id__n))
            
        if id__lte is not None:
            
            _query_params.append(('id__lte', id__lte))
            
        if id__lt is not None:
            
            _query_params.append(('id__lt', id__lt))
            
        if id__gte is not None:
            
            _query_params.append(('id__gte', id__gte))
            
        if id__gt is not None:
            
            _query_params.append(('id__gt', id__gt))
            
        if name__n is not None:
            
            _query_params.append(('name__n', name__n))
            
        if name__ic is not None:
            
            _query_params.append(('name__ic', name__ic))
            
        if name__nic is not None:
            
            _query_params.append(('name__nic', name__nic))
            
        if name__iew is not None:
            
            _query_params.append(('name__iew', name__iew))
            
        if name__niew is not None:
            
            _query_params.append(('name__niew', name__niew))
            
        if name__isw is not None:
            
            _query_params.append(('name__isw', name__isw))
            
        if name__nisw is not None:
            
            _query_params.append(('name__nisw', name__nisw))
            
        if name__ie is not None:
            
            _query_params.append(('name__ie', name__ie))
            
        if name__nie is not None:
            
            _query_params.append(('name__nie', name__nie))
            
        if name__empty is not None:
            
            _query_params.append(('name__empty', name__empty))
            
        if rd__n is not None:
            
            _query_params.append(('rd__n', rd__n))
            
        if rd__ic is not None:
            
            _query_params.append(('rd__ic', rd__ic))
            
        if rd__nic is not None:
            
            _query_params.append(('rd__nic', rd__nic))
            
        if rd__iew is not None:
            
            _query_params.append(('rd__iew', rd__iew))
            
        if rd__niew is not None:
            
            _query_params.append(('rd__niew', rd__niew))
            
        if rd__isw is not None:
            
            _query_params.append(('rd__isw', rd__isw))
            
        if rd__nisw is not None:
            
            _query_params.append(('rd__nisw', rd__nisw))
            
        if rd__ie is not None:
            
            _query_params.append(('rd__ie', rd__ie))
            
        if rd__nie is not None:
            
            _query_params.append(('rd__nie', rd__nie))
            
        if rd__empty is not None:
            
            _query_params.append(('rd__empty', rd__empty))
            
        if description__n is not None:
            
            _query_params.append(('description__n', description__n))
            
        if description__ic is not None:
            
            _query_params.append(('description__ic', description__ic))
            
        if description__nic is not None:
            
            _query_params.append(('description__nic', description__nic))
            
        if description__iew is not None:
            
            _query_params.append(('description__iew', description__iew))
            
        if description__niew is not None:
            
            _query_params.append(('description__niew', description__niew))
            
        if description__isw is not None:
            
            _query_params.append(('description__isw', description__isw))
            
        if description__nisw is not None:
            
            _query_params.append(('description__nisw', description__nisw))
            
        if description__ie is not None:
            
            _query_params.append(('description__ie', description__ie))
            
        if description__nie is not None:
            
            _query_params.append(('description__nie', description__nie))
            
        if description__empty is not None:
            
            _query_params.append(('description__empty', description__empty))
            
        if created__n is not None:
            
            _query_params.append(('created__n', created__n))
            
        if created__lte is not None:
            
            _query_params.append(('created__lte', created__lte))
            
        if created__lt is not None:
            
            _query_params.append(('created__lt', created__lt))
            
        if created__gte is not None:
            
            _query_params.append(('created__gte', created__gte))
            
        if created__gt is not None:
            
            _query_params.append(('created__gt', created__gt))
            
        if last_updated__n is not None:
            
            _query_params.append(('last_updated__n', last_updated__n))
            
        if last_updated__lte is not None:
            
            _query_params.append(('last_updated__lte', last_updated__lte))
            
        if last_updated__lt is not None:
            
            _query_params.append(('last_updated__lt', last_updated__lt))
            
        if last_updated__gte is not None:
            
            _query_params.append(('last_updated__gte', last_updated__gte))
            
        if last_updated__gt is not None:
            
            _query_params.append(('last_updated__gt', last_updated__gt))
            
        if tag__n is not None:
            
            _query_params.append(('tag__n', tag__n))
            
        if tenant_group_id__n is not None:
            
            _query_params.append(('tenant_group_id__n', tenant_group_id__n))
            
        if tenant_group__n is not None:
            
            _query_params.append(('tenant_group__n', tenant_group__n))
            
        if tenant_id__n is not None:
            
            _query_params.append(('tenant_id__n', tenant_id__n))
            
        if tenant__n is not None:
            
            _query_params.append(('tenant__n', tenant__n))
            
        if import_target_id__n is not None:
            
            _query_params.append(('import_target_id__n', import_target_id__n))
            
        if import_target__n is not None:
            
            _query_params.append(('import_target__n', import_target__n))
            
        if export_target_id__n is not None:
            
            _query_params.append(('export_target_id__n', export_target_id__n))
            
        if export_target__n is not None:
            
            _query_params.append(('export_target__n', export_target__n))
            
        if ordering is not None:
            
            _query_params.append(('ordering', ordering))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/vrfs/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vrfs_partial_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VRF:
        """ipam_vrfs_partial_update

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_partial_update_serialize(
            id=id,
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vrfs_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VRF]:
        """ipam_vrfs_partial_update

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_partial_update_serialize(
            id=id,
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vrfs_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vrfs_partial_update

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_partial_update_serialize(
            id=id,
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vrfs_partial_update_serialize(
        self,
        id,
        writable_vrf,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_vrf is not None:
            _body_params = writable_vrf


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/ipam/vrfs/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vrfs_read(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VRF:
        """ipam_vrfs_read

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vrfs_read_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VRF]:
        """ipam_vrfs_read

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vrfs_read_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vrfs_read

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_read_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vrfs_read_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ipam/vrfs/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ipam_vrfs_update(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VRF:
        """ipam_vrfs_update

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_update_serialize(
            id=id,
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ipam_vrfs_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VRF]:
        """ipam_vrfs_update

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_update_serialize(
            id=id,
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ipam_vrfs_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="A unique integer value identifying this VRF.")],
        writable_vrf: WritableVRF,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ipam_vrfs_update

        

        :param id: A unique integer value identifying this VRF. (required)
        :type id: int
        :param writable_vrf: (required)
        :type writable_vrf: WritableVRF
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ipam_vrfs_update_serialize(
            id=id,
            writable_vrf=writable_vrf,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VRF",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ipam_vrfs_update_serialize(
        self,
        id,
        writable_vrf,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if writable_vrf is not None:
            _body_params = writable_vrf


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/ipam/vrfs/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


