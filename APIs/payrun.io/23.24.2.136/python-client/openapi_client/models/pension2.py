# coding: utf-8

"""
    PayRun.IO

    Open, scableable, transparent payroll API.

    The version of the OpenAPI document: 23.24.2.136
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.pensionable_pay_codes import PensionablePayCodes
from openapi_client.models.qualifying_pay_codes import QualifyingPayCodes
from typing import Optional, Set
from typing_extensions import Self

class Pension2(BaseModel):
    """
    Pension2
    """ # noqa: E501
    ae_compatible: Optional[StrictBool] = Field(default=None, description="The pensions' a e compatible", alias="AECompatible")
    certification: Optional[StrictStr] = Field(default=None, description="The pensions' certification", alias="Certification")
    code: Optional[StrictStr] = Field(default=None, description="The pensions' code", alias="Code")
    contribution_deduction_day: Optional[StrictInt] = Field(default=None, description="The pensions' contribution deduction day", alias="ContributionDeductionDay")
    effective_date: Optional[date] = Field(default=None, description="The pensions' effective date", alias="EffectiveDate")
    employee_contribution_cash: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The pensions' employee contribution cash", alias="EmployeeContributionCash")
    employee_contribution_percent: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The pensions' employee contribution percent", alias="EmployeeContributionPercent")
    employer_contribution_cash: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The pensions' employer contribution cash", alias="EmployerContributionCash")
    employer_contribution_percent: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The pensions' employer contribution percent", alias="EmployerContributionPercent")
    employer_ni_saving: Optional[StrictBool] = Field(default=None, description="The pensions' employer ni saving", alias="EmployerNiSaving")
    employer_ni_saving_percentage: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The pensions' employer ni saving percentage", alias="EmployerNiSavingPercentage")
    group: Optional[StrictStr] = Field(default=None, description="The pensions' group", alias="Group")
    lower_threshold: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The pensions' lower threshold", alias="LowerThreshold")
    meta_data: Optional[Dict[str, Any]] = Field(default=None, description="The pensions' meta data", alias="MetaData")
    next_revision_date: Optional[date] = Field(default=None, description="The pensions' next revision date", alias="NextRevisionDate")
    pensionable_pay_codes: Optional[PensionablePayCodes] = Field(default=None, alias="PensionablePayCodes")
    pro_rata_method: Optional[StrictStr] = Field(default=None, description="The pensions' pro rata method", alias="ProRataMethod")
    provider_employer_ref: Optional[StrictStr] = Field(default=None, description="The pensions' provider employer ref", alias="ProviderEmployerRef")
    provider_name: Optional[StrictStr] = Field(default=None, description="The pensions' provider name", alias="ProviderName")
    qualifying_pay_codes: Optional[QualifyingPayCodes] = Field(default=None, alias="QualifyingPayCodes")
    ras_rounding_override: Optional[StrictStr] = Field(default=None, description="The pensions' ras rounding override", alias="RasRoundingOverride")
    revision: Optional[StrictInt] = Field(default=None, description="The pensions' revision", alias="Revision")
    rounding_option: Optional[StrictStr] = Field(default=None, description="The pensions' rounding option", alias="RoundingOption")
    salary_sacrifice: Optional[StrictBool] = Field(default=None, description="The pensions' salary sacrifice", alias="SalarySacrifice")
    scheme_name: Optional[StrictStr] = Field(default=None, description="The pensions' scheme name", alias="SchemeName")
    sub_group: Optional[StrictStr] = Field(default=None, description="The pensions' sub group", alias="SubGroup")
    taxation_method: Optional[StrictStr] = Field(default=None, description="The pensions' taxation method", alias="TaxationMethod")
    upper_threshold: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The pensions' upper threshold", alias="UpperThreshold")
    use_ae_thresholds: Optional[StrictBool] = Field(default=None, description="The pensions' use a e thresholds", alias="UseAEThresholds")
    __properties: ClassVar[List[str]] = ["AECompatible", "Certification", "Code", "ContributionDeductionDay", "EffectiveDate", "EmployeeContributionCash", "EmployeeContributionPercent", "EmployerContributionCash", "EmployerContributionPercent", "EmployerNiSaving", "EmployerNiSavingPercentage", "Group", "LowerThreshold", "MetaData", "NextRevisionDate", "PensionablePayCodes", "ProRataMethod", "ProviderEmployerRef", "ProviderName", "QualifyingPayCodes", "RasRoundingOverride", "Revision", "RoundingOption", "SalarySacrifice", "SchemeName", "SubGroup", "TaxationMethod", "UpperThreshold", "UseAEThresholds"]

    @field_validator('certification')
    def certification_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NotSet', 'Set1', 'Set2', 'Set3']):
            raise ValueError("must be one of enum values ('NotSet', 'Set1', 'Set2', 'Set3')")
        return value

    @field_validator('pro_rata_method')
    def pro_rata_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NotSet', 'Annual260Days', 'Annual365Days', 'AnnualQualifyingDays', 'DaysPerCalendarMonth', 'DaysPerTaxPeriod', 'WorkingDaysPerCalendarMonth', 'WeekDaysPerCalendarMonth']):
            raise ValueError("must be one of enum values ('NotSet', 'Annual260Days', 'Annual365Days', 'AnnualQualifyingDays', 'DaysPerCalendarMonth', 'DaysPerTaxPeriod', 'WorkingDaysPerCalendarMonth', 'WeekDaysPerCalendarMonth')")
        return value

    @field_validator('ras_rounding_override')
    def ras_rounding_override_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NotSet', 'PennyUp', 'PennyDown', 'Bankers', 'FiveUp', 'FiveDown', 'Floor', 'Ceiling']):
            raise ValueError("must be one of enum values ('NotSet', 'PennyUp', 'PennyDown', 'Bankers', 'FiveUp', 'FiveDown', 'Floor', 'Ceiling')")
        return value

    @field_validator('rounding_option')
    def rounding_option_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NotSet', 'PennyUp', 'PennyDown', 'Bankers', 'FiveUp', 'FiveDown', 'Floor', 'Ceiling']):
            raise ValueError("must be one of enum values ('NotSet', 'PennyUp', 'PennyDown', 'Bankers', 'FiveUp', 'FiveDown', 'Floor', 'Ceiling')")
        return value

    @field_validator('taxation_method')
    def taxation_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NotSet', 'NetBased', 'ReliefAtSource', 'TaxReliefExcluded']):
            raise ValueError("must be one of enum values ('NotSet', 'NetBased', 'ReliefAtSource', 'TaxReliefExcluded')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Pension2 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of pensionable_pay_codes
        if self.pensionable_pay_codes:
            _dict['PensionablePayCodes'] = self.pensionable_pay_codes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of qualifying_pay_codes
        if self.qualifying_pay_codes:
            _dict['QualifyingPayCodes'] = self.qualifying_pay_codes.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Pension2 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "AECompatible": obj.get("AECompatible"),
            "Certification": obj.get("Certification"),
            "Code": obj.get("Code"),
            "ContributionDeductionDay": obj.get("ContributionDeductionDay"),
            "EffectiveDate": obj.get("EffectiveDate"),
            "EmployeeContributionCash": obj.get("EmployeeContributionCash"),
            "EmployeeContributionPercent": obj.get("EmployeeContributionPercent"),
            "EmployerContributionCash": obj.get("EmployerContributionCash"),
            "EmployerContributionPercent": obj.get("EmployerContributionPercent"),
            "EmployerNiSaving": obj.get("EmployerNiSaving"),
            "EmployerNiSavingPercentage": obj.get("EmployerNiSavingPercentage"),
            "Group": obj.get("Group"),
            "LowerThreshold": obj.get("LowerThreshold"),
            "MetaData": obj.get("MetaData"),
            "NextRevisionDate": obj.get("NextRevisionDate"),
            "PensionablePayCodes": PensionablePayCodes.from_dict(obj["PensionablePayCodes"]) if obj.get("PensionablePayCodes") is not None else None,
            "ProRataMethod": obj.get("ProRataMethod"),
            "ProviderEmployerRef": obj.get("ProviderEmployerRef"),
            "ProviderName": obj.get("ProviderName"),
            "QualifyingPayCodes": QualifyingPayCodes.from_dict(obj["QualifyingPayCodes"]) if obj.get("QualifyingPayCodes") is not None else None,
            "RasRoundingOverride": obj.get("RasRoundingOverride"),
            "Revision": obj.get("Revision"),
            "RoundingOption": obj.get("RoundingOption"),
            "SalarySacrifice": obj.get("SalarySacrifice"),
            "SchemeName": obj.get("SchemeName"),
            "SubGroup": obj.get("SubGroup"),
            "TaxationMethod": obj.get("TaxationMethod"),
            "UpperThreshold": obj.get("UpperThreshold"),
            "UseAEThresholds": obj.get("UseAEThresholds")
        })
        return _obj


