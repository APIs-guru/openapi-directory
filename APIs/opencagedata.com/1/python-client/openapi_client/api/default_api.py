# coding: utf-8

"""
    OpenCage Geocoder

    Worldwide forward and reverse geocoding

    The version of the OpenAPI document: 1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.response import Response

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def vversion_format_get(
        self,
        version: Annotated[StrictInt, Field(description="API version.")],
        format: Annotated[StrictStr, Field(description="format of the response. One of 'json', 'xml' or 'map'.")],
        q: Annotated[StrictStr, Field(description="string or lat,lng to be geocoded.")],
        key: Annotated[StrictStr, Field(description="an application key.")],
        abbrv: Annotated[Optional[StrictBool], Field(description="when true we attempt to abbreviate the formatted field of results.")] = None,
        address_only: Annotated[Optional[StrictBool], Field(description="when true we include only address details in the formatted field of results.")] = None,
        add_request: Annotated[Optional[StrictBool], Field(description="if true the request is included in the response.")] = None,
        bounds: Annotated[Optional[StrictStr], Field(description="four coordinate points forming the south-west and north-east corners of a bounding box (min long, min lat, max long, max lat).")] = None,
        countrycode: Annotated[Optional[StrictStr], Field(description="two letter code ISO 3166-1 Alpha 2 code to limit results to that country.")] = None,
        jsonp: Annotated[Optional[StrictStr], Field(description="wraps the returned JSON with a function name.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="an IETF format language code (ex: 'es' or 'pt-BR').")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="maximum number of results to return. Default is 10. Maximum is 100.")] = None,
        min_confidence: Annotated[Optional[StrictInt], Field(description="integer from 1-10. Only results with at least this confidence are returned.")] = None,
        no_annotations: Annotated[Optional[StrictBool], Field(description="when true annotations are not added to results.")] = None,
        no_dedupe: Annotated[Optional[StrictBool], Field(description="when true results are not deduplicated.")] = None,
        no_record: Annotated[Optional[StrictBool], Field(description="when true query content is not logged.")] = None,
        pretty: Annotated[Optional[StrictBool], Field(description="when true results are pretty printed. Useful for debugging.")] = None,
        proximity: Annotated[Optional[StrictStr], Field(description="lat,lng to bias results.")] = None,
        roadinfo: Annotated[Optional[StrictBool], Field(description="match nearest road, include roadinfo annotation")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Response:
        """vversion_format_get

        geocode a query

        :param version: API version. (required)
        :type version: int
        :param format: format of the response. One of 'json', 'xml' or 'map'. (required)
        :type format: str
        :param q: string or lat,lng to be geocoded. (required)
        :type q: str
        :param key: an application key. (required)
        :type key: str
        :param abbrv: when true we attempt to abbreviate the formatted field of results.
        :type abbrv: bool
        :param address_only: when true we include only address details in the formatted field of results.
        :type address_only: bool
        :param add_request: if true the request is included in the response.
        :type add_request: bool
        :param bounds: four coordinate points forming the south-west and north-east corners of a bounding box (min long, min lat, max long, max lat).
        :type bounds: str
        :param countrycode: two letter code ISO 3166-1 Alpha 2 code to limit results to that country.
        :type countrycode: str
        :param jsonp: wraps the returned JSON with a function name.
        :type jsonp: str
        :param language: an IETF format language code (ex: 'es' or 'pt-BR').
        :type language: str
        :param limit: maximum number of results to return. Default is 10. Maximum is 100.
        :type limit: int
        :param min_confidence: integer from 1-10. Only results with at least this confidence are returned.
        :type min_confidence: int
        :param no_annotations: when true annotations are not added to results.
        :type no_annotations: bool
        :param no_dedupe: when true results are not deduplicated.
        :type no_dedupe: bool
        :param no_record: when true query content is not logged.
        :type no_record: bool
        :param pretty: when true results are pretty printed. Useful for debugging.
        :type pretty: bool
        :param proximity: lat,lng to bias results.
        :type proximity: str
        :param roadinfo: match nearest road, include roadinfo annotation
        :type roadinfo: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vversion_format_get_serialize(
            version=version,
            format=format,
            q=q,
            key=key,
            abbrv=abbrv,
            address_only=address_only,
            add_request=add_request,
            bounds=bounds,
            countrycode=countrycode,
            jsonp=jsonp,
            language=language,
            limit=limit,
            min_confidence=min_confidence,
            no_annotations=no_annotations,
            no_dedupe=no_dedupe,
            no_record=no_record,
            pretty=pretty,
            proximity=proximity,
            roadinfo=roadinfo,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Response",
            '400': "Response",
            '401': "Response",
            '402': "Response",
            '403': "Response",
            '404': "Response",
            '405': "Response",
            '408': "Response",
            '410': "Response",
            '426': "Response",
            '429': "Response",
            '503': "Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def vversion_format_get_with_http_info(
        self,
        version: Annotated[StrictInt, Field(description="API version.")],
        format: Annotated[StrictStr, Field(description="format of the response. One of 'json', 'xml' or 'map'.")],
        q: Annotated[StrictStr, Field(description="string or lat,lng to be geocoded.")],
        key: Annotated[StrictStr, Field(description="an application key.")],
        abbrv: Annotated[Optional[StrictBool], Field(description="when true we attempt to abbreviate the formatted field of results.")] = None,
        address_only: Annotated[Optional[StrictBool], Field(description="when true we include only address details in the formatted field of results.")] = None,
        add_request: Annotated[Optional[StrictBool], Field(description="if true the request is included in the response.")] = None,
        bounds: Annotated[Optional[StrictStr], Field(description="four coordinate points forming the south-west and north-east corners of a bounding box (min long, min lat, max long, max lat).")] = None,
        countrycode: Annotated[Optional[StrictStr], Field(description="two letter code ISO 3166-1 Alpha 2 code to limit results to that country.")] = None,
        jsonp: Annotated[Optional[StrictStr], Field(description="wraps the returned JSON with a function name.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="an IETF format language code (ex: 'es' or 'pt-BR').")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="maximum number of results to return. Default is 10. Maximum is 100.")] = None,
        min_confidence: Annotated[Optional[StrictInt], Field(description="integer from 1-10. Only results with at least this confidence are returned.")] = None,
        no_annotations: Annotated[Optional[StrictBool], Field(description="when true annotations are not added to results.")] = None,
        no_dedupe: Annotated[Optional[StrictBool], Field(description="when true results are not deduplicated.")] = None,
        no_record: Annotated[Optional[StrictBool], Field(description="when true query content is not logged.")] = None,
        pretty: Annotated[Optional[StrictBool], Field(description="when true results are pretty printed. Useful for debugging.")] = None,
        proximity: Annotated[Optional[StrictStr], Field(description="lat,lng to bias results.")] = None,
        roadinfo: Annotated[Optional[StrictBool], Field(description="match nearest road, include roadinfo annotation")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Response]:
        """vversion_format_get

        geocode a query

        :param version: API version. (required)
        :type version: int
        :param format: format of the response. One of 'json', 'xml' or 'map'. (required)
        :type format: str
        :param q: string or lat,lng to be geocoded. (required)
        :type q: str
        :param key: an application key. (required)
        :type key: str
        :param abbrv: when true we attempt to abbreviate the formatted field of results.
        :type abbrv: bool
        :param address_only: when true we include only address details in the formatted field of results.
        :type address_only: bool
        :param add_request: if true the request is included in the response.
        :type add_request: bool
        :param bounds: four coordinate points forming the south-west and north-east corners of a bounding box (min long, min lat, max long, max lat).
        :type bounds: str
        :param countrycode: two letter code ISO 3166-1 Alpha 2 code to limit results to that country.
        :type countrycode: str
        :param jsonp: wraps the returned JSON with a function name.
        :type jsonp: str
        :param language: an IETF format language code (ex: 'es' or 'pt-BR').
        :type language: str
        :param limit: maximum number of results to return. Default is 10. Maximum is 100.
        :type limit: int
        :param min_confidence: integer from 1-10. Only results with at least this confidence are returned.
        :type min_confidence: int
        :param no_annotations: when true annotations are not added to results.
        :type no_annotations: bool
        :param no_dedupe: when true results are not deduplicated.
        :type no_dedupe: bool
        :param no_record: when true query content is not logged.
        :type no_record: bool
        :param pretty: when true results are pretty printed. Useful for debugging.
        :type pretty: bool
        :param proximity: lat,lng to bias results.
        :type proximity: str
        :param roadinfo: match nearest road, include roadinfo annotation
        :type roadinfo: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vversion_format_get_serialize(
            version=version,
            format=format,
            q=q,
            key=key,
            abbrv=abbrv,
            address_only=address_only,
            add_request=add_request,
            bounds=bounds,
            countrycode=countrycode,
            jsonp=jsonp,
            language=language,
            limit=limit,
            min_confidence=min_confidence,
            no_annotations=no_annotations,
            no_dedupe=no_dedupe,
            no_record=no_record,
            pretty=pretty,
            proximity=proximity,
            roadinfo=roadinfo,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Response",
            '400': "Response",
            '401': "Response",
            '402': "Response",
            '403': "Response",
            '404': "Response",
            '405': "Response",
            '408': "Response",
            '410': "Response",
            '426': "Response",
            '429': "Response",
            '503': "Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def vversion_format_get_without_preload_content(
        self,
        version: Annotated[StrictInt, Field(description="API version.")],
        format: Annotated[StrictStr, Field(description="format of the response. One of 'json', 'xml' or 'map'.")],
        q: Annotated[StrictStr, Field(description="string or lat,lng to be geocoded.")],
        key: Annotated[StrictStr, Field(description="an application key.")],
        abbrv: Annotated[Optional[StrictBool], Field(description="when true we attempt to abbreviate the formatted field of results.")] = None,
        address_only: Annotated[Optional[StrictBool], Field(description="when true we include only address details in the formatted field of results.")] = None,
        add_request: Annotated[Optional[StrictBool], Field(description="if true the request is included in the response.")] = None,
        bounds: Annotated[Optional[StrictStr], Field(description="four coordinate points forming the south-west and north-east corners of a bounding box (min long, min lat, max long, max lat).")] = None,
        countrycode: Annotated[Optional[StrictStr], Field(description="two letter code ISO 3166-1 Alpha 2 code to limit results to that country.")] = None,
        jsonp: Annotated[Optional[StrictStr], Field(description="wraps the returned JSON with a function name.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="an IETF format language code (ex: 'es' or 'pt-BR').")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="maximum number of results to return. Default is 10. Maximum is 100.")] = None,
        min_confidence: Annotated[Optional[StrictInt], Field(description="integer from 1-10. Only results with at least this confidence are returned.")] = None,
        no_annotations: Annotated[Optional[StrictBool], Field(description="when true annotations are not added to results.")] = None,
        no_dedupe: Annotated[Optional[StrictBool], Field(description="when true results are not deduplicated.")] = None,
        no_record: Annotated[Optional[StrictBool], Field(description="when true query content is not logged.")] = None,
        pretty: Annotated[Optional[StrictBool], Field(description="when true results are pretty printed. Useful for debugging.")] = None,
        proximity: Annotated[Optional[StrictStr], Field(description="lat,lng to bias results.")] = None,
        roadinfo: Annotated[Optional[StrictBool], Field(description="match nearest road, include roadinfo annotation")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """vversion_format_get

        geocode a query

        :param version: API version. (required)
        :type version: int
        :param format: format of the response. One of 'json', 'xml' or 'map'. (required)
        :type format: str
        :param q: string or lat,lng to be geocoded. (required)
        :type q: str
        :param key: an application key. (required)
        :type key: str
        :param abbrv: when true we attempt to abbreviate the formatted field of results.
        :type abbrv: bool
        :param address_only: when true we include only address details in the formatted field of results.
        :type address_only: bool
        :param add_request: if true the request is included in the response.
        :type add_request: bool
        :param bounds: four coordinate points forming the south-west and north-east corners of a bounding box (min long, min lat, max long, max lat).
        :type bounds: str
        :param countrycode: two letter code ISO 3166-1 Alpha 2 code to limit results to that country.
        :type countrycode: str
        :param jsonp: wraps the returned JSON with a function name.
        :type jsonp: str
        :param language: an IETF format language code (ex: 'es' or 'pt-BR').
        :type language: str
        :param limit: maximum number of results to return. Default is 10. Maximum is 100.
        :type limit: int
        :param min_confidence: integer from 1-10. Only results with at least this confidence are returned.
        :type min_confidence: int
        :param no_annotations: when true annotations are not added to results.
        :type no_annotations: bool
        :param no_dedupe: when true results are not deduplicated.
        :type no_dedupe: bool
        :param no_record: when true query content is not logged.
        :type no_record: bool
        :param pretty: when true results are pretty printed. Useful for debugging.
        :type pretty: bool
        :param proximity: lat,lng to bias results.
        :type proximity: str
        :param roadinfo: match nearest road, include roadinfo annotation
        :type roadinfo: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._vversion_format_get_serialize(
            version=version,
            format=format,
            q=q,
            key=key,
            abbrv=abbrv,
            address_only=address_only,
            add_request=add_request,
            bounds=bounds,
            countrycode=countrycode,
            jsonp=jsonp,
            language=language,
            limit=limit,
            min_confidence=min_confidence,
            no_annotations=no_annotations,
            no_dedupe=no_dedupe,
            no_record=no_record,
            pretty=pretty,
            proximity=proximity,
            roadinfo=roadinfo,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Response",
            '400': "Response",
            '401': "Response",
            '402': "Response",
            '403': "Response",
            '404': "Response",
            '405': "Response",
            '408': "Response",
            '410': "Response",
            '426': "Response",
            '429': "Response",
            '503': "Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _vversion_format_get_serialize(
        self,
        version,
        format,
        q,
        key,
        abbrv,
        address_only,
        add_request,
        bounds,
        countrycode,
        jsonp,
        language,
        limit,
        min_confidence,
        no_annotations,
        no_dedupe,
        no_record,
        pretty,
        proximity,
        roadinfo,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        if format is not None:
            _path_params['format'] = format
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if abbrv is not None:
            
            _query_params.append(('abbrv', abbrv))
            
        if address_only is not None:
            
            _query_params.append(('address_only', address_only))
            
        if add_request is not None:
            
            _query_params.append(('add_request', add_request))
            
        if bounds is not None:
            
            _query_params.append(('bounds', bounds))
            
        if countrycode is not None:
            
            _query_params.append(('countrycode', countrycode))
            
        if jsonp is not None:
            
            _query_params.append(('jsonp', jsonp))
            
        if language is not None:
            
            _query_params.append(('language', language))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if min_confidence is not None:
            
            _query_params.append(('min_confidence', min_confidence))
            
        if no_annotations is not None:
            
            _query_params.append(('no_annotations', no_annotations))
            
        if no_dedupe is not None:
            
            _query_params.append(('no_dedupe', no_dedupe))
            
        if no_record is not None:
            
            _query_params.append(('no_record', no_record))
            
        if pretty is not None:
            
            _query_params.append(('pretty', pretty))
            
        if proximity is not None:
            
            _query_params.append(('proximity', proximity))
            
        if roadinfo is not None:
            
            _query_params.append(('roadinfo', roadinfo))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/html'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v{version}/{format}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


