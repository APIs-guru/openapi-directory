# coding: utf-8

"""
    LanguageTool API

    Check texts for style and grammar issues with <a href='https://languagetool.org'>LanguageTool</a>. Please consider the following default limitations:<ul><li>your daily request limit depending on <a href='https://languagetool.org/editor/settings/access-tokens'>your plan</a> <li>maximum number of requests per minute: 20 (free) / 80 (Premium) <li>maximum number of characters per minute: 75,000 (free) / 300,000 (Premium) <li>maximum number of characters per request: 20,000 (free) / 60,000 (Premium) <li>for the free version, also consider the <a href='https://dev.languagetool.org/public-http-api'>limitations documented here</a> <li><b>Note:</b> any parameters or outputs not part of this documentation are internal and must not be relied on</ul> Need more generous limits? Just <a href='https://languagetool.org/proofreading-api'>contact us</a>.

    The version of the OpenAPI document: 1.1.2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from openapi_client.models.check_post200_response import CheckPost200Response
from openapi_client.models.languages_get200_response_inner import LanguagesGet200ResponseInner
from openapi_client.models.words_add_post200_response import WordsAddPost200Response
from openapi_client.models.words_delete_post200_response import WordsDeletePost200Response
from openapi_client.models.words_get200_response import WordsGet200Response

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def check_post(
        self,
        language: Annotated[StrictStr, Field(description="A language code like `en-US`, `de-DE`, `fr`, or `auto` to guess the language automatically (see `preferredVariants` below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. `en-GB` instead of just `en`.")],
        text: Annotated[Optional[StrictStr], Field(description="The text to be checked. This or 'data' is required.")] = None,
        data: Annotated[Optional[StrictStr], Field(description="The text to be checked, given as a JSON document that specifies what's text and what's markup. This or 'text' is required. Markup will be ignored when looking for errors. Example text: <pre>A &lt;b>test&lt;/b></pre>JSON for the example text: <pre>{\\\"annotation\\\":[  {\\\"text\\\": \\\"A \\\"},  {\\\"markup\\\": \\\"&lt;b>\\\"},  {\\\"text\\\": \\\"test\\\"},  {\\\"markup\\\": \\\"&lt;/b>\\\"} ]}</pre> <p>If you have markup that should be interpreted as whitespace, like <tt>&lt;p&gt;</tt> in HTML, you can have it interpreted like this: <pre>{\\\"markup\\\": \\\"&lt;p&gt;\\\", \\\"interpretAs\\\": \\\"\\\\n\\\\n\\\"}</pre><p>The 'data' feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set to get Premium API access: Your username/email as used to log in at languagetool.org.")] = None,
        api_key: Annotated[Optional[StrictStr], Field(description="Set to get Premium API access: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>your API key</a>")] = None,
        dicts: Annotated[Optional[StrictStr], Field(description="Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset")] = None,
        mother_tongue: Annotated[Optional[StrictStr], Field(description="A language code of the user's native language, enabling false friends checks for some language pairs.")] = None,
        preferred_variants: Annotated[Optional[StrictStr], Field(description="Comma-separated list of preferred language variants. The language detector used with `language=auto` can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like `en-GB` and `de-AT`. Only available with `language=auto`. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just `en` or `de`.")] = None,
        enabled_rules: Annotated[Optional[StrictStr], Field(description="IDs of rules to be enabled, comma-separated")] = None,
        disabled_rules: Annotated[Optional[StrictStr], Field(description="IDs of rules to be disabled, comma-separated")] = None,
        enabled_categories: Annotated[Optional[StrictStr], Field(description="IDs of categories to be enabled, comma-separated")] = None,
        disabled_categories: Annotated[Optional[StrictStr], Field(description="IDs of categories to be disabled, comma-separated")] = None,
        enabled_only: Annotated[Optional[StrictBool], Field(description="If true, only the rules and categories whose IDs are specified with `enabledRules` or `enabledCategories` are enabled.")] = None,
        level: Annotated[Optional[StrictStr], Field(description="If set to `picky`, additional rules will be activated, i.e. rules that you might only find useful when checking formal text.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CheckPost200Response:
        """Check a text

        The main feature - check a text with LanguageTool for possible style and grammar issues.

        :param language: A language code like `en-US`, `de-DE`, `fr`, or `auto` to guess the language automatically (see `preferredVariants` below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. `en-GB` instead of just `en`. (required)
        :type language: str
        :param text: The text to be checked. This or 'data' is required.
        :type text: str
        :param data: The text to be checked, given as a JSON document that specifies what's text and what's markup. This or 'text' is required. Markup will be ignored when looking for errors. Example text: <pre>A &lt;b>test&lt;/b></pre>JSON for the example text: <pre>{\\\"annotation\\\":[  {\\\"text\\\": \\\"A \\\"},  {\\\"markup\\\": \\\"&lt;b>\\\"},  {\\\"text\\\": \\\"test\\\"},  {\\\"markup\\\": \\\"&lt;/b>\\\"} ]}</pre> <p>If you have markup that should be interpreted as whitespace, like <tt>&lt;p&gt;</tt> in HTML, you can have it interpreted like this: <pre>{\\\"markup\\\": \\\"&lt;p&gt;\\\", \\\"interpretAs\\\": \\\"\\\\n\\\\n\\\"}</pre><p>The 'data' feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input.
        :type data: str
        :param username: Set to get Premium API access: Your username/email as used to log in at languagetool.org.
        :type username: str
        :param api_key: Set to get Premium API access: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>your API key</a>
        :type api_key: str
        :param dicts: Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset
        :type dicts: str
        :param mother_tongue: A language code of the user's native language, enabling false friends checks for some language pairs.
        :type mother_tongue: str
        :param preferred_variants: Comma-separated list of preferred language variants. The language detector used with `language=auto` can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like `en-GB` and `de-AT`. Only available with `language=auto`. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just `en` or `de`.
        :type preferred_variants: str
        :param enabled_rules: IDs of rules to be enabled, comma-separated
        :type enabled_rules: str
        :param disabled_rules: IDs of rules to be disabled, comma-separated
        :type disabled_rules: str
        :param enabled_categories: IDs of categories to be enabled, comma-separated
        :type enabled_categories: str
        :param disabled_categories: IDs of categories to be disabled, comma-separated
        :type disabled_categories: str
        :param enabled_only: If true, only the rules and categories whose IDs are specified with `enabledRules` or `enabledCategories` are enabled.
        :type enabled_only: bool
        :param level: If set to `picky`, additional rules will be activated, i.e. rules that you might only find useful when checking formal text.
        :type level: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._check_post_serialize(
            language=language,
            text=text,
            data=data,
            username=username,
            api_key=api_key,
            dicts=dicts,
            mother_tongue=mother_tongue,
            preferred_variants=preferred_variants,
            enabled_rules=enabled_rules,
            disabled_rules=disabled_rules,
            enabled_categories=enabled_categories,
            disabled_categories=disabled_categories,
            enabled_only=enabled_only,
            level=level,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckPost200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def check_post_with_http_info(
        self,
        language: Annotated[StrictStr, Field(description="A language code like `en-US`, `de-DE`, `fr`, or `auto` to guess the language automatically (see `preferredVariants` below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. `en-GB` instead of just `en`.")],
        text: Annotated[Optional[StrictStr], Field(description="The text to be checked. This or 'data' is required.")] = None,
        data: Annotated[Optional[StrictStr], Field(description="The text to be checked, given as a JSON document that specifies what's text and what's markup. This or 'text' is required. Markup will be ignored when looking for errors. Example text: <pre>A &lt;b>test&lt;/b></pre>JSON for the example text: <pre>{\\\"annotation\\\":[  {\\\"text\\\": \\\"A \\\"},  {\\\"markup\\\": \\\"&lt;b>\\\"},  {\\\"text\\\": \\\"test\\\"},  {\\\"markup\\\": \\\"&lt;/b>\\\"} ]}</pre> <p>If you have markup that should be interpreted as whitespace, like <tt>&lt;p&gt;</tt> in HTML, you can have it interpreted like this: <pre>{\\\"markup\\\": \\\"&lt;p&gt;\\\", \\\"interpretAs\\\": \\\"\\\\n\\\\n\\\"}</pre><p>The 'data' feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set to get Premium API access: Your username/email as used to log in at languagetool.org.")] = None,
        api_key: Annotated[Optional[StrictStr], Field(description="Set to get Premium API access: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>your API key</a>")] = None,
        dicts: Annotated[Optional[StrictStr], Field(description="Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset")] = None,
        mother_tongue: Annotated[Optional[StrictStr], Field(description="A language code of the user's native language, enabling false friends checks for some language pairs.")] = None,
        preferred_variants: Annotated[Optional[StrictStr], Field(description="Comma-separated list of preferred language variants. The language detector used with `language=auto` can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like `en-GB` and `de-AT`. Only available with `language=auto`. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just `en` or `de`.")] = None,
        enabled_rules: Annotated[Optional[StrictStr], Field(description="IDs of rules to be enabled, comma-separated")] = None,
        disabled_rules: Annotated[Optional[StrictStr], Field(description="IDs of rules to be disabled, comma-separated")] = None,
        enabled_categories: Annotated[Optional[StrictStr], Field(description="IDs of categories to be enabled, comma-separated")] = None,
        disabled_categories: Annotated[Optional[StrictStr], Field(description="IDs of categories to be disabled, comma-separated")] = None,
        enabled_only: Annotated[Optional[StrictBool], Field(description="If true, only the rules and categories whose IDs are specified with `enabledRules` or `enabledCategories` are enabled.")] = None,
        level: Annotated[Optional[StrictStr], Field(description="If set to `picky`, additional rules will be activated, i.e. rules that you might only find useful when checking formal text.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CheckPost200Response]:
        """Check a text

        The main feature - check a text with LanguageTool for possible style and grammar issues.

        :param language: A language code like `en-US`, `de-DE`, `fr`, or `auto` to guess the language automatically (see `preferredVariants` below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. `en-GB` instead of just `en`. (required)
        :type language: str
        :param text: The text to be checked. This or 'data' is required.
        :type text: str
        :param data: The text to be checked, given as a JSON document that specifies what's text and what's markup. This or 'text' is required. Markup will be ignored when looking for errors. Example text: <pre>A &lt;b>test&lt;/b></pre>JSON for the example text: <pre>{\\\"annotation\\\":[  {\\\"text\\\": \\\"A \\\"},  {\\\"markup\\\": \\\"&lt;b>\\\"},  {\\\"text\\\": \\\"test\\\"},  {\\\"markup\\\": \\\"&lt;/b>\\\"} ]}</pre> <p>If you have markup that should be interpreted as whitespace, like <tt>&lt;p&gt;</tt> in HTML, you can have it interpreted like this: <pre>{\\\"markup\\\": \\\"&lt;p&gt;\\\", \\\"interpretAs\\\": \\\"\\\\n\\\\n\\\"}</pre><p>The 'data' feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input.
        :type data: str
        :param username: Set to get Premium API access: Your username/email as used to log in at languagetool.org.
        :type username: str
        :param api_key: Set to get Premium API access: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>your API key</a>
        :type api_key: str
        :param dicts: Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset
        :type dicts: str
        :param mother_tongue: A language code of the user's native language, enabling false friends checks for some language pairs.
        :type mother_tongue: str
        :param preferred_variants: Comma-separated list of preferred language variants. The language detector used with `language=auto` can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like `en-GB` and `de-AT`. Only available with `language=auto`. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just `en` or `de`.
        :type preferred_variants: str
        :param enabled_rules: IDs of rules to be enabled, comma-separated
        :type enabled_rules: str
        :param disabled_rules: IDs of rules to be disabled, comma-separated
        :type disabled_rules: str
        :param enabled_categories: IDs of categories to be enabled, comma-separated
        :type enabled_categories: str
        :param disabled_categories: IDs of categories to be disabled, comma-separated
        :type disabled_categories: str
        :param enabled_only: If true, only the rules and categories whose IDs are specified with `enabledRules` or `enabledCategories` are enabled.
        :type enabled_only: bool
        :param level: If set to `picky`, additional rules will be activated, i.e. rules that you might only find useful when checking formal text.
        :type level: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._check_post_serialize(
            language=language,
            text=text,
            data=data,
            username=username,
            api_key=api_key,
            dicts=dicts,
            mother_tongue=mother_tongue,
            preferred_variants=preferred_variants,
            enabled_rules=enabled_rules,
            disabled_rules=disabled_rules,
            enabled_categories=enabled_categories,
            disabled_categories=disabled_categories,
            enabled_only=enabled_only,
            level=level,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckPost200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def check_post_without_preload_content(
        self,
        language: Annotated[StrictStr, Field(description="A language code like `en-US`, `de-DE`, `fr`, or `auto` to guess the language automatically (see `preferredVariants` below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. `en-GB` instead of just `en`.")],
        text: Annotated[Optional[StrictStr], Field(description="The text to be checked. This or 'data' is required.")] = None,
        data: Annotated[Optional[StrictStr], Field(description="The text to be checked, given as a JSON document that specifies what's text and what's markup. This or 'text' is required. Markup will be ignored when looking for errors. Example text: <pre>A &lt;b>test&lt;/b></pre>JSON for the example text: <pre>{\\\"annotation\\\":[  {\\\"text\\\": \\\"A \\\"},  {\\\"markup\\\": \\\"&lt;b>\\\"},  {\\\"text\\\": \\\"test\\\"},  {\\\"markup\\\": \\\"&lt;/b>\\\"} ]}</pre> <p>If you have markup that should be interpreted as whitespace, like <tt>&lt;p&gt;</tt> in HTML, you can have it interpreted like this: <pre>{\\\"markup\\\": \\\"&lt;p&gt;\\\", \\\"interpretAs\\\": \\\"\\\\n\\\\n\\\"}</pre><p>The 'data' feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set to get Premium API access: Your username/email as used to log in at languagetool.org.")] = None,
        api_key: Annotated[Optional[StrictStr], Field(description="Set to get Premium API access: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>your API key</a>")] = None,
        dicts: Annotated[Optional[StrictStr], Field(description="Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset")] = None,
        mother_tongue: Annotated[Optional[StrictStr], Field(description="A language code of the user's native language, enabling false friends checks for some language pairs.")] = None,
        preferred_variants: Annotated[Optional[StrictStr], Field(description="Comma-separated list of preferred language variants. The language detector used with `language=auto` can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like `en-GB` and `de-AT`. Only available with `language=auto`. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just `en` or `de`.")] = None,
        enabled_rules: Annotated[Optional[StrictStr], Field(description="IDs of rules to be enabled, comma-separated")] = None,
        disabled_rules: Annotated[Optional[StrictStr], Field(description="IDs of rules to be disabled, comma-separated")] = None,
        enabled_categories: Annotated[Optional[StrictStr], Field(description="IDs of categories to be enabled, comma-separated")] = None,
        disabled_categories: Annotated[Optional[StrictStr], Field(description="IDs of categories to be disabled, comma-separated")] = None,
        enabled_only: Annotated[Optional[StrictBool], Field(description="If true, only the rules and categories whose IDs are specified with `enabledRules` or `enabledCategories` are enabled.")] = None,
        level: Annotated[Optional[StrictStr], Field(description="If set to `picky`, additional rules will be activated, i.e. rules that you might only find useful when checking formal text.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Check a text

        The main feature - check a text with LanguageTool for possible style and grammar issues.

        :param language: A language code like `en-US`, `de-DE`, `fr`, or `auto` to guess the language automatically (see `preferredVariants` below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. `en-GB` instead of just `en`. (required)
        :type language: str
        :param text: The text to be checked. This or 'data' is required.
        :type text: str
        :param data: The text to be checked, given as a JSON document that specifies what's text and what's markup. This or 'text' is required. Markup will be ignored when looking for errors. Example text: <pre>A &lt;b>test&lt;/b></pre>JSON for the example text: <pre>{\\\"annotation\\\":[  {\\\"text\\\": \\\"A \\\"},  {\\\"markup\\\": \\\"&lt;b>\\\"},  {\\\"text\\\": \\\"test\\\"},  {\\\"markup\\\": \\\"&lt;/b>\\\"} ]}</pre> <p>If you have markup that should be interpreted as whitespace, like <tt>&lt;p&gt;</tt> in HTML, you can have it interpreted like this: <pre>{\\\"markup\\\": \\\"&lt;p&gt;\\\", \\\"interpretAs\\\": \\\"\\\\n\\\\n\\\"}</pre><p>The 'data' feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input.
        :type data: str
        :param username: Set to get Premium API access: Your username/email as used to log in at languagetool.org.
        :type username: str
        :param api_key: Set to get Premium API access: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>your API key</a>
        :type api_key: str
        :param dicts: Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset
        :type dicts: str
        :param mother_tongue: A language code of the user's native language, enabling false friends checks for some language pairs.
        :type mother_tongue: str
        :param preferred_variants: Comma-separated list of preferred language variants. The language detector used with `language=auto` can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like `en-GB` and `de-AT`. Only available with `language=auto`. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just `en` or `de`.
        :type preferred_variants: str
        :param enabled_rules: IDs of rules to be enabled, comma-separated
        :type enabled_rules: str
        :param disabled_rules: IDs of rules to be disabled, comma-separated
        :type disabled_rules: str
        :param enabled_categories: IDs of categories to be enabled, comma-separated
        :type enabled_categories: str
        :param disabled_categories: IDs of categories to be disabled, comma-separated
        :type disabled_categories: str
        :param enabled_only: If true, only the rules and categories whose IDs are specified with `enabledRules` or `enabledCategories` are enabled.
        :type enabled_only: bool
        :param level: If set to `picky`, additional rules will be activated, i.e. rules that you might only find useful when checking formal text.
        :type level: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._check_post_serialize(
            language=language,
            text=text,
            data=data,
            username=username,
            api_key=api_key,
            dicts=dicts,
            mother_tongue=mother_tongue,
            preferred_variants=preferred_variants,
            enabled_rules=enabled_rules,
            disabled_rules=disabled_rules,
            enabled_categories=enabled_categories,
            disabled_categories=disabled_categories,
            enabled_only=enabled_only,
            level=level,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CheckPost200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _check_post_serialize(
        self,
        language,
        text,
        data,
        username,
        api_key,
        dicts,
        mother_tongue,
        preferred_variants,
        enabled_rules,
        disabled_rules,
        enabled_categories,
        disabled_categories,
        enabled_only,
        level,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if text is not None:
            _form_params.append(('text', text))
        if data is not None:
            _form_params.append(('data', data))
        if language is not None:
            _form_params.append(('language', language))
        if username is not None:
            _form_params.append(('username', username))
        if api_key is not None:
            _form_params.append(('apiKey', api_key))
        if dicts is not None:
            _form_params.append(('dicts', dicts))
        if mother_tongue is not None:
            _form_params.append(('motherTongue', mother_tongue))
        if preferred_variants is not None:
            _form_params.append(('preferredVariants', preferred_variants))
        if enabled_rules is not None:
            _form_params.append(('enabledRules', enabled_rules))
        if disabled_rules is not None:
            _form_params.append(('disabledRules', disabled_rules))
        if enabled_categories is not None:
            _form_params.append(('enabledCategories', enabled_categories))
        if disabled_categories is not None:
            _form_params.append(('disabledCategories', disabled_categories))
        if enabled_only is not None:
            _form_params.append(('enabledOnly', enabled_only))
        if level is not None:
            _form_params.append(('level', level))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/check',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def languages_get(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[LanguagesGet200ResponseInner]:
        """Get a list of supported languages.


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._languages_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LanguagesGet200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def languages_get_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[LanguagesGet200ResponseInner]]:
        """Get a list of supported languages.


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._languages_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LanguagesGet200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def languages_get_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a list of supported languages.


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._languages_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LanguagesGet200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _languages_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/languages',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def words_add_post(
        self,
        word: Annotated[StrictStr, Field(description="The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages.")],
        username: Annotated[StrictStr, Field(description="Your username as used to log in at languagetool.org.")],
        api_key: Annotated[StrictStr, Field(description="<a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a>")],
        dict: Annotated[Optional[StrictStr], Field(description="Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WordsAddPost200Response:
        """Add word to a dictionary

        Add a word to one of the user's personal dictionaries. Please note that this feature is considered to be used for personal dictionaries which must not contain more than 500 words. If this is an issue for you, please contact us.

        :param word: The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages. (required)
        :type word: str
        :param username: Your username as used to log in at languagetool.org. (required)
        :type username: str
        :param api_key: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a> (required)
        :type api_key: str
        :param dict: Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary
        :type dict: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._words_add_post_serialize(
            word=word,
            username=username,
            api_key=api_key,
            dict=dict,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WordsAddPost200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def words_add_post_with_http_info(
        self,
        word: Annotated[StrictStr, Field(description="The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages.")],
        username: Annotated[StrictStr, Field(description="Your username as used to log in at languagetool.org.")],
        api_key: Annotated[StrictStr, Field(description="<a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a>")],
        dict: Annotated[Optional[StrictStr], Field(description="Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WordsAddPost200Response]:
        """Add word to a dictionary

        Add a word to one of the user's personal dictionaries. Please note that this feature is considered to be used for personal dictionaries which must not contain more than 500 words. If this is an issue for you, please contact us.

        :param word: The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages. (required)
        :type word: str
        :param username: Your username as used to log in at languagetool.org. (required)
        :type username: str
        :param api_key: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a> (required)
        :type api_key: str
        :param dict: Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary
        :type dict: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._words_add_post_serialize(
            word=word,
            username=username,
            api_key=api_key,
            dict=dict,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WordsAddPost200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def words_add_post_without_preload_content(
        self,
        word: Annotated[StrictStr, Field(description="The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages.")],
        username: Annotated[StrictStr, Field(description="Your username as used to log in at languagetool.org.")],
        api_key: Annotated[StrictStr, Field(description="<a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a>")],
        dict: Annotated[Optional[StrictStr], Field(description="Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add word to a dictionary

        Add a word to one of the user's personal dictionaries. Please note that this feature is considered to be used for personal dictionaries which must not contain more than 500 words. If this is an issue for you, please contact us.

        :param word: The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages. (required)
        :type word: str
        :param username: Your username as used to log in at languagetool.org. (required)
        :type username: str
        :param api_key: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a> (required)
        :type api_key: str
        :param dict: Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary
        :type dict: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._words_add_post_serialize(
            word=word,
            username=username,
            api_key=api_key,
            dict=dict,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WordsAddPost200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _words_add_post_serialize(
        self,
        word,
        username,
        api_key,
        dict,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if word is not None:
            _form_params.append(('word', word))
        if username is not None:
            _form_params.append(('username', username))
        if api_key is not None:
            _form_params.append(('apiKey', api_key))
        if dict is not None:
            _form_params.append(('dict', dict))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/words/add',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def words_delete_post(
        self,
        word: Annotated[StrictStr, Field(description="The word to be removed.")],
        username: Annotated[StrictStr, Field(description="Your username as used to log in at languagetool.org.")],
        api_key: Annotated[StrictStr, Field(description="<a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a>")],
        dict: Annotated[Optional[StrictStr], Field(description="Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WordsDeletePost200Response:
        """Remove word from a dictionary

        Remove a word from one of the user's personal dictionaries.

        :param word: The word to be removed. (required)
        :type word: str
        :param username: Your username as used to log in at languagetool.org. (required)
        :type username: str
        :param api_key: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a> (required)
        :type api_key: str
        :param dict: Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary
        :type dict: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._words_delete_post_serialize(
            word=word,
            username=username,
            api_key=api_key,
            dict=dict,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WordsDeletePost200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def words_delete_post_with_http_info(
        self,
        word: Annotated[StrictStr, Field(description="The word to be removed.")],
        username: Annotated[StrictStr, Field(description="Your username as used to log in at languagetool.org.")],
        api_key: Annotated[StrictStr, Field(description="<a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a>")],
        dict: Annotated[Optional[StrictStr], Field(description="Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WordsDeletePost200Response]:
        """Remove word from a dictionary

        Remove a word from one of the user's personal dictionaries.

        :param word: The word to be removed. (required)
        :type word: str
        :param username: Your username as used to log in at languagetool.org. (required)
        :type username: str
        :param api_key: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a> (required)
        :type api_key: str
        :param dict: Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary
        :type dict: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._words_delete_post_serialize(
            word=word,
            username=username,
            api_key=api_key,
            dict=dict,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WordsDeletePost200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def words_delete_post_without_preload_content(
        self,
        word: Annotated[StrictStr, Field(description="The word to be removed.")],
        username: Annotated[StrictStr, Field(description="Your username as used to log in at languagetool.org.")],
        api_key: Annotated[StrictStr, Field(description="<a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a>")],
        dict: Annotated[Optional[StrictStr], Field(description="Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Remove word from a dictionary

        Remove a word from one of the user's personal dictionaries.

        :param word: The word to be removed. (required)
        :type word: str
        :param username: Your username as used to log in at languagetool.org. (required)
        :type username: str
        :param api_key: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a> (required)
        :type api_key: str
        :param dict: Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary
        :type dict: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._words_delete_post_serialize(
            word=word,
            username=username,
            api_key=api_key,
            dict=dict,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WordsDeletePost200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _words_delete_post_serialize(
        self,
        word,
        username,
        api_key,
        dict,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if word is not None:
            _form_params.append(('word', word))
        if username is not None:
            _form_params.append(('username', username))
        if api_key is not None:
            _form_params.append(('apiKey', api_key))
        if dict is not None:
            _form_params.append(('dict', dict))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/words/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def words_get(
        self,
        username: Annotated[StrictStr, Field(description="Your username as used to log in at languagetool.org.")],
        api_key: Annotated[StrictStr, Field(description="<a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a>")],
        offset: Annotated[Optional[StrictInt], Field(description="Offset of where to start in the list of words. Defaults to 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Maximum number of words to return. Defaults to 10.")] = None,
        dicts: Annotated[Optional[StrictStr], Field(description="Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WordsGet200Response:
        """List words in dictionaries

        List words in the user's personal dictionaries.

        :param username: Your username as used to log in at languagetool.org. (required)
        :type username: str
        :param api_key: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a> (required)
        :type api_key: str
        :param offset: Offset of where to start in the list of words. Defaults to 0.
        :type offset: int
        :param limit: Maximum number of words to return. Defaults to 10.
        :type limit: int
        :param dicts: Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset
        :type dicts: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._words_get_serialize(
            username=username,
            api_key=api_key,
            offset=offset,
            limit=limit,
            dicts=dicts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WordsGet200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def words_get_with_http_info(
        self,
        username: Annotated[StrictStr, Field(description="Your username as used to log in at languagetool.org.")],
        api_key: Annotated[StrictStr, Field(description="<a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a>")],
        offset: Annotated[Optional[StrictInt], Field(description="Offset of where to start in the list of words. Defaults to 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Maximum number of words to return. Defaults to 10.")] = None,
        dicts: Annotated[Optional[StrictStr], Field(description="Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WordsGet200Response]:
        """List words in dictionaries

        List words in the user's personal dictionaries.

        :param username: Your username as used to log in at languagetool.org. (required)
        :type username: str
        :param api_key: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a> (required)
        :type api_key: str
        :param offset: Offset of where to start in the list of words. Defaults to 0.
        :type offset: int
        :param limit: Maximum number of words to return. Defaults to 10.
        :type limit: int
        :param dicts: Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset
        :type dicts: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._words_get_serialize(
            username=username,
            api_key=api_key,
            offset=offset,
            limit=limit,
            dicts=dicts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WordsGet200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def words_get_without_preload_content(
        self,
        username: Annotated[StrictStr, Field(description="Your username as used to log in at languagetool.org.")],
        api_key: Annotated[StrictStr, Field(description="<a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a>")],
        offset: Annotated[Optional[StrictInt], Field(description="Offset of where to start in the list of words. Defaults to 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Maximum number of words to return. Defaults to 10.")] = None,
        dicts: Annotated[Optional[StrictStr], Field(description="Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List words in dictionaries

        List words in the user's personal dictionaries.

        :param username: Your username as used to log in at languagetool.org. (required)
        :type username: str
        :param api_key: <a target='_blank' href='https://languagetool.org/editor/settings/access-tokens'>Your API key</a> (required)
        :type api_key: str
        :param offset: Offset of where to start in the list of words. Defaults to 0.
        :type offset: int
        :param limit: Maximum number of words to return. Defaults to 10.
        :type limit: int
        :param dicts: Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset
        :type dicts: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._words_get_serialize(
            username=username,
            api_key=api_key,
            offset=offset,
            limit=limit,
            dicts=dicts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WordsGet200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _words_get_serialize(
        self,
        username,
        api_key,
        offset,
        limit,
        dicts,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if username is not None:
            
            _query_params.append(('username', username))
            
        if api_key is not None:
            
            _query_params.append(('apiKey', api_key))
            
        if dicts is not None:
            
            _query_params.append(('dicts', dicts))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/words',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


