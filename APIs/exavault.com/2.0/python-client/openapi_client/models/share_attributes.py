# coding: utf-8

"""
    ExaVault

    ExaVaults API allows you to incorporate ExaVaults suite of file transfer and user management tools into your own application.\\nExaVault supports both POST (recommended when requesting large data sets) and GET operations, and requires an API key in order to use.

    The version of the OpenAPI document: 2.0
    Contact: support@exavault.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.access_mode import AccessMode
from openapi_client.models.share_message import ShareMessage
from openapi_client.models.share_recipient import ShareRecipient
from typing import Optional, Set
from typing_extensions import Self

class ShareAttributes(BaseModel):
    """
    Attributes of the share including the name, path and share recipients. 
    """ # noqa: E501
    access_description: Optional[StrictStr] = Field(default=None, description="Description of the share access rights.", alias="accessDescription")
    access_mode: Optional[AccessMode] = Field(default=None, alias="accessMode")
    created: Optional[datetime] = Field(default=None, description="Timestamp of share creation.")
    embed: Optional[StrictBool] = Field(default=None, description="True if share can be embedded.")
    expiration: Optional[StrictStr] = Field(default=None, description="Expiration date of the share.")
    expired: Optional[StrictBool] = Field(default=None, description="True if the share has expired.")
    file_drop_create_folders: Optional[StrictBool] = Field(default=None, description="Flag to show if separate folders should be created for each file upload to receive folder.", alias="fileDropCreateFolders")
    form_id: Optional[StrictInt] = Field(default=None, description="ID of the form.", alias="formId")
    has_notification: Optional[StrictBool] = Field(default=None, description="True if share has notification.", alias="hasNotification")
    has_password: Optional[StrictBool] = Field(default=None, description="True if the share has password.", alias="hasPassword")
    hash: Optional[StrictStr] = Field(default=None, description="Share hash.")
    inherited: Optional[StrictBool] = Field(default=None, description="True if share inherited from parent folder.")
    messages: Optional[List[ShareMessage]] = Field(default=None, description="Array of invitation messages.")
    modified: Optional[datetime] = Field(default=None, description="Timestamp of share modification. Can be `null` if it wasn't modified.")
    name: Optional[StrictStr] = Field(default=None, description="Share name.")
    owner_hash: Optional[StrictStr] = Field(default=None, description="Share owner's hash.", alias="ownerHash")
    paths: Optional[List[StrictStr]] = Field(default=None, description="Path to the shared resource in your account.")
    public: Optional[StrictBool] = Field(default=None, description="True if the share has a public url.")
    recipients: Optional[List[ShareRecipient]] = Field(default=None, description="Array of recipients.")
    require_email: Optional[StrictBool] = Field(default=None, description="True if share requires email to access.", alias="requireEmail")
    resent: Optional[datetime] = Field(default=None, description="Invitations resent date. Can be `null` if resent never happened.")
    status: Optional[StrictInt] = Field(default=None, description="Share activity status. Can be active (1) or deactivated (0).")
    tracking_status: Optional[StrictStr] = Field(default=None, description="Checks recipient received status and returns whether it's been received (`complete`,) partial received (`incomplete`,) or not received yet (`pending`.)", alias="trackingStatus")
    type: Optional[StrictStr] = Field(default=None, description="Type of share.")
    __properties: ClassVar[List[str]] = ["accessDescription", "accessMode", "created", "embed", "expiration", "expired", "fileDropCreateFolders", "formId", "hasNotification", "hasPassword", "hash", "inherited", "messages", "modified", "name", "ownerHash", "paths", "public", "recipients", "requireEmail", "resent", "status", "trackingStatus", "type"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set([0, 1]):
            raise ValueError("must be one of enum values (0, 1)")
        return value

    @field_validator('tracking_status')
    def tracking_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['complete', 'incomplete', 'pending']):
            raise ValueError("must be one of enum values ('complete', 'incomplete', 'pending')")
        return value

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['shared_folder', 'send', 'receive']):
            raise ValueError("must be one of enum values ('shared_folder', 'send', 'receive')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ShareAttributes from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of access_mode
        if self.access_mode:
            _dict['accessMode'] = self.access_mode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in messages (list)
        _items = []
        if self.messages:
            for _item_messages in self.messages:
                if _item_messages:
                    _items.append(_item_messages.to_dict())
            _dict['messages'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in recipients (list)
        _items = []
        if self.recipients:
            for _item_recipients in self.recipients:
                if _item_recipients:
                    _items.append(_item_recipients.to_dict())
            _dict['recipients'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ShareAttributes from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accessDescription": obj.get("accessDescription"),
            "accessMode": AccessMode.from_dict(obj["accessMode"]) if obj.get("accessMode") is not None else None,
            "created": obj.get("created"),
            "embed": obj.get("embed"),
            "expiration": obj.get("expiration"),
            "expired": obj.get("expired"),
            "fileDropCreateFolders": obj.get("fileDropCreateFolders"),
            "formId": obj.get("formId"),
            "hasNotification": obj.get("hasNotification"),
            "hasPassword": obj.get("hasPassword"),
            "hash": obj.get("hash"),
            "inherited": obj.get("inherited"),
            "messages": [ShareMessage.from_dict(_item) for _item in obj["messages"]] if obj.get("messages") is not None else None,
            "modified": obj.get("modified"),
            "name": obj.get("name"),
            "ownerHash": obj.get("ownerHash"),
            "paths": obj.get("paths"),
            "public": obj.get("public"),
            "recipients": [ShareRecipient.from_dict(_item) for _item in obj["recipients"]] if obj.get("recipients") is not None else None,
            "requireEmail": obj.get("requireEmail"),
            "resent": obj.get("resent"),
            "status": obj.get("status"),
            "trackingStatus": obj.get("trackingStatus"),
            "type": obj.get("type")
        })
        return _obj


