# coding: utf-8

"""
    ExaVault

    ExaVaults API allows you to incorporate ExaVaults suite of file transfer and user management tools into your own application.\\nExaVault supports both POST (recommended when requesting large data sets) and GET operations, and requires an API key in order to use.

    The version of the OpenAPI document: 2.0
    Contact: support@exavault.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.access_mode import AccessMode
from openapi_client.models.add_share_request_body_recipients_inner import AddShareRequestBodyRecipientsInner
from typing import Optional, Set
from typing_extensions import Self

class AddShareRequestBody(BaseModel):
    """
    AddShareRequestBody
    """ # noqa: E501
    access_mode: Optional[AccessMode] = Field(default=None, alias="accessMode")
    embed: Optional[StrictBool] = Field(default=None, description="Whether this share can be embedded within a web page.")
    expiration: Optional[datetime] = Field(default=None, description="Expiration date for the share. If someone attempts to use the share after this date, they will receive an error that the share is not available.")
    file_drop_create_folders: Optional[StrictBool] = Field(default=None, description="Only used for **receive** shares. If true, uploads will be automatically placed into sub-folders of the folder, named after the chosen field on your form. ", alias="fileDropCreateFolders")
    has_notification: Optional[StrictBool] = Field(default=None, description="Whether delivery receipts should be sent.", alias="hasNotification")
    is_public: Optional[StrictBool] = Field(default=None, description="Whether someone can visit the share without following a personalized recipient link.", alias="isPublic")
    message_body: Optional[StrictStr] = Field(default=None, description="The message to be included in email invitations for your recipients. Ignored if you have not also provided `recipients` and `messageSubject`", alias="messageBody")
    message_subject: Optional[StrictStr] = Field(default=None, description="Subject to use on emails inviting recipients to the share. Ignored if you have not also provided `recipients` and a `messageBody`", alias="messageSubject")
    name: StrictStr = Field(description="A name for the share. This will be visible on the page that recipients visit. ")
    notification_emails: Optional[List[StrictStr]] = Field(default=None, description="Emails that will receive delivery receipts for this share. `hasNotification` must be **true** for delivery receipts will be sent.", alias="notificationEmails")
    password: Optional[StrictStr] = Field(default=None, description="Set a password for recipients to access the share. All recipients will use the same password.")
    recipients: Optional[List[AddShareRequestBodyRecipientsInner]] = Field(default=None, description="People you want to invite to the share. **Note**: unless you also set the `messageSubject` and `messageBody` for the new share, invitation emails will not be sent to these recipients.")
    require_email: Optional[StrictBool] = Field(default=None, description="True if recipients must provide their email to view the share.", alias="requireEmail")
    resources: Optional[List[StrictStr]] = Field(default=None, description="Array of resources for this share. See details on [how to specify resources](#section/Identifying-Resources) above.  **shared_folder** and **receive** shares must have only one `resource`, which is a directory that does not have a current share attached.  **send** shares may have multiple `resource` parameters. You can also leave this parameter null if you are planning to upload files to the send. If you are planning to upload files to the send that are not yet in your account, you will also need to call the [POST /shares/complete-send/{id}](#operation/completeDirectSend) endpoint to finish the send operation. ")
    sending_local_files: Optional[StrictBool] = Field(default=None, description="Use this only for **send** shares. Flag to indicate that you are going to upload additional files from your computer to the share. If this is **true**, you will also need to use the [POST /shares/complete-send/{id}](#operation/completeDirectSend) call to finish setting up your share after the files are uploaded.", alias="sendingLocalFiles")
    type: StrictStr = Field(description="The type of share to create. See above for a description of each.")
    __properties: ClassVar[List[str]] = ["accessMode", "embed", "expiration", "fileDropCreateFolders", "hasNotification", "isPublic", "messageBody", "messageSubject", "name", "notificationEmails", "password", "recipients", "requireEmail", "resources", "sendingLocalFiles", "type"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['shared_folder', 'receive', 'send']):
            raise ValueError("must be one of enum values ('shared_folder', 'receive', 'send')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AddShareRequestBody from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of access_mode
        if self.access_mode:
            _dict['accessMode'] = self.access_mode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in recipients (list)
        _items = []
        if self.recipients:
            for _item_recipients in self.recipients:
                if _item_recipients:
                    _items.append(_item_recipients.to_dict())
            _dict['recipients'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AddShareRequestBody from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accessMode": AccessMode.from_dict(obj["accessMode"]) if obj.get("accessMode") is not None else None,
            "embed": obj.get("embed"),
            "expiration": obj.get("expiration"),
            "fileDropCreateFolders": obj.get("fileDropCreateFolders"),
            "hasNotification": obj.get("hasNotification"),
            "isPublic": obj.get("isPublic"),
            "messageBody": obj.get("messageBody"),
            "messageSubject": obj.get("messageSubject"),
            "name": obj.get("name"),
            "notificationEmails": obj.get("notificationEmails"),
            "password": obj.get("password"),
            "recipients": [AddShareRequestBodyRecipientsInner.from_dict(_item) for _item in obj["recipients"]] if obj.get("recipients") is not None else None,
            "requireEmail": obj.get("requireEmail"),
            "resources": obj.get("resources"),
            "sendingLocalFiles": obj.get("sendingLocalFiles"),
            "type": obj.get("type")
        })
        return _obj


