# coding: utf-8

"""
    spoonacular API

    The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

    The version of the OpenAPI document: 1.1
    Contact: mail@spoonacular.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, Dict, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.autocomplete_menu_item_search200_response import AutocompleteMenuItemSearch200Response
from openapi_client.models.get_menu_item_information200_response import GetMenuItemInformation200Response
from openapi_client.models.search_menu_items200_response import SearchMenuItems200Response

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class MenuItemsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def autocomplete_menu_item_search(
        self,
        query: Annotated[StrictStr, Field(description="The (partial) search query.")],
        number: Annotated[Optional[Union[Annotated[float, Field(le=25, strict=True, ge=1)], Annotated[int, Field(le=25, strict=True, ge=1)]]], Field(description="The number of results to return (between 1 and 25).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AutocompleteMenuItemSearch200Response:
        """Autocomplete Menu Item Search

        Generate suggestions for menu items based on a (partial) query. The matches will be found by looking in the title only.

        :param query: The (partial) search query. (required)
        :type query: str
        :param number: The number of results to return (between 1 and 25).
        :type number: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_menu_item_search_serialize(
            query=query,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AutocompleteMenuItemSearch200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def autocomplete_menu_item_search_with_http_info(
        self,
        query: Annotated[StrictStr, Field(description="The (partial) search query.")],
        number: Annotated[Optional[Union[Annotated[float, Field(le=25, strict=True, ge=1)], Annotated[int, Field(le=25, strict=True, ge=1)]]], Field(description="The number of results to return (between 1 and 25).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AutocompleteMenuItemSearch200Response]:
        """Autocomplete Menu Item Search

        Generate suggestions for menu items based on a (partial) query. The matches will be found by looking in the title only.

        :param query: The (partial) search query. (required)
        :type query: str
        :param number: The number of results to return (between 1 and 25).
        :type number: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_menu_item_search_serialize(
            query=query,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AutocompleteMenuItemSearch200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def autocomplete_menu_item_search_without_preload_content(
        self,
        query: Annotated[StrictStr, Field(description="The (partial) search query.")],
        number: Annotated[Optional[Union[Annotated[float, Field(le=25, strict=True, ge=1)], Annotated[int, Field(le=25, strict=True, ge=1)]]], Field(description="The number of results to return (between 1 and 25).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Autocomplete Menu Item Search

        Generate suggestions for menu items based on a (partial) query. The matches will be found by looking in the title only.

        :param query: The (partial) search query. (required)
        :type query: str
        :param number: The number of results to return (between 1 and 25).
        :type number: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_menu_item_search_serialize(
            query=query,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AutocompleteMenuItemSearch200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _autocomplete_menu_item_search_serialize(
        self,
        query,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if number is not None:
            
            _query_params.append(('number', number))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/menuItems/suggest',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_menu_item_information(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetMenuItemInformation200Response:
        """Get Menu Item Information

        Use a menu item id to get all available information about a menu item, such as nutrition.

        :param id: The item's id. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_menu_item_information_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMenuItemInformation200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_menu_item_information_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetMenuItemInformation200Response]:
        """Get Menu Item Information

        Use a menu item id to get all available information about a menu item, such as nutrition.

        :param id: The item's id. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_menu_item_information_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMenuItemInformation200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_menu_item_information_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Menu Item Information

        Use a menu item id to get all available information about a menu item, such as nutrition.

        :param id: The item's id. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_menu_item_information_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetMenuItemInformation200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_menu_item_information_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/menuItems/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def menu_item_nutrition_by_id_image(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The menu item id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Menu Item Nutrition by ID Image

        Visualize a menu item's nutritional information as HTML including CSS.

        :param id: The menu item id. (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._menu_item_nutrition_by_id_image_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def menu_item_nutrition_by_id_image_with_http_info(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The menu item id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Menu Item Nutrition by ID Image

        Visualize a menu item's nutritional information as HTML including CSS.

        :param id: The menu item id. (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._menu_item_nutrition_by_id_image_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def menu_item_nutrition_by_id_image_without_preload_content(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The menu item id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Menu Item Nutrition by ID Image

        Visualize a menu item's nutritional information as HTML including CSS.

        :param id: The menu item id. (required)
        :type id: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._menu_item_nutrition_by_id_image_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _menu_item_nutrition_by_id_image_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'image/png'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/menuItems/{id}/nutritionWidget.png',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def menu_item_nutrition_label_image(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The menu item id.")],
        show_optional_nutrients: Annotated[Optional[StrictBool], Field(description="Whether to show optional nutrients.")] = None,
        show_zero_values: Annotated[Optional[StrictBool], Field(description="Whether to show zero values.")] = None,
        show_ingredients: Annotated[Optional[StrictBool], Field(description="Whether to show a list of ingredients.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Menu Item Nutrition Label Image

        Visualize a menu item's nutritional label information as an image.

        :param id: The menu item id. (required)
        :type id: float
        :param show_optional_nutrients: Whether to show optional nutrients.
        :type show_optional_nutrients: bool
        :param show_zero_values: Whether to show zero values.
        :type show_zero_values: bool
        :param show_ingredients: Whether to show a list of ingredients.
        :type show_ingredients: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._menu_item_nutrition_label_image_serialize(
            id=id,
            show_optional_nutrients=show_optional_nutrients,
            show_zero_values=show_zero_values,
            show_ingredients=show_ingredients,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def menu_item_nutrition_label_image_with_http_info(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The menu item id.")],
        show_optional_nutrients: Annotated[Optional[StrictBool], Field(description="Whether to show optional nutrients.")] = None,
        show_zero_values: Annotated[Optional[StrictBool], Field(description="Whether to show zero values.")] = None,
        show_ingredients: Annotated[Optional[StrictBool], Field(description="Whether to show a list of ingredients.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Menu Item Nutrition Label Image

        Visualize a menu item's nutritional label information as an image.

        :param id: The menu item id. (required)
        :type id: float
        :param show_optional_nutrients: Whether to show optional nutrients.
        :type show_optional_nutrients: bool
        :param show_zero_values: Whether to show zero values.
        :type show_zero_values: bool
        :param show_ingredients: Whether to show a list of ingredients.
        :type show_ingredients: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._menu_item_nutrition_label_image_serialize(
            id=id,
            show_optional_nutrients=show_optional_nutrients,
            show_zero_values=show_zero_values,
            show_ingredients=show_ingredients,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def menu_item_nutrition_label_image_without_preload_content(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The menu item id.")],
        show_optional_nutrients: Annotated[Optional[StrictBool], Field(description="Whether to show optional nutrients.")] = None,
        show_zero_values: Annotated[Optional[StrictBool], Field(description="Whether to show zero values.")] = None,
        show_ingredients: Annotated[Optional[StrictBool], Field(description="Whether to show a list of ingredients.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Menu Item Nutrition Label Image

        Visualize a menu item's nutritional label information as an image.

        :param id: The menu item id. (required)
        :type id: float
        :param show_optional_nutrients: Whether to show optional nutrients.
        :type show_optional_nutrients: bool
        :param show_zero_values: Whether to show zero values.
        :type show_zero_values: bool
        :param show_ingredients: Whether to show a list of ingredients.
        :type show_ingredients: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._menu_item_nutrition_label_image_serialize(
            id=id,
            show_optional_nutrients=show_optional_nutrients,
            show_zero_values=show_zero_values,
            show_ingredients=show_ingredients,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _menu_item_nutrition_label_image_serialize(
        self,
        id,
        show_optional_nutrients,
        show_zero_values,
        show_ingredients,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if show_optional_nutrients is not None:
            
            _query_params.append(('showOptionalNutrients', show_optional_nutrients))
            
        if show_zero_values is not None:
            
            _query_params.append(('showZeroValues', show_zero_values))
            
        if show_ingredients is not None:
            
            _query_params.append(('showIngredients', show_ingredients))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'image/png'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/menuItems/{id}/nutritionLabel.png',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def menu_item_nutrition_label_widget(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The menu item id.")],
        default_css: Annotated[Optional[StrictBool], Field(description="Whether the default CSS should be added to the response.")] = None,
        show_optional_nutrients: Annotated[Optional[StrictBool], Field(description="Whether to show optional nutrients.")] = None,
        show_zero_values: Annotated[Optional[StrictBool], Field(description="Whether to show zero values.")] = None,
        show_ingredients: Annotated[Optional[StrictBool], Field(description="Whether to show a list of ingredients.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Menu Item Nutrition Label Widget

        Visualize a menu item's nutritional label information as HTML including CSS.

        :param id: The menu item id. (required)
        :type id: float
        :param default_css: Whether the default CSS should be added to the response.
        :type default_css: bool
        :param show_optional_nutrients: Whether to show optional nutrients.
        :type show_optional_nutrients: bool
        :param show_zero_values: Whether to show zero values.
        :type show_zero_values: bool
        :param show_ingredients: Whether to show a list of ingredients.
        :type show_ingredients: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._menu_item_nutrition_label_widget_serialize(
            id=id,
            default_css=default_css,
            show_optional_nutrients=show_optional_nutrients,
            show_zero_values=show_zero_values,
            show_ingredients=show_ingredients,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def menu_item_nutrition_label_widget_with_http_info(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The menu item id.")],
        default_css: Annotated[Optional[StrictBool], Field(description="Whether the default CSS should be added to the response.")] = None,
        show_optional_nutrients: Annotated[Optional[StrictBool], Field(description="Whether to show optional nutrients.")] = None,
        show_zero_values: Annotated[Optional[StrictBool], Field(description="Whether to show zero values.")] = None,
        show_ingredients: Annotated[Optional[StrictBool], Field(description="Whether to show a list of ingredients.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Menu Item Nutrition Label Widget

        Visualize a menu item's nutritional label information as HTML including CSS.

        :param id: The menu item id. (required)
        :type id: float
        :param default_css: Whether the default CSS should be added to the response.
        :type default_css: bool
        :param show_optional_nutrients: Whether to show optional nutrients.
        :type show_optional_nutrients: bool
        :param show_zero_values: Whether to show zero values.
        :type show_zero_values: bool
        :param show_ingredients: Whether to show a list of ingredients.
        :type show_ingredients: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._menu_item_nutrition_label_widget_serialize(
            id=id,
            default_css=default_css,
            show_optional_nutrients=show_optional_nutrients,
            show_zero_values=show_zero_values,
            show_ingredients=show_ingredients,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def menu_item_nutrition_label_widget_without_preload_content(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The menu item id.")],
        default_css: Annotated[Optional[StrictBool], Field(description="Whether the default CSS should be added to the response.")] = None,
        show_optional_nutrients: Annotated[Optional[StrictBool], Field(description="Whether to show optional nutrients.")] = None,
        show_zero_values: Annotated[Optional[StrictBool], Field(description="Whether to show zero values.")] = None,
        show_ingredients: Annotated[Optional[StrictBool], Field(description="Whether to show a list of ingredients.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Menu Item Nutrition Label Widget

        Visualize a menu item's nutritional label information as HTML including CSS.

        :param id: The menu item id. (required)
        :type id: float
        :param default_css: Whether the default CSS should be added to the response.
        :type default_css: bool
        :param show_optional_nutrients: Whether to show optional nutrients.
        :type show_optional_nutrients: bool
        :param show_zero_values: Whether to show zero values.
        :type show_zero_values: bool
        :param show_ingredients: Whether to show a list of ingredients.
        :type show_ingredients: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._menu_item_nutrition_label_widget_serialize(
            id=id,
            default_css=default_css,
            show_optional_nutrients=show_optional_nutrients,
            show_zero_values=show_zero_values,
            show_ingredients=show_ingredients,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _menu_item_nutrition_label_widget_serialize(
        self,
        id,
        default_css,
        show_optional_nutrients,
        show_zero_values,
        show_ingredients,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if default_css is not None:
            
            _query_params.append(('defaultCss', default_css))
            
        if show_optional_nutrients is not None:
            
            _query_params.append(('showOptionalNutrients', show_optional_nutrients))
            
        if show_zero_values is not None:
            
            _query_params.append(('showZeroValues', show_zero_values))
            
        if show_ingredients is not None:
            
            _query_params.append(('showIngredients', show_ingredients))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/html'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/menuItems/{id}/nutritionLabel',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_menu_items(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The (natural language) search query.")] = None,
        min_calories: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of calories the menu item must have.")] = None,
        max_calories: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of calories the menu item can have.")] = None,
        min_carbs: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of carbohydrates in grams the menu item must have.")] = None,
        max_carbs: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of carbohydrates in grams the menu item can have.")] = None,
        min_protein: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of protein in grams the menu item must have.")] = None,
        max_protein: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of protein in grams the menu item can have.")] = None,
        min_fat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of fat in grams the menu item must have.")] = None,
        max_fat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of fat in grams the menu item can have.")] = None,
        add_menu_item_information: Annotated[Optional[StrictBool], Field(description="If set to true, you get more information about the menu items returned.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=900, strict=True, ge=0)]], Field(description="The number of results to skip (between 0 and 900).")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to return (between 1 and 100). Defaults to 10.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SearchMenuItems200Response:
        """Search Menu Items

        Search over 115,000 menu items from over 800 fast food and chain restaurants. For example, McDonald's Big Mac or Starbucks Mocha.

        :param query: The (natural language) search query.
        :type query: str
        :param min_calories: The minimum amount of calories the menu item must have.
        :type min_calories: float
        :param max_calories: The maximum amount of calories the menu item can have.
        :type max_calories: float
        :param min_carbs: The minimum amount of carbohydrates in grams the menu item must have.
        :type min_carbs: float
        :param max_carbs: The maximum amount of carbohydrates in grams the menu item can have.
        :type max_carbs: float
        :param min_protein: The minimum amount of protein in grams the menu item must have.
        :type min_protein: float
        :param max_protein: The maximum amount of protein in grams the menu item can have.
        :type max_protein: float
        :param min_fat: The minimum amount of fat in grams the menu item must have.
        :type min_fat: float
        :param max_fat: The maximum amount of fat in grams the menu item can have.
        :type max_fat: float
        :param add_menu_item_information: If set to true, you get more information about the menu items returned.
        :type add_menu_item_information: bool
        :param offset: The number of results to skip (between 0 and 900).
        :type offset: int
        :param number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :type number: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_menu_items_serialize(
            query=query,
            min_calories=min_calories,
            max_calories=max_calories,
            min_carbs=min_carbs,
            max_carbs=max_carbs,
            min_protein=min_protein,
            max_protein=max_protein,
            min_fat=min_fat,
            max_fat=max_fat,
            add_menu_item_information=add_menu_item_information,
            offset=offset,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchMenuItems200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_menu_items_with_http_info(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The (natural language) search query.")] = None,
        min_calories: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of calories the menu item must have.")] = None,
        max_calories: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of calories the menu item can have.")] = None,
        min_carbs: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of carbohydrates in grams the menu item must have.")] = None,
        max_carbs: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of carbohydrates in grams the menu item can have.")] = None,
        min_protein: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of protein in grams the menu item must have.")] = None,
        max_protein: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of protein in grams the menu item can have.")] = None,
        min_fat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of fat in grams the menu item must have.")] = None,
        max_fat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of fat in grams the menu item can have.")] = None,
        add_menu_item_information: Annotated[Optional[StrictBool], Field(description="If set to true, you get more information about the menu items returned.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=900, strict=True, ge=0)]], Field(description="The number of results to skip (between 0 and 900).")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to return (between 1 and 100). Defaults to 10.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SearchMenuItems200Response]:
        """Search Menu Items

        Search over 115,000 menu items from over 800 fast food and chain restaurants. For example, McDonald's Big Mac or Starbucks Mocha.

        :param query: The (natural language) search query.
        :type query: str
        :param min_calories: The minimum amount of calories the menu item must have.
        :type min_calories: float
        :param max_calories: The maximum amount of calories the menu item can have.
        :type max_calories: float
        :param min_carbs: The minimum amount of carbohydrates in grams the menu item must have.
        :type min_carbs: float
        :param max_carbs: The maximum amount of carbohydrates in grams the menu item can have.
        :type max_carbs: float
        :param min_protein: The minimum amount of protein in grams the menu item must have.
        :type min_protein: float
        :param max_protein: The maximum amount of protein in grams the menu item can have.
        :type max_protein: float
        :param min_fat: The minimum amount of fat in grams the menu item must have.
        :type min_fat: float
        :param max_fat: The maximum amount of fat in grams the menu item can have.
        :type max_fat: float
        :param add_menu_item_information: If set to true, you get more information about the menu items returned.
        :type add_menu_item_information: bool
        :param offset: The number of results to skip (between 0 and 900).
        :type offset: int
        :param number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :type number: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_menu_items_serialize(
            query=query,
            min_calories=min_calories,
            max_calories=max_calories,
            min_carbs=min_carbs,
            max_carbs=max_carbs,
            min_protein=min_protein,
            max_protein=max_protein,
            min_fat=min_fat,
            max_fat=max_fat,
            add_menu_item_information=add_menu_item_information,
            offset=offset,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchMenuItems200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_menu_items_without_preload_content(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The (natural language) search query.")] = None,
        min_calories: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of calories the menu item must have.")] = None,
        max_calories: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of calories the menu item can have.")] = None,
        min_carbs: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of carbohydrates in grams the menu item must have.")] = None,
        max_carbs: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of carbohydrates in grams the menu item can have.")] = None,
        min_protein: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of protein in grams the menu item must have.")] = None,
        max_protein: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of protein in grams the menu item can have.")] = None,
        min_fat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum amount of fat in grams the menu item must have.")] = None,
        max_fat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of fat in grams the menu item can have.")] = None,
        add_menu_item_information: Annotated[Optional[StrictBool], Field(description="If set to true, you get more information about the menu items returned.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=900, strict=True, ge=0)]], Field(description="The number of results to skip (between 0 and 900).")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to return (between 1 and 100). Defaults to 10.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Menu Items

        Search over 115,000 menu items from over 800 fast food and chain restaurants. For example, McDonald's Big Mac or Starbucks Mocha.

        :param query: The (natural language) search query.
        :type query: str
        :param min_calories: The minimum amount of calories the menu item must have.
        :type min_calories: float
        :param max_calories: The maximum amount of calories the menu item can have.
        :type max_calories: float
        :param min_carbs: The minimum amount of carbohydrates in grams the menu item must have.
        :type min_carbs: float
        :param max_carbs: The maximum amount of carbohydrates in grams the menu item can have.
        :type max_carbs: float
        :param min_protein: The minimum amount of protein in grams the menu item must have.
        :type min_protein: float
        :param max_protein: The maximum amount of protein in grams the menu item can have.
        :type max_protein: float
        :param min_fat: The minimum amount of fat in grams the menu item must have.
        :type min_fat: float
        :param max_fat: The maximum amount of fat in grams the menu item can have.
        :type max_fat: float
        :param add_menu_item_information: If set to true, you get more information about the menu items returned.
        :type add_menu_item_information: bool
        :param offset: The number of results to skip (between 0 and 900).
        :type offset: int
        :param number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :type number: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_menu_items_serialize(
            query=query,
            min_calories=min_calories,
            max_calories=max_calories,
            min_carbs=min_carbs,
            max_carbs=max_carbs,
            min_protein=min_protein,
            max_protein=max_protein,
            min_fat=min_fat,
            max_fat=max_fat,
            add_menu_item_information=add_menu_item_information,
            offset=offset,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchMenuItems200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_menu_items_serialize(
        self,
        query,
        min_calories,
        max_calories,
        min_carbs,
        max_carbs,
        min_protein,
        max_protein,
        min_fat,
        max_fat,
        add_menu_item_information,
        offset,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if min_calories is not None:
            
            _query_params.append(('minCalories', min_calories))
            
        if max_calories is not None:
            
            _query_params.append(('maxCalories', max_calories))
            
        if min_carbs is not None:
            
            _query_params.append(('minCarbs', min_carbs))
            
        if max_carbs is not None:
            
            _query_params.append(('maxCarbs', max_carbs))
            
        if min_protein is not None:
            
            _query_params.append(('minProtein', min_protein))
            
        if max_protein is not None:
            
            _query_params.append(('maxProtein', max_protein))
            
        if min_fat is not None:
            
            _query_params.append(('minFat', min_fat))
            
        if max_fat is not None:
            
            _query_params.append(('maxFat', max_fat))
            
        if add_menu_item_information is not None:
            
            _query_params.append(('addMenuItemInformation', add_menu_item_information))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if number is not None:
            
            _query_params.append(('number', number))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/menuItems/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def visualize_menu_item_nutrition_by_id(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        default_css: Annotated[Optional[StrictBool], Field(description="Whether the default CSS should be added to the response.")] = None,
        accept: Annotated[Optional[StrictStr], Field(description="Accept header.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Menu Item Nutrition by ID Widget

        Visualize a menu item's nutritional information as HTML including CSS.

        :param id: The item's id. (required)
        :type id: int
        :param default_css: Whether the default CSS should be added to the response.
        :type default_css: bool
        :param accept: Accept header.
        :type accept: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._visualize_menu_item_nutrition_by_id_serialize(
            id=id,
            default_css=default_css,
            accept=accept,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def visualize_menu_item_nutrition_by_id_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        default_css: Annotated[Optional[StrictBool], Field(description="Whether the default CSS should be added to the response.")] = None,
        accept: Annotated[Optional[StrictStr], Field(description="Accept header.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Menu Item Nutrition by ID Widget

        Visualize a menu item's nutritional information as HTML including CSS.

        :param id: The item's id. (required)
        :type id: int
        :param default_css: Whether the default CSS should be added to the response.
        :type default_css: bool
        :param accept: Accept header.
        :type accept: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._visualize_menu_item_nutrition_by_id_serialize(
            id=id,
            default_css=default_css,
            accept=accept,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def visualize_menu_item_nutrition_by_id_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        default_css: Annotated[Optional[StrictBool], Field(description="Whether the default CSS should be added to the response.")] = None,
        accept: Annotated[Optional[StrictStr], Field(description="Accept header.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Menu Item Nutrition by ID Widget

        Visualize a menu item's nutritional information as HTML including CSS.

        :param id: The item's id. (required)
        :type id: int
        :param default_css: Whether the default CSS should be added to the response.
        :type default_css: bool
        :param accept: Accept header.
        :type accept: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._visualize_menu_item_nutrition_by_id_serialize(
            id=id,
            default_css=default_css,
            accept=accept,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _visualize_menu_item_nutrition_by_id_serialize(
        self,
        id,
        default_css,
        accept,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if default_css is not None:
            
            _query_params.append(('defaultCss', default_css))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/html'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/menuItems/{id}/nutritionWidget',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


