# coding: utf-8

"""
    spoonacular API

    The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

    The version of the OpenAPI document: 1.1
    Contact: mail@spoonacular.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, Dict, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.analyze_recipe_request import AnalyzeRecipeRequest
from openapi_client.models.search_restaurants200_response import SearchRestaurants200Response

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def analyze_recipe(
        self,
        analyze_recipe_request: Annotated[AnalyzeRecipeRequest, Field(description="Example request body.")],
        language: Annotated[Optional[StrictStr], Field(description="The input language, either \"en\" or \"de\".")] = None,
        include_nutrition: Annotated[Optional[StrictBool], Field(description="Whether nutrition data should be added to correctly parsed ingredients.")] = None,
        include_taste: Annotated[Optional[StrictBool], Field(description="Whether taste data should be added to correctly parsed ingredients.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Analyze Recipe

        This endpoint allows you to send raw recipe information, such as title, servings, and ingredients, to then see what we compute (badges, diets, nutrition, and more). This is useful if you have your own recipe data and want to enrich it with our semantic analysis.

        :param analyze_recipe_request: Example request body. (required)
        :type analyze_recipe_request: AnalyzeRecipeRequest
        :param language: The input language, either \"en\" or \"de\".
        :type language: str
        :param include_nutrition: Whether nutrition data should be added to correctly parsed ingredients.
        :type include_nutrition: bool
        :param include_taste: Whether taste data should be added to correctly parsed ingredients.
        :type include_taste: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._analyze_recipe_serialize(
            analyze_recipe_request=analyze_recipe_request,
            language=language,
            include_nutrition=include_nutrition,
            include_taste=include_taste,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def analyze_recipe_with_http_info(
        self,
        analyze_recipe_request: Annotated[AnalyzeRecipeRequest, Field(description="Example request body.")],
        language: Annotated[Optional[StrictStr], Field(description="The input language, either \"en\" or \"de\".")] = None,
        include_nutrition: Annotated[Optional[StrictBool], Field(description="Whether nutrition data should be added to correctly parsed ingredients.")] = None,
        include_taste: Annotated[Optional[StrictBool], Field(description="Whether taste data should be added to correctly parsed ingredients.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Analyze Recipe

        This endpoint allows you to send raw recipe information, such as title, servings, and ingredients, to then see what we compute (badges, diets, nutrition, and more). This is useful if you have your own recipe data and want to enrich it with our semantic analysis.

        :param analyze_recipe_request: Example request body. (required)
        :type analyze_recipe_request: AnalyzeRecipeRequest
        :param language: The input language, either \"en\" or \"de\".
        :type language: str
        :param include_nutrition: Whether nutrition data should be added to correctly parsed ingredients.
        :type include_nutrition: bool
        :param include_taste: Whether taste data should be added to correctly parsed ingredients.
        :type include_taste: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._analyze_recipe_serialize(
            analyze_recipe_request=analyze_recipe_request,
            language=language,
            include_nutrition=include_nutrition,
            include_taste=include_taste,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def analyze_recipe_without_preload_content(
        self,
        analyze_recipe_request: Annotated[AnalyzeRecipeRequest, Field(description="Example request body.")],
        language: Annotated[Optional[StrictStr], Field(description="The input language, either \"en\" or \"de\".")] = None,
        include_nutrition: Annotated[Optional[StrictBool], Field(description="Whether nutrition data should be added to correctly parsed ingredients.")] = None,
        include_taste: Annotated[Optional[StrictBool], Field(description="Whether taste data should be added to correctly parsed ingredients.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Analyze Recipe

        This endpoint allows you to send raw recipe information, such as title, servings, and ingredients, to then see what we compute (badges, diets, nutrition, and more). This is useful if you have your own recipe data and want to enrich it with our semantic analysis.

        :param analyze_recipe_request: Example request body. (required)
        :type analyze_recipe_request: AnalyzeRecipeRequest
        :param language: The input language, either \"en\" or \"de\".
        :type language: str
        :param include_nutrition: Whether nutrition data should be added to correctly parsed ingredients.
        :type include_nutrition: bool
        :param include_taste: Whether taste data should be added to correctly parsed ingredients.
        :type include_taste: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._analyze_recipe_serialize(
            analyze_recipe_request=analyze_recipe_request,
            language=language,
            include_nutrition=include_nutrition,
            include_taste=include_taste,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _analyze_recipe_serialize(
        self,
        analyze_recipe_request,
        language,
        include_nutrition,
        include_taste,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if language is not None:
            
            _query_params.append(('language', language))
            
        if include_nutrition is not None:
            
            _query_params.append(('includeNutrition', include_nutrition))
            
        if include_taste is not None:
            
            _query_params.append(('includeTaste', include_taste))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if analyze_recipe_request is not None:
            _body_params = analyze_recipe_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        '', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/recipes/analyze',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_recipe_card_get(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The recipe id.")],
        mask: Annotated[Optional[StrictStr], Field(description="The mask to put over the recipe image (\"ellipseMask\", \"diamondMask\", \"starMask\", \"heartMask\", \"potMask\", \"fishMask\").")] = None,
        background_image: Annotated[Optional[StrictStr], Field(description="The background image (\"none\",\"background1\", or \"background2\").")] = None,
        background_color: Annotated[Optional[StrictStr], Field(description="The background color for the recipe card as a hex-string.")] = None,
        font_color: Annotated[Optional[StrictStr], Field(description="The font color for the recipe card as a hex-string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Create Recipe Card

        Generate a recipe card for a recipe.

        :param id: The recipe id. (required)
        :type id: float
        :param mask: The mask to put over the recipe image (\"ellipseMask\", \"diamondMask\", \"starMask\", \"heartMask\", \"potMask\", \"fishMask\").
        :type mask: str
        :param background_image: The background image (\"none\",\"background1\", or \"background2\").
        :type background_image: str
        :param background_color: The background color for the recipe card as a hex-string.
        :type background_color: str
        :param font_color: The font color for the recipe card as a hex-string.
        :type font_color: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_recipe_card_get_serialize(
            id=id,
            mask=mask,
            background_image=background_image,
            background_color=background_color,
            font_color=font_color,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_recipe_card_get_with_http_info(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The recipe id.")],
        mask: Annotated[Optional[StrictStr], Field(description="The mask to put over the recipe image (\"ellipseMask\", \"diamondMask\", \"starMask\", \"heartMask\", \"potMask\", \"fishMask\").")] = None,
        background_image: Annotated[Optional[StrictStr], Field(description="The background image (\"none\",\"background1\", or \"background2\").")] = None,
        background_color: Annotated[Optional[StrictStr], Field(description="The background color for the recipe card as a hex-string.")] = None,
        font_color: Annotated[Optional[StrictStr], Field(description="The font color for the recipe card as a hex-string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Create Recipe Card

        Generate a recipe card for a recipe.

        :param id: The recipe id. (required)
        :type id: float
        :param mask: The mask to put over the recipe image (\"ellipseMask\", \"diamondMask\", \"starMask\", \"heartMask\", \"potMask\", \"fishMask\").
        :type mask: str
        :param background_image: The background image (\"none\",\"background1\", or \"background2\").
        :type background_image: str
        :param background_color: The background color for the recipe card as a hex-string.
        :type background_color: str
        :param font_color: The font color for the recipe card as a hex-string.
        :type font_color: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_recipe_card_get_serialize(
            id=id,
            mask=mask,
            background_image=background_image,
            background_color=background_color,
            font_color=font_color,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_recipe_card_get_without_preload_content(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The recipe id.")],
        mask: Annotated[Optional[StrictStr], Field(description="The mask to put over the recipe image (\"ellipseMask\", \"diamondMask\", \"starMask\", \"heartMask\", \"potMask\", \"fishMask\").")] = None,
        background_image: Annotated[Optional[StrictStr], Field(description="The background image (\"none\",\"background1\", or \"background2\").")] = None,
        background_color: Annotated[Optional[StrictStr], Field(description="The background color for the recipe card as a hex-string.")] = None,
        font_color: Annotated[Optional[StrictStr], Field(description="The font color for the recipe card as a hex-string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Recipe Card

        Generate a recipe card for a recipe.

        :param id: The recipe id. (required)
        :type id: float
        :param mask: The mask to put over the recipe image (\"ellipseMask\", \"diamondMask\", \"starMask\", \"heartMask\", \"potMask\", \"fishMask\").
        :type mask: str
        :param background_image: The background image (\"none\",\"background1\", or \"background2\").
        :type background_image: str
        :param background_color: The background color for the recipe card as a hex-string.
        :type background_color: str
        :param font_color: The font color for the recipe card as a hex-string.
        :type font_color: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_recipe_card_get_serialize(
            id=id,
            mask=mask,
            background_image=background_image,
            background_color=background_color,
            font_color=font_color,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_recipe_card_get_serialize(
        self,
        id,
        mask,
        background_image,
        background_color,
        font_color,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if mask is not None:
            
            _query_params.append(('mask', mask))
            
        if background_image is not None:
            
            _query_params.append(('backgroundImage', background_image))
            
        if background_color is not None:
            
            _query_params.append(('backgroundColor', background_color))
            
        if font_color is not None:
            
            _query_params.append(('fontColor', font_color))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipes/{id}/card',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_restaurants(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The search query.")] = None,
        lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the user's location.")] = None,
        lng: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the user's location.\".")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The distance around the location in miles.")] = None,
        budget: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The user's budget for a meal in USD.")] = None,
        cuisine: Annotated[Optional[StrictStr], Field(description="The cuisine of the restaurant.")] = None,
        min_rating: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum rating of the restaurant between 0 and 5.")] = None,
        is_open: Annotated[Optional[StrictBool], Field(description="Whether the restaurant must be open at the time of search.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="How to sort the results, one of the following 'cheapest', 'fastest', 'rating', 'distance' or the default 'relevance'.")] = None,
        page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The page number of results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SearchRestaurants200Response:
        """Search Restaurants

        Search through thousands of restaurants (in North America) by location, cuisine, budget, and more.

        :param query: The search query.
        :type query: str
        :param lat: The latitude of the user's location.
        :type lat: float
        :param lng: The longitude of the user's location.\".
        :type lng: float
        :param distance: The distance around the location in miles.
        :type distance: float
        :param budget: The user's budget for a meal in USD.
        :type budget: float
        :param cuisine: The cuisine of the restaurant.
        :type cuisine: str
        :param min_rating: The minimum rating of the restaurant between 0 and 5.
        :type min_rating: float
        :param is_open: Whether the restaurant must be open at the time of search.
        :type is_open: bool
        :param sort: How to sort the results, one of the following 'cheapest', 'fastest', 'rating', 'distance' or the default 'relevance'.
        :type sort: str
        :param page: The page number of results.
        :type page: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_restaurants_serialize(
            query=query,
            lat=lat,
            lng=lng,
            distance=distance,
            budget=budget,
            cuisine=cuisine,
            min_rating=min_rating,
            is_open=is_open,
            sort=sort,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchRestaurants200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_restaurants_with_http_info(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The search query.")] = None,
        lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the user's location.")] = None,
        lng: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the user's location.\".")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The distance around the location in miles.")] = None,
        budget: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The user's budget for a meal in USD.")] = None,
        cuisine: Annotated[Optional[StrictStr], Field(description="The cuisine of the restaurant.")] = None,
        min_rating: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum rating of the restaurant between 0 and 5.")] = None,
        is_open: Annotated[Optional[StrictBool], Field(description="Whether the restaurant must be open at the time of search.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="How to sort the results, one of the following 'cheapest', 'fastest', 'rating', 'distance' or the default 'relevance'.")] = None,
        page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The page number of results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SearchRestaurants200Response]:
        """Search Restaurants

        Search through thousands of restaurants (in North America) by location, cuisine, budget, and more.

        :param query: The search query.
        :type query: str
        :param lat: The latitude of the user's location.
        :type lat: float
        :param lng: The longitude of the user's location.\".
        :type lng: float
        :param distance: The distance around the location in miles.
        :type distance: float
        :param budget: The user's budget for a meal in USD.
        :type budget: float
        :param cuisine: The cuisine of the restaurant.
        :type cuisine: str
        :param min_rating: The minimum rating of the restaurant between 0 and 5.
        :type min_rating: float
        :param is_open: Whether the restaurant must be open at the time of search.
        :type is_open: bool
        :param sort: How to sort the results, one of the following 'cheapest', 'fastest', 'rating', 'distance' or the default 'relevance'.
        :type sort: str
        :param page: The page number of results.
        :type page: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_restaurants_serialize(
            query=query,
            lat=lat,
            lng=lng,
            distance=distance,
            budget=budget,
            cuisine=cuisine,
            min_rating=min_rating,
            is_open=is_open,
            sort=sort,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchRestaurants200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_restaurants_without_preload_content(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The search query.")] = None,
        lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the user's location.")] = None,
        lng: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the user's location.\".")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The distance around the location in miles.")] = None,
        budget: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The user's budget for a meal in USD.")] = None,
        cuisine: Annotated[Optional[StrictStr], Field(description="The cuisine of the restaurant.")] = None,
        min_rating: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum rating of the restaurant between 0 and 5.")] = None,
        is_open: Annotated[Optional[StrictBool], Field(description="Whether the restaurant must be open at the time of search.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="How to sort the results, one of the following 'cheapest', 'fastest', 'rating', 'distance' or the default 'relevance'.")] = None,
        page: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The page number of results.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Restaurants

        Search through thousands of restaurants (in North America) by location, cuisine, budget, and more.

        :param query: The search query.
        :type query: str
        :param lat: The latitude of the user's location.
        :type lat: float
        :param lng: The longitude of the user's location.\".
        :type lng: float
        :param distance: The distance around the location in miles.
        :type distance: float
        :param budget: The user's budget for a meal in USD.
        :type budget: float
        :param cuisine: The cuisine of the restaurant.
        :type cuisine: str
        :param min_rating: The minimum rating of the restaurant between 0 and 5.
        :type min_rating: float
        :param is_open: Whether the restaurant must be open at the time of search.
        :type is_open: bool
        :param sort: How to sort the results, one of the following 'cheapest', 'fastest', 'rating', 'distance' or the default 'relevance'.
        :type sort: str
        :param page: The page number of results.
        :type page: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_restaurants_serialize(
            query=query,
            lat=lat,
            lng=lng,
            distance=distance,
            budget=budget,
            cuisine=cuisine,
            min_rating=min_rating,
            is_open=is_open,
            sort=sort,
            page=page,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchRestaurants200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_restaurants_serialize(
        self,
        query,
        lat,
        lng,
        distance,
        budget,
        cuisine,
        min_rating,
        is_open,
        sort,
        page,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if lat is not None:
            
            _query_params.append(('lat', lat))
            
        if lng is not None:
            
            _query_params.append(('lng', lng))
            
        if distance is not None:
            
            _query_params.append(('distance', distance))
            
        if budget is not None:
            
            _query_params.append(('budget', budget))
            
        if cuisine is not None:
            
            _query_params.append(('cuisine', cuisine))
            
        if min_rating is not None:
            
            _query_params.append(('min-rating', min_rating))
            
        if is_open is not None:
            
            _query_params.append(('is-open', is_open))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if page is not None:
            
            _query_params.append(('page', page))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/restaurants/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


