# coding: utf-8

"""
    spoonacular API

    The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

    The version of the OpenAPI document: 1.1
    Contact: mail@spoonacular.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.autocomplete_ingredient_search200_response_inner import AutocompleteIngredientSearch200ResponseInner
from openapi_client.models.compute_ingredient_amount200_response import ComputeIngredientAmount200Response
from openapi_client.models.get_ingredient_information200_response import GetIngredientInformation200Response
from openapi_client.models.get_ingredient_substitutes200_response import GetIngredientSubstitutes200Response
from openapi_client.models.ingredient_search200_response import IngredientSearch200Response
from openapi_client.models.map_ingredients_to_grocery_products200_response_inner import MapIngredientsToGroceryProducts200ResponseInner
from openapi_client.models.map_ingredients_to_grocery_products_request import MapIngredientsToGroceryProductsRequest

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class IngredientsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def autocomplete_ingredient_search(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The (natural language) search query.")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to return (between 1 and 100). Defaults to 10.")] = None,
        meta_information: Annotated[Optional[StrictBool], Field(description="Whether to return more meta information about the ingredients.")] = None,
        intolerances: Annotated[Optional[StrictStr], Field(description="A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="The language of the input. Either 'en' or 'de'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AutocompleteIngredientSearch200ResponseInner]:
        """Autocomplete Ingredient Search

        Autocomplete the entry of an ingredient.

        :param query: The (natural language) search query.
        :type query: str
        :param number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :type number: int
        :param meta_information: Whether to return more meta information about the ingredients.
        :type meta_information: bool
        :param intolerances: A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
        :type intolerances: str
        :param language: The language of the input. Either 'en' or 'de'.
        :type language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_ingredient_search_serialize(
            query=query,
            number=number,
            meta_information=meta_information,
            intolerances=intolerances,
            language=language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AutocompleteIngredientSearch200ResponseInner]",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def autocomplete_ingredient_search_with_http_info(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The (natural language) search query.")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to return (between 1 and 100). Defaults to 10.")] = None,
        meta_information: Annotated[Optional[StrictBool], Field(description="Whether to return more meta information about the ingredients.")] = None,
        intolerances: Annotated[Optional[StrictStr], Field(description="A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="The language of the input. Either 'en' or 'de'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AutocompleteIngredientSearch200ResponseInner]]:
        """Autocomplete Ingredient Search

        Autocomplete the entry of an ingredient.

        :param query: The (natural language) search query.
        :type query: str
        :param number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :type number: int
        :param meta_information: Whether to return more meta information about the ingredients.
        :type meta_information: bool
        :param intolerances: A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
        :type intolerances: str
        :param language: The language of the input. Either 'en' or 'de'.
        :type language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_ingredient_search_serialize(
            query=query,
            number=number,
            meta_information=meta_information,
            intolerances=intolerances,
            language=language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AutocompleteIngredientSearch200ResponseInner]",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def autocomplete_ingredient_search_without_preload_content(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The (natural language) search query.")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to return (between 1 and 100). Defaults to 10.")] = None,
        meta_information: Annotated[Optional[StrictBool], Field(description="Whether to return more meta information about the ingredients.")] = None,
        intolerances: Annotated[Optional[StrictStr], Field(description="A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="The language of the input. Either 'en' or 'de'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Autocomplete Ingredient Search

        Autocomplete the entry of an ingredient.

        :param query: The (natural language) search query.
        :type query: str
        :param number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :type number: int
        :param meta_information: Whether to return more meta information about the ingredients.
        :type meta_information: bool
        :param intolerances: A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
        :type intolerances: str
        :param language: The language of the input. Either 'en' or 'de'.
        :type language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_ingredient_search_serialize(
            query=query,
            number=number,
            meta_information=meta_information,
            intolerances=intolerances,
            language=language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AutocompleteIngredientSearch200ResponseInner]",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _autocomplete_ingredient_search_serialize(
        self,
        query,
        number,
        meta_information,
        intolerances,
        language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if number is not None:
            
            _query_params.append(('number', number))
            
        if meta_information is not None:
            
            _query_params.append(('metaInformation', meta_information))
            
        if intolerances is not None:
            
            _query_params.append(('intolerances', intolerances))
            
        if language is not None:
            
            _query_params.append(('language', language))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/ingredients/autocomplete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def compute_ingredient_amount(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The id of the ingredient you want the amount for.")],
        nutrient: Annotated[StrictStr, Field(description="The target nutrient. See a list of supported nutrients.")],
        target: Annotated[Union[StrictFloat, StrictInt], Field(description="The target number of the given nutrient.")],
        unit: Annotated[Optional[StrictStr], Field(description="The target unit.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ComputeIngredientAmount200Response:
        """Compute Ingredient Amount

        Compute the amount you need of a certain ingredient for a certain nutritional goal. For example, how much pineapple do you have to eat to get 10 grams of protein?

        :param id: The id of the ingredient you want the amount for. (required)
        :type id: float
        :param nutrient: The target nutrient. See a list of supported nutrients. (required)
        :type nutrient: str
        :param target: The target number of the given nutrient. (required)
        :type target: float
        :param unit: The target unit.
        :type unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._compute_ingredient_amount_serialize(
            id=id,
            nutrient=nutrient,
            target=target,
            unit=unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeIngredientAmount200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def compute_ingredient_amount_with_http_info(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The id of the ingredient you want the amount for.")],
        nutrient: Annotated[StrictStr, Field(description="The target nutrient. See a list of supported nutrients.")],
        target: Annotated[Union[StrictFloat, StrictInt], Field(description="The target number of the given nutrient.")],
        unit: Annotated[Optional[StrictStr], Field(description="The target unit.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ComputeIngredientAmount200Response]:
        """Compute Ingredient Amount

        Compute the amount you need of a certain ingredient for a certain nutritional goal. For example, how much pineapple do you have to eat to get 10 grams of protein?

        :param id: The id of the ingredient you want the amount for. (required)
        :type id: float
        :param nutrient: The target nutrient. See a list of supported nutrients. (required)
        :type nutrient: str
        :param target: The target number of the given nutrient. (required)
        :type target: float
        :param unit: The target unit.
        :type unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._compute_ingredient_amount_serialize(
            id=id,
            nutrient=nutrient,
            target=target,
            unit=unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeIngredientAmount200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def compute_ingredient_amount_without_preload_content(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The id of the ingredient you want the amount for.")],
        nutrient: Annotated[StrictStr, Field(description="The target nutrient. See a list of supported nutrients.")],
        target: Annotated[Union[StrictFloat, StrictInt], Field(description="The target number of the given nutrient.")],
        unit: Annotated[Optional[StrictStr], Field(description="The target unit.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Compute Ingredient Amount

        Compute the amount you need of a certain ingredient for a certain nutritional goal. For example, how much pineapple do you have to eat to get 10 grams of protein?

        :param id: The id of the ingredient you want the amount for. (required)
        :type id: float
        :param nutrient: The target nutrient. See a list of supported nutrients. (required)
        :type nutrient: str
        :param target: The target number of the given nutrient. (required)
        :type target: float
        :param unit: The target unit.
        :type unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._compute_ingredient_amount_serialize(
            id=id,
            nutrient=nutrient,
            target=target,
            unit=unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ComputeIngredientAmount200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _compute_ingredient_amount_serialize(
        self,
        id,
        nutrient,
        target,
        unit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if nutrient is not None:
            
            _query_params.append(('nutrient', nutrient))
            
        if target is not None:
            
            _query_params.append(('target', target))
            
        if unit is not None:
            
            _query_params.append(('unit', unit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/ingredients/{id}/amount',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ingredient_information(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The amount of this ingredient.")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="The unit for the given amount.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetIngredientInformation200Response:
        """Get Ingredient Information

        Use an ingredient id to get all available information about an ingredient, such as its image and supermarket aisle.

        :param id: The item's id. (required)
        :type id: int
        :param amount: The amount of this ingredient.
        :type amount: float
        :param unit: The unit for the given amount.
        :type unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ingredient_information_serialize(
            id=id,
            amount=amount,
            unit=unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIngredientInformation200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ingredient_information_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The amount of this ingredient.")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="The unit for the given amount.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetIngredientInformation200Response]:
        """Get Ingredient Information

        Use an ingredient id to get all available information about an ingredient, such as its image and supermarket aisle.

        :param id: The item's id. (required)
        :type id: int
        :param amount: The amount of this ingredient.
        :type amount: float
        :param unit: The unit for the given amount.
        :type unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ingredient_information_serialize(
            id=id,
            amount=amount,
            unit=unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIngredientInformation200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ingredient_information_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        amount: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The amount of this ingredient.")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="The unit for the given amount.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Ingredient Information

        Use an ingredient id to get all available information about an ingredient, such as its image and supermarket aisle.

        :param id: The item's id. (required)
        :type id: int
        :param amount: The amount of this ingredient.
        :type amount: float
        :param unit: The unit for the given amount.
        :type unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ingredient_information_serialize(
            id=id,
            amount=amount,
            unit=unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIngredientInformation200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ingredient_information_serialize(
        self,
        id,
        amount,
        unit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if amount is not None:
            
            _query_params.append(('amount', amount))
            
        if unit is not None:
            
            _query_params.append(('unit', unit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/ingredients/{id}/information',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ingredient_substitutes(
        self,
        ingredient_name: Annotated[StrictStr, Field(description="The name of the ingredient you want to replace.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetIngredientSubstitutes200Response:
        """Get Ingredient Substitutes

        Search for substitutes for a given ingredient.

        :param ingredient_name: The name of the ingredient you want to replace. (required)
        :type ingredient_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ingredient_substitutes_serialize(
            ingredient_name=ingredient_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIngredientSubstitutes200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ingredient_substitutes_with_http_info(
        self,
        ingredient_name: Annotated[StrictStr, Field(description="The name of the ingredient you want to replace.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetIngredientSubstitutes200Response]:
        """Get Ingredient Substitutes

        Search for substitutes for a given ingredient.

        :param ingredient_name: The name of the ingredient you want to replace. (required)
        :type ingredient_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ingredient_substitutes_serialize(
            ingredient_name=ingredient_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIngredientSubstitutes200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ingredient_substitutes_without_preload_content(
        self,
        ingredient_name: Annotated[StrictStr, Field(description="The name of the ingredient you want to replace.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Ingredient Substitutes

        Search for substitutes for a given ingredient.

        :param ingredient_name: The name of the ingredient you want to replace. (required)
        :type ingredient_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ingredient_substitutes_serialize(
            ingredient_name=ingredient_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIngredientSubstitutes200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ingredient_substitutes_serialize(
        self,
        ingredient_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ingredient_name is not None:
            
            _query_params.append(('ingredientName', ingredient_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/ingredients/substitutes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ingredient_substitutes_by_id(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetIngredientSubstitutes200Response:
        """Get Ingredient Substitutes by ID

        Search for substitutes for a given ingredient.

        :param id: The item's id. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ingredient_substitutes_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIngredientSubstitutes200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ingredient_substitutes_by_id_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetIngredientSubstitutes200Response]:
        """Get Ingredient Substitutes by ID

        Search for substitutes for a given ingredient.

        :param id: The item's id. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ingredient_substitutes_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIngredientSubstitutes200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ingredient_substitutes_by_id_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The item's id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Ingredient Substitutes by ID

        Search for substitutes for a given ingredient.

        :param id: The item's id. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ingredient_substitutes_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIngredientSubstitutes200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ingredient_substitutes_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/ingredients/{id}/substitutes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingredient_search(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The (natural language) search query.")] = None,
        add_children: Annotated[Optional[StrictBool], Field(description="Whether to add children of found foods.")] = None,
        min_protein_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum percentage of protein the food must have (between 0 and 100).")] = None,
        max_protein_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum percentage of protein the food can have (between 0 and 100).")] = None,
        min_fat_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum percentage of fat the food must have (between 0 and 100).")] = None,
        max_fat_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum percentage of fat the food can have (between 0 and 100).")] = None,
        min_carbs_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum percentage of carbs the food must have (between 0 and 100).")] = None,
        max_carbs_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum percentage of carbs the food can have (between 0 and 100).")] = None,
        meta_information: Annotated[Optional[StrictBool], Field(description="Whether to return more meta information about the ingredients.")] = None,
        intolerances: Annotated[Optional[StrictStr], Field(description="A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="The strategy to sort recipes by. See a full list of supported sorting options.")] = None,
        sort_direction: Annotated[Optional[StrictStr], Field(description="The direction in which to sort. Must be either 'asc' (ascending) or 'desc' (descending).")] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=900, strict=True, ge=0)]], Field(description="The number of results to skip (between 0 and 900).")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to return (between 1 and 100). Defaults to 10.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="The language of the input. Either 'en' or 'de'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IngredientSearch200Response:
        """Ingredient Search

        Search for simple whole foods (e.g. fruits, vegetables, nuts, grains, meat, fish, dairy etc.).

        :param query: The (natural language) search query.
        :type query: str
        :param add_children: Whether to add children of found foods.
        :type add_children: bool
        :param min_protein_percent: The minimum percentage of protein the food must have (between 0 and 100).
        :type min_protein_percent: float
        :param max_protein_percent: The maximum percentage of protein the food can have (between 0 and 100).
        :type max_protein_percent: float
        :param min_fat_percent: The minimum percentage of fat the food must have (between 0 and 100).
        :type min_fat_percent: float
        :param max_fat_percent: The maximum percentage of fat the food can have (between 0 and 100).
        :type max_fat_percent: float
        :param min_carbs_percent: The minimum percentage of carbs the food must have (between 0 and 100).
        :type min_carbs_percent: float
        :param max_carbs_percent: The maximum percentage of carbs the food can have (between 0 and 100).
        :type max_carbs_percent: float
        :param meta_information: Whether to return more meta information about the ingredients.
        :type meta_information: bool
        :param intolerances: A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
        :type intolerances: str
        :param sort: The strategy to sort recipes by. See a full list of supported sorting options.
        :type sort: str
        :param sort_direction: The direction in which to sort. Must be either 'asc' (ascending) or 'desc' (descending).
        :type sort_direction: str
        :param offset: The number of results to skip (between 0 and 900).
        :type offset: int
        :param number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :type number: int
        :param language: The language of the input. Either 'en' or 'de'.
        :type language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingredient_search_serialize(
            query=query,
            add_children=add_children,
            min_protein_percent=min_protein_percent,
            max_protein_percent=max_protein_percent,
            min_fat_percent=min_fat_percent,
            max_fat_percent=max_fat_percent,
            min_carbs_percent=min_carbs_percent,
            max_carbs_percent=max_carbs_percent,
            meta_information=meta_information,
            intolerances=intolerances,
            sort=sort,
            sort_direction=sort_direction,
            offset=offset,
            number=number,
            language=language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IngredientSearch200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingredient_search_with_http_info(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The (natural language) search query.")] = None,
        add_children: Annotated[Optional[StrictBool], Field(description="Whether to add children of found foods.")] = None,
        min_protein_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum percentage of protein the food must have (between 0 and 100).")] = None,
        max_protein_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum percentage of protein the food can have (between 0 and 100).")] = None,
        min_fat_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum percentage of fat the food must have (between 0 and 100).")] = None,
        max_fat_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum percentage of fat the food can have (between 0 and 100).")] = None,
        min_carbs_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum percentage of carbs the food must have (between 0 and 100).")] = None,
        max_carbs_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum percentage of carbs the food can have (between 0 and 100).")] = None,
        meta_information: Annotated[Optional[StrictBool], Field(description="Whether to return more meta information about the ingredients.")] = None,
        intolerances: Annotated[Optional[StrictStr], Field(description="A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="The strategy to sort recipes by. See a full list of supported sorting options.")] = None,
        sort_direction: Annotated[Optional[StrictStr], Field(description="The direction in which to sort. Must be either 'asc' (ascending) or 'desc' (descending).")] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=900, strict=True, ge=0)]], Field(description="The number of results to skip (between 0 and 900).")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to return (between 1 and 100). Defaults to 10.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="The language of the input. Either 'en' or 'de'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IngredientSearch200Response]:
        """Ingredient Search

        Search for simple whole foods (e.g. fruits, vegetables, nuts, grains, meat, fish, dairy etc.).

        :param query: The (natural language) search query.
        :type query: str
        :param add_children: Whether to add children of found foods.
        :type add_children: bool
        :param min_protein_percent: The minimum percentage of protein the food must have (between 0 and 100).
        :type min_protein_percent: float
        :param max_protein_percent: The maximum percentage of protein the food can have (between 0 and 100).
        :type max_protein_percent: float
        :param min_fat_percent: The minimum percentage of fat the food must have (between 0 and 100).
        :type min_fat_percent: float
        :param max_fat_percent: The maximum percentage of fat the food can have (between 0 and 100).
        :type max_fat_percent: float
        :param min_carbs_percent: The minimum percentage of carbs the food must have (between 0 and 100).
        :type min_carbs_percent: float
        :param max_carbs_percent: The maximum percentage of carbs the food can have (between 0 and 100).
        :type max_carbs_percent: float
        :param meta_information: Whether to return more meta information about the ingredients.
        :type meta_information: bool
        :param intolerances: A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
        :type intolerances: str
        :param sort: The strategy to sort recipes by. See a full list of supported sorting options.
        :type sort: str
        :param sort_direction: The direction in which to sort. Must be either 'asc' (ascending) or 'desc' (descending).
        :type sort_direction: str
        :param offset: The number of results to skip (between 0 and 900).
        :type offset: int
        :param number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :type number: int
        :param language: The language of the input. Either 'en' or 'de'.
        :type language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingredient_search_serialize(
            query=query,
            add_children=add_children,
            min_protein_percent=min_protein_percent,
            max_protein_percent=max_protein_percent,
            min_fat_percent=min_fat_percent,
            max_fat_percent=max_fat_percent,
            min_carbs_percent=min_carbs_percent,
            max_carbs_percent=max_carbs_percent,
            meta_information=meta_information,
            intolerances=intolerances,
            sort=sort,
            sort_direction=sort_direction,
            offset=offset,
            number=number,
            language=language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IngredientSearch200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingredient_search_without_preload_content(
        self,
        query: Annotated[Optional[StrictStr], Field(description="The (natural language) search query.")] = None,
        add_children: Annotated[Optional[StrictBool], Field(description="Whether to add children of found foods.")] = None,
        min_protein_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum percentage of protein the food must have (between 0 and 100).")] = None,
        max_protein_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum percentage of protein the food can have (between 0 and 100).")] = None,
        min_fat_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum percentage of fat the food must have (between 0 and 100).")] = None,
        max_fat_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum percentage of fat the food can have (between 0 and 100).")] = None,
        min_carbs_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The minimum percentage of carbs the food must have (between 0 and 100).")] = None,
        max_carbs_percent: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum percentage of carbs the food can have (between 0 and 100).")] = None,
        meta_information: Annotated[Optional[StrictBool], Field(description="Whether to return more meta information about the ingredients.")] = None,
        intolerances: Annotated[Optional[StrictStr], Field(description="A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="The strategy to sort recipes by. See a full list of supported sorting options.")] = None,
        sort_direction: Annotated[Optional[StrictStr], Field(description="The direction in which to sort. Must be either 'asc' (ascending) or 'desc' (descending).")] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=900, strict=True, ge=0)]], Field(description="The number of results to skip (between 0 and 900).")] = None,
        number: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of items to return (between 1 and 100). Defaults to 10.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="The language of the input. Either 'en' or 'de'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Ingredient Search

        Search for simple whole foods (e.g. fruits, vegetables, nuts, grains, meat, fish, dairy etc.).

        :param query: The (natural language) search query.
        :type query: str
        :param add_children: Whether to add children of found foods.
        :type add_children: bool
        :param min_protein_percent: The minimum percentage of protein the food must have (between 0 and 100).
        :type min_protein_percent: float
        :param max_protein_percent: The maximum percentage of protein the food can have (between 0 and 100).
        :type max_protein_percent: float
        :param min_fat_percent: The minimum percentage of fat the food must have (between 0 and 100).
        :type min_fat_percent: float
        :param max_fat_percent: The maximum percentage of fat the food can have (between 0 and 100).
        :type max_fat_percent: float
        :param min_carbs_percent: The minimum percentage of carbs the food must have (between 0 and 100).
        :type min_carbs_percent: float
        :param max_carbs_percent: The maximum percentage of carbs the food can have (between 0 and 100).
        :type max_carbs_percent: float
        :param meta_information: Whether to return more meta information about the ingredients.
        :type meta_information: bool
        :param intolerances: A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
        :type intolerances: str
        :param sort: The strategy to sort recipes by. See a full list of supported sorting options.
        :type sort: str
        :param sort_direction: The direction in which to sort. Must be either 'asc' (ascending) or 'desc' (descending).
        :type sort_direction: str
        :param offset: The number of results to skip (between 0 and 900).
        :type offset: int
        :param number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :type number: int
        :param language: The language of the input. Either 'en' or 'de'.
        :type language: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingredient_search_serialize(
            query=query,
            add_children=add_children,
            min_protein_percent=min_protein_percent,
            max_protein_percent=max_protein_percent,
            min_fat_percent=min_fat_percent,
            max_fat_percent=max_fat_percent,
            min_carbs_percent=min_carbs_percent,
            max_carbs_percent=max_carbs_percent,
            meta_information=meta_information,
            intolerances=intolerances,
            sort=sort,
            sort_direction=sort_direction,
            offset=offset,
            number=number,
            language=language,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IngredientSearch200Response",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingredient_search_serialize(
        self,
        query,
        add_children,
        min_protein_percent,
        max_protein_percent,
        min_fat_percent,
        max_fat_percent,
        min_carbs_percent,
        max_carbs_percent,
        meta_information,
        intolerances,
        sort,
        sort_direction,
        offset,
        number,
        language,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if add_children is not None:
            
            _query_params.append(('addChildren', add_children))
            
        if min_protein_percent is not None:
            
            _query_params.append(('minProteinPercent', min_protein_percent))
            
        if max_protein_percent is not None:
            
            _query_params.append(('maxProteinPercent', max_protein_percent))
            
        if min_fat_percent is not None:
            
            _query_params.append(('minFatPercent', min_fat_percent))
            
        if max_fat_percent is not None:
            
            _query_params.append(('maxFatPercent', max_fat_percent))
            
        if min_carbs_percent is not None:
            
            _query_params.append(('minCarbsPercent', min_carbs_percent))
            
        if max_carbs_percent is not None:
            
            _query_params.append(('maxCarbsPercent', max_carbs_percent))
            
        if meta_information is not None:
            
            _query_params.append(('metaInformation', meta_information))
            
        if intolerances is not None:
            
            _query_params.append(('intolerances', intolerances))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if sort_direction is not None:
            
            _query_params.append(('sortDirection', sort_direction))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if number is not None:
            
            _query_params.append(('number', number))
            
        if language is not None:
            
            _query_params.append(('language', language))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/food/ingredients/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ingredients_by_id_image(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The recipe id.")],
        measure: Annotated[Optional[StrictStr], Field(description="Whether the the measures should be 'us' or 'metric'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Ingredients by ID Image

        Visualize a recipe's ingredient list.

        :param id: The recipe id. (required)
        :type id: float
        :param measure: Whether the the measures should be 'us' or 'metric'.
        :type measure: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingredients_by_id_image_serialize(
            id=id,
            measure=measure,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ingredients_by_id_image_with_http_info(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The recipe id.")],
        measure: Annotated[Optional[StrictStr], Field(description="Whether the the measures should be 'us' or 'metric'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Ingredients by ID Image

        Visualize a recipe's ingredient list.

        :param id: The recipe id. (required)
        :type id: float
        :param measure: Whether the the measures should be 'us' or 'metric'.
        :type measure: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingredients_by_id_image_serialize(
            id=id,
            measure=measure,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ingredients_by_id_image_without_preload_content(
        self,
        id: Annotated[Union[StrictFloat, StrictInt], Field(description="The recipe id.")],
        measure: Annotated[Optional[StrictStr], Field(description="Whether the the measures should be 'us' or 'metric'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Ingredients by ID Image

        Visualize a recipe's ingredient list.

        :param id: The recipe id. (required)
        :type id: float
        :param measure: Whether the the measures should be 'us' or 'metric'.
        :type measure: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ingredients_by_id_image_serialize(
            id=id,
            measure=measure,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ingredients_by_id_image_serialize(
        self,
        id,
        measure,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if measure is not None:
            
            _query_params.append(('measure', measure))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'image/png'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipes/{id}/ingredientWidget.png',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def map_ingredients_to_grocery_products(
        self,
        map_ingredients_to_grocery_products_request: MapIngredientsToGroceryProductsRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[MapIngredientsToGroceryProducts200ResponseInner]:
        """Map Ingredients to Grocery Products

        Map a set of ingredients to products you can buy in the grocery store.

        :param map_ingredients_to_grocery_products_request: (required)
        :type map_ingredients_to_grocery_products_request: MapIngredientsToGroceryProductsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._map_ingredients_to_grocery_products_serialize(
            map_ingredients_to_grocery_products_request=map_ingredients_to_grocery_products_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MapIngredientsToGroceryProducts200ResponseInner]",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def map_ingredients_to_grocery_products_with_http_info(
        self,
        map_ingredients_to_grocery_products_request: MapIngredientsToGroceryProductsRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[MapIngredientsToGroceryProducts200ResponseInner]]:
        """Map Ingredients to Grocery Products

        Map a set of ingredients to products you can buy in the grocery store.

        :param map_ingredients_to_grocery_products_request: (required)
        :type map_ingredients_to_grocery_products_request: MapIngredientsToGroceryProductsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._map_ingredients_to_grocery_products_serialize(
            map_ingredients_to_grocery_products_request=map_ingredients_to_grocery_products_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MapIngredientsToGroceryProducts200ResponseInner]",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def map_ingredients_to_grocery_products_without_preload_content(
        self,
        map_ingredients_to_grocery_products_request: MapIngredientsToGroceryProductsRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Map Ingredients to Grocery Products

        Map a set of ingredients to products you can buy in the grocery store.

        :param map_ingredients_to_grocery_products_request: (required)
        :type map_ingredients_to_grocery_products_request: MapIngredientsToGroceryProductsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._map_ingredients_to_grocery_products_serialize(
            map_ingredients_to_grocery_products_request=map_ingredients_to_grocery_products_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MapIngredientsToGroceryProducts200ResponseInner]",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _map_ingredients_to_grocery_products_serialize(
        self,
        map_ingredients_to_grocery_products_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if map_ingredients_to_grocery_products_request is not None:
            _body_params = map_ingredients_to_grocery_products_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/food/ingredients/map',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def visualize_ingredients(
        self,
        content_type: Annotated[Optional[StrictStr], Field(description="The content type.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="The language of the input. Either 'en' or 'de'.")] = None,
        accept: Annotated[Optional[StrictStr], Field(description="Accept header.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Ingredients Widget

        Visualize ingredients of a recipe. You can play around with that endpoint!

        :param content_type: The content type.
        :type content_type: str
        :param language: The language of the input. Either 'en' or 'de'.
        :type language: str
        :param accept: Accept header.
        :type accept: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._visualize_ingredients_serialize(
            content_type=content_type,
            language=language,
            accept=accept,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def visualize_ingredients_with_http_info(
        self,
        content_type: Annotated[Optional[StrictStr], Field(description="The content type.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="The language of the input. Either 'en' or 'de'.")] = None,
        accept: Annotated[Optional[StrictStr], Field(description="Accept header.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Ingredients Widget

        Visualize ingredients of a recipe. You can play around with that endpoint!

        :param content_type: The content type.
        :type content_type: str
        :param language: The language of the input. Either 'en' or 'de'.
        :type language: str
        :param accept: Accept header.
        :type accept: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._visualize_ingredients_serialize(
            content_type=content_type,
            language=language,
            accept=accept,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def visualize_ingredients_without_preload_content(
        self,
        content_type: Annotated[Optional[StrictStr], Field(description="The content type.")] = None,
        language: Annotated[Optional[StrictStr], Field(description="The language of the input. Either 'en' or 'de'.")] = None,
        accept: Annotated[Optional[StrictStr], Field(description="Accept header.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Ingredients Widget

        Visualize ingredients of a recipe. You can play around with that endpoint!

        :param content_type: The content type.
        :type content_type: str
        :param language: The language of the input. Either 'en' or 'de'.
        :type language: str
        :param accept: Accept header.
        :type accept: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._visualize_ingredients_serialize(
            content_type=content_type,
            language=language,
            accept=accept,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '403': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _visualize_ingredients_serialize(
        self,
        content_type,
        language,
        accept,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if language is not None:
            
            _query_params.append(('language', language))
            
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/html'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyScheme'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/recipes/visualizeIngredients',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


