# coding: utf-8

"""
    API

    Web API for TL mobile and web app

    The version of the OpenAPI document: 2020-08-10_6-22
    Contact: support@unicorn-solutions.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.gym_article_details_dto import GymArticleDetailsDTO
from openapi_client.models.gym_dto import GymDTO
from typing import Optional, Set
from typing_extensions import Self

class ArticleDTO(BaseModel):
    """
    The ArticleDTO Class. Contains relevant fields of Article DTO by masking actual Article entity's fields in application.             
    """ # noqa: E501
    active_status: Optional[StrictBool] = Field(default=None, description="Active Status ", alias="activeStatus")
    apply_for_all_gyms: Optional[StrictBool] = Field(default=None, alias="applyForAllGyms")
    article_id: Optional[StrictInt] = Field(default=None, alias="articleId")
    available_gyms: List[GymDTO] = Field(alias="availableGyms")
    available_qty: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Default AvailableQty", alias="availableQty")
    barcode: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=100)]] = None
    created_date: Optional[datetime] = Field(default=None, alias="createdDate")
    created_user: Optional[StrictStr] = Field(default=None, alias="createdUser")
    cron_expression: Optional[StrictStr] = Field(default=None, description="Access Schedule CRON Expression ", alias="cronExpression")
    description: Optional[StrictStr] = None
    discount: Optional[Union[Annotated[float, Field(strict=True)], Annotated[int, Field(strict=True)]]] = None
    employee_discount: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Default EmployeeDiscount", alias="employeeDiscount")
    employee_price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Default EmployeePrice", alias="employeePrice")
    gym_articles: Optional[List[GymArticleDetailsDTO]] = Field(default=None, description="Gym Customizations ", alias="gymArticles")
    is_add_on: Optional[StrictBool] = Field(default=None, alias="isAddOn")
    is_inventory_item: Optional[StrictBool] = Field(default=None, description="Default IsInventoryItem of the Article ", alias="isInventoryItem")
    is_obsolete: Optional[StrictBool] = Field(default=None, description="Default IsObsolete of the Article ", alias="isObsolete")
    measure_unit: Annotated[str, Field(min_length=1, strict=True)] = Field(alias="measureUnit")
    modified_date: Optional[datetime] = Field(default=None, alias="modifiedDate")
    modified_user: Optional[StrictStr] = Field(default=None, alias="modifiedUser")
    name: Annotated[str, Field(min_length=0, strict=True, max_length=100)]
    number: Optional[StrictInt] = None
    price: Union[Annotated[float, Field(strict=True)], Annotated[int, Field(strict=True)]]
    reorder_level: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Deafault ReorderLevel", alias="reorderLevel")
    revenue_account_id: Optional[StrictInt] = Field(default=None, description="Default Revenue account", alias="revenueAccountId")
    selling_price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Default SellingPrice", alias="sellingPrice")
    tags: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=200)]] = None
    type: Annotated[str, Field(min_length=1, strict=True)]
    vat: Optional[Union[Annotated[float, Field(strict=True)], Annotated[int, Field(strict=True)]]] = None
    vat_applicable: Optional[StrictBool] = Field(default=None, description="VAT Applicable ", alias="vatApplicable")
    __properties: ClassVar[List[str]] = ["activeStatus", "applyForAllGyms", "articleId", "availableGyms", "availableQty", "barcode", "createdDate", "createdUser", "cronExpression", "description", "discount", "employeeDiscount", "employeePrice", "gymArticles", "isAddOn", "isInventoryItem", "isObsolete", "measureUnit", "modifiedDate", "modifiedUser", "name", "number", "price", "reorderLevel", "revenueAccountId", "sellingPrice", "tags", "type", "vat", "vatApplicable"]

    @field_validator('type')
    def type_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"item|service|access", value):
            raise ValueError(r"must validate the regular expression /item|service|access/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ArticleDTO from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in available_gyms (list)
        _items = []
        if self.available_gyms:
            for _item_available_gyms in self.available_gyms:
                if _item_available_gyms:
                    _items.append(_item_available_gyms.to_dict())
            _dict['availableGyms'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in gym_articles (list)
        _items = []
        if self.gym_articles:
            for _item_gym_articles in self.gym_articles:
                if _item_gym_articles:
                    _items.append(_item_gym_articles.to_dict())
            _dict['gymArticles'] = _items
        # set to None if barcode (nullable) is None
        # and model_fields_set contains the field
        if self.barcode is None and "barcode" in self.model_fields_set:
            _dict['barcode'] = None

        # set to None if created_user (nullable) is None
        # and model_fields_set contains the field
        if self.created_user is None and "created_user" in self.model_fields_set:
            _dict['createdUser'] = None

        # set to None if cron_expression (nullable) is None
        # and model_fields_set contains the field
        if self.cron_expression is None and "cron_expression" in self.model_fields_set:
            _dict['cronExpression'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if gym_articles (nullable) is None
        # and model_fields_set contains the field
        if self.gym_articles is None and "gym_articles" in self.model_fields_set:
            _dict['gymArticles'] = None

        # set to None if modified_user (nullable) is None
        # and model_fields_set contains the field
        if self.modified_user is None and "modified_user" in self.model_fields_set:
            _dict['modifiedUser'] = None

        # set to None if tags (nullable) is None
        # and model_fields_set contains the field
        if self.tags is None and "tags" in self.model_fields_set:
            _dict['tags'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ArticleDTO from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "activeStatus": obj.get("activeStatus"),
            "applyForAllGyms": obj.get("applyForAllGyms"),
            "articleId": obj.get("articleId"),
            "availableGyms": [GymDTO.from_dict(_item) for _item in obj["availableGyms"]] if obj.get("availableGyms") is not None else None,
            "availableQty": obj.get("availableQty"),
            "barcode": obj.get("barcode"),
            "createdDate": obj.get("createdDate"),
            "createdUser": obj.get("createdUser"),
            "cronExpression": obj.get("cronExpression"),
            "description": obj.get("description"),
            "discount": obj.get("discount"),
            "employeeDiscount": obj.get("employeeDiscount"),
            "employeePrice": obj.get("employeePrice"),
            "gymArticles": [GymArticleDetailsDTO.from_dict(_item) for _item in obj["gymArticles"]] if obj.get("gymArticles") is not None else None,
            "isAddOn": obj.get("isAddOn"),
            "isInventoryItem": obj.get("isInventoryItem"),
            "isObsolete": obj.get("isObsolete"),
            "measureUnit": obj.get("measureUnit"),
            "modifiedDate": obj.get("modifiedDate"),
            "modifiedUser": obj.get("modifiedUser"),
            "name": obj.get("name"),
            "number": obj.get("number"),
            "price": obj.get("price"),
            "reorderLevel": obj.get("reorderLevel"),
            "revenueAccountId": obj.get("revenueAccountId"),
            "sellingPrice": obj.get("sellingPrice"),
            "tags": obj.get("tags"),
            "type": obj.get("type"),
            "vat": obj.get("vat"),
            "vatApplicable": obj.get("vatApplicable")
        })
        return _obj


