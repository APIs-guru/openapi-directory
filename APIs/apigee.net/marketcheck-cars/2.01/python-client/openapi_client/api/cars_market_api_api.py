# coding: utf-8

"""
    Marketcheck APIs

    One API serving data spanned across multiple verticals

    The version of the OpenAPI document: 2.01
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from openapi_client.models.daily_stats import DailyStats
from openapi_client.models.fare_value import FareValue
from openapi_client.models.mds import Mds
from openapi_client.models.popular_cars import PopularCars
from openapi_client.models.price_prediction import PricePrediction
from openapi_client.models.sales import Sales

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class CarsMarketAPIApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def fare_value(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vrm: Annotated[Optional[StrictStr], Field(description="Predict price for a VRM")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Car manufacturing year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Car's make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="Car's model")] = None,
        variant: Annotated[Optional[StrictStr], Field(description="Car's variant")] = None,
        miles: Annotated[Optional[StrictInt], Field(description="miles vehicle has driven in total")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="Postal code of the car")] = None,
        radius: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=0)]], Field(description="Radius around the search location (Unit - Miles)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FareValue:
        """Predict fare value of car for UK based on YMMT & miles

        Predict fare value of car for UK based on YMMT & miles

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vrm: Predict price for a VRM
        :type vrm: str
        :param year: Car manufacturing year
        :type year: int
        :param make: Car's make
        :type make: str
        :param model: Car's model
        :type model: str
        :param variant: Car's variant
        :type variant: str
        :param miles: miles vehicle has driven in total
        :type miles: int
        :param postal_code: Postal code of the car
        :type postal_code: str
        :param radius: Radius around the search location (Unit - Miles)
        :type radius: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fare_value_serialize(
            api_key=api_key,
            vrm=vrm,
            year=year,
            make=make,
            model=model,
            variant=variant,
            miles=miles,
            postal_code=postal_code,
            radius=radius,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FareValue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fare_value_with_http_info(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vrm: Annotated[Optional[StrictStr], Field(description="Predict price for a VRM")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Car manufacturing year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Car's make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="Car's model")] = None,
        variant: Annotated[Optional[StrictStr], Field(description="Car's variant")] = None,
        miles: Annotated[Optional[StrictInt], Field(description="miles vehicle has driven in total")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="Postal code of the car")] = None,
        radius: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=0)]], Field(description="Radius around the search location (Unit - Miles)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FareValue]:
        """Predict fare value of car for UK based on YMMT & miles

        Predict fare value of car for UK based on YMMT & miles

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vrm: Predict price for a VRM
        :type vrm: str
        :param year: Car manufacturing year
        :type year: int
        :param make: Car's make
        :type make: str
        :param model: Car's model
        :type model: str
        :param variant: Car's variant
        :type variant: str
        :param miles: miles vehicle has driven in total
        :type miles: int
        :param postal_code: Postal code of the car
        :type postal_code: str
        :param radius: Radius around the search location (Unit - Miles)
        :type radius: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fare_value_serialize(
            api_key=api_key,
            vrm=vrm,
            year=year,
            make=make,
            model=model,
            variant=variant,
            miles=miles,
            postal_code=postal_code,
            radius=radius,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FareValue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fare_value_without_preload_content(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vrm: Annotated[Optional[StrictStr], Field(description="Predict price for a VRM")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Car manufacturing year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Car's make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="Car's model")] = None,
        variant: Annotated[Optional[StrictStr], Field(description="Car's variant")] = None,
        miles: Annotated[Optional[StrictInt], Field(description="miles vehicle has driven in total")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="Postal code of the car")] = None,
        radius: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=0)]], Field(description="Radius around the search location (Unit - Miles)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Predict fare value of car for UK based on YMMT & miles

        Predict fare value of car for UK based on YMMT & miles

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vrm: Predict price for a VRM
        :type vrm: str
        :param year: Car manufacturing year
        :type year: int
        :param make: Car's make
        :type make: str
        :param model: Car's model
        :type model: str
        :param variant: Car's variant
        :type variant: str
        :param miles: miles vehicle has driven in total
        :type miles: int
        :param postal_code: Postal code of the car
        :type postal_code: str
        :param radius: Radius around the search location (Unit - Miles)
        :type radius: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fare_value_serialize(
            api_key=api_key,
            vrm=vrm,
            year=year,
            make=make,
            model=model,
            variant=variant,
            miles=miles,
            postal_code=postal_code,
            radius=radius,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FareValue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fare_value_serialize(
        self,
        api_key,
        vrm,
        year,
        make,
        model,
        variant,
        miles,
        postal_code,
        radius,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        if vrm is not None:
            
            _query_params.append(('vrm', vrm))
            
        if year is not None:
            
            _query_params.append(('year', year))
            
        if make is not None:
            
            _query_params.append(('make', make))
            
        if model is not None:
            
            _query_params.append(('model', model))
            
        if variant is not None:
            
            _query_params.append(('variant', variant))
            
        if miles is not None:
            
            _query_params.append(('miles', miles))
            
        if postal_code is not None:
            
            _query_params.append(('postal_code', postal_code))
            
        if radius is not None:
            
            _query_params.append(('radius', radius))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/predict/car/uk/fmv',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_daily_stats(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which the stats are to be searched")] = None,
        car_type: Annotated[Optional[StrictStr], Field(description="Inventory type for which stats are to be searched, default is used")] = None,
        ymm: Annotated[Optional[StrictStr], Field(description="Year, Make, Model of the car, Separated by pipe e.g. ymm=2015|ford|f-150")] = None,
        ymmt: Annotated[Optional[StrictStr], Field(description="Year, Make, Model, Trim of the car, Separated by pipe e.g. ymmt=2015|ford|f-150|platinum")] = None,
        taxonomy_vin: Annotated[Optional[StrictStr], Field(description="Taxonomy vin for referance to find stats of similar cars")] = None,
        vin: Annotated[Optional[StrictStr], Field(description="VIN that will be transformed to taxonomy_vin")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State level stats")] = None,
        city_state: Annotated[Optional[StrictStr], Field(description="City level stats, pipe seperated like city_state=jacksonville|FL")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DailyStats:
        """Price, Miles and Days on Market stats

        National, state and city level stats for price, miles and dom

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param country: Country for which the stats are to be searched
        :type country: str
        :param car_type: Inventory type for which stats are to be searched, default is used
        :type car_type: str
        :param ymm: Year, Make, Model of the car, Separated by pipe e.g. ymm=2015|ford|f-150
        :type ymm: str
        :param ymmt: Year, Make, Model, Trim of the car, Separated by pipe e.g. ymmt=2015|ford|f-150|platinum
        :type ymmt: str
        :param taxonomy_vin: Taxonomy vin for referance to find stats of similar cars
        :type taxonomy_vin: str
        :param vin: VIN that will be transformed to taxonomy_vin
        :type vin: str
        :param state: State level stats
        :type state: str
        :param city_state: City level stats, pipe seperated like city_state=jacksonville|FL
        :type city_state: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_daily_stats_serialize(
            api_key=api_key,
            country=country,
            car_type=car_type,
            ymm=ymm,
            ymmt=ymmt,
            taxonomy_vin=taxonomy_vin,
            vin=vin,
            state=state,
            city_state=city_state,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DailyStats",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_daily_stats_with_http_info(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which the stats are to be searched")] = None,
        car_type: Annotated[Optional[StrictStr], Field(description="Inventory type for which stats are to be searched, default is used")] = None,
        ymm: Annotated[Optional[StrictStr], Field(description="Year, Make, Model of the car, Separated by pipe e.g. ymm=2015|ford|f-150")] = None,
        ymmt: Annotated[Optional[StrictStr], Field(description="Year, Make, Model, Trim of the car, Separated by pipe e.g. ymmt=2015|ford|f-150|platinum")] = None,
        taxonomy_vin: Annotated[Optional[StrictStr], Field(description="Taxonomy vin for referance to find stats of similar cars")] = None,
        vin: Annotated[Optional[StrictStr], Field(description="VIN that will be transformed to taxonomy_vin")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State level stats")] = None,
        city_state: Annotated[Optional[StrictStr], Field(description="City level stats, pipe seperated like city_state=jacksonville|FL")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DailyStats]:
        """Price, Miles and Days on Market stats

        National, state and city level stats for price, miles and dom

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param country: Country for which the stats are to be searched
        :type country: str
        :param car_type: Inventory type for which stats are to be searched, default is used
        :type car_type: str
        :param ymm: Year, Make, Model of the car, Separated by pipe e.g. ymm=2015|ford|f-150
        :type ymm: str
        :param ymmt: Year, Make, Model, Trim of the car, Separated by pipe e.g. ymmt=2015|ford|f-150|platinum
        :type ymmt: str
        :param taxonomy_vin: Taxonomy vin for referance to find stats of similar cars
        :type taxonomy_vin: str
        :param vin: VIN that will be transformed to taxonomy_vin
        :type vin: str
        :param state: State level stats
        :type state: str
        :param city_state: City level stats, pipe seperated like city_state=jacksonville|FL
        :type city_state: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_daily_stats_serialize(
            api_key=api_key,
            country=country,
            car_type=car_type,
            ymm=ymm,
            ymmt=ymmt,
            taxonomy_vin=taxonomy_vin,
            vin=vin,
            state=state,
            city_state=city_state,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DailyStats",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_daily_stats_without_preload_content(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which the stats are to be searched")] = None,
        car_type: Annotated[Optional[StrictStr], Field(description="Inventory type for which stats are to be searched, default is used")] = None,
        ymm: Annotated[Optional[StrictStr], Field(description="Year, Make, Model of the car, Separated by pipe e.g. ymm=2015|ford|f-150")] = None,
        ymmt: Annotated[Optional[StrictStr], Field(description="Year, Make, Model, Trim of the car, Separated by pipe e.g. ymmt=2015|ford|f-150|platinum")] = None,
        taxonomy_vin: Annotated[Optional[StrictStr], Field(description="Taxonomy vin for referance to find stats of similar cars")] = None,
        vin: Annotated[Optional[StrictStr], Field(description="VIN that will be transformed to taxonomy_vin")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State level stats")] = None,
        city_state: Annotated[Optional[StrictStr], Field(description="City level stats, pipe seperated like city_state=jacksonville|FL")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Price, Miles and Days on Market stats

        National, state and city level stats for price, miles and dom

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param country: Country for which the stats are to be searched
        :type country: str
        :param car_type: Inventory type for which stats are to be searched, default is used
        :type car_type: str
        :param ymm: Year, Make, Model of the car, Separated by pipe e.g. ymm=2015|ford|f-150
        :type ymm: str
        :param ymmt: Year, Make, Model, Trim of the car, Separated by pipe e.g. ymmt=2015|ford|f-150|platinum
        :type ymmt: str
        :param taxonomy_vin: Taxonomy vin for referance to find stats of similar cars
        :type taxonomy_vin: str
        :param vin: VIN that will be transformed to taxonomy_vin
        :type vin: str
        :param state: State level stats
        :type state: str
        :param city_state: City level stats, pipe seperated like city_state=jacksonville|FL
        :type city_state: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_daily_stats_serialize(
            api_key=api_key,
            country=country,
            car_type=car_type,
            ymm=ymm,
            ymmt=ymmt,
            taxonomy_vin=taxonomy_vin,
            vin=vin,
            state=state,
            city_state=city_state,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DailyStats",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_daily_stats_serialize(
        self,
        api_key,
        country,
        car_type,
        ymm,
        ymmt,
        taxonomy_vin,
        vin,
        state,
        city_state,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if car_type is not None:
            
            _query_params.append(('car_type', car_type))
            
        if ymm is not None:
            
            _query_params.append(('ymm', ymm))
            
        if ymmt is not None:
            
            _query_params.append(('ymmt', ymmt))
            
        if taxonomy_vin is not None:
            
            _query_params.append(('taxonomy_vin', taxonomy_vin))
            
        if vin is not None:
            
            _query_params.append(('vin', vin))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if city_state is not None:
            
            _query_params.append(('city_state', city_state))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/stats/car',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_mds(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vin: Annotated[Optional[Annotated[str, Field(min_length=10, strict=True)]], Field(description="VIN to decode")] = None,
        exact: Annotated[Optional[StrictBool], Field(description="Exact parameter")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude component of location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude component of location")] = None,
        radius: Annotated[Optional[StrictInt], Field(description="Radius around the search location (Unit - Miles)")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="To filter listing on ZIP around which they are listed")] = None,
        msa_code: Annotated[Optional[StrictStr], Field(description="To filter listing on msa code in which they are listed")] = None,
        debug: Annotated[Optional[StrictBool], Field(description="Debug parameter")] = None,
        include_sold: Annotated[Optional[StrictBool], Field(description="To fetch sold vins")] = None,
        country: Annotated[Optional[StrictStr], Field(description="To filter listing on Country in which they are listed")] = None,
        state: Annotated[Optional[StrictStr], Field(description="To filter listing on State in which they are listed")] = None,
        city: Annotated[Optional[StrictStr], Field(description="To filter listing on City in which they are listed")] = None,
        ymmt: Annotated[Optional[StrictStr], Field(description="Comma separated list of Year, Make, Model, Trim combinations. Each combination needs to have the year,make,model, trim values separated by a pipe '|' character in the form year|make|model|trim. e.g. 2010|Audi|A5,2014|Nissan|Sentra|S 6MT,|Honda|City|   You could just provide strings of the form - 'year|make||' or 'year|make|model' or '|make|model|' combinations. Individual year / make / model filters provied with the API calls will take precedence over the Year, Make, Model, Trim combinations. The Make, Model, Trim values must be valid values as per the Marketcheck Vin Decoder. If you are using a separate vin decoder then look at using the 'vins' or 'taxonomy_vins' parameter to the search api instead the year|make|model|trim combinations.")] = None,
        car_type: Annotated[Optional[StrictStr], Field(description="Car type. Allowed values are - new / used / certified")] = None,
        lease_term: Annotated[Optional[StrictStr], Field(description="Search listings with exact lease term, or inside a range with min and max seperated by a dash like lease_term=30-60")] = None,
        lease_down_payment: Annotated[Optional[StrictStr], Field(description="Search listings with exact down payment in lease offers, or inside a range with min and max seperated by a dash like lease_down_payment=30-60")] = None,
        lease_emp: Annotated[Optional[StrictStr], Field(description="Search listings with lease offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like lease_emp=30-60")] = None,
        finance_loan_term: Annotated[Optional[StrictStr], Field(description="Search listings with exact finance loan term, or inside a range with min and max seperated by a dash like finance_loan_term=30-60")] = None,
        finance_loan_apr: Annotated[Optional[StrictStr], Field(description="Search listings with finance offers exactly matching loans Annual Percentage Rate, or inside a range with min and max seperated by a dash like finance_loan_apr=30-60")] = None,
        finance_emp: Annotated[Optional[StrictStr], Field(description="Search listings with finance offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like finance_emp=30-60")] = None,
        finance_down_payment: Annotated[Optional[StrictStr], Field(description="Search listings with exact down payment in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment=30-60")] = None,
        finance_down_payment_per: Annotated[Optional[StrictStr], Field(description="Search listings with exact down payment percentage in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment_per=30-60")] = None,
        carfax_1_owner: Annotated[Optional[StrictStr], Field(description="Indicates whether car has had only one owner or not")] = None,
        carfax_clean_title: Annotated[Optional[StrictStr], Field(description="Indicates whether car has clean ownership records")] = None,
        year: Annotated[Optional[Annotated[str, Field(min_length=4, strict=True)]], Field(description="To filter listing on their year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="To filter listings on their make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="To filter listings on their model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="To filter listing on their trim")] = None,
        dealer_id: Annotated[Optional[StrictStr], Field(description="Dealer id to filter the listings.")] = None,
        source: Annotated[Optional[StrictStr], Field(description="To filter listing on their source")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their body type")] = None,
        body_subtype: Annotated[Optional[StrictStr], Field(description="Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated")] = None,
        vehicle_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their vehicle type")] = None,
        cylinders: Annotated[Optional[StrictStr], Field(description="To filter listing on their cylinders")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="To filter listing on their transmission")] = None,
        doors: Annotated[Optional[StrictStr], Field(description="Doors to filter the cars on. Valid filter values are those that our Search facets API returns for unique doors. You can pass in multiple doors values comma separated")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="To filter listing on their drivetrain")] = None,
        exterior_color: Annotated[Optional[StrictStr], Field(description="Exterior color to match. Valid filter values are those that our Search facets API returns for unique exterior colors. You can pass in multiple exterior color values comma separated")] = None,
        interior_color: Annotated[Optional[StrictStr], Field(description="Interior color to match. Valid filter values are those that our Search facets API returns for unique interior colors. You can pass in multiple interior color values comma separated")] = None,
        base_exterior_color: Annotated[Optional[StrictStr], Field(description="Base exterior color to match. Valid filter values are those that our Search facets API returns for unique base exterior colors. You can pass in multiple base interior color values comma separated")] = None,
        base_interior_color: Annotated[Optional[StrictStr], Field(description="Base interior color to match. Valid filter values are those that our Search facets API returns for unique base interior colors. You can pass in multiple base interior color values comma separated")] = None,
        engine: Annotated[Optional[StrictStr], Field(description="To filter listing on their engine")] = None,
        engine_size: Annotated[Optional[StrictStr], Field(description="Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated")] = None,
        engine_aspiration: Annotated[Optional[StrictStr], Field(description="Engine Aspiration to match. Valid filter values are those that our Search facets API returns for unique Engine Aspirations. You can pass in multiple Engine aspirations values comma separated")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated")] = None,
        highway_mpg_range: Annotated[Optional[StrictStr], Field(description="Highway mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        city_mpg_range: Annotated[Optional[StrictStr], Field(description="City mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        miles_range: Annotated[Optional[StrictStr], Field(description="Miles range to filter listings with miles in the given range. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        price_range: Annotated[Optional[StrictStr], Field(description="Price range to filter listings with the price in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        msrp_range: Annotated[Optional[StrictStr], Field(description="MSRP range to filter listings with the msrp in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        dom_range: Annotated[Optional[StrictStr], Field(description="Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50")] = None,
        dealership_group_name: Annotated[Optional[StrictStr], Field(description="Name of the dealership group to search for")] = None,
        dom_active_range: Annotated[Optional[StrictStr], Field(description="Active Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50")] = None,
        dom_180_range: Annotated[Optional[StrictStr], Field(description="Last 180 Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their fuel type")] = None,
        dealer_type: Annotated[Optional[StrictStr], Field(description="Filter based on dealer type independant or franchise")] = None,
        engine_size_range: Annotated[Optional[StrictStr], Field(description="Engine size range to filter listings with engine size in the given range. Range to be given in the format - min-max e.g. 1.0-2")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Mds:
        """Market Days Supply

        Get the basic information on specifications for a car identified by a valid VIN

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vin: VIN to decode
        :type vin: str
        :param exact: Exact parameter
        :type exact: bool
        :param latitude: Latitude component of location
        :type latitude: float
        :param longitude: Longitude component of location
        :type longitude: float
        :param radius: Radius around the search location (Unit - Miles)
        :type radius: int
        :param zip: To filter listing on ZIP around which they are listed
        :type zip: str
        :param msa_code: To filter listing on msa code in which they are listed
        :type msa_code: str
        :param debug: Debug parameter
        :type debug: bool
        :param include_sold: To fetch sold vins
        :type include_sold: bool
        :param country: To filter listing on Country in which they are listed
        :type country: str
        :param state: To filter listing on State in which they are listed
        :type state: str
        :param city: To filter listing on City in which they are listed
        :type city: str
        :param ymmt: Comma separated list of Year, Make, Model, Trim combinations. Each combination needs to have the year,make,model, trim values separated by a pipe '|' character in the form year|make|model|trim. e.g. 2010|Audi|A5,2014|Nissan|Sentra|S 6MT,|Honda|City|   You could just provide strings of the form - 'year|make||' or 'year|make|model' or '|make|model|' combinations. Individual year / make / model filters provied with the API calls will take precedence over the Year, Make, Model, Trim combinations. The Make, Model, Trim values must be valid values as per the Marketcheck Vin Decoder. If you are using a separate vin decoder then look at using the 'vins' or 'taxonomy_vins' parameter to the search api instead the year|make|model|trim combinations.
        :type ymmt: str
        :param car_type: Car type. Allowed values are - new / used / certified
        :type car_type: str
        :param lease_term: Search listings with exact lease term, or inside a range with min and max seperated by a dash like lease_term=30-60
        :type lease_term: str
        :param lease_down_payment: Search listings with exact down payment in lease offers, or inside a range with min and max seperated by a dash like lease_down_payment=30-60
        :type lease_down_payment: str
        :param lease_emp: Search listings with lease offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like lease_emp=30-60
        :type lease_emp: str
        :param finance_loan_term: Search listings with exact finance loan term, or inside a range with min and max seperated by a dash like finance_loan_term=30-60
        :type finance_loan_term: str
        :param finance_loan_apr: Search listings with finance offers exactly matching loans Annual Percentage Rate, or inside a range with min and max seperated by a dash like finance_loan_apr=30-60
        :type finance_loan_apr: str
        :param finance_emp: Search listings with finance offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like finance_emp=30-60
        :type finance_emp: str
        :param finance_down_payment: Search listings with exact down payment in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment=30-60
        :type finance_down_payment: str
        :param finance_down_payment_per: Search listings with exact down payment percentage in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment_per=30-60
        :type finance_down_payment_per: str
        :param carfax_1_owner: Indicates whether car has had only one owner or not
        :type carfax_1_owner: str
        :param carfax_clean_title: Indicates whether car has clean ownership records
        :type carfax_clean_title: str
        :param year: To filter listing on their year
        :type year: str
        :param make: To filter listings on their make
        :type make: str
        :param model: To filter listings on their model
        :type model: str
        :param trim: To filter listing on their trim
        :type trim: str
        :param dealer_id: Dealer id to filter the listings.
        :type dealer_id: str
        :param source: To filter listing on their source
        :type source: str
        :param body_type: To filter listing on their body type
        :type body_type: str
        :param body_subtype: Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated
        :type body_subtype: str
        :param vehicle_type: To filter listing on their vehicle type
        :type vehicle_type: str
        :param cylinders: To filter listing on their cylinders
        :type cylinders: str
        :param transmission: To filter listing on their transmission
        :type transmission: str
        :param doors: Doors to filter the cars on. Valid filter values are those that our Search facets API returns for unique doors. You can pass in multiple doors values comma separated
        :type doors: str
        :param drivetrain: To filter listing on their drivetrain
        :type drivetrain: str
        :param exterior_color: Exterior color to match. Valid filter values are those that our Search facets API returns for unique exterior colors. You can pass in multiple exterior color values comma separated
        :type exterior_color: str
        :param interior_color: Interior color to match. Valid filter values are those that our Search facets API returns for unique interior colors. You can pass in multiple interior color values comma separated
        :type interior_color: str
        :param base_exterior_color: Base exterior color to match. Valid filter values are those that our Search facets API returns for unique base exterior colors. You can pass in multiple base interior color values comma separated
        :type base_exterior_color: str
        :param base_interior_color: Base interior color to match. Valid filter values are those that our Search facets API returns for unique base interior colors. You can pass in multiple base interior color values comma separated
        :type base_interior_color: str
        :param engine: To filter listing on their engine
        :type engine: str
        :param engine_size: Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated
        :type engine_size: str
        :param engine_aspiration: Engine Aspiration to match. Valid filter values are those that our Search facets API returns for unique Engine Aspirations. You can pass in multiple Engine aspirations values comma separated
        :type engine_aspiration: str
        :param engine_block: Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated
        :type engine_block: str
        :param highway_mpg_range: Highway mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type highway_mpg_range: str
        :param city_mpg_range: City mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type city_mpg_range: str
        :param miles_range: Miles range to filter listings with miles in the given range. Range to be given in the format - min-max e.g. 1000-5000
        :type miles_range: str
        :param price_range: Price range to filter listings with the price in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type price_range: str
        :param msrp_range: MSRP range to filter listings with the msrp in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type msrp_range: str
        :param dom_range: Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
        :type dom_range: str
        :param dealership_group_name: Name of the dealership group to search for
        :type dealership_group_name: str
        :param dom_active_range: Active Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
        :type dom_active_range: str
        :param dom_180_range: Last 180 Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
        :type dom_180_range: str
        :param fuel_type: To filter listing on their fuel type
        :type fuel_type: str
        :param dealer_type: Filter based on dealer type independant or franchise
        :type dealer_type: str
        :param engine_size_range: Engine size range to filter listings with engine size in the given range. Range to be given in the format - min-max e.g. 1.0-2
        :type engine_size_range: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_mds_serialize(
            api_key=api_key,
            vin=vin,
            exact=exact,
            latitude=latitude,
            longitude=longitude,
            radius=radius,
            zip=zip,
            msa_code=msa_code,
            debug=debug,
            include_sold=include_sold,
            country=country,
            state=state,
            city=city,
            ymmt=ymmt,
            car_type=car_type,
            lease_term=lease_term,
            lease_down_payment=lease_down_payment,
            lease_emp=lease_emp,
            finance_loan_term=finance_loan_term,
            finance_loan_apr=finance_loan_apr,
            finance_emp=finance_emp,
            finance_down_payment=finance_down_payment,
            finance_down_payment_per=finance_down_payment_per,
            carfax_1_owner=carfax_1_owner,
            carfax_clean_title=carfax_clean_title,
            year=year,
            make=make,
            model=model,
            trim=trim,
            dealer_id=dealer_id,
            source=source,
            body_type=body_type,
            body_subtype=body_subtype,
            vehicle_type=vehicle_type,
            cylinders=cylinders,
            transmission=transmission,
            doors=doors,
            drivetrain=drivetrain,
            exterior_color=exterior_color,
            interior_color=interior_color,
            base_exterior_color=base_exterior_color,
            base_interior_color=base_interior_color,
            engine=engine,
            engine_size=engine_size,
            engine_aspiration=engine_aspiration,
            engine_block=engine_block,
            highway_mpg_range=highway_mpg_range,
            city_mpg_range=city_mpg_range,
            miles_range=miles_range,
            price_range=price_range,
            msrp_range=msrp_range,
            dom_range=dom_range,
            dealership_group_name=dealership_group_name,
            dom_active_range=dom_active_range,
            dom_180_range=dom_180_range,
            fuel_type=fuel_type,
            dealer_type=dealer_type,
            engine_size_range=engine_size_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Mds",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_mds_with_http_info(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vin: Annotated[Optional[Annotated[str, Field(min_length=10, strict=True)]], Field(description="VIN to decode")] = None,
        exact: Annotated[Optional[StrictBool], Field(description="Exact parameter")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude component of location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude component of location")] = None,
        radius: Annotated[Optional[StrictInt], Field(description="Radius around the search location (Unit - Miles)")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="To filter listing on ZIP around which they are listed")] = None,
        msa_code: Annotated[Optional[StrictStr], Field(description="To filter listing on msa code in which they are listed")] = None,
        debug: Annotated[Optional[StrictBool], Field(description="Debug parameter")] = None,
        include_sold: Annotated[Optional[StrictBool], Field(description="To fetch sold vins")] = None,
        country: Annotated[Optional[StrictStr], Field(description="To filter listing on Country in which they are listed")] = None,
        state: Annotated[Optional[StrictStr], Field(description="To filter listing on State in which they are listed")] = None,
        city: Annotated[Optional[StrictStr], Field(description="To filter listing on City in which they are listed")] = None,
        ymmt: Annotated[Optional[StrictStr], Field(description="Comma separated list of Year, Make, Model, Trim combinations. Each combination needs to have the year,make,model, trim values separated by a pipe '|' character in the form year|make|model|trim. e.g. 2010|Audi|A5,2014|Nissan|Sentra|S 6MT,|Honda|City|   You could just provide strings of the form - 'year|make||' or 'year|make|model' or '|make|model|' combinations. Individual year / make / model filters provied with the API calls will take precedence over the Year, Make, Model, Trim combinations. The Make, Model, Trim values must be valid values as per the Marketcheck Vin Decoder. If you are using a separate vin decoder then look at using the 'vins' or 'taxonomy_vins' parameter to the search api instead the year|make|model|trim combinations.")] = None,
        car_type: Annotated[Optional[StrictStr], Field(description="Car type. Allowed values are - new / used / certified")] = None,
        lease_term: Annotated[Optional[StrictStr], Field(description="Search listings with exact lease term, or inside a range with min and max seperated by a dash like lease_term=30-60")] = None,
        lease_down_payment: Annotated[Optional[StrictStr], Field(description="Search listings with exact down payment in lease offers, or inside a range with min and max seperated by a dash like lease_down_payment=30-60")] = None,
        lease_emp: Annotated[Optional[StrictStr], Field(description="Search listings with lease offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like lease_emp=30-60")] = None,
        finance_loan_term: Annotated[Optional[StrictStr], Field(description="Search listings with exact finance loan term, or inside a range with min and max seperated by a dash like finance_loan_term=30-60")] = None,
        finance_loan_apr: Annotated[Optional[StrictStr], Field(description="Search listings with finance offers exactly matching loans Annual Percentage Rate, or inside a range with min and max seperated by a dash like finance_loan_apr=30-60")] = None,
        finance_emp: Annotated[Optional[StrictStr], Field(description="Search listings with finance offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like finance_emp=30-60")] = None,
        finance_down_payment: Annotated[Optional[StrictStr], Field(description="Search listings with exact down payment in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment=30-60")] = None,
        finance_down_payment_per: Annotated[Optional[StrictStr], Field(description="Search listings with exact down payment percentage in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment_per=30-60")] = None,
        carfax_1_owner: Annotated[Optional[StrictStr], Field(description="Indicates whether car has had only one owner or not")] = None,
        carfax_clean_title: Annotated[Optional[StrictStr], Field(description="Indicates whether car has clean ownership records")] = None,
        year: Annotated[Optional[Annotated[str, Field(min_length=4, strict=True)]], Field(description="To filter listing on their year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="To filter listings on their make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="To filter listings on their model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="To filter listing on their trim")] = None,
        dealer_id: Annotated[Optional[StrictStr], Field(description="Dealer id to filter the listings.")] = None,
        source: Annotated[Optional[StrictStr], Field(description="To filter listing on their source")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their body type")] = None,
        body_subtype: Annotated[Optional[StrictStr], Field(description="Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated")] = None,
        vehicle_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their vehicle type")] = None,
        cylinders: Annotated[Optional[StrictStr], Field(description="To filter listing on their cylinders")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="To filter listing on their transmission")] = None,
        doors: Annotated[Optional[StrictStr], Field(description="Doors to filter the cars on. Valid filter values are those that our Search facets API returns for unique doors. You can pass in multiple doors values comma separated")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="To filter listing on their drivetrain")] = None,
        exterior_color: Annotated[Optional[StrictStr], Field(description="Exterior color to match. Valid filter values are those that our Search facets API returns for unique exterior colors. You can pass in multiple exterior color values comma separated")] = None,
        interior_color: Annotated[Optional[StrictStr], Field(description="Interior color to match. Valid filter values are those that our Search facets API returns for unique interior colors. You can pass in multiple interior color values comma separated")] = None,
        base_exterior_color: Annotated[Optional[StrictStr], Field(description="Base exterior color to match. Valid filter values are those that our Search facets API returns for unique base exterior colors. You can pass in multiple base interior color values comma separated")] = None,
        base_interior_color: Annotated[Optional[StrictStr], Field(description="Base interior color to match. Valid filter values are those that our Search facets API returns for unique base interior colors. You can pass in multiple base interior color values comma separated")] = None,
        engine: Annotated[Optional[StrictStr], Field(description="To filter listing on their engine")] = None,
        engine_size: Annotated[Optional[StrictStr], Field(description="Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated")] = None,
        engine_aspiration: Annotated[Optional[StrictStr], Field(description="Engine Aspiration to match. Valid filter values are those that our Search facets API returns for unique Engine Aspirations. You can pass in multiple Engine aspirations values comma separated")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated")] = None,
        highway_mpg_range: Annotated[Optional[StrictStr], Field(description="Highway mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        city_mpg_range: Annotated[Optional[StrictStr], Field(description="City mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        miles_range: Annotated[Optional[StrictStr], Field(description="Miles range to filter listings with miles in the given range. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        price_range: Annotated[Optional[StrictStr], Field(description="Price range to filter listings with the price in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        msrp_range: Annotated[Optional[StrictStr], Field(description="MSRP range to filter listings with the msrp in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        dom_range: Annotated[Optional[StrictStr], Field(description="Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50")] = None,
        dealership_group_name: Annotated[Optional[StrictStr], Field(description="Name of the dealership group to search for")] = None,
        dom_active_range: Annotated[Optional[StrictStr], Field(description="Active Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50")] = None,
        dom_180_range: Annotated[Optional[StrictStr], Field(description="Last 180 Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their fuel type")] = None,
        dealer_type: Annotated[Optional[StrictStr], Field(description="Filter based on dealer type independant or franchise")] = None,
        engine_size_range: Annotated[Optional[StrictStr], Field(description="Engine size range to filter listings with engine size in the given range. Range to be given in the format - min-max e.g. 1.0-2")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Mds]:
        """Market Days Supply

        Get the basic information on specifications for a car identified by a valid VIN

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vin: VIN to decode
        :type vin: str
        :param exact: Exact parameter
        :type exact: bool
        :param latitude: Latitude component of location
        :type latitude: float
        :param longitude: Longitude component of location
        :type longitude: float
        :param radius: Radius around the search location (Unit - Miles)
        :type radius: int
        :param zip: To filter listing on ZIP around which they are listed
        :type zip: str
        :param msa_code: To filter listing on msa code in which they are listed
        :type msa_code: str
        :param debug: Debug parameter
        :type debug: bool
        :param include_sold: To fetch sold vins
        :type include_sold: bool
        :param country: To filter listing on Country in which they are listed
        :type country: str
        :param state: To filter listing on State in which they are listed
        :type state: str
        :param city: To filter listing on City in which they are listed
        :type city: str
        :param ymmt: Comma separated list of Year, Make, Model, Trim combinations. Each combination needs to have the year,make,model, trim values separated by a pipe '|' character in the form year|make|model|trim. e.g. 2010|Audi|A5,2014|Nissan|Sentra|S 6MT,|Honda|City|   You could just provide strings of the form - 'year|make||' or 'year|make|model' or '|make|model|' combinations. Individual year / make / model filters provied with the API calls will take precedence over the Year, Make, Model, Trim combinations. The Make, Model, Trim values must be valid values as per the Marketcheck Vin Decoder. If you are using a separate vin decoder then look at using the 'vins' or 'taxonomy_vins' parameter to the search api instead the year|make|model|trim combinations.
        :type ymmt: str
        :param car_type: Car type. Allowed values are - new / used / certified
        :type car_type: str
        :param lease_term: Search listings with exact lease term, or inside a range with min and max seperated by a dash like lease_term=30-60
        :type lease_term: str
        :param lease_down_payment: Search listings with exact down payment in lease offers, or inside a range with min and max seperated by a dash like lease_down_payment=30-60
        :type lease_down_payment: str
        :param lease_emp: Search listings with lease offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like lease_emp=30-60
        :type lease_emp: str
        :param finance_loan_term: Search listings with exact finance loan term, or inside a range with min and max seperated by a dash like finance_loan_term=30-60
        :type finance_loan_term: str
        :param finance_loan_apr: Search listings with finance offers exactly matching loans Annual Percentage Rate, or inside a range with min and max seperated by a dash like finance_loan_apr=30-60
        :type finance_loan_apr: str
        :param finance_emp: Search listings with finance offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like finance_emp=30-60
        :type finance_emp: str
        :param finance_down_payment: Search listings with exact down payment in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment=30-60
        :type finance_down_payment: str
        :param finance_down_payment_per: Search listings with exact down payment percentage in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment_per=30-60
        :type finance_down_payment_per: str
        :param carfax_1_owner: Indicates whether car has had only one owner or not
        :type carfax_1_owner: str
        :param carfax_clean_title: Indicates whether car has clean ownership records
        :type carfax_clean_title: str
        :param year: To filter listing on their year
        :type year: str
        :param make: To filter listings on their make
        :type make: str
        :param model: To filter listings on their model
        :type model: str
        :param trim: To filter listing on their trim
        :type trim: str
        :param dealer_id: Dealer id to filter the listings.
        :type dealer_id: str
        :param source: To filter listing on their source
        :type source: str
        :param body_type: To filter listing on their body type
        :type body_type: str
        :param body_subtype: Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated
        :type body_subtype: str
        :param vehicle_type: To filter listing on their vehicle type
        :type vehicle_type: str
        :param cylinders: To filter listing on their cylinders
        :type cylinders: str
        :param transmission: To filter listing on their transmission
        :type transmission: str
        :param doors: Doors to filter the cars on. Valid filter values are those that our Search facets API returns for unique doors. You can pass in multiple doors values comma separated
        :type doors: str
        :param drivetrain: To filter listing on their drivetrain
        :type drivetrain: str
        :param exterior_color: Exterior color to match. Valid filter values are those that our Search facets API returns for unique exterior colors. You can pass in multiple exterior color values comma separated
        :type exterior_color: str
        :param interior_color: Interior color to match. Valid filter values are those that our Search facets API returns for unique interior colors. You can pass in multiple interior color values comma separated
        :type interior_color: str
        :param base_exterior_color: Base exterior color to match. Valid filter values are those that our Search facets API returns for unique base exterior colors. You can pass in multiple base interior color values comma separated
        :type base_exterior_color: str
        :param base_interior_color: Base interior color to match. Valid filter values are those that our Search facets API returns for unique base interior colors. You can pass in multiple base interior color values comma separated
        :type base_interior_color: str
        :param engine: To filter listing on their engine
        :type engine: str
        :param engine_size: Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated
        :type engine_size: str
        :param engine_aspiration: Engine Aspiration to match. Valid filter values are those that our Search facets API returns for unique Engine Aspirations. You can pass in multiple Engine aspirations values comma separated
        :type engine_aspiration: str
        :param engine_block: Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated
        :type engine_block: str
        :param highway_mpg_range: Highway mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type highway_mpg_range: str
        :param city_mpg_range: City mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type city_mpg_range: str
        :param miles_range: Miles range to filter listings with miles in the given range. Range to be given in the format - min-max e.g. 1000-5000
        :type miles_range: str
        :param price_range: Price range to filter listings with the price in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type price_range: str
        :param msrp_range: MSRP range to filter listings with the msrp in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type msrp_range: str
        :param dom_range: Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
        :type dom_range: str
        :param dealership_group_name: Name of the dealership group to search for
        :type dealership_group_name: str
        :param dom_active_range: Active Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
        :type dom_active_range: str
        :param dom_180_range: Last 180 Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
        :type dom_180_range: str
        :param fuel_type: To filter listing on their fuel type
        :type fuel_type: str
        :param dealer_type: Filter based on dealer type independant or franchise
        :type dealer_type: str
        :param engine_size_range: Engine size range to filter listings with engine size in the given range. Range to be given in the format - min-max e.g. 1.0-2
        :type engine_size_range: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_mds_serialize(
            api_key=api_key,
            vin=vin,
            exact=exact,
            latitude=latitude,
            longitude=longitude,
            radius=radius,
            zip=zip,
            msa_code=msa_code,
            debug=debug,
            include_sold=include_sold,
            country=country,
            state=state,
            city=city,
            ymmt=ymmt,
            car_type=car_type,
            lease_term=lease_term,
            lease_down_payment=lease_down_payment,
            lease_emp=lease_emp,
            finance_loan_term=finance_loan_term,
            finance_loan_apr=finance_loan_apr,
            finance_emp=finance_emp,
            finance_down_payment=finance_down_payment,
            finance_down_payment_per=finance_down_payment_per,
            carfax_1_owner=carfax_1_owner,
            carfax_clean_title=carfax_clean_title,
            year=year,
            make=make,
            model=model,
            trim=trim,
            dealer_id=dealer_id,
            source=source,
            body_type=body_type,
            body_subtype=body_subtype,
            vehicle_type=vehicle_type,
            cylinders=cylinders,
            transmission=transmission,
            doors=doors,
            drivetrain=drivetrain,
            exterior_color=exterior_color,
            interior_color=interior_color,
            base_exterior_color=base_exterior_color,
            base_interior_color=base_interior_color,
            engine=engine,
            engine_size=engine_size,
            engine_aspiration=engine_aspiration,
            engine_block=engine_block,
            highway_mpg_range=highway_mpg_range,
            city_mpg_range=city_mpg_range,
            miles_range=miles_range,
            price_range=price_range,
            msrp_range=msrp_range,
            dom_range=dom_range,
            dealership_group_name=dealership_group_name,
            dom_active_range=dom_active_range,
            dom_180_range=dom_180_range,
            fuel_type=fuel_type,
            dealer_type=dealer_type,
            engine_size_range=engine_size_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Mds",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_mds_without_preload_content(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vin: Annotated[Optional[Annotated[str, Field(min_length=10, strict=True)]], Field(description="VIN to decode")] = None,
        exact: Annotated[Optional[StrictBool], Field(description="Exact parameter")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude component of location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude component of location")] = None,
        radius: Annotated[Optional[StrictInt], Field(description="Radius around the search location (Unit - Miles)")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="To filter listing on ZIP around which they are listed")] = None,
        msa_code: Annotated[Optional[StrictStr], Field(description="To filter listing on msa code in which they are listed")] = None,
        debug: Annotated[Optional[StrictBool], Field(description="Debug parameter")] = None,
        include_sold: Annotated[Optional[StrictBool], Field(description="To fetch sold vins")] = None,
        country: Annotated[Optional[StrictStr], Field(description="To filter listing on Country in which they are listed")] = None,
        state: Annotated[Optional[StrictStr], Field(description="To filter listing on State in which they are listed")] = None,
        city: Annotated[Optional[StrictStr], Field(description="To filter listing on City in which they are listed")] = None,
        ymmt: Annotated[Optional[StrictStr], Field(description="Comma separated list of Year, Make, Model, Trim combinations. Each combination needs to have the year,make,model, trim values separated by a pipe '|' character in the form year|make|model|trim. e.g. 2010|Audi|A5,2014|Nissan|Sentra|S 6MT,|Honda|City|   You could just provide strings of the form - 'year|make||' or 'year|make|model' or '|make|model|' combinations. Individual year / make / model filters provied with the API calls will take precedence over the Year, Make, Model, Trim combinations. The Make, Model, Trim values must be valid values as per the Marketcheck Vin Decoder. If you are using a separate vin decoder then look at using the 'vins' or 'taxonomy_vins' parameter to the search api instead the year|make|model|trim combinations.")] = None,
        car_type: Annotated[Optional[StrictStr], Field(description="Car type. Allowed values are - new / used / certified")] = None,
        lease_term: Annotated[Optional[StrictStr], Field(description="Search listings with exact lease term, or inside a range with min and max seperated by a dash like lease_term=30-60")] = None,
        lease_down_payment: Annotated[Optional[StrictStr], Field(description="Search listings with exact down payment in lease offers, or inside a range with min and max seperated by a dash like lease_down_payment=30-60")] = None,
        lease_emp: Annotated[Optional[StrictStr], Field(description="Search listings with lease offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like lease_emp=30-60")] = None,
        finance_loan_term: Annotated[Optional[StrictStr], Field(description="Search listings with exact finance loan term, or inside a range with min and max seperated by a dash like finance_loan_term=30-60")] = None,
        finance_loan_apr: Annotated[Optional[StrictStr], Field(description="Search listings with finance offers exactly matching loans Annual Percentage Rate, or inside a range with min and max seperated by a dash like finance_loan_apr=30-60")] = None,
        finance_emp: Annotated[Optional[StrictStr], Field(description="Search listings with finance offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like finance_emp=30-60")] = None,
        finance_down_payment: Annotated[Optional[StrictStr], Field(description="Search listings with exact down payment in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment=30-60")] = None,
        finance_down_payment_per: Annotated[Optional[StrictStr], Field(description="Search listings with exact down payment percentage in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment_per=30-60")] = None,
        carfax_1_owner: Annotated[Optional[StrictStr], Field(description="Indicates whether car has had only one owner or not")] = None,
        carfax_clean_title: Annotated[Optional[StrictStr], Field(description="Indicates whether car has clean ownership records")] = None,
        year: Annotated[Optional[Annotated[str, Field(min_length=4, strict=True)]], Field(description="To filter listing on their year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="To filter listings on their make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="To filter listings on their model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="To filter listing on their trim")] = None,
        dealer_id: Annotated[Optional[StrictStr], Field(description="Dealer id to filter the listings.")] = None,
        source: Annotated[Optional[StrictStr], Field(description="To filter listing on their source")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their body type")] = None,
        body_subtype: Annotated[Optional[StrictStr], Field(description="Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated")] = None,
        vehicle_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their vehicle type")] = None,
        cylinders: Annotated[Optional[StrictStr], Field(description="To filter listing on their cylinders")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="To filter listing on their transmission")] = None,
        doors: Annotated[Optional[StrictStr], Field(description="Doors to filter the cars on. Valid filter values are those that our Search facets API returns for unique doors. You can pass in multiple doors values comma separated")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="To filter listing on their drivetrain")] = None,
        exterior_color: Annotated[Optional[StrictStr], Field(description="Exterior color to match. Valid filter values are those that our Search facets API returns for unique exterior colors. You can pass in multiple exterior color values comma separated")] = None,
        interior_color: Annotated[Optional[StrictStr], Field(description="Interior color to match. Valid filter values are those that our Search facets API returns for unique interior colors. You can pass in multiple interior color values comma separated")] = None,
        base_exterior_color: Annotated[Optional[StrictStr], Field(description="Base exterior color to match. Valid filter values are those that our Search facets API returns for unique base exterior colors. You can pass in multiple base interior color values comma separated")] = None,
        base_interior_color: Annotated[Optional[StrictStr], Field(description="Base interior color to match. Valid filter values are those that our Search facets API returns for unique base interior colors. You can pass in multiple base interior color values comma separated")] = None,
        engine: Annotated[Optional[StrictStr], Field(description="To filter listing on their engine")] = None,
        engine_size: Annotated[Optional[StrictStr], Field(description="Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated")] = None,
        engine_aspiration: Annotated[Optional[StrictStr], Field(description="Engine Aspiration to match. Valid filter values are those that our Search facets API returns for unique Engine Aspirations. You can pass in multiple Engine aspirations values comma separated")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated")] = None,
        highway_mpg_range: Annotated[Optional[StrictStr], Field(description="Highway mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        city_mpg_range: Annotated[Optional[StrictStr], Field(description="City mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        miles_range: Annotated[Optional[StrictStr], Field(description="Miles range to filter listings with miles in the given range. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        price_range: Annotated[Optional[StrictStr], Field(description="Price range to filter listings with the price in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        msrp_range: Annotated[Optional[StrictStr], Field(description="MSRP range to filter listings with the msrp in the range given. Range to be given in the format - min-max e.g. 1000-5000")] = None,
        dom_range: Annotated[Optional[StrictStr], Field(description="Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50")] = None,
        dealership_group_name: Annotated[Optional[StrictStr], Field(description="Name of the dealership group to search for")] = None,
        dom_active_range: Annotated[Optional[StrictStr], Field(description="Active Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50")] = None,
        dom_180_range: Annotated[Optional[StrictStr], Field(description="Last 180 Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their fuel type")] = None,
        dealer_type: Annotated[Optional[StrictStr], Field(description="Filter based on dealer type independant or franchise")] = None,
        engine_size_range: Annotated[Optional[StrictStr], Field(description="Engine size range to filter listings with engine size in the given range. Range to be given in the format - min-max e.g. 1.0-2")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Market Days Supply

        Get the basic information on specifications for a car identified by a valid VIN

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vin: VIN to decode
        :type vin: str
        :param exact: Exact parameter
        :type exact: bool
        :param latitude: Latitude component of location
        :type latitude: float
        :param longitude: Longitude component of location
        :type longitude: float
        :param radius: Radius around the search location (Unit - Miles)
        :type radius: int
        :param zip: To filter listing on ZIP around which they are listed
        :type zip: str
        :param msa_code: To filter listing on msa code in which they are listed
        :type msa_code: str
        :param debug: Debug parameter
        :type debug: bool
        :param include_sold: To fetch sold vins
        :type include_sold: bool
        :param country: To filter listing on Country in which they are listed
        :type country: str
        :param state: To filter listing on State in which they are listed
        :type state: str
        :param city: To filter listing on City in which they are listed
        :type city: str
        :param ymmt: Comma separated list of Year, Make, Model, Trim combinations. Each combination needs to have the year,make,model, trim values separated by a pipe '|' character in the form year|make|model|trim. e.g. 2010|Audi|A5,2014|Nissan|Sentra|S 6MT,|Honda|City|   You could just provide strings of the form - 'year|make||' or 'year|make|model' or '|make|model|' combinations. Individual year / make / model filters provied with the API calls will take precedence over the Year, Make, Model, Trim combinations. The Make, Model, Trim values must be valid values as per the Marketcheck Vin Decoder. If you are using a separate vin decoder then look at using the 'vins' or 'taxonomy_vins' parameter to the search api instead the year|make|model|trim combinations.
        :type ymmt: str
        :param car_type: Car type. Allowed values are - new / used / certified
        :type car_type: str
        :param lease_term: Search listings with exact lease term, or inside a range with min and max seperated by a dash like lease_term=30-60
        :type lease_term: str
        :param lease_down_payment: Search listings with exact down payment in lease offers, or inside a range with min and max seperated by a dash like lease_down_payment=30-60
        :type lease_down_payment: str
        :param lease_emp: Search listings with lease offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like lease_emp=30-60
        :type lease_emp: str
        :param finance_loan_term: Search listings with exact finance loan term, or inside a range with min and max seperated by a dash like finance_loan_term=30-60
        :type finance_loan_term: str
        :param finance_loan_apr: Search listings with finance offers exactly matching loans Annual Percentage Rate, or inside a range with min and max seperated by a dash like finance_loan_apr=30-60
        :type finance_loan_apr: str
        :param finance_emp: Search listings with finance offers exactly matching Estimated Monthly Payment(EMI), or inside a range with min and max seperated by a dash like finance_emp=30-60
        :type finance_emp: str
        :param finance_down_payment: Search listings with exact down payment in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment=30-60
        :type finance_down_payment: str
        :param finance_down_payment_per: Search listings with exact down payment percentage in finance offers, or inside a range with min and max seperated by a dash like finance_down_payment_per=30-60
        :type finance_down_payment_per: str
        :param carfax_1_owner: Indicates whether car has had only one owner or not
        :type carfax_1_owner: str
        :param carfax_clean_title: Indicates whether car has clean ownership records
        :type carfax_clean_title: str
        :param year: To filter listing on their year
        :type year: str
        :param make: To filter listings on their make
        :type make: str
        :param model: To filter listings on their model
        :type model: str
        :param trim: To filter listing on their trim
        :type trim: str
        :param dealer_id: Dealer id to filter the listings.
        :type dealer_id: str
        :param source: To filter listing on their source
        :type source: str
        :param body_type: To filter listing on their body type
        :type body_type: str
        :param body_subtype: Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated
        :type body_subtype: str
        :param vehicle_type: To filter listing on their vehicle type
        :type vehicle_type: str
        :param cylinders: To filter listing on their cylinders
        :type cylinders: str
        :param transmission: To filter listing on their transmission
        :type transmission: str
        :param doors: Doors to filter the cars on. Valid filter values are those that our Search facets API returns for unique doors. You can pass in multiple doors values comma separated
        :type doors: str
        :param drivetrain: To filter listing on their drivetrain
        :type drivetrain: str
        :param exterior_color: Exterior color to match. Valid filter values are those that our Search facets API returns for unique exterior colors. You can pass in multiple exterior color values comma separated
        :type exterior_color: str
        :param interior_color: Interior color to match. Valid filter values are those that our Search facets API returns for unique interior colors. You can pass in multiple interior color values comma separated
        :type interior_color: str
        :param base_exterior_color: Base exterior color to match. Valid filter values are those that our Search facets API returns for unique base exterior colors. You can pass in multiple base interior color values comma separated
        :type base_exterior_color: str
        :param base_interior_color: Base interior color to match. Valid filter values are those that our Search facets API returns for unique base interior colors. You can pass in multiple base interior color values comma separated
        :type base_interior_color: str
        :param engine: To filter listing on their engine
        :type engine: str
        :param engine_size: Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated
        :type engine_size: str
        :param engine_aspiration: Engine Aspiration to match. Valid filter values are those that our Search facets API returns for unique Engine Aspirations. You can pass in multiple Engine aspirations values comma separated
        :type engine_aspiration: str
        :param engine_block: Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated
        :type engine_block: str
        :param highway_mpg_range: Highway mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type highway_mpg_range: str
        :param city_mpg_range: City mileage range to filter listings with the mileage in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type city_mpg_range: str
        :param miles_range: Miles range to filter listings with miles in the given range. Range to be given in the format - min-max e.g. 1000-5000
        :type miles_range: str
        :param price_range: Price range to filter listings with the price in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type price_range: str
        :param msrp_range: MSRP range to filter listings with the msrp in the range given. Range to be given in the format - min-max e.g. 1000-5000
        :type msrp_range: str
        :param dom_range: Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
        :type dom_range: str
        :param dealership_group_name: Name of the dealership group to search for
        :type dealership_group_name: str
        :param dom_active_range: Active Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
        :type dom_active_range: str
        :param dom_180_range: Last 180 Days on Market range to filter cars with the DOM within the given range. Range to be given in the format - min-max e.g. 10-50
        :type dom_180_range: str
        :param fuel_type: To filter listing on their fuel type
        :type fuel_type: str
        :param dealer_type: Filter based on dealer type independant or franchise
        :type dealer_type: str
        :param engine_size_range: Engine size range to filter listings with engine size in the given range. Range to be given in the format - min-max e.g. 1.0-2
        :type engine_size_range: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_mds_serialize(
            api_key=api_key,
            vin=vin,
            exact=exact,
            latitude=latitude,
            longitude=longitude,
            radius=radius,
            zip=zip,
            msa_code=msa_code,
            debug=debug,
            include_sold=include_sold,
            country=country,
            state=state,
            city=city,
            ymmt=ymmt,
            car_type=car_type,
            lease_term=lease_term,
            lease_down_payment=lease_down_payment,
            lease_emp=lease_emp,
            finance_loan_term=finance_loan_term,
            finance_loan_apr=finance_loan_apr,
            finance_emp=finance_emp,
            finance_down_payment=finance_down_payment,
            finance_down_payment_per=finance_down_payment_per,
            carfax_1_owner=carfax_1_owner,
            carfax_clean_title=carfax_clean_title,
            year=year,
            make=make,
            model=model,
            trim=trim,
            dealer_id=dealer_id,
            source=source,
            body_type=body_type,
            body_subtype=body_subtype,
            vehicle_type=vehicle_type,
            cylinders=cylinders,
            transmission=transmission,
            doors=doors,
            drivetrain=drivetrain,
            exterior_color=exterior_color,
            interior_color=interior_color,
            base_exterior_color=base_exterior_color,
            base_interior_color=base_interior_color,
            engine=engine,
            engine_size=engine_size,
            engine_aspiration=engine_aspiration,
            engine_block=engine_block,
            highway_mpg_range=highway_mpg_range,
            city_mpg_range=city_mpg_range,
            miles_range=miles_range,
            price_range=price_range,
            msrp_range=msrp_range,
            dom_range=dom_range,
            dealership_group_name=dealership_group_name,
            dom_active_range=dom_active_range,
            dom_180_range=dom_180_range,
            fuel_type=fuel_type,
            dealer_type=dealer_type,
            engine_size_range=engine_size_range,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Mds",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_mds_serialize(
        self,
        api_key,
        vin,
        exact,
        latitude,
        longitude,
        radius,
        zip,
        msa_code,
        debug,
        include_sold,
        country,
        state,
        city,
        ymmt,
        car_type,
        lease_term,
        lease_down_payment,
        lease_emp,
        finance_loan_term,
        finance_loan_apr,
        finance_emp,
        finance_down_payment,
        finance_down_payment_per,
        carfax_1_owner,
        carfax_clean_title,
        year,
        make,
        model,
        trim,
        dealer_id,
        source,
        body_type,
        body_subtype,
        vehicle_type,
        cylinders,
        transmission,
        doors,
        drivetrain,
        exterior_color,
        interior_color,
        base_exterior_color,
        base_interior_color,
        engine,
        engine_size,
        engine_aspiration,
        engine_block,
        highway_mpg_range,
        city_mpg_range,
        miles_range,
        price_range,
        msrp_range,
        dom_range,
        dealership_group_name,
        dom_active_range,
        dom_180_range,
        fuel_type,
        dealer_type,
        engine_size_range,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        if vin is not None:
            
            _query_params.append(('vin', vin))
            
        if exact is not None:
            
            _query_params.append(('exact', exact))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if radius is not None:
            
            _query_params.append(('radius', radius))
            
        if zip is not None:
            
            _query_params.append(('zip', zip))
            
        if msa_code is not None:
            
            _query_params.append(('msa_code', msa_code))
            
        if debug is not None:
            
            _query_params.append(('debug', debug))
            
        if include_sold is not None:
            
            _query_params.append(('include_sold', include_sold))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if ymmt is not None:
            
            _query_params.append(('ymmt', ymmt))
            
        if car_type is not None:
            
            _query_params.append(('car_type', car_type))
            
        if lease_term is not None:
            
            _query_params.append(('lease_term', lease_term))
            
        if lease_down_payment is not None:
            
            _query_params.append(('lease_down_payment', lease_down_payment))
            
        if lease_emp is not None:
            
            _query_params.append(('lease_emp', lease_emp))
            
        if finance_loan_term is not None:
            
            _query_params.append(('finance_loan_term', finance_loan_term))
            
        if finance_loan_apr is not None:
            
            _query_params.append(('finance_loan_apr', finance_loan_apr))
            
        if finance_emp is not None:
            
            _query_params.append(('finance_emp', finance_emp))
            
        if finance_down_payment is not None:
            
            _query_params.append(('finance_down_payment', finance_down_payment))
            
        if finance_down_payment_per is not None:
            
            _query_params.append(('finance_down_payment_per', finance_down_payment_per))
            
        if carfax_1_owner is not None:
            
            _query_params.append(('carfax_1_owner', carfax_1_owner))
            
        if carfax_clean_title is not None:
            
            _query_params.append(('carfax_clean_title', carfax_clean_title))
            
        if year is not None:
            
            _query_params.append(('year', year))
            
        if make is not None:
            
            _query_params.append(('make', make))
            
        if model is not None:
            
            _query_params.append(('model', model))
            
        if trim is not None:
            
            _query_params.append(('trim', trim))
            
        if dealer_id is not None:
            
            _query_params.append(('dealer_id', dealer_id))
            
        if source is not None:
            
            _query_params.append(('source', source))
            
        if body_type is not None:
            
            _query_params.append(('body_type', body_type))
            
        if body_subtype is not None:
            
            _query_params.append(('body_subtype', body_subtype))
            
        if vehicle_type is not None:
            
            _query_params.append(('vehicle_type', vehicle_type))
            
        if cylinders is not None:
            
            _query_params.append(('cylinders', cylinders))
            
        if transmission is not None:
            
            _query_params.append(('transmission', transmission))
            
        if doors is not None:
            
            _query_params.append(('doors', doors))
            
        if drivetrain is not None:
            
            _query_params.append(('drivetrain', drivetrain))
            
        if exterior_color is not None:
            
            _query_params.append(('exterior_color', exterior_color))
            
        if interior_color is not None:
            
            _query_params.append(('interior_color', interior_color))
            
        if base_exterior_color is not None:
            
            _query_params.append(('base_exterior_color', base_exterior_color))
            
        if base_interior_color is not None:
            
            _query_params.append(('base_interior_color', base_interior_color))
            
        if engine is not None:
            
            _query_params.append(('engine', engine))
            
        if engine_size is not None:
            
            _query_params.append(('engine_size', engine_size))
            
        if engine_aspiration is not None:
            
            _query_params.append(('engine_aspiration', engine_aspiration))
            
        if engine_block is not None:
            
            _query_params.append(('engine_block', engine_block))
            
        if highway_mpg_range is not None:
            
            _query_params.append(('highway_mpg_range', highway_mpg_range))
            
        if city_mpg_range is not None:
            
            _query_params.append(('city_mpg_range', city_mpg_range))
            
        if miles_range is not None:
            
            _query_params.append(('miles_range', miles_range))
            
        if price_range is not None:
            
            _query_params.append(('price_range', price_range))
            
        if msrp_range is not None:
            
            _query_params.append(('msrp_range', msrp_range))
            
        if dom_range is not None:
            
            _query_params.append(('dom_range', dom_range))
            
        if dealership_group_name is not None:
            
            _query_params.append(('dealership_group_name', dealership_group_name))
            
        if dom_active_range is not None:
            
            _query_params.append(('dom_active_range', dom_active_range))
            
        if dom_180_range is not None:
            
            _query_params.append(('dom_180_range', dom_180_range))
            
        if fuel_type is not None:
            
            _query_params.append(('fuel_type', fuel_type))
            
        if dealer_type is not None:
            
            _query_params.append(('dealer_type', dealer_type))
            
        if engine_size_range is not None:
            
            _query_params.append(('engine_size_range', engine_size_range))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/mds/car',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_popular_cars(
        self,
        car_type: Annotated[StrictStr, Field(description="Inventory type for which popular count is to be searched")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State level sales count")] = None,
        city_state: Annotated[Optional[StrictStr], Field(description="City level sales count, pipe seperated like city_state=jacksonville|FL")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which the popular cars are to be searched")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PopularCars:
        """Get make model wise top 50 popular cars on national, state, city level

        Get make model wise top 50 popular cars on national, state, city level

        :param car_type: Inventory type for which popular count is to be searched (required)
        :type car_type: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param state: State level sales count
        :type state: str
        :param city_state: City level sales count, pipe seperated like city_state=jacksonville|FL
        :type city_state: str
        :param country: Country for which the popular cars are to be searched
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_popular_cars_serialize(
            car_type=car_type,
            api_key=api_key,
            state=state,
            city_state=city_state,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PopularCars",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_popular_cars_with_http_info(
        self,
        car_type: Annotated[StrictStr, Field(description="Inventory type for which popular count is to be searched")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State level sales count")] = None,
        city_state: Annotated[Optional[StrictStr], Field(description="City level sales count, pipe seperated like city_state=jacksonville|FL")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which the popular cars are to be searched")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PopularCars]:
        """Get make model wise top 50 popular cars on national, state, city level

        Get make model wise top 50 popular cars on national, state, city level

        :param car_type: Inventory type for which popular count is to be searched (required)
        :type car_type: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param state: State level sales count
        :type state: str
        :param city_state: City level sales count, pipe seperated like city_state=jacksonville|FL
        :type city_state: str
        :param country: Country for which the popular cars are to be searched
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_popular_cars_serialize(
            car_type=car_type,
            api_key=api_key,
            state=state,
            city_state=city_state,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PopularCars",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_popular_cars_without_preload_content(
        self,
        car_type: Annotated[StrictStr, Field(description="Inventory type for which popular count is to be searched")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State level sales count")] = None,
        city_state: Annotated[Optional[StrictStr], Field(description="City level sales count, pipe seperated like city_state=jacksonville|FL")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which the popular cars are to be searched")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get make model wise top 50 popular cars on national, state, city level

        Get make model wise top 50 popular cars on national, state, city level

        :param car_type: Inventory type for which popular count is to be searched (required)
        :type car_type: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param state: State level sales count
        :type state: str
        :param city_state: City level sales count, pipe seperated like city_state=jacksonville|FL
        :type city_state: str
        :param country: Country for which the popular cars are to be searched
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_popular_cars_serialize(
            car_type=car_type,
            api_key=api_key,
            state=state,
            city_state=city_state,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PopularCars",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_popular_cars_serialize(
        self,
        car_type,
        api_key,
        state,
        city_state,
        country,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if city_state is not None:
            
            _query_params.append(('city_state', city_state))
            
        if car_type is not None:
            
            _query_params.append(('car_type', car_type))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/popular/cars',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_sales_count(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        car_type: Annotated[Optional[StrictStr], Field(description="Inventory type for which sales count is to be searched, default is used")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Make for which sales count is to be searched")] = None,
        mm: Annotated[Optional[StrictStr], Field(description="Make-Model for which sales count is to be searched, pipe seperated like mm=ford|f-150")] = None,
        ymm: Annotated[Optional[StrictStr], Field(description="Year-Make-Model for which sales count is to be searched, pipe seperated like ymm=2015|ford|f-150")] = None,
        ymmt: Annotated[Optional[StrictStr], Field(description="Year-Make-Model-Trim for which sales count is to be searched, pipe seperated like ymmt=2015|ford|f-150|platinum")] = None,
        taxonomy_vin: Annotated[Optional[StrictStr], Field(description="taxonomy_vin for which sales count is to be searched")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State level sales count")] = None,
        city_state: Annotated[Optional[StrictStr], Field(description="City level sales count, pipe seperated like city_state=jacksonville|FL")] = None,
        vin: Annotated[Optional[StrictStr], Field(description="VIN that will be transformed to taxonomy_vin")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which the sales records are to be searched")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Sales:
        """Get sales count by make, model, year, trim or taxonomy vin

        Get a sales count for city, state or national level by make, model, year, trim or taxonomy vin

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param car_type: Inventory type for which sales count is to be searched, default is used
        :type car_type: str
        :param make: Make for which sales count is to be searched
        :type make: str
        :param mm: Make-Model for which sales count is to be searched, pipe seperated like mm=ford|f-150
        :type mm: str
        :param ymm: Year-Make-Model for which sales count is to be searched, pipe seperated like ymm=2015|ford|f-150
        :type ymm: str
        :param ymmt: Year-Make-Model-Trim for which sales count is to be searched, pipe seperated like ymmt=2015|ford|f-150|platinum
        :type ymmt: str
        :param taxonomy_vin: taxonomy_vin for which sales count is to be searched
        :type taxonomy_vin: str
        :param state: State level sales count
        :type state: str
        :param city_state: City level sales count, pipe seperated like city_state=jacksonville|FL
        :type city_state: str
        :param vin: VIN that will be transformed to taxonomy_vin
        :type vin: str
        :param country: Country for which the sales records are to be searched
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sales_count_serialize(
            api_key=api_key,
            car_type=car_type,
            make=make,
            mm=mm,
            ymm=ymm,
            ymmt=ymmt,
            taxonomy_vin=taxonomy_vin,
            state=state,
            city_state=city_state,
            vin=vin,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Sales",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_sales_count_with_http_info(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        car_type: Annotated[Optional[StrictStr], Field(description="Inventory type for which sales count is to be searched, default is used")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Make for which sales count is to be searched")] = None,
        mm: Annotated[Optional[StrictStr], Field(description="Make-Model for which sales count is to be searched, pipe seperated like mm=ford|f-150")] = None,
        ymm: Annotated[Optional[StrictStr], Field(description="Year-Make-Model for which sales count is to be searched, pipe seperated like ymm=2015|ford|f-150")] = None,
        ymmt: Annotated[Optional[StrictStr], Field(description="Year-Make-Model-Trim for which sales count is to be searched, pipe seperated like ymmt=2015|ford|f-150|platinum")] = None,
        taxonomy_vin: Annotated[Optional[StrictStr], Field(description="taxonomy_vin for which sales count is to be searched")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State level sales count")] = None,
        city_state: Annotated[Optional[StrictStr], Field(description="City level sales count, pipe seperated like city_state=jacksonville|FL")] = None,
        vin: Annotated[Optional[StrictStr], Field(description="VIN that will be transformed to taxonomy_vin")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which the sales records are to be searched")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Sales]:
        """Get sales count by make, model, year, trim or taxonomy vin

        Get a sales count for city, state or national level by make, model, year, trim or taxonomy vin

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param car_type: Inventory type for which sales count is to be searched, default is used
        :type car_type: str
        :param make: Make for which sales count is to be searched
        :type make: str
        :param mm: Make-Model for which sales count is to be searched, pipe seperated like mm=ford|f-150
        :type mm: str
        :param ymm: Year-Make-Model for which sales count is to be searched, pipe seperated like ymm=2015|ford|f-150
        :type ymm: str
        :param ymmt: Year-Make-Model-Trim for which sales count is to be searched, pipe seperated like ymmt=2015|ford|f-150|platinum
        :type ymmt: str
        :param taxonomy_vin: taxonomy_vin for which sales count is to be searched
        :type taxonomy_vin: str
        :param state: State level sales count
        :type state: str
        :param city_state: City level sales count, pipe seperated like city_state=jacksonville|FL
        :type city_state: str
        :param vin: VIN that will be transformed to taxonomy_vin
        :type vin: str
        :param country: Country for which the sales records are to be searched
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sales_count_serialize(
            api_key=api_key,
            car_type=car_type,
            make=make,
            mm=mm,
            ymm=ymm,
            ymmt=ymmt,
            taxonomy_vin=taxonomy_vin,
            state=state,
            city_state=city_state,
            vin=vin,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Sales",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_sales_count_without_preload_content(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        car_type: Annotated[Optional[StrictStr], Field(description="Inventory type for which sales count is to be searched, default is used")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Make for which sales count is to be searched")] = None,
        mm: Annotated[Optional[StrictStr], Field(description="Make-Model for which sales count is to be searched, pipe seperated like mm=ford|f-150")] = None,
        ymm: Annotated[Optional[StrictStr], Field(description="Year-Make-Model for which sales count is to be searched, pipe seperated like ymm=2015|ford|f-150")] = None,
        ymmt: Annotated[Optional[StrictStr], Field(description="Year-Make-Model-Trim for which sales count is to be searched, pipe seperated like ymmt=2015|ford|f-150|platinum")] = None,
        taxonomy_vin: Annotated[Optional[StrictStr], Field(description="taxonomy_vin for which sales count is to be searched")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State level sales count")] = None,
        city_state: Annotated[Optional[StrictStr], Field(description="City level sales count, pipe seperated like city_state=jacksonville|FL")] = None,
        vin: Annotated[Optional[StrictStr], Field(description="VIN that will be transformed to taxonomy_vin")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which the sales records are to be searched")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get sales count by make, model, year, trim or taxonomy vin

        Get a sales count for city, state or national level by make, model, year, trim or taxonomy vin

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param car_type: Inventory type for which sales count is to be searched, default is used
        :type car_type: str
        :param make: Make for which sales count is to be searched
        :type make: str
        :param mm: Make-Model for which sales count is to be searched, pipe seperated like mm=ford|f-150
        :type mm: str
        :param ymm: Year-Make-Model for which sales count is to be searched, pipe seperated like ymm=2015|ford|f-150
        :type ymm: str
        :param ymmt: Year-Make-Model-Trim for which sales count is to be searched, pipe seperated like ymmt=2015|ford|f-150|platinum
        :type ymmt: str
        :param taxonomy_vin: taxonomy_vin for which sales count is to be searched
        :type taxonomy_vin: str
        :param state: State level sales count
        :type state: str
        :param city_state: City level sales count, pipe seperated like city_state=jacksonville|FL
        :type city_state: str
        :param vin: VIN that will be transformed to taxonomy_vin
        :type vin: str
        :param country: Country for which the sales records are to be searched
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sales_count_serialize(
            api_key=api_key,
            car_type=car_type,
            make=make,
            mm=mm,
            ymm=ymm,
            ymmt=ymmt,
            taxonomy_vin=taxonomy_vin,
            state=state,
            city_state=city_state,
            vin=vin,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Sales",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_sales_count_serialize(
        self,
        api_key,
        car_type,
        make,
        mm,
        ymm,
        ymmt,
        taxonomy_vin,
        state,
        city_state,
        vin,
        country,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        if car_type is not None:
            
            _query_params.append(('car_type', car_type))
            
        if make is not None:
            
            _query_params.append(('make', make))
            
        if mm is not None:
            
            _query_params.append(('mm', mm))
            
        if ymm is not None:
            
            _query_params.append(('ymm', ymm))
            
        if ymmt is not None:
            
            _query_params.append(('ymmt', ymmt))
            
        if taxonomy_vin is not None:
            
            _query_params.append(('taxonomy_vin', taxonomy_vin))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if city_state is not None:
            
            _query_params.append(('city_state', city_state))
            
        if vin is not None:
            
            _query_params.append(('vin', vin))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/sales/car',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def predict_car_price(
        self,
        car_type: Annotated[StrictStr, Field(description="Car condition")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vin: Annotated[Optional[StrictStr], Field(description="Predict price for a VIN")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Car manufacturing year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Car's make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="Car's model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="Car's trim")] = None,
        is_certified: Annotated[Optional[StrictBool], Field(description="Boolean to indicate car is certified or not")] = None,
        carfax_1_owner: Annotated[Optional[StrictBool], Field(description="Boolean to indicate car is carfax one owner or not")] = None,
        carfax_clean_title: Annotated[Optional[StrictBool], Field(description="Boolean to indicate car has clean title or not")] = None,
        base_exterior_color: Annotated[Optional[StrictStr], Field(description="Base exterior color of the car")] = None,
        base_interior_color: Annotated[Optional[StrictStr], Field(description="Base interior color of the car")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="Transmission on the car")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="Drivetrain on the car")] = None,
        engine_size: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Engine Size of the car")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block of the car")] = None,
        cylinders: Annotated[Optional[StrictInt], Field(description="Number of cylinders in the vehicle")] = None,
        doors: Annotated[Optional[StrictInt], Field(description="Number of doors in the vehicle")] = None,
        highway_mpg: Annotated[Optional[StrictInt], Field(description="Highway mileage")] = None,
        city_mpg: Annotated[Optional[StrictInt], Field(description="City mileage of the car")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude component of the location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude component of the location")] = None,
        miles: Annotated[Optional[StrictInt], Field(description="miles vehicle has driven in total")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="Location zip")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which car price will be predicted")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PricePrediction:
        """Predict car price based on it's specifications

        Predict car price based on it's specifications

        :param car_type: Car condition (required)
        :type car_type: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vin: Predict price for a VIN
        :type vin: str
        :param year: Car manufacturing year
        :type year: int
        :param make: Car's make
        :type make: str
        :param model: Car's model
        :type model: str
        :param trim: Car's trim
        :type trim: str
        :param is_certified: Boolean to indicate car is certified or not
        :type is_certified: bool
        :param carfax_1_owner: Boolean to indicate car is carfax one owner or not
        :type carfax_1_owner: bool
        :param carfax_clean_title: Boolean to indicate car has clean title or not
        :type carfax_clean_title: bool
        :param base_exterior_color: Base exterior color of the car
        :type base_exterior_color: str
        :param base_interior_color: Base interior color of the car
        :type base_interior_color: str
        :param transmission: Transmission on the car
        :type transmission: str
        :param drivetrain: Drivetrain on the car
        :type drivetrain: str
        :param engine_size: Engine Size of the car
        :type engine_size: float
        :param engine_block: Engine Block of the car
        :type engine_block: str
        :param cylinders: Number of cylinders in the vehicle
        :type cylinders: int
        :param doors: Number of doors in the vehicle
        :type doors: int
        :param highway_mpg: Highway mileage
        :type highway_mpg: int
        :param city_mpg: City mileage of the car
        :type city_mpg: int
        :param latitude: Latitude component of the location
        :type latitude: float
        :param longitude: Longitude component of the location
        :type longitude: float
        :param miles: miles vehicle has driven in total
        :type miles: int
        :param zip: Location zip
        :type zip: str
        :param country: Country for which car price will be predicted
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._predict_car_price_serialize(
            car_type=car_type,
            api_key=api_key,
            vin=vin,
            year=year,
            make=make,
            model=model,
            trim=trim,
            is_certified=is_certified,
            carfax_1_owner=carfax_1_owner,
            carfax_clean_title=carfax_clean_title,
            base_exterior_color=base_exterior_color,
            base_interior_color=base_interior_color,
            transmission=transmission,
            drivetrain=drivetrain,
            engine_size=engine_size,
            engine_block=engine_block,
            cylinders=cylinders,
            doors=doors,
            highway_mpg=highway_mpg,
            city_mpg=city_mpg,
            latitude=latitude,
            longitude=longitude,
            miles=miles,
            zip=zip,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PricePrediction",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def predict_car_price_with_http_info(
        self,
        car_type: Annotated[StrictStr, Field(description="Car condition")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vin: Annotated[Optional[StrictStr], Field(description="Predict price for a VIN")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Car manufacturing year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Car's make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="Car's model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="Car's trim")] = None,
        is_certified: Annotated[Optional[StrictBool], Field(description="Boolean to indicate car is certified or not")] = None,
        carfax_1_owner: Annotated[Optional[StrictBool], Field(description="Boolean to indicate car is carfax one owner or not")] = None,
        carfax_clean_title: Annotated[Optional[StrictBool], Field(description="Boolean to indicate car has clean title or not")] = None,
        base_exterior_color: Annotated[Optional[StrictStr], Field(description="Base exterior color of the car")] = None,
        base_interior_color: Annotated[Optional[StrictStr], Field(description="Base interior color of the car")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="Transmission on the car")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="Drivetrain on the car")] = None,
        engine_size: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Engine Size of the car")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block of the car")] = None,
        cylinders: Annotated[Optional[StrictInt], Field(description="Number of cylinders in the vehicle")] = None,
        doors: Annotated[Optional[StrictInt], Field(description="Number of doors in the vehicle")] = None,
        highway_mpg: Annotated[Optional[StrictInt], Field(description="Highway mileage")] = None,
        city_mpg: Annotated[Optional[StrictInt], Field(description="City mileage of the car")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude component of the location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude component of the location")] = None,
        miles: Annotated[Optional[StrictInt], Field(description="miles vehicle has driven in total")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="Location zip")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which car price will be predicted")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PricePrediction]:
        """Predict car price based on it's specifications

        Predict car price based on it's specifications

        :param car_type: Car condition (required)
        :type car_type: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vin: Predict price for a VIN
        :type vin: str
        :param year: Car manufacturing year
        :type year: int
        :param make: Car's make
        :type make: str
        :param model: Car's model
        :type model: str
        :param trim: Car's trim
        :type trim: str
        :param is_certified: Boolean to indicate car is certified or not
        :type is_certified: bool
        :param carfax_1_owner: Boolean to indicate car is carfax one owner or not
        :type carfax_1_owner: bool
        :param carfax_clean_title: Boolean to indicate car has clean title or not
        :type carfax_clean_title: bool
        :param base_exterior_color: Base exterior color of the car
        :type base_exterior_color: str
        :param base_interior_color: Base interior color of the car
        :type base_interior_color: str
        :param transmission: Transmission on the car
        :type transmission: str
        :param drivetrain: Drivetrain on the car
        :type drivetrain: str
        :param engine_size: Engine Size of the car
        :type engine_size: float
        :param engine_block: Engine Block of the car
        :type engine_block: str
        :param cylinders: Number of cylinders in the vehicle
        :type cylinders: int
        :param doors: Number of doors in the vehicle
        :type doors: int
        :param highway_mpg: Highway mileage
        :type highway_mpg: int
        :param city_mpg: City mileage of the car
        :type city_mpg: int
        :param latitude: Latitude component of the location
        :type latitude: float
        :param longitude: Longitude component of the location
        :type longitude: float
        :param miles: miles vehicle has driven in total
        :type miles: int
        :param zip: Location zip
        :type zip: str
        :param country: Country for which car price will be predicted
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._predict_car_price_serialize(
            car_type=car_type,
            api_key=api_key,
            vin=vin,
            year=year,
            make=make,
            model=model,
            trim=trim,
            is_certified=is_certified,
            carfax_1_owner=carfax_1_owner,
            carfax_clean_title=carfax_clean_title,
            base_exterior_color=base_exterior_color,
            base_interior_color=base_interior_color,
            transmission=transmission,
            drivetrain=drivetrain,
            engine_size=engine_size,
            engine_block=engine_block,
            cylinders=cylinders,
            doors=doors,
            highway_mpg=highway_mpg,
            city_mpg=city_mpg,
            latitude=latitude,
            longitude=longitude,
            miles=miles,
            zip=zip,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PricePrediction",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def predict_car_price_without_preload_content(
        self,
        car_type: Annotated[StrictStr, Field(description="Car condition")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vin: Annotated[Optional[StrictStr], Field(description="Predict price for a VIN")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Car manufacturing year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Car's make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="Car's model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="Car's trim")] = None,
        is_certified: Annotated[Optional[StrictBool], Field(description="Boolean to indicate car is certified or not")] = None,
        carfax_1_owner: Annotated[Optional[StrictBool], Field(description="Boolean to indicate car is carfax one owner or not")] = None,
        carfax_clean_title: Annotated[Optional[StrictBool], Field(description="Boolean to indicate car has clean title or not")] = None,
        base_exterior_color: Annotated[Optional[StrictStr], Field(description="Base exterior color of the car")] = None,
        base_interior_color: Annotated[Optional[StrictStr], Field(description="Base interior color of the car")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="Transmission on the car")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="Drivetrain on the car")] = None,
        engine_size: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Engine Size of the car")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block of the car")] = None,
        cylinders: Annotated[Optional[StrictInt], Field(description="Number of cylinders in the vehicle")] = None,
        doors: Annotated[Optional[StrictInt], Field(description="Number of doors in the vehicle")] = None,
        highway_mpg: Annotated[Optional[StrictInt], Field(description="Highway mileage")] = None,
        city_mpg: Annotated[Optional[StrictInt], Field(description="City mileage of the car")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude component of the location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude component of the location")] = None,
        miles: Annotated[Optional[StrictInt], Field(description="miles vehicle has driven in total")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="Location zip")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country for which car price will be predicted")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Predict car price based on it's specifications

        Predict car price based on it's specifications

        :param car_type: Car condition (required)
        :type car_type: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vin: Predict price for a VIN
        :type vin: str
        :param year: Car manufacturing year
        :type year: int
        :param make: Car's make
        :type make: str
        :param model: Car's model
        :type model: str
        :param trim: Car's trim
        :type trim: str
        :param is_certified: Boolean to indicate car is certified or not
        :type is_certified: bool
        :param carfax_1_owner: Boolean to indicate car is carfax one owner or not
        :type carfax_1_owner: bool
        :param carfax_clean_title: Boolean to indicate car has clean title or not
        :type carfax_clean_title: bool
        :param base_exterior_color: Base exterior color of the car
        :type base_exterior_color: str
        :param base_interior_color: Base interior color of the car
        :type base_interior_color: str
        :param transmission: Transmission on the car
        :type transmission: str
        :param drivetrain: Drivetrain on the car
        :type drivetrain: str
        :param engine_size: Engine Size of the car
        :type engine_size: float
        :param engine_block: Engine Block of the car
        :type engine_block: str
        :param cylinders: Number of cylinders in the vehicle
        :type cylinders: int
        :param doors: Number of doors in the vehicle
        :type doors: int
        :param highway_mpg: Highway mileage
        :type highway_mpg: int
        :param city_mpg: City mileage of the car
        :type city_mpg: int
        :param latitude: Latitude component of the location
        :type latitude: float
        :param longitude: Longitude component of the location
        :type longitude: float
        :param miles: miles vehicle has driven in total
        :type miles: int
        :param zip: Location zip
        :type zip: str
        :param country: Country for which car price will be predicted
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._predict_car_price_serialize(
            car_type=car_type,
            api_key=api_key,
            vin=vin,
            year=year,
            make=make,
            model=model,
            trim=trim,
            is_certified=is_certified,
            carfax_1_owner=carfax_1_owner,
            carfax_clean_title=carfax_clean_title,
            base_exterior_color=base_exterior_color,
            base_interior_color=base_interior_color,
            transmission=transmission,
            drivetrain=drivetrain,
            engine_size=engine_size,
            engine_block=engine_block,
            cylinders=cylinders,
            doors=doors,
            highway_mpg=highway_mpg,
            city_mpg=city_mpg,
            latitude=latitude,
            longitude=longitude,
            miles=miles,
            zip=zip,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PricePrediction",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _predict_car_price_serialize(
        self,
        car_type,
        api_key,
        vin,
        year,
        make,
        model,
        trim,
        is_certified,
        carfax_1_owner,
        carfax_clean_title,
        base_exterior_color,
        base_interior_color,
        transmission,
        drivetrain,
        engine_size,
        engine_block,
        cylinders,
        doors,
        highway_mpg,
        city_mpg,
        latitude,
        longitude,
        miles,
        zip,
        country,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        if vin is not None:
            
            _query_params.append(('vin', vin))
            
        if car_type is not None:
            
            _query_params.append(('car_type', car_type))
            
        if year is not None:
            
            _query_params.append(('year', year))
            
        if make is not None:
            
            _query_params.append(('make', make))
            
        if model is not None:
            
            _query_params.append(('model', model))
            
        if trim is not None:
            
            _query_params.append(('trim', trim))
            
        if is_certified is not None:
            
            _query_params.append(('is_certified', is_certified))
            
        if carfax_1_owner is not None:
            
            _query_params.append(('carfax_1_owner', carfax_1_owner))
            
        if carfax_clean_title is not None:
            
            _query_params.append(('carfax_clean_title', carfax_clean_title))
            
        if base_exterior_color is not None:
            
            _query_params.append(('base_exterior_color', base_exterior_color))
            
        if base_interior_color is not None:
            
            _query_params.append(('base_interior_color', base_interior_color))
            
        if transmission is not None:
            
            _query_params.append(('transmission', transmission))
            
        if drivetrain is not None:
            
            _query_params.append(('drivetrain', drivetrain))
            
        if engine_size is not None:
            
            _query_params.append(('engine_size', engine_size))
            
        if engine_block is not None:
            
            _query_params.append(('engine_block', engine_block))
            
        if cylinders is not None:
            
            _query_params.append(('cylinders', cylinders))
            
        if doors is not None:
            
            _query_params.append(('doors', doors))
            
        if highway_mpg is not None:
            
            _query_params.append(('highway_mpg', highway_mpg))
            
        if city_mpg is not None:
            
            _query_params.append(('city_mpg', city_mpg))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if miles is not None:
            
            _query_params.append(('miles', miles))
            
        if zip is not None:
            
            _query_params.append(('zip', zip))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/predict/car/price',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def predict_uk_car_price(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vrm: Annotated[Optional[StrictStr], Field(description="Predict price for a VRM")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Car manufacturing year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Car's make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="Car's model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="Car's trim")] = None,
        base_exterior_color: Annotated[Optional[StrictStr], Field(description="Base exterior color of the car")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="Transmission on the car")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="Drivetrain on the car")] = None,
        engine_size: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Engine Size of the car")] = None,
        cylinders: Annotated[Optional[StrictInt], Field(description="Number of cylinders in the vehicle")] = None,
        doors: Annotated[Optional[StrictInt], Field(description="Number of doors in the vehicle")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="Fuel type of the car")] = None,
        highway_mpg: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Highway mileage")] = None,
        city_mpg: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="City mileage of the car")] = None,
        combined_mpg: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Combiined mileage of the car")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude component of the location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude component of the location")] = None,
        miles: Annotated[Optional[StrictInt], Field(description="miles vehicle has driven in total")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="Location zip")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PricePrediction:
        """Predict car price for UK based on it's specifications

        Predict car price for UK based on it's specifications

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vrm: Predict price for a VRM
        :type vrm: str
        :param year: Car manufacturing year
        :type year: int
        :param make: Car's make
        :type make: str
        :param model: Car's model
        :type model: str
        :param trim: Car's trim
        :type trim: str
        :param base_exterior_color: Base exterior color of the car
        :type base_exterior_color: str
        :param transmission: Transmission on the car
        :type transmission: str
        :param drivetrain: Drivetrain on the car
        :type drivetrain: str
        :param engine_size: Engine Size of the car
        :type engine_size: float
        :param cylinders: Number of cylinders in the vehicle
        :type cylinders: int
        :param doors: Number of doors in the vehicle
        :type doors: int
        :param fuel_type: Fuel type of the car
        :type fuel_type: str
        :param highway_mpg: Highway mileage
        :type highway_mpg: float
        :param city_mpg: City mileage of the car
        :type city_mpg: float
        :param combined_mpg: Combiined mileage of the car
        :type combined_mpg: float
        :param latitude: Latitude component of the location
        :type latitude: float
        :param longitude: Longitude component of the location
        :type longitude: float
        :param miles: miles vehicle has driven in total
        :type miles: int
        :param zip: Location zip
        :type zip: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._predict_uk_car_price_serialize(
            api_key=api_key,
            vrm=vrm,
            year=year,
            make=make,
            model=model,
            trim=trim,
            base_exterior_color=base_exterior_color,
            transmission=transmission,
            drivetrain=drivetrain,
            engine_size=engine_size,
            cylinders=cylinders,
            doors=doors,
            fuel_type=fuel_type,
            highway_mpg=highway_mpg,
            city_mpg=city_mpg,
            combined_mpg=combined_mpg,
            latitude=latitude,
            longitude=longitude,
            miles=miles,
            zip=zip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PricePrediction",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def predict_uk_car_price_with_http_info(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vrm: Annotated[Optional[StrictStr], Field(description="Predict price for a VRM")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Car manufacturing year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Car's make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="Car's model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="Car's trim")] = None,
        base_exterior_color: Annotated[Optional[StrictStr], Field(description="Base exterior color of the car")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="Transmission on the car")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="Drivetrain on the car")] = None,
        engine_size: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Engine Size of the car")] = None,
        cylinders: Annotated[Optional[StrictInt], Field(description="Number of cylinders in the vehicle")] = None,
        doors: Annotated[Optional[StrictInt], Field(description="Number of doors in the vehicle")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="Fuel type of the car")] = None,
        highway_mpg: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Highway mileage")] = None,
        city_mpg: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="City mileage of the car")] = None,
        combined_mpg: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Combiined mileage of the car")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude component of the location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude component of the location")] = None,
        miles: Annotated[Optional[StrictInt], Field(description="miles vehicle has driven in total")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="Location zip")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PricePrediction]:
        """Predict car price for UK based on it's specifications

        Predict car price for UK based on it's specifications

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vrm: Predict price for a VRM
        :type vrm: str
        :param year: Car manufacturing year
        :type year: int
        :param make: Car's make
        :type make: str
        :param model: Car's model
        :type model: str
        :param trim: Car's trim
        :type trim: str
        :param base_exterior_color: Base exterior color of the car
        :type base_exterior_color: str
        :param transmission: Transmission on the car
        :type transmission: str
        :param drivetrain: Drivetrain on the car
        :type drivetrain: str
        :param engine_size: Engine Size of the car
        :type engine_size: float
        :param cylinders: Number of cylinders in the vehicle
        :type cylinders: int
        :param doors: Number of doors in the vehicle
        :type doors: int
        :param fuel_type: Fuel type of the car
        :type fuel_type: str
        :param highway_mpg: Highway mileage
        :type highway_mpg: float
        :param city_mpg: City mileage of the car
        :type city_mpg: float
        :param combined_mpg: Combiined mileage of the car
        :type combined_mpg: float
        :param latitude: Latitude component of the location
        :type latitude: float
        :param longitude: Longitude component of the location
        :type longitude: float
        :param miles: miles vehicle has driven in total
        :type miles: int
        :param zip: Location zip
        :type zip: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._predict_uk_car_price_serialize(
            api_key=api_key,
            vrm=vrm,
            year=year,
            make=make,
            model=model,
            trim=trim,
            base_exterior_color=base_exterior_color,
            transmission=transmission,
            drivetrain=drivetrain,
            engine_size=engine_size,
            cylinders=cylinders,
            doors=doors,
            fuel_type=fuel_type,
            highway_mpg=highway_mpg,
            city_mpg=city_mpg,
            combined_mpg=combined_mpg,
            latitude=latitude,
            longitude=longitude,
            miles=miles,
            zip=zip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PricePrediction",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def predict_uk_car_price_without_preload_content(
        self,
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        vrm: Annotated[Optional[StrictStr], Field(description="Predict price for a VRM")] = None,
        year: Annotated[Optional[StrictInt], Field(description="Car manufacturing year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="Car's make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="Car's model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="Car's trim")] = None,
        base_exterior_color: Annotated[Optional[StrictStr], Field(description="Base exterior color of the car")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="Transmission on the car")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="Drivetrain on the car")] = None,
        engine_size: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Engine Size of the car")] = None,
        cylinders: Annotated[Optional[StrictInt], Field(description="Number of cylinders in the vehicle")] = None,
        doors: Annotated[Optional[StrictInt], Field(description="Number of doors in the vehicle")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="Fuel type of the car")] = None,
        highway_mpg: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Highway mileage")] = None,
        city_mpg: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="City mileage of the car")] = None,
        combined_mpg: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Combiined mileage of the car")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude component of the location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude component of the location")] = None,
        miles: Annotated[Optional[StrictInt], Field(description="miles vehicle has driven in total")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="Location zip")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Predict car price for UK based on it's specifications

        Predict car price for UK based on it's specifications

        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param vrm: Predict price for a VRM
        :type vrm: str
        :param year: Car manufacturing year
        :type year: int
        :param make: Car's make
        :type make: str
        :param model: Car's model
        :type model: str
        :param trim: Car's trim
        :type trim: str
        :param base_exterior_color: Base exterior color of the car
        :type base_exterior_color: str
        :param transmission: Transmission on the car
        :type transmission: str
        :param drivetrain: Drivetrain on the car
        :type drivetrain: str
        :param engine_size: Engine Size of the car
        :type engine_size: float
        :param cylinders: Number of cylinders in the vehicle
        :type cylinders: int
        :param doors: Number of doors in the vehicle
        :type doors: int
        :param fuel_type: Fuel type of the car
        :type fuel_type: str
        :param highway_mpg: Highway mileage
        :type highway_mpg: float
        :param city_mpg: City mileage of the car
        :type city_mpg: float
        :param combined_mpg: Combiined mileage of the car
        :type combined_mpg: float
        :param latitude: Latitude component of the location
        :type latitude: float
        :param longitude: Longitude component of the location
        :type longitude: float
        :param miles: miles vehicle has driven in total
        :type miles: int
        :param zip: Location zip
        :type zip: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._predict_uk_car_price_serialize(
            api_key=api_key,
            vrm=vrm,
            year=year,
            make=make,
            model=model,
            trim=trim,
            base_exterior_color=base_exterior_color,
            transmission=transmission,
            drivetrain=drivetrain,
            engine_size=engine_size,
            cylinders=cylinders,
            doors=doors,
            fuel_type=fuel_type,
            highway_mpg=highway_mpg,
            city_mpg=city_mpg,
            combined_mpg=combined_mpg,
            latitude=latitude,
            longitude=longitude,
            miles=miles,
            zip=zip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PricePrediction",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _predict_uk_car_price_serialize(
        self,
        api_key,
        vrm,
        year,
        make,
        model,
        trim,
        base_exterior_color,
        transmission,
        drivetrain,
        engine_size,
        cylinders,
        doors,
        fuel_type,
        highway_mpg,
        city_mpg,
        combined_mpg,
        latitude,
        longitude,
        miles,
        zip,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        if vrm is not None:
            
            _query_params.append(('vrm', vrm))
            
        if year is not None:
            
            _query_params.append(('year', year))
            
        if make is not None:
            
            _query_params.append(('make', make))
            
        if model is not None:
            
            _query_params.append(('model', model))
            
        if trim is not None:
            
            _query_params.append(('trim', trim))
            
        if base_exterior_color is not None:
            
            _query_params.append(('base_exterior_color', base_exterior_color))
            
        if transmission is not None:
            
            _query_params.append(('transmission', transmission))
            
        if drivetrain is not None:
            
            _query_params.append(('drivetrain', drivetrain))
            
        if engine_size is not None:
            
            _query_params.append(('engine_size', engine_size))
            
        if cylinders is not None:
            
            _query_params.append(('cylinders', cylinders))
            
        if doors is not None:
            
            _query_params.append(('doors', doors))
            
        if fuel_type is not None:
            
            _query_params.append(('fuel_type', fuel_type))
            
        if highway_mpg is not None:
            
            _query_params.append(('highway_mpg', highway_mpg))
            
        if city_mpg is not None:
            
            _query_params.append(('city_mpg', city_mpg))
            
        if combined_mpg is not None:
            
            _query_params.append(('combined_mpg', combined_mpg))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if miles is not None:
            
            _query_params.append(('miles', miles))
            
        if zip is not None:
            
            _query_params.append(('zip', zip))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/predict/car/uk/price',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


