# coding: utf-8

"""
    Marketcheck APIs

    One API serving data spanned across multiple verticals

    The version of the OpenAPI document: 2.01
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from openapi_client.models.build import Build
from openapi_client.models.neo_vin import NeoVIN
from openapi_client.models.specs_auto_complete_response import SpecsAutoCompleteResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class VINDecoderAPIApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def decode(
        self,
        vin: Annotated[str, Field(min_length=17, strict=True, description="The VIN to identify the car. Must be a valid 17 char VIN")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Build:
        """VIN Decoder

        Get the basic information on specifications for a car identified by a valid VIN

        :param vin: The VIN to identify the car. Must be a valid 17 char VIN (required)
        :type vin: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._decode_serialize(
            vin=vin,
            api_key=api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Build",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def decode_with_http_info(
        self,
        vin: Annotated[str, Field(min_length=17, strict=True, description="The VIN to identify the car. Must be a valid 17 char VIN")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Build]:
        """VIN Decoder

        Get the basic information on specifications for a car identified by a valid VIN

        :param vin: The VIN to identify the car. Must be a valid 17 char VIN (required)
        :type vin: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._decode_serialize(
            vin=vin,
            api_key=api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Build",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def decode_without_preload_content(
        self,
        vin: Annotated[str, Field(min_length=17, strict=True, description="The VIN to identify the car. Must be a valid 17 char VIN")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """VIN Decoder

        Get the basic information on specifications for a car identified by a valid VIN

        :param vin: The VIN to identify the car. Must be a valid 17 char VIN (required)
        :type vin: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._decode_serialize(
            vin=vin,
            api_key=api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Build",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _decode_serialize(
        self,
        vin,
        api_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if vin is not None:
            _path_params['vin'] = vin
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/decode/car/{vin}/specs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def decode_via_epi(
        self,
        vin: Annotated[str, Field(min_length=10, strict=True, description="The VIN to identify the car. Must be a valid 17 char VIN")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Build:
        """EPI VIN Decoder

        Get the basic information on specifications for a car identified by a valid VIN from EPI's decoder

        :param vin: The VIN to identify the car. Must be a valid 17 char VIN (required)
        :type vin: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._decode_via_epi_serialize(
            vin=vin,
            api_key=api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Build",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def decode_via_epi_with_http_info(
        self,
        vin: Annotated[str, Field(min_length=10, strict=True, description="The VIN to identify the car. Must be a valid 17 char VIN")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Build]:
        """EPI VIN Decoder

        Get the basic information on specifications for a car identified by a valid VIN from EPI's decoder

        :param vin: The VIN to identify the car. Must be a valid 17 char VIN (required)
        :type vin: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._decode_via_epi_serialize(
            vin=vin,
            api_key=api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Build",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def decode_via_epi_without_preload_content(
        self,
        vin: Annotated[str, Field(min_length=10, strict=True, description="The VIN to identify the car. Must be a valid 17 char VIN")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """EPI VIN Decoder

        Get the basic information on specifications for a car identified by a valid VIN from EPI's decoder

        :param vin: The VIN to identify the car. Must be a valid 17 char VIN (required)
        :type vin: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._decode_via_epi_serialize(
            vin=vin,
            api_key=api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Build",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _decode_via_epi_serialize(
        self,
        vin,
        api_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if vin is not None:
            _path_params['vin'] = vin
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/decode/car/epi/{vin}/specs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def decode_via_neo_vin(
        self,
        vin: Annotated[str, Field(min_length=10, strict=True, description="The VIN to identify the car. Must be a valid 17 char VIN")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        include_generic: Annotated[Optional[StrictBool], Field(description="Boolean variable to indicate wheather to include generic data as well in response")] = None,
        force_decode: Annotated[Optional[StrictBool], Field(description="Decode VIN on the fly instead of cached response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NeoVIN:
        """NeoVIN Decoder

        Get the basic information on specifications for a car identified by a valid VIN from NeoVIN decoder

        :param vin: The VIN to identify the car. Must be a valid 17 char VIN (required)
        :type vin: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param include_generic: Boolean variable to indicate wheather to include generic data as well in response
        :type include_generic: bool
        :param force_decode: Decode VIN on the fly instead of cached response
        :type force_decode: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._decode_via_neo_vin_serialize(
            vin=vin,
            api_key=api_key,
            include_generic=include_generic,
            force_decode=force_decode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NeoVIN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def decode_via_neo_vin_with_http_info(
        self,
        vin: Annotated[str, Field(min_length=10, strict=True, description="The VIN to identify the car. Must be a valid 17 char VIN")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        include_generic: Annotated[Optional[StrictBool], Field(description="Boolean variable to indicate wheather to include generic data as well in response")] = None,
        force_decode: Annotated[Optional[StrictBool], Field(description="Decode VIN on the fly instead of cached response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NeoVIN]:
        """NeoVIN Decoder

        Get the basic information on specifications for a car identified by a valid VIN from NeoVIN decoder

        :param vin: The VIN to identify the car. Must be a valid 17 char VIN (required)
        :type vin: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param include_generic: Boolean variable to indicate wheather to include generic data as well in response
        :type include_generic: bool
        :param force_decode: Decode VIN on the fly instead of cached response
        :type force_decode: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._decode_via_neo_vin_serialize(
            vin=vin,
            api_key=api_key,
            include_generic=include_generic,
            force_decode=force_decode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NeoVIN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def decode_via_neo_vin_without_preload_content(
        self,
        vin: Annotated[str, Field(min_length=10, strict=True, description="The VIN to identify the car. Must be a valid 17 char VIN")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        include_generic: Annotated[Optional[StrictBool], Field(description="Boolean variable to indicate wheather to include generic data as well in response")] = None,
        force_decode: Annotated[Optional[StrictBool], Field(description="Decode VIN on the fly instead of cached response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """NeoVIN Decoder

        Get the basic information on specifications for a car identified by a valid VIN from NeoVIN decoder

        :param vin: The VIN to identify the car. Must be a valid 17 char VIN (required)
        :type vin: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param include_generic: Boolean variable to indicate wheather to include generic data as well in response
        :type include_generic: bool
        :param force_decode: Decode VIN on the fly instead of cached response
        :type force_decode: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._decode_via_neo_vin_serialize(
            vin=vin,
            api_key=api_key,
            include_generic=include_generic,
            force_decode=force_decode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NeoVIN",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _decode_via_neo_vin_serialize(
        self,
        vin,
        api_key,
        include_generic,
        force_decode,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if vin is not None:
            _path_params['vin'] = vin
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        if include_generic is not None:
            
            _query_params.append(('include_generic', include_generic))
            
        if force_decode is not None:
            
            _query_params.append(('force_decode', force_decode))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/decode/car/neovin/{vin}/specs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_taxonomy_terms(
        self,
        var_field: Annotated[StrictStr, Field(description="Comma separated list of fields to get terms for")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        year: Annotated[Optional[Annotated[str, Field(min_length=4, strict=True)]], Field(description="To filter listing on their year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="To filter listings on their make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="To filter listings on their model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="To filter listing on their trim")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their body type")] = None,
        body_subtype: Annotated[Optional[StrictStr], Field(description="Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated")] = None,
        vehicle_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their vehicle type")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="To filter listing on their transmission")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="To filter listing on their drivetrain")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their fuel type")] = None,
        engine: Annotated[Optional[StrictStr], Field(description="To filter listing on their engine")] = None,
        engine_size: Annotated[Optional[StrictStr], Field(description="Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpecsAutoCompleteResponse:
        """API for getting terms from taxonomy

        Facets on taxonomy

        :param var_field: Comma separated list of fields to get terms for (required)
        :type var_field: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param year: To filter listing on their year
        :type year: str
        :param make: To filter listings on their make
        :type make: str
        :param model: To filter listings on their model
        :type model: str
        :param trim: To filter listing on their trim
        :type trim: str
        :param body_type: To filter listing on their body type
        :type body_type: str
        :param body_subtype: Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated
        :type body_subtype: str
        :param vehicle_type: To filter listing on their vehicle type
        :type vehicle_type: str
        :param transmission: To filter listing on their transmission
        :type transmission: str
        :param drivetrain: To filter listing on their drivetrain
        :type drivetrain: str
        :param fuel_type: To filter listing on their fuel type
        :type fuel_type: str
        :param engine: To filter listing on their engine
        :type engine: str
        :param engine_size: Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated
        :type engine_size: str
        :param engine_block: Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated
        :type engine_block: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_taxonomy_terms_serialize(
            var_field=var_field,
            api_key=api_key,
            year=year,
            make=make,
            model=model,
            trim=trim,
            body_type=body_type,
            body_subtype=body_subtype,
            vehicle_type=vehicle_type,
            transmission=transmission,
            drivetrain=drivetrain,
            fuel_type=fuel_type,
            engine=engine,
            engine_size=engine_size,
            engine_block=engine_block,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpecsAutoCompleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_taxonomy_terms_with_http_info(
        self,
        var_field: Annotated[StrictStr, Field(description="Comma separated list of fields to get terms for")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        year: Annotated[Optional[Annotated[str, Field(min_length=4, strict=True)]], Field(description="To filter listing on their year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="To filter listings on their make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="To filter listings on their model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="To filter listing on their trim")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their body type")] = None,
        body_subtype: Annotated[Optional[StrictStr], Field(description="Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated")] = None,
        vehicle_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their vehicle type")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="To filter listing on their transmission")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="To filter listing on their drivetrain")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their fuel type")] = None,
        engine: Annotated[Optional[StrictStr], Field(description="To filter listing on their engine")] = None,
        engine_size: Annotated[Optional[StrictStr], Field(description="Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpecsAutoCompleteResponse]:
        """API for getting terms from taxonomy

        Facets on taxonomy

        :param var_field: Comma separated list of fields to get terms for (required)
        :type var_field: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param year: To filter listing on their year
        :type year: str
        :param make: To filter listings on their make
        :type make: str
        :param model: To filter listings on their model
        :type model: str
        :param trim: To filter listing on their trim
        :type trim: str
        :param body_type: To filter listing on their body type
        :type body_type: str
        :param body_subtype: Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated
        :type body_subtype: str
        :param vehicle_type: To filter listing on their vehicle type
        :type vehicle_type: str
        :param transmission: To filter listing on their transmission
        :type transmission: str
        :param drivetrain: To filter listing on their drivetrain
        :type drivetrain: str
        :param fuel_type: To filter listing on their fuel type
        :type fuel_type: str
        :param engine: To filter listing on their engine
        :type engine: str
        :param engine_size: Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated
        :type engine_size: str
        :param engine_block: Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated
        :type engine_block: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_taxonomy_terms_serialize(
            var_field=var_field,
            api_key=api_key,
            year=year,
            make=make,
            model=model,
            trim=trim,
            body_type=body_type,
            body_subtype=body_subtype,
            vehicle_type=vehicle_type,
            transmission=transmission,
            drivetrain=drivetrain,
            fuel_type=fuel_type,
            engine=engine,
            engine_size=engine_size,
            engine_block=engine_block,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpecsAutoCompleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_taxonomy_terms_without_preload_content(
        self,
        var_field: Annotated[StrictStr, Field(description="Comma separated list of fields to get terms for")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        year: Annotated[Optional[Annotated[str, Field(min_length=4, strict=True)]], Field(description="To filter listing on their year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="To filter listings on their make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="To filter listings on their model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="To filter listing on their trim")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their body type")] = None,
        body_subtype: Annotated[Optional[StrictStr], Field(description="Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated")] = None,
        vehicle_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their vehicle type")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="To filter listing on their transmission")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="To filter listing on their drivetrain")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their fuel type")] = None,
        engine: Annotated[Optional[StrictStr], Field(description="To filter listing on their engine")] = None,
        engine_size: Annotated[Optional[StrictStr], Field(description="Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """API for getting terms from taxonomy

        Facets on taxonomy

        :param var_field: Comma separated list of fields to get terms for (required)
        :type var_field: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param year: To filter listing on their year
        :type year: str
        :param make: To filter listings on their make
        :type make: str
        :param model: To filter listings on their model
        :type model: str
        :param trim: To filter listing on their trim
        :type trim: str
        :param body_type: To filter listing on their body type
        :type body_type: str
        :param body_subtype: Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated
        :type body_subtype: str
        :param vehicle_type: To filter listing on their vehicle type
        :type vehicle_type: str
        :param transmission: To filter listing on their transmission
        :type transmission: str
        :param drivetrain: To filter listing on their drivetrain
        :type drivetrain: str
        :param fuel_type: To filter listing on their fuel type
        :type fuel_type: str
        :param engine: To filter listing on their engine
        :type engine: str
        :param engine_size: Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated
        :type engine_size: str
        :param engine_block: Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated
        :type engine_block: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_taxonomy_terms_serialize(
            var_field=var_field,
            api_key=api_key,
            year=year,
            make=make,
            model=model,
            trim=trim,
            body_type=body_type,
            body_subtype=body_subtype,
            vehicle_type=vehicle_type,
            transmission=transmission,
            drivetrain=drivetrain,
            fuel_type=fuel_type,
            engine=engine,
            engine_size=engine_size,
            engine_block=engine_block,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpecsAutoCompleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_taxonomy_terms_serialize(
        self,
        var_field,
        api_key,
        year,
        make,
        model,
        trim,
        body_type,
        body_subtype,
        vehicle_type,
        transmission,
        drivetrain,
        fuel_type,
        engine,
        engine_size,
        engine_block,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        if var_field is not None:
            
            _query_params.append(('field', var_field))
            
        if year is not None:
            
            _query_params.append(('year', year))
            
        if make is not None:
            
            _query_params.append(('make', make))
            
        if model is not None:
            
            _query_params.append(('model', model))
            
        if trim is not None:
            
            _query_params.append(('trim', trim))
            
        if body_type is not None:
            
            _query_params.append(('body_type', body_type))
            
        if body_subtype is not None:
            
            _query_params.append(('body_subtype', body_subtype))
            
        if vehicle_type is not None:
            
            _query_params.append(('vehicle_type', vehicle_type))
            
        if transmission is not None:
            
            _query_params.append(('transmission', transmission))
            
        if drivetrain is not None:
            
            _query_params.append(('drivetrain', drivetrain))
            
        if fuel_type is not None:
            
            _query_params.append(('fuel_type', fuel_type))
            
        if engine is not None:
            
            _query_params.append(('engine', engine))
            
        if engine_size is not None:
            
            _query_params.append(('engine_size', engine_size))
            
        if engine_block is not None:
            
            _query_params.append(('engine_block', engine_block))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/specs/car/terms',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def specs_car_auto_complete_get(
        self,
        var_field: Annotated[StrictStr, Field(description="Field name for which you want auto-completion")],
        input: Annotated[StrictStr, Field(description="Input entered so far")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        year: Annotated[Optional[Annotated[str, Field(min_length=4, strict=True)]], Field(description="To filter listing on their year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="To filter listings on their make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="To filter listings on their model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="To filter listing on their trim")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their body type")] = None,
        body_subtype: Annotated[Optional[StrictStr], Field(description="Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated")] = None,
        vehicle_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their vehicle type")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="To filter listing on their transmission")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="To filter listing on their drivetrain")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their fuel type")] = None,
        engine: Annotated[Optional[StrictStr], Field(description="To filter listing on their engine")] = None,
        engine_size: Annotated[Optional[StrictStr], Field(description="Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated")] = None,
        ignore_case: Annotated[Optional[StrictBool], Field(description="Boolean variable to indicate ignore case of current input")] = None,
        facet_min_count: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Provide minimum count value for facets")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SpecsAutoCompleteResponse:
        """API for auto-completion of inputs based on taxonomy

        Auto-complete the inputs of your end users, not from active set but from taxonomy (decoder database)

        :param var_field: Field name for which you want auto-completion (required)
        :type var_field: str
        :param input: Input entered so far (required)
        :type input: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param year: To filter listing on their year
        :type year: str
        :param make: To filter listings on their make
        :type make: str
        :param model: To filter listings on their model
        :type model: str
        :param trim: To filter listing on their trim
        :type trim: str
        :param body_type: To filter listing on their body type
        :type body_type: str
        :param body_subtype: Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated
        :type body_subtype: str
        :param vehicle_type: To filter listing on their vehicle type
        :type vehicle_type: str
        :param transmission: To filter listing on their transmission
        :type transmission: str
        :param drivetrain: To filter listing on their drivetrain
        :type drivetrain: str
        :param fuel_type: To filter listing on their fuel type
        :type fuel_type: str
        :param engine: To filter listing on their engine
        :type engine: str
        :param engine_size: Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated
        :type engine_size: str
        :param engine_block: Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated
        :type engine_block: str
        :param ignore_case: Boolean variable to indicate ignore case of current input
        :type ignore_case: bool
        :param facet_min_count: Provide minimum count value for facets
        :type facet_min_count: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._specs_car_auto_complete_get_serialize(
            var_field=var_field,
            input=input,
            api_key=api_key,
            year=year,
            make=make,
            model=model,
            trim=trim,
            body_type=body_type,
            body_subtype=body_subtype,
            vehicle_type=vehicle_type,
            transmission=transmission,
            drivetrain=drivetrain,
            fuel_type=fuel_type,
            engine=engine,
            engine_size=engine_size,
            engine_block=engine_block,
            ignore_case=ignore_case,
            facet_min_count=facet_min_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpecsAutoCompleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def specs_car_auto_complete_get_with_http_info(
        self,
        var_field: Annotated[StrictStr, Field(description="Field name for which you want auto-completion")],
        input: Annotated[StrictStr, Field(description="Input entered so far")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        year: Annotated[Optional[Annotated[str, Field(min_length=4, strict=True)]], Field(description="To filter listing on their year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="To filter listings on their make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="To filter listings on their model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="To filter listing on their trim")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their body type")] = None,
        body_subtype: Annotated[Optional[StrictStr], Field(description="Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated")] = None,
        vehicle_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their vehicle type")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="To filter listing on their transmission")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="To filter listing on their drivetrain")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their fuel type")] = None,
        engine: Annotated[Optional[StrictStr], Field(description="To filter listing on their engine")] = None,
        engine_size: Annotated[Optional[StrictStr], Field(description="Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated")] = None,
        ignore_case: Annotated[Optional[StrictBool], Field(description="Boolean variable to indicate ignore case of current input")] = None,
        facet_min_count: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Provide minimum count value for facets")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SpecsAutoCompleteResponse]:
        """API for auto-completion of inputs based on taxonomy

        Auto-complete the inputs of your end users, not from active set but from taxonomy (decoder database)

        :param var_field: Field name for which you want auto-completion (required)
        :type var_field: str
        :param input: Input entered so far (required)
        :type input: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param year: To filter listing on their year
        :type year: str
        :param make: To filter listings on their make
        :type make: str
        :param model: To filter listings on their model
        :type model: str
        :param trim: To filter listing on their trim
        :type trim: str
        :param body_type: To filter listing on their body type
        :type body_type: str
        :param body_subtype: Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated
        :type body_subtype: str
        :param vehicle_type: To filter listing on their vehicle type
        :type vehicle_type: str
        :param transmission: To filter listing on their transmission
        :type transmission: str
        :param drivetrain: To filter listing on their drivetrain
        :type drivetrain: str
        :param fuel_type: To filter listing on their fuel type
        :type fuel_type: str
        :param engine: To filter listing on their engine
        :type engine: str
        :param engine_size: Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated
        :type engine_size: str
        :param engine_block: Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated
        :type engine_block: str
        :param ignore_case: Boolean variable to indicate ignore case of current input
        :type ignore_case: bool
        :param facet_min_count: Provide minimum count value for facets
        :type facet_min_count: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._specs_car_auto_complete_get_serialize(
            var_field=var_field,
            input=input,
            api_key=api_key,
            year=year,
            make=make,
            model=model,
            trim=trim,
            body_type=body_type,
            body_subtype=body_subtype,
            vehicle_type=vehicle_type,
            transmission=transmission,
            drivetrain=drivetrain,
            fuel_type=fuel_type,
            engine=engine,
            engine_size=engine_size,
            engine_block=engine_block,
            ignore_case=ignore_case,
            facet_min_count=facet_min_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpecsAutoCompleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def specs_car_auto_complete_get_without_preload_content(
        self,
        var_field: Annotated[StrictStr, Field(description="Field name for which you want auto-completion")],
        input: Annotated[StrictStr, Field(description="Input entered so far")],
        api_key: Annotated[Optional[StrictStr], Field(description="The API Authentication Key. Mandatory with all API calls.")] = None,
        year: Annotated[Optional[Annotated[str, Field(min_length=4, strict=True)]], Field(description="To filter listing on their year")] = None,
        make: Annotated[Optional[StrictStr], Field(description="To filter listings on their make")] = None,
        model: Annotated[Optional[StrictStr], Field(description="To filter listings on their model")] = None,
        trim: Annotated[Optional[StrictStr], Field(description="To filter listing on their trim")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their body type")] = None,
        body_subtype: Annotated[Optional[StrictStr], Field(description="Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated")] = None,
        vehicle_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their vehicle type")] = None,
        transmission: Annotated[Optional[StrictStr], Field(description="To filter listing on their transmission")] = None,
        drivetrain: Annotated[Optional[StrictStr], Field(description="To filter listing on their drivetrain")] = None,
        fuel_type: Annotated[Optional[StrictStr], Field(description="To filter listing on their fuel type")] = None,
        engine: Annotated[Optional[StrictStr], Field(description="To filter listing on their engine")] = None,
        engine_size: Annotated[Optional[StrictStr], Field(description="Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated")] = None,
        engine_block: Annotated[Optional[StrictStr], Field(description="Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated")] = None,
        ignore_case: Annotated[Optional[StrictBool], Field(description="Boolean variable to indicate ignore case of current input")] = None,
        facet_min_count: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Provide minimum count value for facets")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """API for auto-completion of inputs based on taxonomy

        Auto-complete the inputs of your end users, not from active set but from taxonomy (decoder database)

        :param var_field: Field name for which you want auto-completion (required)
        :type var_field: str
        :param input: Input entered so far (required)
        :type input: str
        :param api_key: The API Authentication Key. Mandatory with all API calls.
        :type api_key: str
        :param year: To filter listing on their year
        :type year: str
        :param make: To filter listings on their make
        :type make: str
        :param model: To filter listings on their model
        :type model: str
        :param trim: To filter listing on their trim
        :type trim: str
        :param body_type: To filter listing on their body type
        :type body_type: str
        :param body_subtype: Body subtype to filter the listings on. Valid filter values are those that our Search facets API returns for unique body subtypes. You can pass in multiple body subtype values comma separated
        :type body_subtype: str
        :param vehicle_type: To filter listing on their vehicle type
        :type vehicle_type: str
        :param transmission: To filter listing on their transmission
        :type transmission: str
        :param drivetrain: To filter listing on their drivetrain
        :type drivetrain: str
        :param fuel_type: To filter listing on their fuel type
        :type fuel_type: str
        :param engine: To filter listing on their engine
        :type engine: str
        :param engine_size: Engine Size to match. Valid filter values are those that our Search facets API returns for unique engine size. You can pass in multiple engine size values comma separated
        :type engine_size: str
        :param engine_block: Engine Block to match. Valid filter values are those that our Search facets API returns for unique Engine Block. You can pass in multiple Engine Block values comma separated
        :type engine_block: str
        :param ignore_case: Boolean variable to indicate ignore case of current input
        :type ignore_case: bool
        :param facet_min_count: Provide minimum count value for facets
        :type facet_min_count: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._specs_car_auto_complete_get_serialize(
            var_field=var_field,
            input=input,
            api_key=api_key,
            year=year,
            make=make,
            model=model,
            trim=trim,
            body_type=body_type,
            body_subtype=body_subtype,
            vehicle_type=vehicle_type,
            transmission=transmission,
            drivetrain=drivetrain,
            fuel_type=fuel_type,
            engine=engine,
            engine_size=engine_size,
            engine_block=engine_block,
            ignore_case=ignore_case,
            facet_min_count=facet_min_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SpecsAutoCompleteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _specs_car_auto_complete_get_serialize(
        self,
        var_field,
        input,
        api_key,
        year,
        make,
        model,
        trim,
        body_type,
        body_subtype,
        vehicle_type,
        transmission,
        drivetrain,
        fuel_type,
        engine,
        engine_size,
        engine_block,
        ignore_case,
        facet_min_count,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if api_key is not None:
            
            _query_params.append(('api_key', api_key))
            
        if var_field is not None:
            
            _query_params.append(('field', var_field))
            
        if input is not None:
            
            _query_params.append(('input', input))
            
        if year is not None:
            
            _query_params.append(('year', year))
            
        if make is not None:
            
            _query_params.append(('make', make))
            
        if model is not None:
            
            _query_params.append(('model', model))
            
        if trim is not None:
            
            _query_params.append(('trim', trim))
            
        if body_type is not None:
            
            _query_params.append(('body_type', body_type))
            
        if body_subtype is not None:
            
            _query_params.append(('body_subtype', body_subtype))
            
        if vehicle_type is not None:
            
            _query_params.append(('vehicle_type', vehicle_type))
            
        if transmission is not None:
            
            _query_params.append(('transmission', transmission))
            
        if drivetrain is not None:
            
            _query_params.append(('drivetrain', drivetrain))
            
        if fuel_type is not None:
            
            _query_params.append(('fuel_type', fuel_type))
            
        if engine is not None:
            
            _query_params.append(('engine', engine))
            
        if engine_size is not None:
            
            _query_params.append(('engine_size', engine_size))
            
        if engine_block is not None:
            
            _query_params.append(('engine_block', engine_block))
            
        if ignore_case is not None:
            
            _query_params.append(('ignore_case', ignore_case))
            
        if facet_min_count is not None:
            
            _query_params.append(('facet_min_count', facet_min_count))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'authorizeEndpoint'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/specs/car/auto-complete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


