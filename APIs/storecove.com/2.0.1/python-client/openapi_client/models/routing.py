# coding: utf-8

"""
    Storecove API

    Storecove API

    The version of the OpenAPI document: 2.0.1
    Contact: apisupport@storecove.nl
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.routing_identifier import RoutingIdentifier
from typing import Optional, Set
from typing_extensions import Self

class Routing(BaseModel):
    """
    The different ways to send the invoice to the recipient. The publicIdentifiers are used to send via the Peppol network, if the recipient is not registered on the Peppol network, the invoice will be sent to the email addresses in the emails property. This property is only mandatory when sending the invoice data using the <<_openapi_invoice>> property, not when sending using the <<_openapi_invoicedata>> property, in which case this information will be extracted from the <<_openapi_invoicedata>> object. If you do specify an <<_openapi_invoicerecipient>> object and an <<_openapi_invoicedata>> object, the data from the two will be merged.
    """ # noqa: E501
    clear_without_sending: Optional[StrictBool] = Field(default=False, description="If you wish to send the document yourself in a Y-flow, use this flag. Wait for the 'cleared' webhook and use the <<_openapi_show_document_submission_evidence>> endpoint to retrieve the clearing evidence. This will include a sendable document.", alias="clearWithoutSending")
    e_identifiers: Optional[List[RoutingIdentifier]] = Field(default=None, description="A list of electronic routing identifiers. These are the identifiers used on the Peppol network or for other destinations.", alias="eIdentifiers")
    emails: Optional[List[StrictStr]] = Field(default=None, description="The email addresses the invoice should be sent to if none of the other identifiers can be used")
    __properties: ClassVar[List[str]] = ["clearWithoutSending", "eIdentifiers", "emails"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Routing from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in e_identifiers (list)
        _items = []
        if self.e_identifiers:
            for _item_e_identifiers in self.e_identifiers:
                if _item_e_identifiers:
                    _items.append(_item_e_identifiers.to_dict())
            _dict['eIdentifiers'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Routing from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "clearWithoutSending": obj.get("clearWithoutSending") if obj.get("clearWithoutSending") is not None else False,
            "eIdentifiers": [RoutingIdentifier.from_dict(_item) for _item in obj["eIdentifiers"]] if obj.get("eIdentifiers") is not None else None,
            "emails": obj.get("emails")
        })
        return _obj


