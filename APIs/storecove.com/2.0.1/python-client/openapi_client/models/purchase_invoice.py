# coding: utf-8

"""
    Storecove API

    Storecove API

    The version of the OpenAPI document: 2.0.1
    Contact: apisupport@storecove.nl
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.payment_means_deprecated import PaymentMeansDEPRECATED
from openapi_client.models.purchase_invoice_accounting_details import PurchaseInvoiceAccountingDetails
from openapi_client.models.purchase_invoice_allowance_charge import PurchaseInvoiceAllowanceCharge
from openapi_client.models.purchase_invoice_attachment import PurchaseInvoiceAttachment
from openapi_client.models.purchase_invoice_delivery import PurchaseInvoiceDelivery
from openapi_client.models.purchase_invoice_document_totals import PurchaseInvoiceDocumentTotals
from openapi_client.models.purchase_invoice_invoice_line import PurchaseInvoiceInvoiceLine
from openapi_client.models.purchase_invoice_payment_means import PurchaseInvoicePaymentMeans
from openapi_client.models.purchase_invoice_sender import PurchaseInvoiceSender
from openapi_client.models.purchase_invoice_tax_subtotal import PurchaseInvoiceTaxSubtotal
from typing import Optional, Set
from typing_extensions import Self

class PurchaseInvoice(BaseModel):
    """
    PurchaseInvoice
    """ # noqa: E501
    accounting: Optional[PurchaseInvoiceAccountingDetails] = None
    accounting_cost: Optional[StrictStr] = Field(default=None, description="The accounting cost code.")
    allowance_charge: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="DEPRECATED - Use the allowance_charges array.")
    allowance_charges: Optional[List[PurchaseInvoiceAllowanceCharge]] = None
    amount_including_vat: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="DEPRECATED - Use amount_including_tax.")
    attachments: Optional[List[PurchaseInvoiceAttachment]] = None
    billing_reference: Optional[StrictStr] = Field(default=None, description="Reference to the previous invoice this invoice relates to.")
    buyer_reference: Optional[StrictStr] = Field(default=None, description="Reference provided by the buyer. Used for routing.")
    contract_document_reference: Optional[StrictStr] = Field(default=None, description="Reference to the contract.")
    delivery: Optional[PurchaseInvoiceDelivery] = None
    document: Optional[StrictStr] = Field(default=None, description="DEPRECATED. Use the new atatchments array.")
    document_currency_code: Optional[StrictStr] = Field(default=None, description="The ISO 4217 currency for the invoice.")
    document_totals: Optional[PurchaseInvoiceDocumentTotals] = None
    document_type: Optional[StrictStr] = Field(default=None, description="The type of document. Only \"invoice\" for now.")
    due_date: Optional[StrictStr] = Field(default=None, description="The date the invoice must be payed by. Format \"YYYY-MM-DD\".")
    external_key: Optional[StrictStr] = Field(default=None, description="Deprecated. Used for accountants. The id you specified for the organization.")
    external_user_id: Optional[StrictStr] = Field(default=None, description="Deprecated. Used for the embedded portal retrieval service. The external_user_id you provided when the ShopAccount was created.")
    guid: Optional[StrictStr] = Field(default=None, description="The GUID of the invoice")
    invoice_lines: Optional[List[PurchaseInvoiceInvoiceLine]] = None
    invoice_number: Optional[StrictStr] = Field(default=None, description="The invoicenumber.")
    invoice_type: Optional[StrictStr] = Field(default=None, description="The type of invoice.")
    issue_date: Optional[StrictStr] = Field(default=None, description="The date the invoice was issued. Format \"YYYY-MM-DD\".")
    legal_entity_id: Optional[StrictInt] = Field(default=None, description="The id of the LegalEntity the invoice was received for.")
    note: Optional[StrictStr] = Field(default=None, description="The invoice level note.")
    order_reference: Optional[StrictStr] = Field(default=None, description="Reference to the order. Used for matching the invoice to an order.")
    payment_means: Optional[PaymentMeansDEPRECATED] = None
    payment_means_array: Optional[List[PurchaseInvoicePaymentMeans]] = Field(default=None, description="The different payment means that can be used to pay the invoice.")
    payment_means_payment_id: Optional[StrictStr] = Field(default=None, description="DEPRECATED - use the payment_id property in the payment_means_array")
    payment_terms_note: Optional[StrictStr] = Field(default=None, description="A textual description of the payment terms.")
    period_end: Optional[StrictStr] = Field(default=None, description="The end date of the period this invoice relates to. Format \"YYYY-MM-DD\".")
    period_start: Optional[StrictStr] = Field(default=None, description="The start date of the period this invoice relates to. Format \"YYYY-MM-DD\".")
    project_reference: Optional[StrictStr] = Field(default=None, description="Reference to the project.")
    sender: Optional[PurchaseInvoiceSender] = None
    source: Optional[StrictStr] = Field(default=None, description="The source the invoice was received from.")
    sub_type: Optional[StrictStr] = Field(default=None, description="The subtype of document.")
    system_generated_primary_image: Optional[StrictBool] = Field(default=None, description="Whether or not the document image (PDF) was generated by Storecove. If true, it means the invoice was received without any attachments and Storecove generated one for you. If false, the invoice will contain at least one attachment, which was received from the invoice sender.")
    tax_point_date: Optional[StrictStr] = Field(default=None, description="The date the invoice was issued for tax purposes. In most countries MUST match the issue_date. Format \"YYYY-MM-DD\".")
    tax_subtotals: Optional[List[PurchaseInvoiceTaxSubtotal]] = None
    tax_system: Optional[StrictStr] = Field(default=None, description="The tax system of the invoice. Either tax_line_percentages or tax_line_amounts. The first tax system means the invoice lines contain only the tax percentages and the tax amounts are included only in the tax subtotals at the invoice level and so are only calculated at the invoice level. The tax system tax_line_amounts means that in addition to the percentage, each invoice line also contains the tax amount. The tax subtotals at the invoice level are calculated as the sum of the tax of the invoice lines. The distinction between the two tax systems has has implications for rounding.")
    vat_reverse_charge: Optional[StrictBool] = Field(default=None, description="DEPRECATED - This is now part of each invoice line.")
    __properties: ClassVar[List[str]] = ["accounting", "accounting_cost", "allowance_charge", "allowance_charges", "amount_including_vat", "attachments", "billing_reference", "buyer_reference", "contract_document_reference", "delivery", "document", "document_currency_code", "document_totals", "document_type", "due_date", "external_key", "external_user_id", "guid", "invoice_lines", "invoice_number", "invoice_type", "issue_date", "legal_entity_id", "note", "order_reference", "payment_means", "payment_means_array", "payment_means_payment_id", "payment_terms_note", "period_end", "period_start", "project_reference", "sender", "source", "sub_type", "system_generated_primary_image", "tax_point_date", "tax_subtotals", "tax_system", "vat_reverse_charge"]

    @field_validator('document_type')
    def document_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['invoice']):
            raise ValueError("must be one of enum values ('invoice')")
        return value

    @field_validator('invoice_type')
    def invoice_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['invoice', 'creditnote', 'correctioninvoice']):
            raise ValueError("must be one of enum values ('invoice', 'creditnote', 'correctioninvoice')")
        return value

    @field_validator('source')
    def source_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['peppol', 'script', 'supplier', 'email']):
            raise ValueError("must be one of enum values ('peppol', 'script', 'supplier', 'email')")
        return value

    @field_validator('sub_type')
    def sub_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['invoice', 'creditnote', 'correctioninvoice']):
            raise ValueError("must be one of enum values ('invoice', 'creditnote', 'correctioninvoice')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PurchaseInvoice from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of accounting
        if self.accounting:
            _dict['accounting'] = self.accounting.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in allowance_charges (list)
        _items = []
        if self.allowance_charges:
            for _item_allowance_charges in self.allowance_charges:
                if _item_allowance_charges:
                    _items.append(_item_allowance_charges.to_dict())
            _dict['allowance_charges'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in attachments (list)
        _items = []
        if self.attachments:
            for _item_attachments in self.attachments:
                if _item_attachments:
                    _items.append(_item_attachments.to_dict())
            _dict['attachments'] = _items
        # override the default output from pydantic by calling `to_dict()` of delivery
        if self.delivery:
            _dict['delivery'] = self.delivery.to_dict()
        # override the default output from pydantic by calling `to_dict()` of document_totals
        if self.document_totals:
            _dict['document_totals'] = self.document_totals.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in invoice_lines (list)
        _items = []
        if self.invoice_lines:
            for _item_invoice_lines in self.invoice_lines:
                if _item_invoice_lines:
                    _items.append(_item_invoice_lines.to_dict())
            _dict['invoice_lines'] = _items
        # override the default output from pydantic by calling `to_dict()` of payment_means
        if self.payment_means:
            _dict['payment_means'] = self.payment_means.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in payment_means_array (list)
        _items = []
        if self.payment_means_array:
            for _item_payment_means_array in self.payment_means_array:
                if _item_payment_means_array:
                    _items.append(_item_payment_means_array.to_dict())
            _dict['payment_means_array'] = _items
        # override the default output from pydantic by calling `to_dict()` of sender
        if self.sender:
            _dict['sender'] = self.sender.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in tax_subtotals (list)
        _items = []
        if self.tax_subtotals:
            for _item_tax_subtotals in self.tax_subtotals:
                if _item_tax_subtotals:
                    _items.append(_item_tax_subtotals.to_dict())
            _dict['tax_subtotals'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PurchaseInvoice from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accounting": PurchaseInvoiceAccountingDetails.from_dict(obj["accounting"]) if obj.get("accounting") is not None else None,
            "accounting_cost": obj.get("accounting_cost"),
            "allowance_charge": obj.get("allowance_charge"),
            "allowance_charges": [PurchaseInvoiceAllowanceCharge.from_dict(_item) for _item in obj["allowance_charges"]] if obj.get("allowance_charges") is not None else None,
            "amount_including_vat": obj.get("amount_including_vat"),
            "attachments": [PurchaseInvoiceAttachment.from_dict(_item) for _item in obj["attachments"]] if obj.get("attachments") is not None else None,
            "billing_reference": obj.get("billing_reference"),
            "buyer_reference": obj.get("buyer_reference"),
            "contract_document_reference": obj.get("contract_document_reference"),
            "delivery": PurchaseInvoiceDelivery.from_dict(obj["delivery"]) if obj.get("delivery") is not None else None,
            "document": obj.get("document"),
            "document_currency_code": obj.get("document_currency_code"),
            "document_totals": PurchaseInvoiceDocumentTotals.from_dict(obj["document_totals"]) if obj.get("document_totals") is not None else None,
            "document_type": obj.get("document_type"),
            "due_date": obj.get("due_date"),
            "external_key": obj.get("external_key"),
            "external_user_id": obj.get("external_user_id"),
            "guid": obj.get("guid"),
            "invoice_lines": [PurchaseInvoiceInvoiceLine.from_dict(_item) for _item in obj["invoice_lines"]] if obj.get("invoice_lines") is not None else None,
            "invoice_number": obj.get("invoice_number"),
            "invoice_type": obj.get("invoice_type"),
            "issue_date": obj.get("issue_date"),
            "legal_entity_id": obj.get("legal_entity_id"),
            "note": obj.get("note"),
            "order_reference": obj.get("order_reference"),
            "payment_means": PaymentMeansDEPRECATED.from_dict(obj["payment_means"]) if obj.get("payment_means") is not None else None,
            "payment_means_array": [PurchaseInvoicePaymentMeans.from_dict(_item) for _item in obj["payment_means_array"]] if obj.get("payment_means_array") is not None else None,
            "payment_means_payment_id": obj.get("payment_means_payment_id"),
            "payment_terms_note": obj.get("payment_terms_note"),
            "period_end": obj.get("period_end"),
            "period_start": obj.get("period_start"),
            "project_reference": obj.get("project_reference"),
            "sender": PurchaseInvoiceSender.from_dict(obj["sender"]) if obj.get("sender") is not None else None,
            "source": obj.get("source"),
            "sub_type": obj.get("sub_type"),
            "system_generated_primary_image": obj.get("system_generated_primary_image"),
            "tax_point_date": obj.get("tax_point_date"),
            "tax_subtotals": [PurchaseInvoiceTaxSubtotal.from_dict(_item) for _item in obj["tax_subtotals"]] if obj.get("tax_subtotals") is not None else None,
            "tax_system": obj.get("tax_system"),
            "vat_reverse_charge": obj.get("vat_reverse_charge")
        })
        return _obj


