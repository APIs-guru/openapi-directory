# coding: utf-8

"""
    SimplyRETS

    The SimplyRETS API is an exciting step towards making it easier for developers and real estate agents to build something awesome with real estate data!  The documentation below makes live requests to our API using the trial data. To get set up with the API using live MLS data, you must have RETS credentials from your MLS, which you can then use to create an app with SimplyRETS. For more information on that process, please see our [FAQ](https://simplyrets.com/faq), [Getting Started](https://simplyrets.com/blog/getting-set-up.html) page, or [contact us](https://simplyrets.com/\\#home-contact).  Below you'll find the API endpoints, query parameters, response bodies, and other information about using the SimplyRETS API. You can run queries by clicking the 'Try it Out' button at the bottom of each section.  ### Authentication The SimplyRETS API uses Basic Authentication. When you create an app, you'll get a set of API credentials to access your listings. If you're trying out the test data, you can use `simplyrets:simplyrets` for connecting to the API.  ### Media Types The SimplyRETS API uses the `Accept` header to allow clients to control media types (content versions). We maintain backwards compatibility with API clients by allowing them to specify a content version. We highly recommend setting and explicity media type when your application reaches production. Both the structure and content of our API response bodies is subject to change so we can add new features while respecting the stability of applications which have already been developed.  To always use the latest SimplyRETS content version, simply use `application/json` in your application `Accept` header.  If you want to pin your clients media type to a specific version, you can use the vendor-specific SimplyRETS media type, e.g. `application/vnd.simplyrets-v0.1+json\"`  To view all valid content-types for making an `OPTIONS`, make a request to the SimplyRETS api root  `curl -XOPTIONS -u simplyrets:simplyrets https://api.simplyrets.com/`  The default media types used in our API responses may change in the future. If you're building an application and care about the stability of the API, be sure to request a specific media type in the Accept header as shown in the examples below.  The wordpress plugin automatically sets the `Accept` header for the compatible SimplyRETS media types.  ### Pagination  To paginate through listings, start your query with these parameters: 'limit=500&lastId=0'. The 'lastId' is the important part, you can use any limit up to 500. When you receive the response from the API with the results, check the 'Link' header for the 'next' link. That link is pre-built to access the next 'page' of listings. Alternatively, you can use the last listing's 'mlsId' from the previous request and use that in the next query. For example:  First query:  curl -u username:password 'https://api.simplyrets.com/properties?limit=500&lastId=0'  If the 'mlsId' in the last listing of the results is '1234567', then the next query will be:  curl -u username:password 'https://api.simplyrets.com/properties?limit=500&lastId=1234567'  ...and so one until you have reached the final page of listings.  There a few pieces of useful information about each request stored in the HTTP Headers:  - `X-Total-Count` shows you the total amount of listings that match   your current query. - `Link` contains pre-built pagination links for accessing the next 'page' of listings that match your query.  ### RETS Vendor Compliance  Many RETS vendors have strict requirements for showing disclaimers with specific information embedded. For example, in many areas it's required to show the timestamp of the time the listings were refreshed inside a disclaimer or on a listing page.  The timestamp of the last listing refresh timestamp can be found in one of two spots:  - The `X-SimplyRETS-LastUpdate` header from `GET /properties` or `GET /properties/{mlsId}`  - Calling the API root `/` or properties api endpoint `/properties`   with an OPTIONS request    - `OPTIONS /`      This request will show the last update timestamp for all RETS     vendors associated with your application. Look for the     `updates` list in the JSON response.    - `OPTIONS /properties`      Using this request, look for the `lastUpdate` field in the JSON     response. 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.agent import Agent
from openapi_client.models.association import Association
from openapi_client.models.geographic_data import GeographicData
from openapi_client.models.mls_information import MlsInformation
from openapi_client.models.model_property import ModelProperty
from openapi_client.models.office import Office
from openapi_client.models.sales import Sales
from openapi_client.models.school import School
from openapi_client.models.street_address import StreetAddress
from openapi_client.models.tax import Tax
from typing import Optional, Set
from typing_extensions import Self

class Listing(BaseModel):
    """
    RETS MLS Listing Property
    """ # noqa: E501
    address: Optional[StreetAddress] = None
    agent: Optional[Agent] = None
    association: Optional[Association] = None
    co_agent: Optional[Agent] = Field(default=None, alias="coAgent")
    disclaimer: Optional[StrictStr] = Field(default=None, description="Data accuracy disclaimer. The value in the disclaimer may change depending on your MLS vendors rules. ")
    geo: Optional[GeographicData] = None
    lease_term: Optional[StrictStr] = Field(default=None, description="Represents the length of the lease.", alias="leaseTerm")
    lease_type: Optional[StrictStr] = Field(default=None, description="Information about the status of the existing lease on the property.", alias="leaseType")
    list_date: Optional[datetime] = Field(default=None, description="Date and time the listing became Active", alias="listDate")
    list_price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Price of the listing", alias="listPrice")
    listing_id: Optional[StrictStr] = Field(default=None, description="Data Dictionary v1.3 ListingId. The well known identifier for the listing. The value is the id or number by the MLS as a public identifier for the listing.  This identifier should not be confused with the `mlsId`, which is specific to the SimplyRETS API. ", alias="listingId")
    mls: Optional[MlsInformation] = None
    mls_id: Optional[StrictInt] = Field(default=None, description="A unique identifier for this listing specific to the SimplyRETS API. Thie identifier is specific to the SimplyRETS api and has no correlation with the MLS number. Use this id when making requests to the single listing endpoint (eg, `/properties/{mlsId}`).  Applications should not rely on specific `mlsId`s being present. Instead, apps should dynamically use the `mlsId` after using other more general query parameters. Many mls vendors require listings which are expired, terminated or sold to be purged, which will render calls to specific `mlsId`s to return nothing (or possibly a 404). ", alias="mlsId")
    modified: Optional[datetime] = Field(default=None, description="Date and time of the last modification")
    office: Optional[Office] = None
    photos: Optional[List[StrictStr]] = Field(default=None, description="Photos of the property. Images are served over https and are suitable for production use on secure websites ")
    private_remarks: Optional[StrictStr] = Field(default=None, description="Agent only remarks", alias="privateRemarks")
    var_property: Optional[ModelProperty] = Field(default=None, alias="property")
    remarks: Optional[StrictStr] = Field(default=None, description="Description or remarks")
    sales: Optional[Sales] = None
    school: Optional[School] = None
    showing_instructions: Optional[StrictStr] = Field(default=None, description="Public instructions for showing the property.", alias="showingInstructions")
    tax: Optional[Tax] = None
    virtual_tour_url: Optional[StrictStr] = Field(default=None, description="The URL for an unbranded virtual tour of the property.  **Added on 2016/05/04 - Not available for all RETS vendors** ", alias="virtualTourUrl")
    __properties: ClassVar[List[str]] = ["address", "agent", "association", "coAgent", "disclaimer", "geo", "leaseTerm", "leaseType", "listDate", "listPrice", "listingId", "mls", "mlsId", "modified", "office", "photos", "privateRemarks", "property", "remarks", "sales", "school", "showingInstructions", "tax", "virtualTourUrl"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Listing from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of address
        if self.address:
            _dict['address'] = self.address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of agent
        if self.agent:
            _dict['agent'] = self.agent.to_dict()
        # override the default output from pydantic by calling `to_dict()` of association
        if self.association:
            _dict['association'] = self.association.to_dict()
        # override the default output from pydantic by calling `to_dict()` of co_agent
        if self.co_agent:
            _dict['coAgent'] = self.co_agent.to_dict()
        # override the default output from pydantic by calling `to_dict()` of geo
        if self.geo:
            _dict['geo'] = self.geo.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mls
        if self.mls:
            _dict['mls'] = self.mls.to_dict()
        # override the default output from pydantic by calling `to_dict()` of office
        if self.office:
            _dict['office'] = self.office.to_dict()
        # override the default output from pydantic by calling `to_dict()` of var_property
        if self.var_property:
            _dict['property'] = self.var_property.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sales
        if self.sales:
            _dict['sales'] = self.sales.to_dict()
        # override the default output from pydantic by calling `to_dict()` of school
        if self.school:
            _dict['school'] = self.school.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tax
        if self.tax:
            _dict['tax'] = self.tax.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Listing from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "address": StreetAddress.from_dict(obj["address"]) if obj.get("address") is not None else None,
            "agent": Agent.from_dict(obj["agent"]) if obj.get("agent") is not None else None,
            "association": Association.from_dict(obj["association"]) if obj.get("association") is not None else None,
            "coAgent": Agent.from_dict(obj["coAgent"]) if obj.get("coAgent") is not None else None,
            "disclaimer": obj.get("disclaimer"),
            "geo": GeographicData.from_dict(obj["geo"]) if obj.get("geo") is not None else None,
            "leaseTerm": obj.get("leaseTerm"),
            "leaseType": obj.get("leaseType"),
            "listDate": obj.get("listDate"),
            "listPrice": obj.get("listPrice"),
            "listingId": obj.get("listingId"),
            "mls": MlsInformation.from_dict(obj["mls"]) if obj.get("mls") is not None else None,
            "mlsId": obj.get("mlsId"),
            "modified": obj.get("modified"),
            "office": Office.from_dict(obj["office"]) if obj.get("office") is not None else None,
            "photos": obj.get("photos"),
            "privateRemarks": obj.get("privateRemarks"),
            "property": ModelProperty.from_dict(obj["property"]) if obj.get("property") is not None else None,
            "remarks": obj.get("remarks"),
            "sales": Sales.from_dict(obj["sales"]) if obj.get("sales") is not None else None,
            "school": School.from_dict(obj["school"]) if obj.get("school") is not None else None,
            "showingInstructions": obj.get("showingInstructions"),
            "tax": Tax.from_dict(obj["tax"]) if obj.get("tax") is not None else None,
            "virtualTourUrl": obj.get("virtualTourUrl")
        })
        return _obj


