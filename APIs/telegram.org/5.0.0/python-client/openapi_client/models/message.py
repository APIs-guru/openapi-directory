# coding: utf-8

"""
    Telegram Bot API

    Auto-generated OpenAPI schema

    The version of the OpenAPI document: 5.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.animation import Animation
from openapi_client.models.audio import Audio
from openapi_client.models.contact import Contact
from openapi_client.models.dice import Dice
from openapi_client.models.document import Document
from openapi_client.models.game import Game
from openapi_client.models.inline_keyboard_markup import InlineKeyboardMarkup
from openapi_client.models.invoice import Invoice
from openapi_client.models.location import Location
from openapi_client.models.message_entity import MessageEntity
from openapi_client.models.passport_data import PassportData
from openapi_client.models.photo_size import PhotoSize
from openapi_client.models.poll import Poll
from openapi_client.models.proximity_alert_triggered import ProximityAlertTriggered
from openapi_client.models.sticker import Sticker
from openapi_client.models.successful_payment import SuccessfulPayment
from openapi_client.models.user import User
from openapi_client.models.venue import Venue
from openapi_client.models.video import Video
from openapi_client.models.video_note import VideoNote
from openapi_client.models.voice import Voice
from typing import Optional, Set
from typing_extensions import Self

class Message(BaseModel):
    """
    This object represents a message.
    """ # noqa: E501
    animation: Optional[Animation] = None
    audio: Optional[Audio] = None
    author_signature: Optional[StrictStr] = Field(default=None, description="*Optional*. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator")
    caption: Optional[StrictStr] = Field(default=None, description="*Optional*. Caption for the animation, audio, document, photo, video or voice, 0-1024 characters")
    caption_entities: Optional[List[MessageEntity]] = Field(default=None, description="*Optional*. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption")
    channel_chat_created: Optional[StrictBool] = Field(default=None, description="*Optional*. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply\\_to\\_message if someone replies to a very first message in a channel.")
    chat: Chat
    connected_website: Optional[StrictStr] = Field(default=None, description="*Optional*. The domain name of the website on which the user has logged in. [More about Telegram Login Â»](/widgets/login)")
    contact: Optional[Contact] = None
    var_date: StrictInt = Field(description="Date the message was sent in Unix time", alias="date")
    delete_chat_photo: Optional[StrictBool] = Field(default=None, description="*Optional*. Service message: the chat photo was deleted")
    dice: Optional[Dice] = None
    document: Optional[Document] = None
    edit_date: Optional[StrictInt] = Field(default=None, description="*Optional*. Date the message was last edited in Unix time")
    entities: Optional[List[MessageEntity]] = Field(default=None, description="*Optional*. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text")
    forward_date: Optional[StrictInt] = Field(default=None, description="*Optional*. For forwarded messages, date the original message was sent in Unix time")
    forward_from: Optional[User] = None
    forward_from_chat: Optional[Chat] = None
    forward_from_message_id: Optional[StrictInt] = Field(default=None, description="*Optional*. For messages forwarded from channels, identifier of the original message in the channel")
    forward_sender_name: Optional[StrictStr] = Field(default=None, description="*Optional*. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages")
    forward_signature: Optional[StrictStr] = Field(default=None, description="*Optional*. For messages forwarded from channels, signature of the post author if present")
    var_from: Optional[User] = Field(default=None, alias="from")
    game: Optional[Game] = None
    group_chat_created: Optional[StrictBool] = Field(default=None, description="*Optional*. Service message: the group has been created")
    invoice: Optional[Invoice] = None
    left_chat_member: Optional[User] = None
    location: Optional[Location] = None
    media_group_id: Optional[StrictStr] = Field(default=None, description="*Optional*. The unique identifier of a media message group this message belongs to")
    message_id: StrictInt = Field(description="Unique message identifier inside this chat")
    migrate_from_chat_id: Optional[StrictInt] = Field(default=None, description="*Optional*. The supergroup has been migrated from a group with the specified identifier. This number may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier.")
    migrate_to_chat_id: Optional[StrictInt] = Field(default=None, description="*Optional*. The group has been migrated to a supergroup with the specified identifier. This number may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier.")
    new_chat_members: Optional[List[User]] = Field(default=None, description="*Optional*. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)")
    new_chat_photo: Optional[List[PhotoSize]] = Field(default=None, description="*Optional*. A chat photo was change to this value")
    new_chat_title: Optional[StrictStr] = Field(default=None, description="*Optional*. A chat title was changed to this value")
    passport_data: Optional[PassportData] = None
    photo: Optional[List[PhotoSize]] = Field(default=None, description="*Optional*. Message is a photo, available sizes of the photo")
    pinned_message: Optional[Message] = None
    poll: Optional[Poll] = None
    proximity_alert_triggered: Optional[ProximityAlertTriggered] = None
    reply_markup: Optional[InlineKeyboardMarkup] = None
    reply_to_message: Optional[Message] = None
    sender_chat: Optional[Chat] = None
    sticker: Optional[Sticker] = None
    successful_payment: Optional[SuccessfulPayment] = None
    supergroup_chat_created: Optional[StrictBool] = Field(default=None, description="*Optional*. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply\\_to\\_message if someone replies to a very first message in a directly created supergroup.")
    text: Optional[StrictStr] = Field(default=None, description="*Optional*. For text messages, the actual UTF-8 text of the message, 0-4096 characters")
    venue: Optional[Venue] = None
    via_bot: Optional[User] = None
    video: Optional[Video] = None
    video_note: Optional[VideoNote] = None
    voice: Optional[Voice] = None
    __properties: ClassVar[List[str]] = ["animation", "audio", "author_signature", "caption", "caption_entities", "channel_chat_created", "chat", "connected_website", "contact", "date", "delete_chat_photo", "dice", "document", "edit_date", "entities", "forward_date", "forward_from", "forward_from_chat", "forward_from_message_id", "forward_sender_name", "forward_signature", "from", "game", "group_chat_created", "invoice", "left_chat_member", "location", "media_group_id", "message_id", "migrate_from_chat_id", "migrate_to_chat_id", "new_chat_members", "new_chat_photo", "new_chat_title", "passport_data", "photo", "pinned_message", "poll", "proximity_alert_triggered", "reply_markup", "reply_to_message", "sender_chat", "sticker", "successful_payment", "supergroup_chat_created", "text", "venue", "via_bot", "video", "video_note", "voice"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Message from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of animation
        if self.animation:
            _dict['animation'] = self.animation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of audio
        if self.audio:
            _dict['audio'] = self.audio.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in caption_entities (list)
        _items = []
        if self.caption_entities:
            for _item_caption_entities in self.caption_entities:
                if _item_caption_entities:
                    _items.append(_item_caption_entities.to_dict())
            _dict['caption_entities'] = _items
        # override the default output from pydantic by calling `to_dict()` of chat
        if self.chat:
            _dict['chat'] = self.chat.to_dict()
        # override the default output from pydantic by calling `to_dict()` of contact
        if self.contact:
            _dict['contact'] = self.contact.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dice
        if self.dice:
            _dict['dice'] = self.dice.to_dict()
        # override the default output from pydantic by calling `to_dict()` of document
        if self.document:
            _dict['document'] = self.document.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in entities (list)
        _items = []
        if self.entities:
            for _item_entities in self.entities:
                if _item_entities:
                    _items.append(_item_entities.to_dict())
            _dict['entities'] = _items
        # override the default output from pydantic by calling `to_dict()` of forward_from
        if self.forward_from:
            _dict['forward_from'] = self.forward_from.to_dict()
        # override the default output from pydantic by calling `to_dict()` of forward_from_chat
        if self.forward_from_chat:
            _dict['forward_from_chat'] = self.forward_from_chat.to_dict()
        # override the default output from pydantic by calling `to_dict()` of var_from
        if self.var_from:
            _dict['from'] = self.var_from.to_dict()
        # override the default output from pydantic by calling `to_dict()` of game
        if self.game:
            _dict['game'] = self.game.to_dict()
        # override the default output from pydantic by calling `to_dict()` of invoice
        if self.invoice:
            _dict['invoice'] = self.invoice.to_dict()
        # override the default output from pydantic by calling `to_dict()` of left_chat_member
        if self.left_chat_member:
            _dict['left_chat_member'] = self.left_chat_member.to_dict()
        # override the default output from pydantic by calling `to_dict()` of location
        if self.location:
            _dict['location'] = self.location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in new_chat_members (list)
        _items = []
        if self.new_chat_members:
            for _item_new_chat_members in self.new_chat_members:
                if _item_new_chat_members:
                    _items.append(_item_new_chat_members.to_dict())
            _dict['new_chat_members'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in new_chat_photo (list)
        _items = []
        if self.new_chat_photo:
            for _item_new_chat_photo in self.new_chat_photo:
                if _item_new_chat_photo:
                    _items.append(_item_new_chat_photo.to_dict())
            _dict['new_chat_photo'] = _items
        # override the default output from pydantic by calling `to_dict()` of passport_data
        if self.passport_data:
            _dict['passport_data'] = self.passport_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in photo (list)
        _items = []
        if self.photo:
            for _item_photo in self.photo:
                if _item_photo:
                    _items.append(_item_photo.to_dict())
            _dict['photo'] = _items
        # override the default output from pydantic by calling `to_dict()` of pinned_message
        if self.pinned_message:
            _dict['pinned_message'] = self.pinned_message.to_dict()
        # override the default output from pydantic by calling `to_dict()` of poll
        if self.poll:
            _dict['poll'] = self.poll.to_dict()
        # override the default output from pydantic by calling `to_dict()` of proximity_alert_triggered
        if self.proximity_alert_triggered:
            _dict['proximity_alert_triggered'] = self.proximity_alert_triggered.to_dict()
        # override the default output from pydantic by calling `to_dict()` of reply_markup
        if self.reply_markup:
            _dict['reply_markup'] = self.reply_markup.to_dict()
        # override the default output from pydantic by calling `to_dict()` of reply_to_message
        if self.reply_to_message:
            _dict['reply_to_message'] = self.reply_to_message.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sender_chat
        if self.sender_chat:
            _dict['sender_chat'] = self.sender_chat.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sticker
        if self.sticker:
            _dict['sticker'] = self.sticker.to_dict()
        # override the default output from pydantic by calling `to_dict()` of successful_payment
        if self.successful_payment:
            _dict['successful_payment'] = self.successful_payment.to_dict()
        # override the default output from pydantic by calling `to_dict()` of venue
        if self.venue:
            _dict['venue'] = self.venue.to_dict()
        # override the default output from pydantic by calling `to_dict()` of via_bot
        if self.via_bot:
            _dict['via_bot'] = self.via_bot.to_dict()
        # override the default output from pydantic by calling `to_dict()` of video
        if self.video:
            _dict['video'] = self.video.to_dict()
        # override the default output from pydantic by calling `to_dict()` of video_note
        if self.video_note:
            _dict['video_note'] = self.video_note.to_dict()
        # override the default output from pydantic by calling `to_dict()` of voice
        if self.voice:
            _dict['voice'] = self.voice.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Message from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "animation": Animation.from_dict(obj["animation"]) if obj.get("animation") is not None else None,
            "audio": Audio.from_dict(obj["audio"]) if obj.get("audio") is not None else None,
            "author_signature": obj.get("author_signature"),
            "caption": obj.get("caption"),
            "caption_entities": [MessageEntity.from_dict(_item) for _item in obj["caption_entities"]] if obj.get("caption_entities") is not None else None,
            "channel_chat_created": obj.get("channel_chat_created"),
            "chat": Chat.from_dict(obj["chat"]) if obj.get("chat") is not None else None,
            "connected_website": obj.get("connected_website"),
            "contact": Contact.from_dict(obj["contact"]) if obj.get("contact") is not None else None,
            "date": obj.get("date"),
            "delete_chat_photo": obj.get("delete_chat_photo"),
            "dice": Dice.from_dict(obj["dice"]) if obj.get("dice") is not None else None,
            "document": Document.from_dict(obj["document"]) if obj.get("document") is not None else None,
            "edit_date": obj.get("edit_date"),
            "entities": [MessageEntity.from_dict(_item) for _item in obj["entities"]] if obj.get("entities") is not None else None,
            "forward_date": obj.get("forward_date"),
            "forward_from": User.from_dict(obj["forward_from"]) if obj.get("forward_from") is not None else None,
            "forward_from_chat": Chat.from_dict(obj["forward_from_chat"]) if obj.get("forward_from_chat") is not None else None,
            "forward_from_message_id": obj.get("forward_from_message_id"),
            "forward_sender_name": obj.get("forward_sender_name"),
            "forward_signature": obj.get("forward_signature"),
            "from": User.from_dict(obj["from"]) if obj.get("from") is not None else None,
            "game": Game.from_dict(obj["game"]) if obj.get("game") is not None else None,
            "group_chat_created": obj.get("group_chat_created"),
            "invoice": Invoice.from_dict(obj["invoice"]) if obj.get("invoice") is not None else None,
            "left_chat_member": User.from_dict(obj["left_chat_member"]) if obj.get("left_chat_member") is not None else None,
            "location": Location.from_dict(obj["location"]) if obj.get("location") is not None else None,
            "media_group_id": obj.get("media_group_id"),
            "message_id": obj.get("message_id"),
            "migrate_from_chat_id": obj.get("migrate_from_chat_id"),
            "migrate_to_chat_id": obj.get("migrate_to_chat_id"),
            "new_chat_members": [User.from_dict(_item) for _item in obj["new_chat_members"]] if obj.get("new_chat_members") is not None else None,
            "new_chat_photo": [PhotoSize.from_dict(_item) for _item in obj["new_chat_photo"]] if obj.get("new_chat_photo") is not None else None,
            "new_chat_title": obj.get("new_chat_title"),
            "passport_data": PassportData.from_dict(obj["passport_data"]) if obj.get("passport_data") is not None else None,
            "photo": [PhotoSize.from_dict(_item) for _item in obj["photo"]] if obj.get("photo") is not None else None,
            "pinned_message": Message.from_dict(obj["pinned_message"]) if obj.get("pinned_message") is not None else None,
            "poll": Poll.from_dict(obj["poll"]) if obj.get("poll") is not None else None,
            "proximity_alert_triggered": ProximityAlertTriggered.from_dict(obj["proximity_alert_triggered"]) if obj.get("proximity_alert_triggered") is not None else None,
            "reply_markup": InlineKeyboardMarkup.from_dict(obj["reply_markup"]) if obj.get("reply_markup") is not None else None,
            "reply_to_message": Message.from_dict(obj["reply_to_message"]) if obj.get("reply_to_message") is not None else None,
            "sender_chat": Chat.from_dict(obj["sender_chat"]) if obj.get("sender_chat") is not None else None,
            "sticker": Sticker.from_dict(obj["sticker"]) if obj.get("sticker") is not None else None,
            "successful_payment": SuccessfulPayment.from_dict(obj["successful_payment"]) if obj.get("successful_payment") is not None else None,
            "supergroup_chat_created": obj.get("supergroup_chat_created"),
            "text": obj.get("text"),
            "venue": Venue.from_dict(obj["venue"]) if obj.get("venue") is not None else None,
            "via_bot": User.from_dict(obj["via_bot"]) if obj.get("via_bot") is not None else None,
            "video": Video.from_dict(obj["video"]) if obj.get("video") is not None else None,
            "video_note": VideoNote.from_dict(obj["video_note"]) if obj.get("video_note") is not None else None,
            "voice": Voice.from_dict(obj["voice"]) if obj.get("voice") is not None else None
        })
        return _obj

from openapi_client.models.chat import Chat
# TODO: Rewrite to not use raise_errors
Message.model_rebuild(raise_errors=False)

