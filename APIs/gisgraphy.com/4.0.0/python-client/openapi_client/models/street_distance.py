# coding: utf-8

"""
    Gisgraphy webservices

    Since 2006, [Gisgraphy](http://www.gisgraphy.com) is a free, open source framework that offers the possibility to do geolocalisation and geocoding via Java APIs or REST webservices. Because geocoding is nothing without data, it provides an easy to use importer that will automatically download and import the necessary (free) data to your local database ([OpenStreetMap](http://www.openstreetmap.org/), [Geonames](http://www.geonames.org/) and [Quattroshapes](http://www.quattroshapes.com/): more than 100 million entries). You can also add your own data with the Web interface or the importer connectors provided. Gisgraphy is production ready, and has been designed to be scalable(load balanced), performant and used in other languages than just java : results can be output in XML, JSON, PHP, Python, Ruby, YAML, GeoRSS, and Atom. One of the most popular GPS tracking System (OpenGTS) also includes a Gisgraphy client...Gisgraphy is a framework. As a result it's flexible and powerful enough to be used in a lot of different use cases. [read more](http://www.gisgraphy.com)   if you use the premium servers, you can use the api key to test the webservices 

    The version of the OpenAPI document: 4.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class StreetDistance(BaseModel):
    """
    StreetDistance
    """ # noqa: E501
    country_code: Optional[StrictStr] = Field(default=None, description="The ISO 3166 country code", alias="countryCode")
    distance: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The distance between the point and the nearest point to the street in meters")
    fully_qualified_address: Optional[StrictStr] = Field(default=None, description="NOT USED YET", alias="fullyQualifiedAddress")
    gid: Optional[StrictInt] = Field(default=None, description="Unique id of the street, it is unique between GeoNames and OpenStreetMap")
    is_in: Optional[StrictStr] = Field(default=None, description="Information on the city where the street is (depends on OpenStreetMap 'is_in' field), the city in general", alias="isIn")
    is_in_adm: Optional[StrictStr] = Field(default=None, description="Information of the administration division where the street is.", alias="isInAdm")
    is_in_place: Optional[StrictStr] = Field(default=None, description="Information on the place where the street is (quater, common place). Generally a place at a lower level than city", alias="isInPlace")
    is_in_zip: Optional[StrictStr] = Field(default=None, description="Information of the zipcode where the street / POI is (often fill for placetype street)", alias="isInZip")
    lat: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The latitude of the middle of the street(north-south)")
    length: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="length of the street in meters")
    lng: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The longitude of the middle of the street(east-west)")
    name: Optional[StrictStr] = Field(default=None, description="The name of the street")
    one_way: Optional[StrictBool] = Field(default=None, description="Whether the street is a one way street or not", alias="oneWay")
    openstreetmap_id: Optional[StrictInt] = Field(default=None, description="OpenStreetMap unique id of the street", alias="openstreetmapId")
    street_type: Optional[StrictStr] = Field(default=None, description="The type of the street (see street type list)", alias="streetType")
    __properties: ClassVar[List[str]] = ["countryCode", "distance", "fullyQualifiedAddress", "gid", "isIn", "isInAdm", "isInPlace", "isInZip", "lat", "length", "lng", "name", "oneWay", "openstreetmapId", "streetType"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of StreetDistance from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of StreetDistance from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "countryCode": obj.get("countryCode"),
            "distance": obj.get("distance"),
            "fullyQualifiedAddress": obj.get("fullyQualifiedAddress"),
            "gid": obj.get("gid"),
            "isIn": obj.get("isIn"),
            "isInAdm": obj.get("isInAdm"),
            "isInPlace": obj.get("isInPlace"),
            "isInZip": obj.get("isInZip"),
            "lat": obj.get("lat"),
            "length": obj.get("length"),
            "lng": obj.get("lng"),
            "name": obj.get("name"),
            "oneWay": obj.get("oneWay"),
            "openstreetmapId": obj.get("openstreetmapId"),
            "streetType": obj.get("streetType")
        })
        return _obj


