# coding: utf-8

"""
    Alerter System API

    <p>This is the <a href=\"/\">Alerter System</a> API playground. More documentation is available at the <a href=\"/help/developers/\">API Help Center</a>.</p><p>The \"Available Authorizations\" in the Authorize popup only applies to this playground web interface. Other <a href=\"/help/developers/authorization/\">authorizations</a> are available for the actual API.</p>

    The version of the OpenAPI document: 1.7.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.alert_log_jsonld_get_context import AlertLogJsonldGetContext
from typing import Optional, Set
from typing_extensions import Self

class MonitorJsonldGet(BaseModel):
    """
    The Monitor resource is a collection of services that monitor the presence and/or absence of pings, and follow sets of rules to dispatch or not dispatch alerts.
    """ # noqa: E501
    context: Optional[AlertLogJsonldGetContext] = Field(default=None, alias="@context")
    id: Optional[StrictStr] = Field(default=None, alias="@id")
    type: Optional[StrictStr] = Field(default=None, alias="@type")
    alert_payload_extended: Optional[Annotated[str, Field(strict=True, max_length=2100000)]] = Field(default=None, description="Payload that must be sent in the body of each alert when you use your own email or webhook alert services. This is the body for email alerts and the request body for webhook alerts. This text is not sent when using the built-in alert services. Sending user-supplied text via our own email server is too big a risk to our email reputation. Max 2 MB characters.", alias="alertPayloadExtended")
    alert_payload_short: Optional[Annotated[str, Field(strict=True, max_length=100)]] = Field(default=None, description="Payload that must be sent in the body of each alert when you use your own short message alert services. This also serves as the subject for email alerts. Not used for webhooks. This text is not sent when using the built-in alert services. Sending user-supplied text via our own email server is too big a risk to our email reputation. Max 100 characters.", alias="alertPayloadShort")
    alert_services: Optional[List[StrictStr]] = Field(default=None, description="The alert services that are related to this resource.", alias="alertServices")
    allow_unauthenticated_pings: Optional[StrictBool] = Field(default=None, description="Indicates that the monitor will accept pings that are not OAuth authenticated.", alias="allowUnauthenticatedPings")
    content_check_must_not_exist: Optional[StrictBool] = Field(default=None, description="Indicates that the Web Content monitor must verify the absence of the text or the Xpath node, and dispatch an alert if it is present. The default behavior is to verify the presence of the text or the Xpath node, and dispatch an alert if it is absent.", alias="contentCheckMustNotExist")
    content_check_text: Optional[StrictStr] = Field(default=None, description="The text (case-insensitive) that must or must not be present at the contentCheckUrl. If contentCheckXpathFilter is supplied, then the only the text within that nodes is evaluated, otherwise text on the entire web page is evaluated.", alias="contentCheckText")
    content_check_url: Optional[StrictStr] = Field(default=None, description="The URL that the Web Content monitor type must evaluate for the specified conditions.", alias="contentCheckUrl")
    content_check_xpath_filter: Optional[StrictStr] = Field(default=None, description="The Xpath filter (<a href=\"https://en.wikipedia.org/wiki/XPath\">Xpath</a>, <a href=\"https://devhints.io/xpath\">Xpath Cheatsheet</a>) that selects a specific node in the HTML of the target web page. If contentCheckText is supplied, then only the text within the selected node is evaluated. If contentCheckText is left empty, then the presence or the absence of the selected node is evaluated.", alias="contentCheckXpathFilter")
    created_at: Optional[datetime] = Field(default=None, description="When the resource instance was created. This date-time is in the UTC timezone.", alias="createdAt")
    data_segment_code: Optional[Annotated[str, Field(strict=True, max_length=50)]] = Field(default=None, description="User-provided string on which to segment and filter data. Max 50 characters.", alias="dataSegmentCode")
    grace_seconds: Optional[StrictInt] = Field(default=None, description="The number of grace seconds after expiry of the time when the next ping was expected, before raising an alert. The number of grace seconds to allow before classifying a Measured Monitor task duration as an anomaly.", alias="graceSeconds")
    humanized_interval: Optional[StrictStr] = Field(default=None, description="The expected ping / run interval of this monitor in human readable form.", alias="humanizedInterval")
    id: Optional[StrictStr] = Field(default=None, description="The unique identifier of the resource instance.")
    internal_monitor_name: Optional[StrictStr] = Field(default=None, description="The internal name of the monitor. This name is used in alerts when you use the built-in alert services. Sending user-supplied text via our own email server is too big a risk to our email reputation. The monitorName field is used when you use your own alert services.", alias="internalMonitorName")
    interval_days: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of days in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalDays")
    interval_hours: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of hours in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalHours")
    interval_minutes: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of minutes in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalMinutes")
    interval_months: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of months in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalMonths")
    interval_seconds: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of seconds in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalSeconds")
    interval_years: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of years in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalYears")
    is_monitor_paused: Optional[StrictBool] = Field(default=None, description="Indicates that the monitor is paused and will not send alerts.", alias="isMonitorPaused")
    last_ping_at: Optional[datetime] = Field(default=None, description="When the last ping was received. This date-time is in the UTC timezone.", alias="lastPingAt")
    monitor_name: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(description="The name of the monitor. Max 255 characters.", alias="monitorName")
    monitor_notes: Optional[Annotated[str, Field(strict=True, max_length=10000)]] = Field(default=None, description="Notes about the monitor. Max 10,000 characters. Formatting using Markdown is allowed. HTML will be removed.", alias="monitorNotes")
    monitor_status_code: Optional[StrictStr] = Field(default=None, description="The status of the monitor.", alias="monitorStatusCode")
    monitor_type_code: Optional[StrictStr] = Field(description="The type of the monitor.", alias="monitorTypeCode")
    next_ping_at: Optional[datetime] = Field(default=None, description="When the next ping is expected. This date-time is in the UTC timezone.", alias="nextPingAt")
    partition: StrictStr = Field(description="The partition that contains this resource instance. The resource cannot be moved to another partition.")
    ping_secret: Optional[StrictStr] = Field(default=None, description="A secret key that can be sent in the X_PING_SECRET HTTP request header of a ping for additional security. Sending the secret is recommended for unauthenticated ping requests. It is redundant for OAuth authenticated ping requests that have the \"Authorization: Bearer\" header.", alias="pingSecret")
    public_description: Optional[Annotated[str, Field(strict=True, max_length=10000)]] = Field(default=None, description="A text description of the monitor that is accessible to unauthenticated users that receive an alert from the monitor. Formatting using Markdown is allowed. HTML will be removed.", alias="publicDescription")
    resource_owner: Optional[StrictStr] = Field(default=None, description="The name of the person who owns this resource.", alias="resourceOwner")
    start_monitor_at: Optional[datetime] = Field(default=None, description="When to start the Regular Interval type monitor or Heartbeat type monitor, or when to send the first alert of the Scheduled Repeatable Alert monitor. Cannot be blank for a Regular Interval, Heartbeat, or Scheduled Repeatable Alert type monitor, must be blank for other monitors types. This date-time is always interpreted to be in the timezone of the monitor. Any UTC offset is ignored.", alias="startMonitorAt")
    start_monitor_at_utc: Optional[datetime] = Field(default=None, description="The startMonitorAt date-time in the UTC timezone.", alias="startMonitorAtUtc")
    system_messages: Optional[List[StrictStr]] = Field(default=None, description="Service notes regarding the resource.", alias="systemMessages")
    timezone_code: StrictStr = Field(description="The timezone of the monitor. Dates and times in alerts and reports will be in this time zone.", alias="timezoneCode")
    web_response_seconds_limit: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The time in seconds that the Web Response monitor type must allow for the web page to respond.", alias="webResponseSecondsLimit")
    web_response_url: Optional[StrictStr] = Field(default=None, description="The URL that the Web Response monitor type must evaluate for the specified conditions.", alias="webResponseUrl")
    __properties: ClassVar[List[str]] = ["@context", "@id", "@type", "alertPayloadExtended", "alertPayloadShort", "alertServices", "allowUnauthenticatedPings", "contentCheckMustNotExist", "contentCheckText", "contentCheckUrl", "contentCheckXpathFilter", "createdAt", "dataSegmentCode", "graceSeconds", "humanizedInterval", "id", "internalMonitorName", "intervalDays", "intervalHours", "intervalMinutes", "intervalMonths", "intervalSeconds", "intervalYears", "isMonitorPaused", "lastPingAt", "monitorName", "monitorNotes", "monitorStatusCode", "monitorTypeCode", "nextPingAt", "partition", "pingSecret", "publicDescription", "resourceOwner", "startMonitorAt", "startMonitorAtUtc", "systemMessages", "timezoneCode", "webResponseSecondsLimit", "webResponseUrl"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MonitorJsonldGet from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "id",
            "type",
            "created_at",
            "humanized_interval",
            "id",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of context
        if self.context:
            _dict['@context'] = self.context.to_dict()
        # set to None if alert_payload_extended (nullable) is None
        # and model_fields_set contains the field
        if self.alert_payload_extended is None and "alert_payload_extended" in self.model_fields_set:
            _dict['alertPayloadExtended'] = None

        # set to None if alert_payload_short (nullable) is None
        # and model_fields_set contains the field
        if self.alert_payload_short is None and "alert_payload_short" in self.model_fields_set:
            _dict['alertPayloadShort'] = None

        # set to None if content_check_text (nullable) is None
        # and model_fields_set contains the field
        if self.content_check_text is None and "content_check_text" in self.model_fields_set:
            _dict['contentCheckText'] = None

        # set to None if content_check_url (nullable) is None
        # and model_fields_set contains the field
        if self.content_check_url is None and "content_check_url" in self.model_fields_set:
            _dict['contentCheckUrl'] = None

        # set to None if content_check_xpath_filter (nullable) is None
        # and model_fields_set contains the field
        if self.content_check_xpath_filter is None and "content_check_xpath_filter" in self.model_fields_set:
            _dict['contentCheckXpathFilter'] = None

        # set to None if data_segment_code (nullable) is None
        # and model_fields_set contains the field
        if self.data_segment_code is None and "data_segment_code" in self.model_fields_set:
            _dict['dataSegmentCode'] = None

        # set to None if grace_seconds (nullable) is None
        # and model_fields_set contains the field
        if self.grace_seconds is None and "grace_seconds" in self.model_fields_set:
            _dict['graceSeconds'] = None

        # set to None if humanized_interval (nullable) is None
        # and model_fields_set contains the field
        if self.humanized_interval is None and "humanized_interval" in self.model_fields_set:
            _dict['humanizedInterval'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if interval_days (nullable) is None
        # and model_fields_set contains the field
        if self.interval_days is None and "interval_days" in self.model_fields_set:
            _dict['intervalDays'] = None

        # set to None if interval_hours (nullable) is None
        # and model_fields_set contains the field
        if self.interval_hours is None and "interval_hours" in self.model_fields_set:
            _dict['intervalHours'] = None

        # set to None if interval_minutes (nullable) is None
        # and model_fields_set contains the field
        if self.interval_minutes is None and "interval_minutes" in self.model_fields_set:
            _dict['intervalMinutes'] = None

        # set to None if interval_months (nullable) is None
        # and model_fields_set contains the field
        if self.interval_months is None and "interval_months" in self.model_fields_set:
            _dict['intervalMonths'] = None

        # set to None if interval_seconds (nullable) is None
        # and model_fields_set contains the field
        if self.interval_seconds is None and "interval_seconds" in self.model_fields_set:
            _dict['intervalSeconds'] = None

        # set to None if interval_years (nullable) is None
        # and model_fields_set contains the field
        if self.interval_years is None and "interval_years" in self.model_fields_set:
            _dict['intervalYears'] = None

        # set to None if last_ping_at (nullable) is None
        # and model_fields_set contains the field
        if self.last_ping_at is None and "last_ping_at" in self.model_fields_set:
            _dict['lastPingAt'] = None

        # set to None if monitor_name (nullable) is None
        # and model_fields_set contains the field
        if self.monitor_name is None and "monitor_name" in self.model_fields_set:
            _dict['monitorName'] = None

        # set to None if monitor_notes (nullable) is None
        # and model_fields_set contains the field
        if self.monitor_notes is None and "monitor_notes" in self.model_fields_set:
            _dict['monitorNotes'] = None

        # set to None if monitor_type_code (nullable) is None
        # and model_fields_set contains the field
        if self.monitor_type_code is None and "monitor_type_code" in self.model_fields_set:
            _dict['monitorTypeCode'] = None

        # set to None if next_ping_at (nullable) is None
        # and model_fields_set contains the field
        if self.next_ping_at is None and "next_ping_at" in self.model_fields_set:
            _dict['nextPingAt'] = None

        # set to None if public_description (nullable) is None
        # and model_fields_set contains the field
        if self.public_description is None and "public_description" in self.model_fields_set:
            _dict['publicDescription'] = None

        # set to None if resource_owner (nullable) is None
        # and model_fields_set contains the field
        if self.resource_owner is None and "resource_owner" in self.model_fields_set:
            _dict['resourceOwner'] = None

        # set to None if start_monitor_at (nullable) is None
        # and model_fields_set contains the field
        if self.start_monitor_at is None and "start_monitor_at" in self.model_fields_set:
            _dict['startMonitorAt'] = None

        # set to None if start_monitor_at_utc (nullable) is None
        # and model_fields_set contains the field
        if self.start_monitor_at_utc is None and "start_monitor_at_utc" in self.model_fields_set:
            _dict['startMonitorAtUtc'] = None

        # set to None if web_response_seconds_limit (nullable) is None
        # and model_fields_set contains the field
        if self.web_response_seconds_limit is None and "web_response_seconds_limit" in self.model_fields_set:
            _dict['webResponseSecondsLimit'] = None

        # set to None if web_response_url (nullable) is None
        # and model_fields_set contains the field
        if self.web_response_url is None and "web_response_url" in self.model_fields_set:
            _dict['webResponseUrl'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MonitorJsonldGet from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "@context": AlertLogJsonldGetContext.from_dict(obj["@context"]) if obj.get("@context") is not None else None,
            "@id": obj.get("@id"),
            "@type": obj.get("@type"),
            "alertPayloadExtended": obj.get("alertPayloadExtended"),
            "alertPayloadShort": obj.get("alertPayloadShort"),
            "alertServices": obj.get("alertServices"),
            "allowUnauthenticatedPings": obj.get("allowUnauthenticatedPings"),
            "contentCheckMustNotExist": obj.get("contentCheckMustNotExist"),
            "contentCheckText": obj.get("contentCheckText"),
            "contentCheckUrl": obj.get("contentCheckUrl"),
            "contentCheckXpathFilter": obj.get("contentCheckXpathFilter"),
            "createdAt": obj.get("createdAt"),
            "dataSegmentCode": obj.get("dataSegmentCode"),
            "graceSeconds": obj.get("graceSeconds"),
            "humanizedInterval": obj.get("humanizedInterval"),
            "id": obj.get("id"),
            "internalMonitorName": obj.get("internalMonitorName"),
            "intervalDays": obj.get("intervalDays"),
            "intervalHours": obj.get("intervalHours"),
            "intervalMinutes": obj.get("intervalMinutes"),
            "intervalMonths": obj.get("intervalMonths"),
            "intervalSeconds": obj.get("intervalSeconds"),
            "intervalYears": obj.get("intervalYears"),
            "isMonitorPaused": obj.get("isMonitorPaused"),
            "lastPingAt": obj.get("lastPingAt"),
            "monitorName": obj.get("monitorName"),
            "monitorNotes": obj.get("monitorNotes"),
            "monitorStatusCode": obj.get("monitorStatusCode"),
            "monitorTypeCode": obj.get("monitorTypeCode"),
            "nextPingAt": obj.get("nextPingAt"),
            "partition": obj.get("partition"),
            "pingSecret": obj.get("pingSecret"),
            "publicDescription": obj.get("publicDescription"),
            "resourceOwner": obj.get("resourceOwner"),
            "startMonitorAt": obj.get("startMonitorAt"),
            "startMonitorAtUtc": obj.get("startMonitorAtUtc"),
            "systemMessages": obj.get("systemMessages"),
            "timezoneCode": obj.get("timezoneCode"),
            "webResponseSecondsLimit": obj.get("webResponseSecondsLimit"),
            "webResponseUrl": obj.get("webResponseUrl")
        })
        return _obj


