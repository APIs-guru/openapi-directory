# coding: utf-8

"""
    Alerter System API

    <p>This is the <a href=\"/\">Alerter System</a> API playground. More documentation is available at the <a href=\"/help/developers/\">API Help Center</a>.</p><p>The \"Available Authorizations\" in the Authorize popup only applies to this playground web interface. Other <a href=\"/help/developers/authorization/\">authorizations</a> are available for the actual API.</p>

    The version of the OpenAPI document: 1.7.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class MonitorJsonldPost(BaseModel):
    """
    The Monitor resource is a collection of services that monitor the presence and/or absence of pings, and follow sets of rules to dispatch or not dispatch alerts.
    """ # noqa: E501
    alert_payload_extended: Optional[Annotated[str, Field(strict=True, max_length=2100000)]] = Field(default=None, description="Payload that must be sent in the body of each alert when you use your own email or webhook alert services. This is the body for email alerts and the request body for webhook alerts. This text is not sent when using the built-in alert services. Sending user-supplied text via our own email server is too big a risk to our email reputation. Max 2 MB characters.", alias="alertPayloadExtended")
    alert_payload_short: Optional[Annotated[str, Field(strict=True, max_length=100)]] = Field(default=None, description="Payload that must be sent in the body of each alert when you use your own short message alert services. This also serves as the subject for email alerts. Not used for webhooks. This text is not sent when using the built-in alert services. Sending user-supplied text via our own email server is too big a risk to our email reputation. Max 100 characters.", alias="alertPayloadShort")
    alert_services: Optional[List[StrictStr]] = Field(default=None, description="The alert services that are related to this resource.", alias="alertServices")
    allow_unauthenticated_pings: Optional[StrictBool] = Field(default=None, description="Indicates that the monitor will accept pings that are not OAuth authenticated.", alias="allowUnauthenticatedPings")
    content_check_must_not_exist: Optional[StrictBool] = Field(default=None, description="Indicates that the Web Content monitor must verify the absence of the text or the Xpath node, and dispatch an alert if it is present. The default behavior is to verify the presence of the text or the Xpath node, and dispatch an alert if it is absent.", alias="contentCheckMustNotExist")
    content_check_text: Optional[StrictStr] = Field(default=None, description="The text (case-insensitive) that must or must not be present at the contentCheckUrl. If contentCheckXpathFilter is supplied, then the only the text within that nodes is evaluated, otherwise text on the entire web page is evaluated.", alias="contentCheckText")
    content_check_url: Optional[StrictStr] = Field(default=None, description="The URL that the Web Content monitor type must evaluate for the specified conditions.", alias="contentCheckUrl")
    content_check_xpath_filter: Optional[StrictStr] = Field(default=None, description="The Xpath filter (<a href=\"https://en.wikipedia.org/wiki/XPath\">Xpath</a>, <a href=\"https://devhints.io/xpath\">Xpath Cheatsheet</a>) that selects a specific node in the HTML of the target web page. If contentCheckText is supplied, then only the text within the selected node is evaluated. If contentCheckText is left empty, then the presence or the absence of the selected node is evaluated.", alias="contentCheckXpathFilter")
    data_segment_code: Optional[Annotated[str, Field(strict=True, max_length=50)]] = Field(default=None, description="User-provided string on which to segment and filter data. Max 50 characters.", alias="dataSegmentCode")
    grace_seconds: Optional[StrictInt] = Field(default=None, description="The number of grace seconds after expiry of the time when the next ping was expected, before raising an alert. The number of grace seconds to allow before classifying a Measured Monitor task duration as an anomaly.", alias="graceSeconds")
    interval_days: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of days in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalDays")
    interval_hours: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of hours in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalHours")
    interval_minutes: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of minutes in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalMinutes")
    interval_months: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of months in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalMonths")
    interval_seconds: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of seconds in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalSeconds")
    interval_years: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The number of years in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.", alias="intervalYears")
    is_monitor_paused: Optional[StrictBool] = Field(default=None, description="Indicates that the monitor is paused and will not send alerts.", alias="isMonitorPaused")
    monitor_name: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(description="The name of the monitor. Max 255 characters.", alias="monitorName")
    monitor_notes: Optional[Annotated[str, Field(strict=True, max_length=10000)]] = Field(default=None, description="Notes about the monitor. Max 10,000 characters. Formatting using Markdown is allowed. HTML will be removed.", alias="monitorNotes")
    monitor_type_code: Optional[StrictStr] = Field(description="The type of the monitor.", alias="monitorTypeCode")
    partition: StrictStr = Field(description="The partition that contains this resource instance. The resource cannot be moved to another partition.")
    public_description: Optional[Annotated[str, Field(strict=True, max_length=10000)]] = Field(default=None, description="A text description of the monitor that is accessible to unauthenticated users that receive an alert from the monitor. Formatting using Markdown is allowed. HTML will be removed.", alias="publicDescription")
    start_monitor_at: Optional[datetime] = Field(default=None, description="When to start the Regular Interval type monitor or Heartbeat type monitor, or when to send the first alert of the Scheduled Repeatable Alert monitor. Cannot be blank for a Regular Interval, Heartbeat, or Scheduled Repeatable Alert type monitor, must be blank for other monitors types. This date-time is always interpreted to be in the timezone of the monitor. Any UTC offset is ignored.", alias="startMonitorAt")
    timezone_code: StrictStr = Field(description="The timezone of the monitor. Dates and times in alerts and reports will be in this time zone.", alias="timezoneCode")
    web_response_seconds_limit: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The time in seconds that the Web Response monitor type must allow for the web page to respond.", alias="webResponseSecondsLimit")
    web_response_url: Optional[StrictStr] = Field(default=None, description="The URL that the Web Response monitor type must evaluate for the specified conditions.", alias="webResponseUrl")
    __properties: ClassVar[List[str]] = ["alertPayloadExtended", "alertPayloadShort", "alertServices", "allowUnauthenticatedPings", "contentCheckMustNotExist", "contentCheckText", "contentCheckUrl", "contentCheckXpathFilter", "dataSegmentCode", "graceSeconds", "intervalDays", "intervalHours", "intervalMinutes", "intervalMonths", "intervalSeconds", "intervalYears", "isMonitorPaused", "monitorName", "monitorNotes", "monitorTypeCode", "partition", "publicDescription", "startMonitorAt", "timezoneCode", "webResponseSecondsLimit", "webResponseUrl"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MonitorJsonldPost from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if alert_payload_extended (nullable) is None
        # and model_fields_set contains the field
        if self.alert_payload_extended is None and "alert_payload_extended" in self.model_fields_set:
            _dict['alertPayloadExtended'] = None

        # set to None if alert_payload_short (nullable) is None
        # and model_fields_set contains the field
        if self.alert_payload_short is None and "alert_payload_short" in self.model_fields_set:
            _dict['alertPayloadShort'] = None

        # set to None if content_check_text (nullable) is None
        # and model_fields_set contains the field
        if self.content_check_text is None and "content_check_text" in self.model_fields_set:
            _dict['contentCheckText'] = None

        # set to None if content_check_url (nullable) is None
        # and model_fields_set contains the field
        if self.content_check_url is None and "content_check_url" in self.model_fields_set:
            _dict['contentCheckUrl'] = None

        # set to None if content_check_xpath_filter (nullable) is None
        # and model_fields_set contains the field
        if self.content_check_xpath_filter is None and "content_check_xpath_filter" in self.model_fields_set:
            _dict['contentCheckXpathFilter'] = None

        # set to None if data_segment_code (nullable) is None
        # and model_fields_set contains the field
        if self.data_segment_code is None and "data_segment_code" in self.model_fields_set:
            _dict['dataSegmentCode'] = None

        # set to None if grace_seconds (nullable) is None
        # and model_fields_set contains the field
        if self.grace_seconds is None and "grace_seconds" in self.model_fields_set:
            _dict['graceSeconds'] = None

        # set to None if interval_days (nullable) is None
        # and model_fields_set contains the field
        if self.interval_days is None and "interval_days" in self.model_fields_set:
            _dict['intervalDays'] = None

        # set to None if interval_hours (nullable) is None
        # and model_fields_set contains the field
        if self.interval_hours is None and "interval_hours" in self.model_fields_set:
            _dict['intervalHours'] = None

        # set to None if interval_minutes (nullable) is None
        # and model_fields_set contains the field
        if self.interval_minutes is None and "interval_minutes" in self.model_fields_set:
            _dict['intervalMinutes'] = None

        # set to None if interval_months (nullable) is None
        # and model_fields_set contains the field
        if self.interval_months is None and "interval_months" in self.model_fields_set:
            _dict['intervalMonths'] = None

        # set to None if interval_seconds (nullable) is None
        # and model_fields_set contains the field
        if self.interval_seconds is None and "interval_seconds" in self.model_fields_set:
            _dict['intervalSeconds'] = None

        # set to None if interval_years (nullable) is None
        # and model_fields_set contains the field
        if self.interval_years is None and "interval_years" in self.model_fields_set:
            _dict['intervalYears'] = None

        # set to None if monitor_name (nullable) is None
        # and model_fields_set contains the field
        if self.monitor_name is None and "monitor_name" in self.model_fields_set:
            _dict['monitorName'] = None

        # set to None if monitor_notes (nullable) is None
        # and model_fields_set contains the field
        if self.monitor_notes is None and "monitor_notes" in self.model_fields_set:
            _dict['monitorNotes'] = None

        # set to None if monitor_type_code (nullable) is None
        # and model_fields_set contains the field
        if self.monitor_type_code is None and "monitor_type_code" in self.model_fields_set:
            _dict['monitorTypeCode'] = None

        # set to None if public_description (nullable) is None
        # and model_fields_set contains the field
        if self.public_description is None and "public_description" in self.model_fields_set:
            _dict['publicDescription'] = None

        # set to None if start_monitor_at (nullable) is None
        # and model_fields_set contains the field
        if self.start_monitor_at is None and "start_monitor_at" in self.model_fields_set:
            _dict['startMonitorAt'] = None

        # set to None if web_response_seconds_limit (nullable) is None
        # and model_fields_set contains the field
        if self.web_response_seconds_limit is None and "web_response_seconds_limit" in self.model_fields_set:
            _dict['webResponseSecondsLimit'] = None

        # set to None if web_response_url (nullable) is None
        # and model_fields_set contains the field
        if self.web_response_url is None and "web_response_url" in self.model_fields_set:
            _dict['webResponseUrl'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MonitorJsonldPost from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "alertPayloadExtended": obj.get("alertPayloadExtended"),
            "alertPayloadShort": obj.get("alertPayloadShort"),
            "alertServices": obj.get("alertServices"),
            "allowUnauthenticatedPings": obj.get("allowUnauthenticatedPings"),
            "contentCheckMustNotExist": obj.get("contentCheckMustNotExist"),
            "contentCheckText": obj.get("contentCheckText"),
            "contentCheckUrl": obj.get("contentCheckUrl"),
            "contentCheckXpathFilter": obj.get("contentCheckXpathFilter"),
            "dataSegmentCode": obj.get("dataSegmentCode"),
            "graceSeconds": obj.get("graceSeconds"),
            "intervalDays": obj.get("intervalDays"),
            "intervalHours": obj.get("intervalHours"),
            "intervalMinutes": obj.get("intervalMinutes"),
            "intervalMonths": obj.get("intervalMonths"),
            "intervalSeconds": obj.get("intervalSeconds"),
            "intervalYears": obj.get("intervalYears"),
            "isMonitorPaused": obj.get("isMonitorPaused"),
            "monitorName": obj.get("monitorName"),
            "monitorNotes": obj.get("monitorNotes"),
            "monitorTypeCode": obj.get("monitorTypeCode"),
            "partition": obj.get("partition"),
            "publicDescription": obj.get("publicDescription"),
            "startMonitorAt": obj.get("startMonitorAt"),
            "timezoneCode": obj.get("timezoneCode"),
            "webResponseSecondsLimit": obj.get("webResponseSecondsLimit"),
            "webResponseUrl": obj.get("webResponseUrl")
        })
        return _obj


