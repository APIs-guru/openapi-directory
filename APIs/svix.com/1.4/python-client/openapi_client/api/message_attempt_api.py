# coding: utf-8

"""
    Svix API

    Welcome to the Svix API documentation!  Useful links: [Homepage](https://www.svix.com) | [Support email](mailto:support+docs@svix.com) | [Blog](https://www.svix.com/blog/) | [Slack Community](https://www.svix.com/slack/)  # Introduction  This is the reference documentation and schemas for the [Svix webhook service](https://www.svix.com) API. For tutorials and other documentation please refer to [the documentation](https://docs.svix.com).  ## Main concepts  In Svix you have four important entities you will be interacting with:  - `messages`: these are the webhooks being sent. They can have contents and a few other properties. - `application`: this is where `messages` are sent to. Usually you want to create one application for each user on your platform. - `endpoint`: endpoints are the URLs messages will be sent to. Each application can have multiple `endpoints` and each message sent to that application will be sent to all of them (unless they are not subscribed to the sent event type). - `event-type`: event types are identifiers denoting the type of the message being sent. Event types are primarily used to decide which events are sent to which endpoint.   ## Authentication  Get your authentication token (`AUTH_TOKEN`) from the [Svix dashboard](https://dashboard.svix.com) and use it as part of the `Authorization` header as such: `Authorization: Bearer ${AUTH_TOKEN}`.  <SecurityDefinitions />   ## Code samples  The code samples assume you already have the respective libraries installed and you know how to use them. For the latest information on how to do that, please refer to [the documentation](https://docs.svix.com/).   ## Idempotency  Svix supports [idempotency](https://en.wikipedia.org/wiki/Idempotence) for safely retrying requests without accidentally performing the same operation twice. This is useful when an API call is disrupted in transit and you do not receive a response.  To perform an idempotent request, pass the idempotency key in the `Idempotency-Key` header to the request. The idempotency key should be a unique value generated by the client. You can create the key in however way you like, though we suggest using UUID v4, or any other string with enough entropy to avoid collisions.  Svix's idempotency works by saving the resulting status code and body of the first request made for any given idempotency key for any successful request. Subsequent requests with the same key return the same result.  Please note that idempotency is only supported for `POST` requests.   ## Cross-Origin Resource Sharing  This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with [W3C spec](https://www.w3.org/TR/cors/). And that allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site. 

    The version of the OpenAPI document: 1.4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from openapi_client.models.list_response_endpoint_message_out import ListResponseEndpointMessageOut
from openapi_client.models.list_response_message_attempt_endpoint_out import ListResponseMessageAttemptEndpointOut
from openapi_client.models.list_response_message_attempt_out import ListResponseMessageAttemptOut
from openapi_client.models.list_response_message_endpoint_out import ListResponseMessageEndpointOut
from openapi_client.models.message_attempt_out import MessageAttemptOut
from openapi_client.models.message_status import MessageStatus
from openapi_client.models.status_code_class import StatusCodeClass

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class MessageAttemptApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def expunge_attempt_content_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_content_delete(
        self,
        attempt_id: StrictStr,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete attempt response body

        Deletes the given attempt's response body. Useful when an endpoint accidentally returned sensitive content.

        :param attempt_id: (required)
        :type attempt_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._expunge_attempt_content_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_content_delete_serialize(
            attempt_id=attempt_id,
            msg_id=msg_id,
            app_id=app_id,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def expunge_attempt_content_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_content_delete_with_http_info(
        self,
        attempt_id: StrictStr,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete attempt response body

        Deletes the given attempt's response body. Useful when an endpoint accidentally returned sensitive content.

        :param attempt_id: (required)
        :type attempt_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._expunge_attempt_content_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_content_delete_serialize(
            attempt_id=attempt_id,
            msg_id=msg_id,
            app_id=app_id,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def expunge_attempt_content_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_content_delete_without_preload_content(
        self,
        attempt_id: StrictStr,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete attempt response body

        Deletes the given attempt's response body. Useful when an endpoint accidentally returned sensitive content.

        :param attempt_id: (required)
        :type attempt_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._expunge_attempt_content_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_content_delete_serialize(
            attempt_id=attempt_id,
            msg_id=msg_id,
            app_id=app_id,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _expunge_attempt_content_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_content_delete_serialize(
        self,
        attempt_id,
        msg_id,
        app_id,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if attempt_id is not None:
            _path_params['attempt_id'] = attempt_id
        if msg_id is not None:
            _path_params['msg_id'] = msg_id
        if app_id is not None:
            _path_params['app_id'] = app_id
        # process the query parameters
        # process the header parameters
        if idempotency_key is not None:
            _header_params['idempotency-key'] = idempotency_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'HTTPBearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}/content/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_attempt_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_get(
        self,
        attempt_id: StrictStr,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MessageAttemptOut:
        """Get Attempt

        `msg_id`: Use a message id or a message `eventId`

        :param attempt_id: (required)
        :type attempt_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_attempt_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_get_serialize(
            attempt_id=attempt_id,
            msg_id=msg_id,
            app_id=app_id,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_attempt_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_get_with_http_info(
        self,
        attempt_id: StrictStr,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MessageAttemptOut]:
        """Get Attempt

        `msg_id`: Use a message id or a message `eventId`

        :param attempt_id: (required)
        :type attempt_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_attempt_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_get_serialize(
            attempt_id=attempt_id,
            msg_id=msg_id,
            app_id=app_id,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_attempt_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_get_without_preload_content(
        self,
        attempt_id: StrictStr,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Attempt

        `msg_id`: Use a message id or a message `eventId`

        :param attempt_id: (required)
        :type attempt_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_attempt_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_get_serialize(
            attempt_id=attempt_id,
            msg_id=msg_id,
            app_id=app_id,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_attempt_api_v1_app_app_id_msg_msg_id_attempt_attempt_id_get_serialize(
        self,
        attempt_id,
        msg_id,
        app_id,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if attempt_id is not None:
            _path_params['attempt_id'] = attempt_id
        if msg_id is not None:
            _path_params['msg_id'] = msg_id
        if app_id is not None:
            _path_params['app_id'] = app_id
        # process the query parameters
        # process the header parameters
        if idempotency_key is not None:
            _header_params['idempotency-key'] = idempotency_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'HTTPBearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_attempted_destinations_api_v1_app_app_id_msg_msg_id_endpoint_get(
        self,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListResponseMessageEndpointOut:
        """List Attempted Destinations

        `msg_id`: Use a message id or a message `eventId`

        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempted_destinations_api_v1_app_app_id_msg_msg_id_endpoint_get_serialize(
            msg_id=msg_id,
            app_id=app_id,
            iterator=iterator,
            limit=limit,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageEndpointOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_attempted_destinations_api_v1_app_app_id_msg_msg_id_endpoint_get_with_http_info(
        self,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListResponseMessageEndpointOut]:
        """List Attempted Destinations

        `msg_id`: Use a message id or a message `eventId`

        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempted_destinations_api_v1_app_app_id_msg_msg_id_endpoint_get_serialize(
            msg_id=msg_id,
            app_id=app_id,
            iterator=iterator,
            limit=limit,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageEndpointOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_attempted_destinations_api_v1_app_app_id_msg_msg_id_endpoint_get_without_preload_content(
        self,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Attempted Destinations

        `msg_id`: Use a message id or a message `eventId`

        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempted_destinations_api_v1_app_app_id_msg_msg_id_endpoint_get_serialize(
            msg_id=msg_id,
            app_id=app_id,
            iterator=iterator,
            limit=limit,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageEndpointOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_attempted_destinations_api_v1_app_app_id_msg_msg_id_endpoint_get_serialize(
        self,
        msg_id,
        app_id,
        iterator,
        limit,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if msg_id is not None:
            _path_params['msg_id'] = msg_id
        if app_id is not None:
            _path_params['app_id'] = app_id
        # process the query parameters
        if iterator is not None:
            
            _query_params.append(('iterator', iterator))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        if idempotency_key is not None:
            _header_params['idempotency-key'] = idempotency_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'HTTPBearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/app/{app_id}/msg/{msg_id}/endpoint/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_attempted_messages_api_v1_app_app_id_endpoint_endpoint_id_msg_get(
        self,
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        status: Optional[MessageStatus] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListResponseEndpointMessageOut:
        """List Attempted Messages

        List messages for a particular endpoint. Additionally includes metadata about the latest message attempt.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.

        :param endpoint_id: (required)
        :type endpoint_id: str
        :param app_id: (required)
        :type app_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param channel:
        :type channel: str
        :param status:
        :type status: MessageStatus
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempted_messages_api_v1_app_app_id_endpoint_endpoint_id_msg_get_serialize(
            endpoint_id=endpoint_id,
            app_id=app_id,
            iterator=iterator,
            limit=limit,
            channel=channel,
            status=status,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseEndpointMessageOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_attempted_messages_api_v1_app_app_id_endpoint_endpoint_id_msg_get_with_http_info(
        self,
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        status: Optional[MessageStatus] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListResponseEndpointMessageOut]:
        """List Attempted Messages

        List messages for a particular endpoint. Additionally includes metadata about the latest message attempt.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.

        :param endpoint_id: (required)
        :type endpoint_id: str
        :param app_id: (required)
        :type app_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param channel:
        :type channel: str
        :param status:
        :type status: MessageStatus
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempted_messages_api_v1_app_app_id_endpoint_endpoint_id_msg_get_serialize(
            endpoint_id=endpoint_id,
            app_id=app_id,
            iterator=iterator,
            limit=limit,
            channel=channel,
            status=status,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseEndpointMessageOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_attempted_messages_api_v1_app_app_id_endpoint_endpoint_id_msg_get_without_preload_content(
        self,
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        status: Optional[MessageStatus] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Attempted Messages

        List messages for a particular endpoint. Additionally includes metadata about the latest message attempt.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.

        :param endpoint_id: (required)
        :type endpoint_id: str
        :param app_id: (required)
        :type app_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param channel:
        :type channel: str
        :param status:
        :type status: MessageStatus
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempted_messages_api_v1_app_app_id_endpoint_endpoint_id_msg_get_serialize(
            endpoint_id=endpoint_id,
            app_id=app_id,
            iterator=iterator,
            limit=limit,
            channel=channel,
            status=status,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseEndpointMessageOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_attempted_messages_api_v1_app_app_id_endpoint_endpoint_id_msg_get_serialize(
        self,
        endpoint_id,
        app_id,
        iterator,
        limit,
        channel,
        status,
        before,
        after,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if endpoint_id is not None:
            _path_params['endpoint_id'] = endpoint_id
        if app_id is not None:
            _path_params['app_id'] = app_id
        # process the query parameters
        if iterator is not None:
            
            _query_params.append(('iterator', iterator))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if channel is not None:
            
            _query_params.append(('channel', channel))
            
        if status is not None:
            
            _query_params.append(('status', status.value))
            
        if before is not None:
            if isinstance(before, datetime):
                _query_params.append(
                    (
                        'before',
                        before.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('before', before))
            
        if after is not None:
            if isinstance(after, datetime):
                _query_params.append(
                    (
                        'after',
                        after.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('after', after))
            
        # process the header parameters
        if idempotency_key is not None:
            _header_params['idempotency-key'] = idempotency_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'HTTPBearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/app/{app_id}/endpoint/{endpoint_id}/msg/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_attempts_api_v1_app_app_id_msg_msg_id_attempt_get(
        self,
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        endpoint_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=256)]] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        status: Optional[MessageStatus] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListResponseMessageAttemptOut:
        """(Deprecated) List Attempts

        Deprecated: Please use \"List Attempts by Endpoint\" and \"List Attempts by Msg\" instead.  `msg_id`: Use a message id or a message `eventId`

        :param app_id: (required)
        :type app_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param endpoint_id:
        :type endpoint_id: str
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param status:
        :type status: MessageStatus
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/app/{app_id}/msg/{msg_id}/attempt/ is deprecated.", DeprecationWarning)

        _param = self._list_attempts_api_v1_app_app_id_msg_msg_id_attempt_get_serialize(
            app_id=app_id,
            msg_id=msg_id,
            iterator=iterator,
            limit=limit,
            endpoint_id=endpoint_id,
            event_types=event_types,
            channel=channel,
            status=status,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_attempts_api_v1_app_app_id_msg_msg_id_attempt_get_with_http_info(
        self,
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        endpoint_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=256)]] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        status: Optional[MessageStatus] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListResponseMessageAttemptOut]:
        """(Deprecated) List Attempts

        Deprecated: Please use \"List Attempts by Endpoint\" and \"List Attempts by Msg\" instead.  `msg_id`: Use a message id or a message `eventId`

        :param app_id: (required)
        :type app_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param endpoint_id:
        :type endpoint_id: str
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param status:
        :type status: MessageStatus
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/app/{app_id}/msg/{msg_id}/attempt/ is deprecated.", DeprecationWarning)

        _param = self._list_attempts_api_v1_app_app_id_msg_msg_id_attempt_get_serialize(
            app_id=app_id,
            msg_id=msg_id,
            iterator=iterator,
            limit=limit,
            endpoint_id=endpoint_id,
            event_types=event_types,
            channel=channel,
            status=status,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_attempts_api_v1_app_app_id_msg_msg_id_attempt_get_without_preload_content(
        self,
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        endpoint_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=256)]] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        status: Optional[MessageStatus] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) List Attempts

        Deprecated: Please use \"List Attempts by Endpoint\" and \"List Attempts by Msg\" instead.  `msg_id`: Use a message id or a message `eventId`

        :param app_id: (required)
        :type app_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param endpoint_id:
        :type endpoint_id: str
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param status:
        :type status: MessageStatus
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/app/{app_id}/msg/{msg_id}/attempt/ is deprecated.", DeprecationWarning)

        _param = self._list_attempts_api_v1_app_app_id_msg_msg_id_attempt_get_serialize(
            app_id=app_id,
            msg_id=msg_id,
            iterator=iterator,
            limit=limit,
            endpoint_id=endpoint_id,
            event_types=event_types,
            channel=channel,
            status=status,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_attempts_api_v1_app_app_id_msg_msg_id_attempt_get_serialize(
        self,
        app_id,
        msg_id,
        iterator,
        limit,
        endpoint_id,
        event_types,
        channel,
        status,
        before,
        after,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'event_types': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params['app_id'] = app_id
        if msg_id is not None:
            _path_params['msg_id'] = msg_id
        # process the query parameters
        if iterator is not None:
            
            _query_params.append(('iterator', iterator))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if endpoint_id is not None:
            
            _query_params.append(('endpoint_id', endpoint_id))
            
        if event_types is not None:
            
            _query_params.append(('event_types', event_types))
            
        if channel is not None:
            
            _query_params.append(('channel', channel))
            
        if status is not None:
            
            _query_params.append(('status', status.value))
            
        if before is not None:
            if isinstance(before, datetime):
                _query_params.append(
                    (
                        'before',
                        before.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('before', before))
            
        if after is not None:
            if isinstance(after, datetime):
                _query_params.append(
                    (
                        'after',
                        after.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('after', after))
            
        # process the header parameters
        if idempotency_key is not None:
            _header_params['idempotency-key'] = idempotency_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'HTTPBearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/app/{app_id}/msg/{msg_id}/attempt/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_attempts_by_endpoint_api_v1_app_app_id_attempt_endpoint_endpoint_id_get(
        self,
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        status: Optional[MessageStatus] = None,
        status_code_class: Optional[StatusCodeClass] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListResponseMessageAttemptOut:
        """List Attempts By Endpoint

        List attempts by endpoint id

        :param app_id: (required)
        :type app_id: str
        :param endpoint_id: (required)
        :type endpoint_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param status:
        :type status: MessageStatus
        :param status_code_class:
        :type status_code_class: StatusCodeClass
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempts_by_endpoint_api_v1_app_app_id_attempt_endpoint_endpoint_id_get_serialize(
            app_id=app_id,
            endpoint_id=endpoint_id,
            iterator=iterator,
            limit=limit,
            status=status,
            status_code_class=status_code_class,
            event_types=event_types,
            channel=channel,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_attempts_by_endpoint_api_v1_app_app_id_attempt_endpoint_endpoint_id_get_with_http_info(
        self,
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        status: Optional[MessageStatus] = None,
        status_code_class: Optional[StatusCodeClass] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListResponseMessageAttemptOut]:
        """List Attempts By Endpoint

        List attempts by endpoint id

        :param app_id: (required)
        :type app_id: str
        :param endpoint_id: (required)
        :type endpoint_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param status:
        :type status: MessageStatus
        :param status_code_class:
        :type status_code_class: StatusCodeClass
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempts_by_endpoint_api_v1_app_app_id_attempt_endpoint_endpoint_id_get_serialize(
            app_id=app_id,
            endpoint_id=endpoint_id,
            iterator=iterator,
            limit=limit,
            status=status,
            status_code_class=status_code_class,
            event_types=event_types,
            channel=channel,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_attempts_by_endpoint_api_v1_app_app_id_attempt_endpoint_endpoint_id_get_without_preload_content(
        self,
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        status: Optional[MessageStatus] = None,
        status_code_class: Optional[StatusCodeClass] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Attempts By Endpoint

        List attempts by endpoint id

        :param app_id: (required)
        :type app_id: str
        :param endpoint_id: (required)
        :type endpoint_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param status:
        :type status: MessageStatus
        :param status_code_class:
        :type status_code_class: StatusCodeClass
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempts_by_endpoint_api_v1_app_app_id_attempt_endpoint_endpoint_id_get_serialize(
            app_id=app_id,
            endpoint_id=endpoint_id,
            iterator=iterator,
            limit=limit,
            status=status,
            status_code_class=status_code_class,
            event_types=event_types,
            channel=channel,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_attempts_by_endpoint_api_v1_app_app_id_attempt_endpoint_endpoint_id_get_serialize(
        self,
        app_id,
        endpoint_id,
        iterator,
        limit,
        status,
        status_code_class,
        event_types,
        channel,
        before,
        after,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'event_types': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params['app_id'] = app_id
        if endpoint_id is not None:
            _path_params['endpoint_id'] = endpoint_id
        # process the query parameters
        if iterator is not None:
            
            _query_params.append(('iterator', iterator))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if status is not None:
            
            _query_params.append(('status', status.value))
            
        if status_code_class is not None:
            
            _query_params.append(('status_code_class', status_code_class.value))
            
        if event_types is not None:
            
            _query_params.append(('event_types', event_types))
            
        if channel is not None:
            
            _query_params.append(('channel', channel))
            
        if before is not None:
            if isinstance(before, datetime):
                _query_params.append(
                    (
                        'before',
                        before.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('before', before))
            
        if after is not None:
            if isinstance(after, datetime):
                _query_params.append(
                    (
                        'after',
                        after.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('after', after))
            
        # process the header parameters
        if idempotency_key is not None:
            _header_params['idempotency-key'] = idempotency_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'HTTPBearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/app/{app_id}/attempt/endpoint/{endpoint_id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_attempts_by_msg_api_v1_app_app_id_attempt_msg_msg_id_get(
        self,
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        endpoint_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=256)]] = None,
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        status: Optional[MessageStatus] = None,
        status_code_class: Optional[StatusCodeClass] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListResponseMessageAttemptOut:
        """List Attempts By Msg

        List attempts by message id

        :param app_id: (required)
        :type app_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param endpoint_id:
        :type endpoint_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param status:
        :type status: MessageStatus
        :param status_code_class:
        :type status_code_class: StatusCodeClass
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempts_by_msg_api_v1_app_app_id_attempt_msg_msg_id_get_serialize(
            app_id=app_id,
            msg_id=msg_id,
            endpoint_id=endpoint_id,
            iterator=iterator,
            limit=limit,
            status=status,
            status_code_class=status_code_class,
            event_types=event_types,
            channel=channel,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_attempts_by_msg_api_v1_app_app_id_attempt_msg_msg_id_get_with_http_info(
        self,
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        endpoint_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=256)]] = None,
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        status: Optional[MessageStatus] = None,
        status_code_class: Optional[StatusCodeClass] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListResponseMessageAttemptOut]:
        """List Attempts By Msg

        List attempts by message id

        :param app_id: (required)
        :type app_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param endpoint_id:
        :type endpoint_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param status:
        :type status: MessageStatus
        :param status_code_class:
        :type status_code_class: StatusCodeClass
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempts_by_msg_api_v1_app_app_id_attempt_msg_msg_id_get_serialize(
            app_id=app_id,
            msg_id=msg_id,
            endpoint_id=endpoint_id,
            iterator=iterator,
            limit=limit,
            status=status,
            status_code_class=status_code_class,
            event_types=event_types,
            channel=channel,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_attempts_by_msg_api_v1_app_app_id_attempt_msg_msg_id_get_without_preload_content(
        self,
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        endpoint_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=256)]] = None,
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        status: Optional[MessageStatus] = None,
        status_code_class: Optional[StatusCodeClass] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Attempts By Msg

        List attempts by message id

        :param app_id: (required)
        :type app_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param endpoint_id:
        :type endpoint_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param status:
        :type status: MessageStatus
        :param status_code_class:
        :type status_code_class: StatusCodeClass
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_attempts_by_msg_api_v1_app_app_id_attempt_msg_msg_id_get_serialize(
            app_id=app_id,
            msg_id=msg_id,
            endpoint_id=endpoint_id,
            iterator=iterator,
            limit=limit,
            status=status,
            status_code_class=status_code_class,
            event_types=event_types,
            channel=channel,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_attempts_by_msg_api_v1_app_app_id_attempt_msg_msg_id_get_serialize(
        self,
        app_id,
        msg_id,
        endpoint_id,
        iterator,
        limit,
        status,
        status_code_class,
        event_types,
        channel,
        before,
        after,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'event_types': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params['app_id'] = app_id
        if msg_id is not None:
            _path_params['msg_id'] = msg_id
        # process the query parameters
        if endpoint_id is not None:
            
            _query_params.append(('endpoint_id', endpoint_id))
            
        if iterator is not None:
            
            _query_params.append(('iterator', iterator))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if status is not None:
            
            _query_params.append(('status', status.value))
            
        if status_code_class is not None:
            
            _query_params.append(('status_code_class', status_code_class.value))
            
        if event_types is not None:
            
            _query_params.append(('event_types', event_types))
            
        if channel is not None:
            
            _query_params.append(('channel', channel))
            
        if before is not None:
            if isinstance(before, datetime):
                _query_params.append(
                    (
                        'before',
                        before.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('before', before))
            
        if after is not None:
            if isinstance(after, datetime):
                _query_params.append(
                    (
                        'after',
                        after.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('after', after))
            
        # process the header parameters
        if idempotency_key is not None:
            _header_params['idempotency-key'] = idempotency_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'HTTPBearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/app/{app_id}/attempt/msg/{msg_id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_attempts_for_endpoint_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_attempt_get(
        self,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        status: Optional[MessageStatus] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListResponseMessageAttemptEndpointOut:
        """(Deprecated) List Attempts For Endpoint

        DEPRECATED: please use list_attempts with endpoint_id as a query parameter instead.  List the message attempts for a particular endpoint.  Returning the endpoint.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.

        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param endpoint_id: (required)
        :type endpoint_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param status:
        :type status: MessageStatus
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/attempt/ is deprecated.", DeprecationWarning)

        _param = self._list_attempts_for_endpoint_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_attempt_get_serialize(
            msg_id=msg_id,
            app_id=app_id,
            endpoint_id=endpoint_id,
            iterator=iterator,
            limit=limit,
            event_types=event_types,
            channel=channel,
            status=status,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptEndpointOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_attempts_for_endpoint_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_attempt_get_with_http_info(
        self,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        status: Optional[MessageStatus] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListResponseMessageAttemptEndpointOut]:
        """(Deprecated) List Attempts For Endpoint

        DEPRECATED: please use list_attempts with endpoint_id as a query parameter instead.  List the message attempts for a particular endpoint.  Returning the endpoint.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.

        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param endpoint_id: (required)
        :type endpoint_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param status:
        :type status: MessageStatus
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/attempt/ is deprecated.", DeprecationWarning)

        _param = self._list_attempts_for_endpoint_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_attempt_get_serialize(
            msg_id=msg_id,
            app_id=app_id,
            endpoint_id=endpoint_id,
            iterator=iterator,
            limit=limit,
            event_types=event_types,
            channel=channel,
            status=status,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptEndpointOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_attempts_for_endpoint_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_attempt_get_without_preload_content(
        self,
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        iterator: Optional[StrictStr] = None,
        limit: Optional[Annotated[int, Field(le=250, strict=True)]] = None,
        event_types: Optional[List[Annotated[str, Field(strict=True, max_length=256)]]] = None,
        channel: Optional[Annotated[str, Field(strict=True, max_length=128)]] = None,
        status: Optional[MessageStatus] = None,
        before: Optional[datetime] = None,
        after: Optional[datetime] = None,
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) List Attempts For Endpoint

        DEPRECATED: please use list_attempts with endpoint_id as a query parameter instead.  List the message attempts for a particular endpoint.  Returning the endpoint.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.

        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param endpoint_id: (required)
        :type endpoint_id: str
        :param iterator:
        :type iterator: str
        :param limit:
        :type limit: int
        :param event_types:
        :type event_types: List[str]
        :param channel:
        :type channel: str
        :param status:
        :type status: MessageStatus
        :param before:
        :type before: datetime
        :param after:
        :type after: datetime
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/attempt/ is deprecated.", DeprecationWarning)

        _param = self._list_attempts_for_endpoint_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_attempt_get_serialize(
            msg_id=msg_id,
            app_id=app_id,
            endpoint_id=endpoint_id,
            iterator=iterator,
            limit=limit,
            event_types=event_types,
            channel=channel,
            status=status,
            before=before,
            after=after,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListResponseMessageAttemptEndpointOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_attempts_for_endpoint_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_attempt_get_serialize(
        self,
        msg_id,
        app_id,
        endpoint_id,
        iterator,
        limit,
        event_types,
        channel,
        status,
        before,
        after,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'event_types': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if msg_id is not None:
            _path_params['msg_id'] = msg_id
        if app_id is not None:
            _path_params['app_id'] = app_id
        if endpoint_id is not None:
            _path_params['endpoint_id'] = endpoint_id
        # process the query parameters
        if iterator is not None:
            
            _query_params.append(('iterator', iterator))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if event_types is not None:
            
            _query_params.append(('event_types', event_types))
            
        if channel is not None:
            
            _query_params.append(('channel', channel))
            
        if status is not None:
            
            _query_params.append(('status', status.value))
            
        if before is not None:
            if isinstance(before, datetime):
                _query_params.append(
                    (
                        'before',
                        before.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('before', before))
            
        if after is not None:
            if isinstance(after, datetime):
                _query_params.append(
                    (
                        'after',
                        after.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('after', after))
            
        # process the header parameters
        if idempotency_key is not None:
            _header_params['idempotency-key'] = idempotency_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'HTTPBearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/attempt/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resend_webhook_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_resend_post(
        self,
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Resend Webhook

        Resend a message to the specified endpoint.

        :param endpoint_id: (required)
        :type endpoint_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resend_webhook_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_resend_post_serialize(
            endpoint_id=endpoint_id,
            msg_id=msg_id,
            app_id=app_id,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
            '400': "HttpErrorOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resend_webhook_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_resend_post_with_http_info(
        self,
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Resend Webhook

        Resend a message to the specified endpoint.

        :param endpoint_id: (required)
        :type endpoint_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resend_webhook_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_resend_post_serialize(
            endpoint_id=endpoint_id,
            msg_id=msg_id,
            app_id=app_id,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
            '400': "HttpErrorOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resend_webhook_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_resend_post_without_preload_content(
        self,
        endpoint_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        msg_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        app_id: Annotated[str, Field(min_length=1, strict=True, max_length=256)],
        idempotency_key: Annotated[Optional[StrictStr], Field(description="The request's idempotency key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Resend Webhook

        Resend a message to the specified endpoint.

        :param endpoint_id: (required)
        :type endpoint_id: str
        :param msg_id: (required)
        :type msg_id: str
        :param app_id: (required)
        :type app_id: str
        :param idempotency_key: The request's idempotency key
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resend_webhook_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_resend_post_serialize(
            endpoint_id=endpoint_id,
            msg_id=msg_id,
            app_id=app_id,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
            '400': "HttpErrorOut",
            '401': "HttpErrorOut",
            '403': "HttpErrorOut",
            '404': "HttpErrorOut",
            '409': "HttpErrorOut",
            '422': "HTTPValidationError",
            '429': "HttpErrorOut",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resend_webhook_api_v1_app_app_id_msg_msg_id_endpoint_endpoint_id_resend_post_serialize(
        self,
        endpoint_id,
        msg_id,
        app_id,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if endpoint_id is not None:
            _path_params['endpoint_id'] = endpoint_id
        if msg_id is not None:
            _path_params['msg_id'] = msg_id
        if app_id is not None:
            _path_params['app_id'] = app_id
        # process the query parameters
        # process the header parameters
        if idempotency_key is not None:
            _header_params['idempotency-key'] = idempotency_key
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'HTTPBearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/resend/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


