# coding: utf-8

"""
    DaniWeb Connect API

    User Recommendation Engine and Chat Network

    The version of the OpenAPI document: 4
    Contact: dani@daniwebmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.endpoint_get_users import EndpointGetUsers
from openapi_client.models.endpoint_get_users_id import EndpointGetUsersID
from openapi_client.models.endpoint_get_users_id_groups import EndpointGetUsersIDGroups
from openapi_client.models.endpoint_get_users_id_groups_messages import EndpointGetUsersIDGroupsMessages
from openapi_client.models.endpoint_get_users_id_metadata import EndpointGetUsersIDMetadata
from openapi_client.models.endpoint_get_users_id_metadata_collections import EndpointGetUsersIDMetadataCollections
from openapi_client.models.endpoint_get_users_id_positions import EndpointGetUsersIDPositions
from openapi_client.models.endpoint_get_users_id_synergies import EndpointGetUsersIDSynergies
from openapi_client.models.endpoint_get_users_nearby import EndpointGetUsersNearby
from openapi_client.models.endpoint_patch_users import EndpointPatchUsers
from openapi_client.models.endpoint_patch_users_id_synergies import EndpointPatchUsersIDSynergies
from openapi_client.models.endpoint_post_users_id_messages import EndpointPostUsersIDMessages
from openapi_client.models.endpoint_post_users_id_metadata import EndpointPostUsersIDMetadata
from openapi_client.models.endpoint_post_users_invites import EndpointPostUsersInvites
from openapi_client.models.endpoint_post_users_metadata_filters import EndpointPostUsersMetadataFilters
from openapi_client.models.endpoint_post_users_searches import EndpointPostUsersSearches

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class UsersApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def users_get(
        self,
        filter: Optional[StrictStr] = None,
        order_by: Optional[StrictStr] = None,
        bubbled: Optional[StrictBool] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointGetUsers:
        """users_get

        Fetch an array of users that you've been matched with, connected with, skipped, or muted. You can only retrieve users existing within the current access token's bubble. This report may be limited to the last ~500-1000 users you've communicated with within the access token's bubble. Matches are always ordered by synergy, and the order_by parameter is ignored. You can only retrieve bubbled users when retrieving matches, and the bubbled parameter is ignored otherwise. Your 100 best algorithmic matches are based on: Complementary data submitted to Profiles, CVs, and Metadata; Complementary data acquired from third-parties; Location information; Many behavioral data points, such as how responsive users are to connections; Degrees of separation (mutual connections); etc. You may connect with 3 of these algorithmic matches per day for free. However, new members are allowed a grace period of additional daily matches. Each time you choose to meet or mute one of your algorithmic matches, a new match is introduced.

        :param filter:
        :type filter: str
        :param order_by:
        :type order_by: str
        :param bubbled:
        :type bubbled: bool
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_get_serialize(
            filter=filter,
            order_by=order_by,
            bubbled=bubbled,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_get_with_http_info(
        self,
        filter: Optional[StrictStr] = None,
        order_by: Optional[StrictStr] = None,
        bubbled: Optional[StrictBool] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointGetUsers]:
        """users_get

        Fetch an array of users that you've been matched with, connected with, skipped, or muted. You can only retrieve users existing within the current access token's bubble. This report may be limited to the last ~500-1000 users you've communicated with within the access token's bubble. Matches are always ordered by synergy, and the order_by parameter is ignored. You can only retrieve bubbled users when retrieving matches, and the bubbled parameter is ignored otherwise. Your 100 best algorithmic matches are based on: Complementary data submitted to Profiles, CVs, and Metadata; Complementary data acquired from third-parties; Location information; Many behavioral data points, such as how responsive users are to connections; Degrees of separation (mutual connections); etc. You may connect with 3 of these algorithmic matches per day for free. However, new members are allowed a grace period of additional daily matches. Each time you choose to meet or mute one of your algorithmic matches, a new match is introduced.

        :param filter:
        :type filter: str
        :param order_by:
        :type order_by: str
        :param bubbled:
        :type bubbled: bool
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_get_serialize(
            filter=filter,
            order_by=order_by,
            bubbled=bubbled,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_get_without_preload_content(
        self,
        filter: Optional[StrictStr] = None,
        order_by: Optional[StrictStr] = None,
        bubbled: Optional[StrictBool] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_get

        Fetch an array of users that you've been matched with, connected with, skipped, or muted. You can only retrieve users existing within the current access token's bubble. This report may be limited to the last ~500-1000 users you've communicated with within the access token's bubble. Matches are always ordered by synergy, and the order_by parameter is ignored. You can only retrieve bubbled users when retrieving matches, and the bubbled parameter is ignored otherwise. Your 100 best algorithmic matches are based on: Complementary data submitted to Profiles, CVs, and Metadata; Complementary data acquired from third-parties; Location information; Many behavioral data points, such as how responsive users are to connections; Degrees of separation (mutual connections); etc. You may connect with 3 of these algorithmic matches per day for free. However, new members are allowed a grace period of additional daily matches. Each time you choose to meet or mute one of your algorithmic matches, a new match is introduced.

        :param filter:
        :type filter: str
        :param order_by:
        :type order_by: str
        :param bubbled:
        :type bubbled: bool
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_get_serialize(
            filter=filter,
            order_by=order_by,
            bubbled=bubbled,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_get_serialize(
        self,
        filter,
        order_by,
        bubbled,
        offset,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if bubbled is not None:
            
            _query_params.append(('bubbled', bubbled))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_get_0(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointGetUsers:
        """users_get_0

        Retrieve the currently OAuth'ed end-user, based on the access token being used, including private information and settings such as their email address.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_get_0_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_get_0_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointGetUsers]:
        """users_get_0

        Retrieve the currently OAuth'ed end-user, based on the access token being used, including private information and settings such as their email address.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_get_0_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_get_0_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_get_0

        Retrieve the currently OAuth'ed end-user, based on the access token being used, including private information and settings such as their email address.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_get_0_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_get_0_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/users/~',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_get(
        self,
        id: Annotated[List[Annotated[int, Field(strict=True, ge=1)]], Field(max_length=100)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointGetUsersID:
        """users_id_get

        Fetch an array of users. You can only retrieve users existing within the current access token's bubble.

        :param id: (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersID",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_get_with_http_info(
        self,
        id: Annotated[List[Annotated[int, Field(strict=True, ge=1)]], Field(max_length=100)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointGetUsersID]:
        """users_id_get

        Fetch an array of users. You can only retrieve users existing within the current access token's bubble.

        :param id: (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersID",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_get_without_preload_content(
        self,
        id: Annotated[List[Annotated[int, Field(strict=True, ge=1)]], Field(max_length=100)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_id_get

        Fetch an array of users. You can only retrieve users existing within the current access token's bubble.

        :param id: (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersID",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ID': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['ID'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/users/{ID}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_groups_get(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointGetUsersIDGroups:
        """users_id_groups_get

        You can only retrieve groups that were created by users existing within the current access token's bubble.

        :param id: (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_groups_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDGroups",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_groups_get_with_http_info(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointGetUsersIDGroups]:
        """users_id_groups_get

        You can only retrieve groups that were created by users existing within the current access token's bubble.

        :param id: (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_groups_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDGroups",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_groups_get_without_preload_content(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_id_groups_get

        You can only retrieve groups that were created by users existing within the current access token's bubble.

        :param id: (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_groups_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDGroups",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_groups_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['ID'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/users/{ID}/groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_groups_messages_get(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointGetUsersIDGroupsMessages:
        """users_id_groups_messages_get

        Paginated transcript of group messages authored by an individual user who exists within the current access token's bubble. Messages are sorted oldest to newest.

        :param id: (required)
        :type id: int
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_groups_messages_get_serialize(
            id=id,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDGroupsMessages",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_groups_messages_get_with_http_info(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointGetUsersIDGroupsMessages]:
        """users_id_groups_messages_get

        Paginated transcript of group messages authored by an individual user who exists within the current access token's bubble. Messages are sorted oldest to newest.

        :param id: (required)
        :type id: int
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_groups_messages_get_serialize(
            id=id,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDGroupsMessages",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_groups_messages_get_without_preload_content(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_id_groups_messages_get

        Paginated transcript of group messages authored by an individual user who exists within the current access token's bubble. Messages are sorted oldest to newest.

        :param id: (required)
        :type id: int
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_groups_messages_get_serialize(
            id=id,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDGroupsMessages",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_groups_messages_get_serialize(
        self,
        id,
        offset,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['ID'] = id
        # process the query parameters
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/users/{ID}/groups/messages',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_messages_post(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        bubbled: Optional[StrictBool] = None,
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_privacy: Optional[StrictStr] = None,
        metadata_0_values: Optional[List[StrictStr]] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_privacy: Optional[StrictStr] = None,
        metadata_1_values: Optional[List[StrictStr]] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_privacy: Optional[StrictStr] = None,
        metadata_2_values: Optional[List[StrictStr]] = None,
        text_emoticons: Optional[StrictBool] = None,
        text_raw: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointPostUsersIDMessages:
        """users_id_messages_post

        Initiate a conversation with a user who exists within the current access token's bubble by sending them an introductory message. If you aren't already in a conversation with them, this endpoint meets them first, and then sends the message. Note that if you aren't in an existing conversation, you still must meet the criteria to meet them, meaning the user must currently be free for you to meet. You will receive an error message unless it is currently free for you to meet the user. You can use the users/{:IDS}/synergies endpoint to first determine if the user isn't already in a conversation with you and is free for you to meet and, if they aren't, how to pay to meet them. If you don't specify a message, it defaults to your custom introductory message defined in your settings.

        :param id: (required)
        :type id: int
        :param bubbled:
        :type bubbled: bool
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_privacy:
        :type metadata_0_privacy: str
        :param metadata_0_values:
        :type metadata_0_values: List[str]
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_privacy:
        :type metadata_1_privacy: str
        :param metadata_1_values:
        :type metadata_1_values: List[str]
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_privacy:
        :type metadata_2_privacy: str
        :param metadata_2_values:
        :type metadata_2_values: List[str]
        :param text_emoticons:
        :type text_emoticons: bool
        :param text_raw:
        :type text_raw: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_messages_post_serialize(
            id=id,
            bubbled=bubbled,
            metadata_0_key=metadata_0_key,
            metadata_0_privacy=metadata_0_privacy,
            metadata_0_values=metadata_0_values,
            metadata_1_key=metadata_1_key,
            metadata_1_privacy=metadata_1_privacy,
            metadata_1_values=metadata_1_values,
            metadata_2_key=metadata_2_key,
            metadata_2_privacy=metadata_2_privacy,
            metadata_2_values=metadata_2_values,
            text_emoticons=text_emoticons,
            text_raw=text_raw,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersIDMessages",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_messages_post_with_http_info(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        bubbled: Optional[StrictBool] = None,
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_privacy: Optional[StrictStr] = None,
        metadata_0_values: Optional[List[StrictStr]] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_privacy: Optional[StrictStr] = None,
        metadata_1_values: Optional[List[StrictStr]] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_privacy: Optional[StrictStr] = None,
        metadata_2_values: Optional[List[StrictStr]] = None,
        text_emoticons: Optional[StrictBool] = None,
        text_raw: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointPostUsersIDMessages]:
        """users_id_messages_post

        Initiate a conversation with a user who exists within the current access token's bubble by sending them an introductory message. If you aren't already in a conversation with them, this endpoint meets them first, and then sends the message. Note that if you aren't in an existing conversation, you still must meet the criteria to meet them, meaning the user must currently be free for you to meet. You will receive an error message unless it is currently free for you to meet the user. You can use the users/{:IDS}/synergies endpoint to first determine if the user isn't already in a conversation with you and is free for you to meet and, if they aren't, how to pay to meet them. If you don't specify a message, it defaults to your custom introductory message defined in your settings.

        :param id: (required)
        :type id: int
        :param bubbled:
        :type bubbled: bool
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_privacy:
        :type metadata_0_privacy: str
        :param metadata_0_values:
        :type metadata_0_values: List[str]
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_privacy:
        :type metadata_1_privacy: str
        :param metadata_1_values:
        :type metadata_1_values: List[str]
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_privacy:
        :type metadata_2_privacy: str
        :param metadata_2_values:
        :type metadata_2_values: List[str]
        :param text_emoticons:
        :type text_emoticons: bool
        :param text_raw:
        :type text_raw: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_messages_post_serialize(
            id=id,
            bubbled=bubbled,
            metadata_0_key=metadata_0_key,
            metadata_0_privacy=metadata_0_privacy,
            metadata_0_values=metadata_0_values,
            metadata_1_key=metadata_1_key,
            metadata_1_privacy=metadata_1_privacy,
            metadata_1_values=metadata_1_values,
            metadata_2_key=metadata_2_key,
            metadata_2_privacy=metadata_2_privacy,
            metadata_2_values=metadata_2_values,
            text_emoticons=text_emoticons,
            text_raw=text_raw,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersIDMessages",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_messages_post_without_preload_content(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        bubbled: Optional[StrictBool] = None,
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_privacy: Optional[StrictStr] = None,
        metadata_0_values: Optional[List[StrictStr]] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_privacy: Optional[StrictStr] = None,
        metadata_1_values: Optional[List[StrictStr]] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_privacy: Optional[StrictStr] = None,
        metadata_2_values: Optional[List[StrictStr]] = None,
        text_emoticons: Optional[StrictBool] = None,
        text_raw: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_id_messages_post

        Initiate a conversation with a user who exists within the current access token's bubble by sending them an introductory message. If you aren't already in a conversation with them, this endpoint meets them first, and then sends the message. Note that if you aren't in an existing conversation, you still must meet the criteria to meet them, meaning the user must currently be free for you to meet. You will receive an error message unless it is currently free for you to meet the user. You can use the users/{:IDS}/synergies endpoint to first determine if the user isn't already in a conversation with you and is free for you to meet and, if they aren't, how to pay to meet them. If you don't specify a message, it defaults to your custom introductory message defined in your settings.

        :param id: (required)
        :type id: int
        :param bubbled:
        :type bubbled: bool
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_privacy:
        :type metadata_0_privacy: str
        :param metadata_0_values:
        :type metadata_0_values: List[str]
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_privacy:
        :type metadata_1_privacy: str
        :param metadata_1_values:
        :type metadata_1_values: List[str]
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_privacy:
        :type metadata_2_privacy: str
        :param metadata_2_values:
        :type metadata_2_values: List[str]
        :param text_emoticons:
        :type text_emoticons: bool
        :param text_raw:
        :type text_raw: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_messages_post_serialize(
            id=id,
            bubbled=bubbled,
            metadata_0_key=metadata_0_key,
            metadata_0_privacy=metadata_0_privacy,
            metadata_0_values=metadata_0_values,
            metadata_1_key=metadata_1_key,
            metadata_1_privacy=metadata_1_privacy,
            metadata_1_values=metadata_1_values,
            metadata_2_key=metadata_2_key,
            metadata_2_privacy=metadata_2_privacy,
            metadata_2_values=metadata_2_values,
            text_emoticons=text_emoticons,
            text_raw=text_raw,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersIDMessages",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_messages_post_serialize(
        self,
        id,
        bubbled,
        metadata_0_key,
        metadata_0_privacy,
        metadata_0_values,
        metadata_1_key,
        metadata_1_privacy,
        metadata_1_values,
        metadata_2_key,
        metadata_2_privacy,
        metadata_2_values,
        text_emoticons,
        text_raw,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'metadata_0_values[]': 'csv',
            'metadata_1_values[]': 'csv',
            'metadata_2_values[]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['ID'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if bubbled is not None:
            _form_params.append(('bubbled', bubbled))
        if metadata_0_key is not None:
            _form_params.append(('metadata_0_key', metadata_0_key))
        if metadata_0_privacy is not None:
            _form_params.append(('metadata_0_privacy', metadata_0_privacy))
        if metadata_0_values is not None:
            _form_params.append(('metadata_0_values[]', metadata_0_values))
        if metadata_1_key is not None:
            _form_params.append(('metadata_1_key', metadata_1_key))
        if metadata_1_privacy is not None:
            _form_params.append(('metadata_1_privacy', metadata_1_privacy))
        if metadata_1_values is not None:
            _form_params.append(('metadata_1_values[]', metadata_1_values))
        if metadata_2_key is not None:
            _form_params.append(('metadata_2_key', metadata_2_key))
        if metadata_2_privacy is not None:
            _form_params.append(('metadata_2_privacy', metadata_2_privacy))
        if metadata_2_values is not None:
            _form_params.append(('metadata_2_values[]', metadata_2_values))
        if text_emoticons is not None:
            _form_params.append(('text_emoticons', text_emoticons))
        if text_raw is not None:
            _form_params.append(('text_raw', text_raw))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/users/{ID}/messages',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_metadata_collections_get(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointGetUsersIDMetadataCollections:
        """users_id_metadata_collections_get

        Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token's bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token's bubble based on preknown metadata key/value pairs. Metadata will be grouped by key.

        :param id: (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_metadata_collections_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDMetadataCollections",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_metadata_collections_get_with_http_info(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointGetUsersIDMetadataCollections]:
        """users_id_metadata_collections_get

        Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token's bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token's bubble based on preknown metadata key/value pairs. Metadata will be grouped by key.

        :param id: (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_metadata_collections_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDMetadataCollections",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_metadata_collections_get_without_preload_content(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_id_metadata_collections_get

        Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token's bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token's bubble based on preknown metadata key/value pairs. Metadata will be grouped by key.

        :param id: (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_metadata_collections_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDMetadataCollections",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_metadata_collections_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['ID'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/users/{ID}/metadata/collections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_metadata_get(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointGetUsersIDMetadata:
        """users_id_metadata_get

        Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token's bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token's bubble based on preknown metadata key/value pairs.

        :param id: (required)
        :type id: int
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_metadata_get_serialize(
            id=id,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDMetadata",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_metadata_get_with_http_info(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointGetUsersIDMetadata]:
        """users_id_metadata_get

        Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token's bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token's bubble based on preknown metadata key/value pairs.

        :param id: (required)
        :type id: int
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_metadata_get_serialize(
            id=id,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDMetadata",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_metadata_get_without_preload_content(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_id_metadata_get

        Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token's bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token's bubble based on preknown metadata key/value pairs.

        :param id: (required)
        :type id: int
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_metadata_get_serialize(
            id=id,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDMetadata",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_metadata_get_serialize(
        self,
        id,
        offset,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['ID'] = id
        # process the query parameters
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/users/{ID}/metadata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_metadata_post(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_privacy: Optional[StrictStr] = None,
        metadata_0_values: Optional[List[StrictStr]] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_privacy: Optional[StrictStr] = None,
        metadata_1_values: Optional[List[StrictStr]] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_privacy: Optional[StrictStr] = None,
        metadata_2_values: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointPostUsersIDMetadata:
        """users_id_metadata_post

        Attach one-to-many key/value pairs of metadata to a user, so long as the user exists within the current access token's bubble. You can set one key at a time, with one or many values. A key is unique for each author/bubble combination. Attaching metadata with an existing key that was previously created by you, from within the same bubble, overwrites the key with the new value or set of values. The privacy setting allows you to specify who will have access to the metadata: Public metadata by anyone using an access token which grants them access to the user; Bubbled metadata by anyone using an access token existing within the current bubble; User metadata by you, so long as you are using an access token which grants you access to the user; Private metadata by you, so long as you are using an access token existing within the current bubble.

        :param id: (required)
        :type id: int
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_privacy:
        :type metadata_0_privacy: str
        :param metadata_0_values:
        :type metadata_0_values: List[str]
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_privacy:
        :type metadata_1_privacy: str
        :param metadata_1_values:
        :type metadata_1_values: List[str]
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_privacy:
        :type metadata_2_privacy: str
        :param metadata_2_values:
        :type metadata_2_values: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_metadata_post_serialize(
            id=id,
            metadata_0_key=metadata_0_key,
            metadata_0_privacy=metadata_0_privacy,
            metadata_0_values=metadata_0_values,
            metadata_1_key=metadata_1_key,
            metadata_1_privacy=metadata_1_privacy,
            metadata_1_values=metadata_1_values,
            metadata_2_key=metadata_2_key,
            metadata_2_privacy=metadata_2_privacy,
            metadata_2_values=metadata_2_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersIDMetadata",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_metadata_post_with_http_info(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_privacy: Optional[StrictStr] = None,
        metadata_0_values: Optional[List[StrictStr]] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_privacy: Optional[StrictStr] = None,
        metadata_1_values: Optional[List[StrictStr]] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_privacy: Optional[StrictStr] = None,
        metadata_2_values: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointPostUsersIDMetadata]:
        """users_id_metadata_post

        Attach one-to-many key/value pairs of metadata to a user, so long as the user exists within the current access token's bubble. You can set one key at a time, with one or many values. A key is unique for each author/bubble combination. Attaching metadata with an existing key that was previously created by you, from within the same bubble, overwrites the key with the new value or set of values. The privacy setting allows you to specify who will have access to the metadata: Public metadata by anyone using an access token which grants them access to the user; Bubbled metadata by anyone using an access token existing within the current bubble; User metadata by you, so long as you are using an access token which grants you access to the user; Private metadata by you, so long as you are using an access token existing within the current bubble.

        :param id: (required)
        :type id: int
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_privacy:
        :type metadata_0_privacy: str
        :param metadata_0_values:
        :type metadata_0_values: List[str]
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_privacy:
        :type metadata_1_privacy: str
        :param metadata_1_values:
        :type metadata_1_values: List[str]
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_privacy:
        :type metadata_2_privacy: str
        :param metadata_2_values:
        :type metadata_2_values: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_metadata_post_serialize(
            id=id,
            metadata_0_key=metadata_0_key,
            metadata_0_privacy=metadata_0_privacy,
            metadata_0_values=metadata_0_values,
            metadata_1_key=metadata_1_key,
            metadata_1_privacy=metadata_1_privacy,
            metadata_1_values=metadata_1_values,
            metadata_2_key=metadata_2_key,
            metadata_2_privacy=metadata_2_privacy,
            metadata_2_values=metadata_2_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersIDMetadata",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_metadata_post_without_preload_content(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_privacy: Optional[StrictStr] = None,
        metadata_0_values: Optional[List[StrictStr]] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_privacy: Optional[StrictStr] = None,
        metadata_1_values: Optional[List[StrictStr]] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_privacy: Optional[StrictStr] = None,
        metadata_2_values: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_id_metadata_post

        Attach one-to-many key/value pairs of metadata to a user, so long as the user exists within the current access token's bubble. You can set one key at a time, with one or many values. A key is unique for each author/bubble combination. Attaching metadata with an existing key that was previously created by you, from within the same bubble, overwrites the key with the new value or set of values. The privacy setting allows you to specify who will have access to the metadata: Public metadata by anyone using an access token which grants them access to the user; Bubbled metadata by anyone using an access token existing within the current bubble; User metadata by you, so long as you are using an access token which grants you access to the user; Private metadata by you, so long as you are using an access token existing within the current bubble.

        :param id: (required)
        :type id: int
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_privacy:
        :type metadata_0_privacy: str
        :param metadata_0_values:
        :type metadata_0_values: List[str]
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_privacy:
        :type metadata_1_privacy: str
        :param metadata_1_values:
        :type metadata_1_values: List[str]
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_privacy:
        :type metadata_2_privacy: str
        :param metadata_2_values:
        :type metadata_2_values: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_metadata_post_serialize(
            id=id,
            metadata_0_key=metadata_0_key,
            metadata_0_privacy=metadata_0_privacy,
            metadata_0_values=metadata_0_values,
            metadata_1_key=metadata_1_key,
            metadata_1_privacy=metadata_1_privacy,
            metadata_1_values=metadata_1_values,
            metadata_2_key=metadata_2_key,
            metadata_2_privacy=metadata_2_privacy,
            metadata_2_values=metadata_2_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersIDMetadata",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_metadata_post_serialize(
        self,
        id,
        metadata_0_key,
        metadata_0_privacy,
        metadata_0_values,
        metadata_1_key,
        metadata_1_privacy,
        metadata_1_values,
        metadata_2_key,
        metadata_2_privacy,
        metadata_2_values,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'metadata_0_values[]': 'csv',
            'metadata_1_values[]': 'csv',
            'metadata_2_values[]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['ID'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if metadata_0_key is not None:
            _form_params.append(('metadata_0_key', metadata_0_key))
        if metadata_0_privacy is not None:
            _form_params.append(('metadata_0_privacy', metadata_0_privacy))
        if metadata_0_values is not None:
            _form_params.append(('metadata_0_values[]', metadata_0_values))
        if metadata_1_key is not None:
            _form_params.append(('metadata_1_key', metadata_1_key))
        if metadata_1_privacy is not None:
            _form_params.append(('metadata_1_privacy', metadata_1_privacy))
        if metadata_1_values is not None:
            _form_params.append(('metadata_1_values[]', metadata_1_values))
        if metadata_2_key is not None:
            _form_params.append(('metadata_2_key', metadata_2_key))
        if metadata_2_privacy is not None:
            _form_params.append(('metadata_2_privacy', metadata_2_privacy))
        if metadata_2_values is not None:
            _form_params.append(('metadata_2_values[]', metadata_2_values))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/users/{ID}/metadata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_positions_get(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        bubbled: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointGetUsersIDPositions:
        """users_id_positions_get

        Retrieve the CV of a user who exists within the current access token's bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. You can only record CV data to your own account. However, any app that you have OAuth'ed against can do so. By default, you will receive CV data that all apps have recorded for the user. Optionally, you can choose to only receive data that the current access token's bubble has recorded.

        :param id: (required)
        :type id: int
        :param bubbled:
        :type bubbled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_positions_get_serialize(
            id=id,
            bubbled=bubbled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDPositions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_positions_get_with_http_info(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        bubbled: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointGetUsersIDPositions]:
        """users_id_positions_get

        Retrieve the CV of a user who exists within the current access token's bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. You can only record CV data to your own account. However, any app that you have OAuth'ed against can do so. By default, you will receive CV data that all apps have recorded for the user. Optionally, you can choose to only receive data that the current access token's bubble has recorded.

        :param id: (required)
        :type id: int
        :param bubbled:
        :type bubbled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_positions_get_serialize(
            id=id,
            bubbled=bubbled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDPositions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_positions_get_without_preload_content(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        bubbled: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_id_positions_get

        Retrieve the CV of a user who exists within the current access token's bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. You can only record CV data to your own account. However, any app that you have OAuth'ed against can do so. By default, you will receive CV data that all apps have recorded for the user. Optionally, you can choose to only receive data that the current access token's bubble has recorded.

        :param id: (required)
        :type id: int
        :param bubbled:
        :type bubbled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_positions_get_serialize(
            id=id,
            bubbled=bubbled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDPositions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_positions_get_serialize(
        self,
        id,
        bubbled,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['ID'] = id
        # process the query parameters
        if bubbled is not None:
            
            _query_params.append(('bubbled', bubbled))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/users/{ID}/positions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_synergies_get(
        self,
        id: Annotated[List[Annotated[int, Field(strict=True, ge=1)]], Field(max_length=100)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointGetUsersIDSynergies:
        """users_id_synergies_get

        Determine your match relationship with one or more users who exist within the current access token's bubble. Under some conditions, the price to meet the user will be $0. However, if this is not the case, the PayPal URL payment method will be provided along with the price to meet the user. The PayPal API can be leveraged to send payments programatically, provided the parameters passed in remain the same to ensure that the payment is correctly recorded. Once the payment has been recorded via PayPal IPN, the price to meet the user changes to $0. You can then call the users/{:ID}/meet endpoint to meet the user.

        :param id: (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_synergies_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDSynergies",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_synergies_get_with_http_info(
        self,
        id: Annotated[List[Annotated[int, Field(strict=True, ge=1)]], Field(max_length=100)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointGetUsersIDSynergies]:
        """users_id_synergies_get

        Determine your match relationship with one or more users who exist within the current access token's bubble. Under some conditions, the price to meet the user will be $0. However, if this is not the case, the PayPal URL payment method will be provided along with the price to meet the user. The PayPal API can be leveraged to send payments programatically, provided the parameters passed in remain the same to ensure that the payment is correctly recorded. Once the payment has been recorded via PayPal IPN, the price to meet the user changes to $0. You can then call the users/{:ID}/meet endpoint to meet the user.

        :param id: (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_synergies_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDSynergies",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_synergies_get_without_preload_content(
        self,
        id: Annotated[List[Annotated[int, Field(strict=True, ge=1)]], Field(max_length=100)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_id_synergies_get

        Determine your match relationship with one or more users who exist within the current access token's bubble. Under some conditions, the price to meet the user will be $0. However, if this is not the case, the PayPal URL payment method will be provided along with the price to meet the user. The PayPal API can be leveraged to send payments programatically, provided the parameters passed in remain the same to ensure that the payment is correctly recorded. Once the payment has been recorded via PayPal IPN, the price to meet the user changes to $0. You can then call the users/{:ID}/meet endpoint to meet the user.

        :param id: (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_synergies_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersIDSynergies",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_synergies_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ID': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['ID'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/users/{ID}/synergies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_id_synergies_patch(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        relationship_muted: Optional[StrictBool] = None,
        relationship_skipped: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointPatchUsersIDSynergies:
        """users_id_synergies_patch

        Skip, mute or unmute a user you've been matched with. Skipped matches are only presented as algorithmic matches after all other candidates have been exhausted. You cannot be matched with or meet muted users. You can only skip, mute or unmute users existing within the same bubble.

        :param id: (required)
        :type id: int
        :param relationship_muted:
        :type relationship_muted: bool
        :param relationship_skipped:
        :type relationship_skipped: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_synergies_patch_serialize(
            id=id,
            relationship_muted=relationship_muted,
            relationship_skipped=relationship_skipped,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPatchUsersIDSynergies",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_id_synergies_patch_with_http_info(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        relationship_muted: Optional[StrictBool] = None,
        relationship_skipped: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointPatchUsersIDSynergies]:
        """users_id_synergies_patch

        Skip, mute or unmute a user you've been matched with. Skipped matches are only presented as algorithmic matches after all other candidates have been exhausted. You cannot be matched with or meet muted users. You can only skip, mute or unmute users existing within the same bubble.

        :param id: (required)
        :type id: int
        :param relationship_muted:
        :type relationship_muted: bool
        :param relationship_skipped:
        :type relationship_skipped: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_synergies_patch_serialize(
            id=id,
            relationship_muted=relationship_muted,
            relationship_skipped=relationship_skipped,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPatchUsersIDSynergies",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_id_synergies_patch_without_preload_content(
        self,
        id: Annotated[int, Field(strict=True, ge=1)],
        relationship_muted: Optional[StrictBool] = None,
        relationship_skipped: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_id_synergies_patch

        Skip, mute or unmute a user you've been matched with. Skipped matches are only presented as algorithmic matches after all other candidates have been exhausted. You cannot be matched with or meet muted users. You can only skip, mute or unmute users existing within the same bubble.

        :param id: (required)
        :type id: int
        :param relationship_muted:
        :type relationship_muted: bool
        :param relationship_skipped:
        :type relationship_skipped: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_id_synergies_patch_serialize(
            id=id,
            relationship_muted=relationship_muted,
            relationship_skipped=relationship_skipped,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPatchUsersIDSynergies",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_id_synergies_patch_serialize(
        self,
        id,
        relationship_muted,
        relationship_skipped,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['ID'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if relationship_muted is not None:
            _form_params.append(('relationship_muted', relationship_muted))
        if relationship_skipped is not None:
            _form_params.append(('relationship_skipped', relationship_skipped))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/users/{ID}/synergies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_invites_post(
        self,
        csv: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = None,
        emails: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointPostUsersInvites:
        """users_invites_post

        Invite users to into your current access token's bubble by having Dazah send out email invitations on your behalf. The invitation sends users to begin the OAuth flow for the current application (based on the settings specified in the application's profile), and therefore they will be redirected to the application upon signing up / logging in. Upon doing so, if they aren't already, they will automatically be connected with you as well. If your current access token does not escape the bubble, the invitation will specify you wish to connect within the application's name. If your current access token escapes the bubble, the invitation will specify you wish to connect within Dazah. Submit either a list of emails, or a LinkedIn or Outlook CSV file. You can retrieve your LinkedIn CSV file by exporting your LinkedIn Connections at https://www.linkedin.com/people/export-settings. You can retrieve your Outlook CSV file by using the Outlook Import and Export Wizard. This endpoint buckets the invitations into four categories: Existing invites are existing users who are already connected with you within the current bubble, and are therefore not emailed; Discovered invites are existing Dazah users who are available to be connected with within the current bubble, and are therefore not emailed. Now that they have been discovered, the users/{:ID}/meet API endpoint may be used to connect with them; Invalid invites are existing Dazah users who are unavailable to be connected with, because they have deactivated accounts, are muting you, etc., and are therefore not emailed; Emailed invites are queued to receive an invitation within approximately 1 hour. Note that if you are attempting to invite an existing Dazah user who does not currently exist within your current access token's bubble, they will fall within the Discovered bucket if your current access token escapes the bubble, but will be emailed an invitation to join the application if your current access token does not escape the bubble.

        :param csv:
        :type csv: bytearray
        :param emails:
        :type emails: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_invites_post_serialize(
            csv=csv,
            emails=emails,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersInvites",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_invites_post_with_http_info(
        self,
        csv: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = None,
        emails: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointPostUsersInvites]:
        """users_invites_post

        Invite users to into your current access token's bubble by having Dazah send out email invitations on your behalf. The invitation sends users to begin the OAuth flow for the current application (based on the settings specified in the application's profile), and therefore they will be redirected to the application upon signing up / logging in. Upon doing so, if they aren't already, they will automatically be connected with you as well. If your current access token does not escape the bubble, the invitation will specify you wish to connect within the application's name. If your current access token escapes the bubble, the invitation will specify you wish to connect within Dazah. Submit either a list of emails, or a LinkedIn or Outlook CSV file. You can retrieve your LinkedIn CSV file by exporting your LinkedIn Connections at https://www.linkedin.com/people/export-settings. You can retrieve your Outlook CSV file by using the Outlook Import and Export Wizard. This endpoint buckets the invitations into four categories: Existing invites are existing users who are already connected with you within the current bubble, and are therefore not emailed; Discovered invites are existing Dazah users who are available to be connected with within the current bubble, and are therefore not emailed. Now that they have been discovered, the users/{:ID}/meet API endpoint may be used to connect with them; Invalid invites are existing Dazah users who are unavailable to be connected with, because they have deactivated accounts, are muting you, etc., and are therefore not emailed; Emailed invites are queued to receive an invitation within approximately 1 hour. Note that if you are attempting to invite an existing Dazah user who does not currently exist within your current access token's bubble, they will fall within the Discovered bucket if your current access token escapes the bubble, but will be emailed an invitation to join the application if your current access token does not escape the bubble.

        :param csv:
        :type csv: bytearray
        :param emails:
        :type emails: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_invites_post_serialize(
            csv=csv,
            emails=emails,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersInvites",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_invites_post_without_preload_content(
        self,
        csv: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = None,
        emails: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_invites_post

        Invite users to into your current access token's bubble by having Dazah send out email invitations on your behalf. The invitation sends users to begin the OAuth flow for the current application (based on the settings specified in the application's profile), and therefore they will be redirected to the application upon signing up / logging in. Upon doing so, if they aren't already, they will automatically be connected with you as well. If your current access token does not escape the bubble, the invitation will specify you wish to connect within the application's name. If your current access token escapes the bubble, the invitation will specify you wish to connect within Dazah. Submit either a list of emails, or a LinkedIn or Outlook CSV file. You can retrieve your LinkedIn CSV file by exporting your LinkedIn Connections at https://www.linkedin.com/people/export-settings. You can retrieve your Outlook CSV file by using the Outlook Import and Export Wizard. This endpoint buckets the invitations into four categories: Existing invites are existing users who are already connected with you within the current bubble, and are therefore not emailed; Discovered invites are existing Dazah users who are available to be connected with within the current bubble, and are therefore not emailed. Now that they have been discovered, the users/{:ID}/meet API endpoint may be used to connect with them; Invalid invites are existing Dazah users who are unavailable to be connected with, because they have deactivated accounts, are muting you, etc., and are therefore not emailed; Emailed invites are queued to receive an invitation within approximately 1 hour. Note that if you are attempting to invite an existing Dazah user who does not currently exist within your current access token's bubble, they will fall within the Discovered bucket if your current access token escapes the bubble, but will be emailed an invitation to join the application if your current access token does not escape the bubble.

        :param csv:
        :type csv: bytearray
        :param emails:
        :type emails: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_invites_post_serialize(
            csv=csv,
            emails=emails,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersInvites",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_invites_post_serialize(
        self,
        csv,
        emails,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'emails[]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if csv is not None:
            _files['csv'] = csv
        if emails is not None:
            _form_params.append(('emails[]', emails))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/users/invites',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_metadata_filters_post(
        self,
        limit: Optional[StrictInt] = None,
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_values: Optional[List[StrictStr]] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_values: Optional[List[StrictStr]] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_values: Optional[List[StrictStr]] = None,
        offset: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointPostUsersMetadataFilters:
        """users_metadata_filters_post

        Paginated listing of users filtered by arbitrary metadata criteria. Users must match on all key/value pairs passed in. Users may only match on one value of an array passed in. However, users are sorted based on how many distinct values they match on (most matches first).

        :param limit:
        :type limit: int
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_values:
        :type metadata_0_values: List[str]
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_values:
        :type metadata_1_values: List[str]
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_values:
        :type metadata_2_values: List[str]
        :param offset:
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_metadata_filters_post_serialize(
            limit=limit,
            metadata_0_key=metadata_0_key,
            metadata_0_values=metadata_0_values,
            metadata_1_key=metadata_1_key,
            metadata_1_values=metadata_1_values,
            metadata_2_key=metadata_2_key,
            metadata_2_values=metadata_2_values,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersMetadataFilters",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_metadata_filters_post_with_http_info(
        self,
        limit: Optional[StrictInt] = None,
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_values: Optional[List[StrictStr]] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_values: Optional[List[StrictStr]] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_values: Optional[List[StrictStr]] = None,
        offset: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointPostUsersMetadataFilters]:
        """users_metadata_filters_post

        Paginated listing of users filtered by arbitrary metadata criteria. Users must match on all key/value pairs passed in. Users may only match on one value of an array passed in. However, users are sorted based on how many distinct values they match on (most matches first).

        :param limit:
        :type limit: int
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_values:
        :type metadata_0_values: List[str]
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_values:
        :type metadata_1_values: List[str]
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_values:
        :type metadata_2_values: List[str]
        :param offset:
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_metadata_filters_post_serialize(
            limit=limit,
            metadata_0_key=metadata_0_key,
            metadata_0_values=metadata_0_values,
            metadata_1_key=metadata_1_key,
            metadata_1_values=metadata_1_values,
            metadata_2_key=metadata_2_key,
            metadata_2_values=metadata_2_values,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersMetadataFilters",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_metadata_filters_post_without_preload_content(
        self,
        limit: Optional[StrictInt] = None,
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_values: Optional[List[StrictStr]] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_values: Optional[List[StrictStr]] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_values: Optional[List[StrictStr]] = None,
        offset: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_metadata_filters_post

        Paginated listing of users filtered by arbitrary metadata criteria. Users must match on all key/value pairs passed in. Users may only match on one value of an array passed in. However, users are sorted based on how many distinct values they match on (most matches first).

        :param limit:
        :type limit: int
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_values:
        :type metadata_0_values: List[str]
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_values:
        :type metadata_1_values: List[str]
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_values:
        :type metadata_2_values: List[str]
        :param offset:
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_metadata_filters_post_serialize(
            limit=limit,
            metadata_0_key=metadata_0_key,
            metadata_0_values=metadata_0_values,
            metadata_1_key=metadata_1_key,
            metadata_1_values=metadata_1_values,
            metadata_2_key=metadata_2_key,
            metadata_2_values=metadata_2_values,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersMetadataFilters",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_metadata_filters_post_serialize(
        self,
        limit,
        metadata_0_key,
        metadata_0_values,
        metadata_1_key,
        metadata_1_values,
        metadata_2_key,
        metadata_2_values,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'metadata_0_values[]': 'csv',
            'metadata_1_values[]': 'csv',
            'metadata_2_values[]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if limit is not None:
            _form_params.append(('limit', limit))
        if metadata_0_key is not None:
            _form_params.append(('metadata_0_key', metadata_0_key))
        if metadata_0_values is not None:
            _form_params.append(('metadata_0_values[]', metadata_0_values))
        if metadata_1_key is not None:
            _form_params.append(('metadata_1_key', metadata_1_key))
        if metadata_1_values is not None:
            _form_params.append(('metadata_1_values[]', metadata_1_values))
        if metadata_2_key is not None:
            _form_params.append(('metadata_2_key', metadata_2_key))
        if metadata_2_values is not None:
            _form_params.append(('metadata_2_values[]', metadata_2_values))
        if offset is not None:
            _form_params.append(('offset', offset))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/users/metadata/filters',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_nearby_get(
        self,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointGetUsersNearby:
        """users_nearby_get

        Fetch an array of users that are geographically close to a set of coordinates. You can only retrieve users existing within the current access token's bubble.

        :param latitude:
        :type latitude: float
        :param longitude:
        :type longitude: float
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_nearby_get_serialize(
            latitude=latitude,
            longitude=longitude,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersNearby",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_nearby_get_with_http_info(
        self,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointGetUsersNearby]:
        """users_nearby_get

        Fetch an array of users that are geographically close to a set of coordinates. You can only retrieve users existing within the current access token's bubble.

        :param latitude:
        :type latitude: float
        :param longitude:
        :type longitude: float
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_nearby_get_serialize(
            latitude=latitude,
            longitude=longitude,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersNearby",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_nearby_get_without_preload_content(
        self,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        offset: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_nearby_get

        Fetch an array of users that are geographically close to a set of coordinates. You can only retrieve users existing within the current access token's bubble.

        :param latitude:
        :type latitude: float
        :param longitude:
        :type longitude: float
        :param offset:
        :type offset: int
        :param limit:
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_nearby_get_serialize(
            latitude=latitude,
            longitude=longitude,
            offset=offset,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointGetUsersNearby",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_nearby_get_serialize(
        self,
        latitude,
        longitude,
        offset,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/users/nearby',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_patch(
        self,
        company: Optional[StrictStr] = None,
        company_size: Optional[StrictStr] = None,
        first_name: Optional[StrictStr] = None,
        goals: Optional[List[StrictStr]] = None,
        headline: Optional[StrictStr] = None,
        industry: Optional[StrictStr] = None,
        introduction: Optional[StrictStr] = None,
        job_position: Optional[StrictStr] = None,
        last_name: Optional[StrictStr] = None,
        location_importance: Optional[StrictStr] = None,
        match_tags: Optional[List[StrictStr]] = None,
        pitch: Optional[StrictStr] = None,
        tags: Optional[List[StrictStr]] = None,
        targeted_industry: Optional[StrictStr] = None,
        url: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointPatchUsers:
        """users_patch

        Update the OAuth'ed end user's account profile. At this time, for anti-spam reasons, restrictions preclude the ability to update email address and some other settings via the API.

        :param company:
        :type company: str
        :param company_size:
        :type company_size: str
        :param first_name:
        :type first_name: str
        :param goals:
        :type goals: List[str]
        :param headline:
        :type headline: str
        :param industry:
        :type industry: str
        :param introduction:
        :type introduction: str
        :param job_position:
        :type job_position: str
        :param last_name:
        :type last_name: str
        :param location_importance:
        :type location_importance: str
        :param match_tags:
        :type match_tags: List[str]
        :param pitch:
        :type pitch: str
        :param tags:
        :type tags: List[str]
        :param targeted_industry:
        :type targeted_industry: str
        :param url:
        :type url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_patch_serialize(
            company=company,
            company_size=company_size,
            first_name=first_name,
            goals=goals,
            headline=headline,
            industry=industry,
            introduction=introduction,
            job_position=job_position,
            last_name=last_name,
            location_importance=location_importance,
            match_tags=match_tags,
            pitch=pitch,
            tags=tags,
            targeted_industry=targeted_industry,
            url=url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPatchUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_patch_with_http_info(
        self,
        company: Optional[StrictStr] = None,
        company_size: Optional[StrictStr] = None,
        first_name: Optional[StrictStr] = None,
        goals: Optional[List[StrictStr]] = None,
        headline: Optional[StrictStr] = None,
        industry: Optional[StrictStr] = None,
        introduction: Optional[StrictStr] = None,
        job_position: Optional[StrictStr] = None,
        last_name: Optional[StrictStr] = None,
        location_importance: Optional[StrictStr] = None,
        match_tags: Optional[List[StrictStr]] = None,
        pitch: Optional[StrictStr] = None,
        tags: Optional[List[StrictStr]] = None,
        targeted_industry: Optional[StrictStr] = None,
        url: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointPatchUsers]:
        """users_patch

        Update the OAuth'ed end user's account profile. At this time, for anti-spam reasons, restrictions preclude the ability to update email address and some other settings via the API.

        :param company:
        :type company: str
        :param company_size:
        :type company_size: str
        :param first_name:
        :type first_name: str
        :param goals:
        :type goals: List[str]
        :param headline:
        :type headline: str
        :param industry:
        :type industry: str
        :param introduction:
        :type introduction: str
        :param job_position:
        :type job_position: str
        :param last_name:
        :type last_name: str
        :param location_importance:
        :type location_importance: str
        :param match_tags:
        :type match_tags: List[str]
        :param pitch:
        :type pitch: str
        :param tags:
        :type tags: List[str]
        :param targeted_industry:
        :type targeted_industry: str
        :param url:
        :type url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_patch_serialize(
            company=company,
            company_size=company_size,
            first_name=first_name,
            goals=goals,
            headline=headline,
            industry=industry,
            introduction=introduction,
            job_position=job_position,
            last_name=last_name,
            location_importance=location_importance,
            match_tags=match_tags,
            pitch=pitch,
            tags=tags,
            targeted_industry=targeted_industry,
            url=url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPatchUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_patch_without_preload_content(
        self,
        company: Optional[StrictStr] = None,
        company_size: Optional[StrictStr] = None,
        first_name: Optional[StrictStr] = None,
        goals: Optional[List[StrictStr]] = None,
        headline: Optional[StrictStr] = None,
        industry: Optional[StrictStr] = None,
        introduction: Optional[StrictStr] = None,
        job_position: Optional[StrictStr] = None,
        last_name: Optional[StrictStr] = None,
        location_importance: Optional[StrictStr] = None,
        match_tags: Optional[List[StrictStr]] = None,
        pitch: Optional[StrictStr] = None,
        tags: Optional[List[StrictStr]] = None,
        targeted_industry: Optional[StrictStr] = None,
        url: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_patch

        Update the OAuth'ed end user's account profile. At this time, for anti-spam reasons, restrictions preclude the ability to update email address and some other settings via the API.

        :param company:
        :type company: str
        :param company_size:
        :type company_size: str
        :param first_name:
        :type first_name: str
        :param goals:
        :type goals: List[str]
        :param headline:
        :type headline: str
        :param industry:
        :type industry: str
        :param introduction:
        :type introduction: str
        :param job_position:
        :type job_position: str
        :param last_name:
        :type last_name: str
        :param location_importance:
        :type location_importance: str
        :param match_tags:
        :type match_tags: List[str]
        :param pitch:
        :type pitch: str
        :param tags:
        :type tags: List[str]
        :param targeted_industry:
        :type targeted_industry: str
        :param url:
        :type url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_patch_serialize(
            company=company,
            company_size=company_size,
            first_name=first_name,
            goals=goals,
            headline=headline,
            industry=industry,
            introduction=introduction,
            job_position=job_position,
            last_name=last_name,
            location_importance=location_importance,
            match_tags=match_tags,
            pitch=pitch,
            tags=tags,
            targeted_industry=targeted_industry,
            url=url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPatchUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_patch_serialize(
        self,
        company,
        company_size,
        first_name,
        goals,
        headline,
        industry,
        introduction,
        job_position,
        last_name,
        location_importance,
        match_tags,
        pitch,
        tags,
        targeted_industry,
        url,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'goals[]': 'csv',
            'match_tags[]': 'csv',
            'tags[]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if company is not None:
            _form_params.append(('company', company))
        if company_size is not None:
            _form_params.append(('company_size', company_size))
        if first_name is not None:
            _form_params.append(('first_name', first_name))
        if goals is not None:
            _form_params.append(('goals[]', goals))
        if headline is not None:
            _form_params.append(('headline', headline))
        if industry is not None:
            _form_params.append(('industry', industry))
        if introduction is not None:
            _form_params.append(('introduction', introduction))
        if job_position is not None:
            _form_params.append(('job_position', job_position))
        if last_name is not None:
            _form_params.append(('last_name', last_name))
        if location_importance is not None:
            _form_params.append(('location_importance', location_importance))
        if match_tags is not None:
            _form_params.append(('match_tags[]', match_tags))
        if pitch is not None:
            _form_params.append(('pitch', pitch))
        if tags is not None:
            _form_params.append(('tags[]', tags))
        if targeted_industry is not None:
            _form_params.append(('targeted_industry', targeted_industry))
        if url is not None:
            _form_params.append(('url', url))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/users/~',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def users_searches_post(
        self,
        active_within_x_days: Optional[StrictInt] = None,
        audience_ids: Optional[List[StrictInt]] = None,
        bubbled: Optional[StrictBool] = None,
        exclude_connections: Optional[StrictBool] = None,
        exclude_matches: Optional[StrictBool] = None,
        exclude_muted: Optional[StrictBool] = None,
        exclude_skipped: Optional[StrictBool] = None,
        geo_latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        geo_longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        geo_miles_away: Optional[Union[StrictFloat, StrictInt]] = None,
        group_id: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        location_city_query: Optional[StrictStr] = None,
        location_city_weight: Optional[StrictInt] = None,
        location_country_query: Optional[StrictStr] = None,
        location_country_weight: Optional[StrictInt] = None,
        location_region_query: Optional[StrictStr] = None,
        location_region_weight: Optional[StrictInt] = None,
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_query: Optional[StrictStr] = None,
        metadata_0_weight: Optional[StrictInt] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_query: Optional[StrictStr] = None,
        metadata_1_weight: Optional[StrictInt] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_query: Optional[StrictStr] = None,
        metadata_2_weight: Optional[StrictInt] = None,
        offset: Optional[StrictInt] = None,
        position_organization_query: Optional[StrictStr] = None,
        position_organization_weight: Optional[StrictInt] = None,
        position_role_query: Optional[StrictStr] = None,
        position_role_weight: Optional[StrictInt] = None,
        position_summary_query: Optional[StrictStr] = None,
        position_summary_weight: Optional[StrictInt] = None,
        profile_first_name_query: Optional[StrictStr] = None,
        profile_first_name_weight: Optional[StrictInt] = None,
        profile_goals_query: Optional[StrictStr] = None,
        profile_goals_weight: Optional[StrictStr] = None,
        profile_headline_query: Optional[StrictStr] = None,
        profile_headline_weight: Optional[StrictInt] = None,
        profile_industry_query: Optional[StrictStr] = None,
        profile_industry_weight: Optional[StrictInt] = None,
        profile_last_name_query: Optional[StrictStr] = None,
        profile_last_name_weight: Optional[StrictInt] = None,
        profile_pitch_query: Optional[StrictStr] = None,
        profile_pitch_weight: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EndpointPostUsersSearches:
        """users_searches_post

        Filter and perform a weighted search against user profile fields, CV fields, and metadata by specifying a string to search on for each individual field. By default, results are filtered such that all words in the string must exist, unless you seprate the words with OR. To perform a weighted search (as opposed to filtering), specify the weight (from 0-100) the search algorithm should assign to the field. You can optionally exclude users who you are already in or not in conversations with, exclude users who you previously skipped, or exclude users who you are muting. By doing so, you can effectively customize your own matching algorithm. You can specify geo coordinates to only find users a certain distance away from a specific location, or only find users within a certain distance from the OAuth'ed end-user's last known location. If your app utilizes multiple audience segments, you can specify which audiences you would like to search. You can also limit users to just those who have been recently active. You can also choose to only receive users originating from the current access token's bubble. Only users existing within the current access token's bubble will be matched, and you can only search within a group created by a bubbled user.

        :param active_within_x_days:
        :type active_within_x_days: int
        :param audience_ids:
        :type audience_ids: List[int]
        :param bubbled:
        :type bubbled: bool
        :param exclude_connections:
        :type exclude_connections: bool
        :param exclude_matches:
        :type exclude_matches: bool
        :param exclude_muted:
        :type exclude_muted: bool
        :param exclude_skipped:
        :type exclude_skipped: bool
        :param geo_latitude:
        :type geo_latitude: float
        :param geo_longitude:
        :type geo_longitude: float
        :param geo_miles_away:
        :type geo_miles_away: float
        :param group_id:
        :type group_id: int
        :param limit:
        :type limit: int
        :param location_city_query:
        :type location_city_query: str
        :param location_city_weight:
        :type location_city_weight: int
        :param location_country_query:
        :type location_country_query: str
        :param location_country_weight:
        :type location_country_weight: int
        :param location_region_query:
        :type location_region_query: str
        :param location_region_weight:
        :type location_region_weight: int
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_query:
        :type metadata_0_query: str
        :param metadata_0_weight:
        :type metadata_0_weight: int
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_query:
        :type metadata_1_query: str
        :param metadata_1_weight:
        :type metadata_1_weight: int
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_query:
        :type metadata_2_query: str
        :param metadata_2_weight:
        :type metadata_2_weight: int
        :param offset:
        :type offset: int
        :param position_organization_query:
        :type position_organization_query: str
        :param position_organization_weight:
        :type position_organization_weight: int
        :param position_role_query:
        :type position_role_query: str
        :param position_role_weight:
        :type position_role_weight: int
        :param position_summary_query:
        :type position_summary_query: str
        :param position_summary_weight:
        :type position_summary_weight: int
        :param profile_first_name_query:
        :type profile_first_name_query: str
        :param profile_first_name_weight:
        :type profile_first_name_weight: int
        :param profile_goals_query:
        :type profile_goals_query: str
        :param profile_goals_weight:
        :type profile_goals_weight: str
        :param profile_headline_query:
        :type profile_headline_query: str
        :param profile_headline_weight:
        :type profile_headline_weight: int
        :param profile_industry_query:
        :type profile_industry_query: str
        :param profile_industry_weight:
        :type profile_industry_weight: int
        :param profile_last_name_query:
        :type profile_last_name_query: str
        :param profile_last_name_weight:
        :type profile_last_name_weight: int
        :param profile_pitch_query:
        :type profile_pitch_query: str
        :param profile_pitch_weight:
        :type profile_pitch_weight: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_searches_post_serialize(
            active_within_x_days=active_within_x_days,
            audience_ids=audience_ids,
            bubbled=bubbled,
            exclude_connections=exclude_connections,
            exclude_matches=exclude_matches,
            exclude_muted=exclude_muted,
            exclude_skipped=exclude_skipped,
            geo_latitude=geo_latitude,
            geo_longitude=geo_longitude,
            geo_miles_away=geo_miles_away,
            group_id=group_id,
            limit=limit,
            location_city_query=location_city_query,
            location_city_weight=location_city_weight,
            location_country_query=location_country_query,
            location_country_weight=location_country_weight,
            location_region_query=location_region_query,
            location_region_weight=location_region_weight,
            metadata_0_key=metadata_0_key,
            metadata_0_query=metadata_0_query,
            metadata_0_weight=metadata_0_weight,
            metadata_1_key=metadata_1_key,
            metadata_1_query=metadata_1_query,
            metadata_1_weight=metadata_1_weight,
            metadata_2_key=metadata_2_key,
            metadata_2_query=metadata_2_query,
            metadata_2_weight=metadata_2_weight,
            offset=offset,
            position_organization_query=position_organization_query,
            position_organization_weight=position_organization_weight,
            position_role_query=position_role_query,
            position_role_weight=position_role_weight,
            position_summary_query=position_summary_query,
            position_summary_weight=position_summary_weight,
            profile_first_name_query=profile_first_name_query,
            profile_first_name_weight=profile_first_name_weight,
            profile_goals_query=profile_goals_query,
            profile_goals_weight=profile_goals_weight,
            profile_headline_query=profile_headline_query,
            profile_headline_weight=profile_headline_weight,
            profile_industry_query=profile_industry_query,
            profile_industry_weight=profile_industry_weight,
            profile_last_name_query=profile_last_name_query,
            profile_last_name_weight=profile_last_name_weight,
            profile_pitch_query=profile_pitch_query,
            profile_pitch_weight=profile_pitch_weight,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersSearches",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def users_searches_post_with_http_info(
        self,
        active_within_x_days: Optional[StrictInt] = None,
        audience_ids: Optional[List[StrictInt]] = None,
        bubbled: Optional[StrictBool] = None,
        exclude_connections: Optional[StrictBool] = None,
        exclude_matches: Optional[StrictBool] = None,
        exclude_muted: Optional[StrictBool] = None,
        exclude_skipped: Optional[StrictBool] = None,
        geo_latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        geo_longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        geo_miles_away: Optional[Union[StrictFloat, StrictInt]] = None,
        group_id: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        location_city_query: Optional[StrictStr] = None,
        location_city_weight: Optional[StrictInt] = None,
        location_country_query: Optional[StrictStr] = None,
        location_country_weight: Optional[StrictInt] = None,
        location_region_query: Optional[StrictStr] = None,
        location_region_weight: Optional[StrictInt] = None,
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_query: Optional[StrictStr] = None,
        metadata_0_weight: Optional[StrictInt] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_query: Optional[StrictStr] = None,
        metadata_1_weight: Optional[StrictInt] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_query: Optional[StrictStr] = None,
        metadata_2_weight: Optional[StrictInt] = None,
        offset: Optional[StrictInt] = None,
        position_organization_query: Optional[StrictStr] = None,
        position_organization_weight: Optional[StrictInt] = None,
        position_role_query: Optional[StrictStr] = None,
        position_role_weight: Optional[StrictInt] = None,
        position_summary_query: Optional[StrictStr] = None,
        position_summary_weight: Optional[StrictInt] = None,
        profile_first_name_query: Optional[StrictStr] = None,
        profile_first_name_weight: Optional[StrictInt] = None,
        profile_goals_query: Optional[StrictStr] = None,
        profile_goals_weight: Optional[StrictStr] = None,
        profile_headline_query: Optional[StrictStr] = None,
        profile_headline_weight: Optional[StrictInt] = None,
        profile_industry_query: Optional[StrictStr] = None,
        profile_industry_weight: Optional[StrictInt] = None,
        profile_last_name_query: Optional[StrictStr] = None,
        profile_last_name_weight: Optional[StrictInt] = None,
        profile_pitch_query: Optional[StrictStr] = None,
        profile_pitch_weight: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EndpointPostUsersSearches]:
        """users_searches_post

        Filter and perform a weighted search against user profile fields, CV fields, and metadata by specifying a string to search on for each individual field. By default, results are filtered such that all words in the string must exist, unless you seprate the words with OR. To perform a weighted search (as opposed to filtering), specify the weight (from 0-100) the search algorithm should assign to the field. You can optionally exclude users who you are already in or not in conversations with, exclude users who you previously skipped, or exclude users who you are muting. By doing so, you can effectively customize your own matching algorithm. You can specify geo coordinates to only find users a certain distance away from a specific location, or only find users within a certain distance from the OAuth'ed end-user's last known location. If your app utilizes multiple audience segments, you can specify which audiences you would like to search. You can also limit users to just those who have been recently active. You can also choose to only receive users originating from the current access token's bubble. Only users existing within the current access token's bubble will be matched, and you can only search within a group created by a bubbled user.

        :param active_within_x_days:
        :type active_within_x_days: int
        :param audience_ids:
        :type audience_ids: List[int]
        :param bubbled:
        :type bubbled: bool
        :param exclude_connections:
        :type exclude_connections: bool
        :param exclude_matches:
        :type exclude_matches: bool
        :param exclude_muted:
        :type exclude_muted: bool
        :param exclude_skipped:
        :type exclude_skipped: bool
        :param geo_latitude:
        :type geo_latitude: float
        :param geo_longitude:
        :type geo_longitude: float
        :param geo_miles_away:
        :type geo_miles_away: float
        :param group_id:
        :type group_id: int
        :param limit:
        :type limit: int
        :param location_city_query:
        :type location_city_query: str
        :param location_city_weight:
        :type location_city_weight: int
        :param location_country_query:
        :type location_country_query: str
        :param location_country_weight:
        :type location_country_weight: int
        :param location_region_query:
        :type location_region_query: str
        :param location_region_weight:
        :type location_region_weight: int
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_query:
        :type metadata_0_query: str
        :param metadata_0_weight:
        :type metadata_0_weight: int
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_query:
        :type metadata_1_query: str
        :param metadata_1_weight:
        :type metadata_1_weight: int
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_query:
        :type metadata_2_query: str
        :param metadata_2_weight:
        :type metadata_2_weight: int
        :param offset:
        :type offset: int
        :param position_organization_query:
        :type position_organization_query: str
        :param position_organization_weight:
        :type position_organization_weight: int
        :param position_role_query:
        :type position_role_query: str
        :param position_role_weight:
        :type position_role_weight: int
        :param position_summary_query:
        :type position_summary_query: str
        :param position_summary_weight:
        :type position_summary_weight: int
        :param profile_first_name_query:
        :type profile_first_name_query: str
        :param profile_first_name_weight:
        :type profile_first_name_weight: int
        :param profile_goals_query:
        :type profile_goals_query: str
        :param profile_goals_weight:
        :type profile_goals_weight: str
        :param profile_headline_query:
        :type profile_headline_query: str
        :param profile_headline_weight:
        :type profile_headline_weight: int
        :param profile_industry_query:
        :type profile_industry_query: str
        :param profile_industry_weight:
        :type profile_industry_weight: int
        :param profile_last_name_query:
        :type profile_last_name_query: str
        :param profile_last_name_weight:
        :type profile_last_name_weight: int
        :param profile_pitch_query:
        :type profile_pitch_query: str
        :param profile_pitch_weight:
        :type profile_pitch_weight: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_searches_post_serialize(
            active_within_x_days=active_within_x_days,
            audience_ids=audience_ids,
            bubbled=bubbled,
            exclude_connections=exclude_connections,
            exclude_matches=exclude_matches,
            exclude_muted=exclude_muted,
            exclude_skipped=exclude_skipped,
            geo_latitude=geo_latitude,
            geo_longitude=geo_longitude,
            geo_miles_away=geo_miles_away,
            group_id=group_id,
            limit=limit,
            location_city_query=location_city_query,
            location_city_weight=location_city_weight,
            location_country_query=location_country_query,
            location_country_weight=location_country_weight,
            location_region_query=location_region_query,
            location_region_weight=location_region_weight,
            metadata_0_key=metadata_0_key,
            metadata_0_query=metadata_0_query,
            metadata_0_weight=metadata_0_weight,
            metadata_1_key=metadata_1_key,
            metadata_1_query=metadata_1_query,
            metadata_1_weight=metadata_1_weight,
            metadata_2_key=metadata_2_key,
            metadata_2_query=metadata_2_query,
            metadata_2_weight=metadata_2_weight,
            offset=offset,
            position_organization_query=position_organization_query,
            position_organization_weight=position_organization_weight,
            position_role_query=position_role_query,
            position_role_weight=position_role_weight,
            position_summary_query=position_summary_query,
            position_summary_weight=position_summary_weight,
            profile_first_name_query=profile_first_name_query,
            profile_first_name_weight=profile_first_name_weight,
            profile_goals_query=profile_goals_query,
            profile_goals_weight=profile_goals_weight,
            profile_headline_query=profile_headline_query,
            profile_headline_weight=profile_headline_weight,
            profile_industry_query=profile_industry_query,
            profile_industry_weight=profile_industry_weight,
            profile_last_name_query=profile_last_name_query,
            profile_last_name_weight=profile_last_name_weight,
            profile_pitch_query=profile_pitch_query,
            profile_pitch_weight=profile_pitch_weight,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersSearches",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def users_searches_post_without_preload_content(
        self,
        active_within_x_days: Optional[StrictInt] = None,
        audience_ids: Optional[List[StrictInt]] = None,
        bubbled: Optional[StrictBool] = None,
        exclude_connections: Optional[StrictBool] = None,
        exclude_matches: Optional[StrictBool] = None,
        exclude_muted: Optional[StrictBool] = None,
        exclude_skipped: Optional[StrictBool] = None,
        geo_latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        geo_longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        geo_miles_away: Optional[Union[StrictFloat, StrictInt]] = None,
        group_id: Optional[StrictInt] = None,
        limit: Optional[StrictInt] = None,
        location_city_query: Optional[StrictStr] = None,
        location_city_weight: Optional[StrictInt] = None,
        location_country_query: Optional[StrictStr] = None,
        location_country_weight: Optional[StrictInt] = None,
        location_region_query: Optional[StrictStr] = None,
        location_region_weight: Optional[StrictInt] = None,
        metadata_0_key: Optional[StrictStr] = None,
        metadata_0_query: Optional[StrictStr] = None,
        metadata_0_weight: Optional[StrictInt] = None,
        metadata_1_key: Optional[StrictStr] = None,
        metadata_1_query: Optional[StrictStr] = None,
        metadata_1_weight: Optional[StrictInt] = None,
        metadata_2_key: Optional[StrictStr] = None,
        metadata_2_query: Optional[StrictStr] = None,
        metadata_2_weight: Optional[StrictInt] = None,
        offset: Optional[StrictInt] = None,
        position_organization_query: Optional[StrictStr] = None,
        position_organization_weight: Optional[StrictInt] = None,
        position_role_query: Optional[StrictStr] = None,
        position_role_weight: Optional[StrictInt] = None,
        position_summary_query: Optional[StrictStr] = None,
        position_summary_weight: Optional[StrictInt] = None,
        profile_first_name_query: Optional[StrictStr] = None,
        profile_first_name_weight: Optional[StrictInt] = None,
        profile_goals_query: Optional[StrictStr] = None,
        profile_goals_weight: Optional[StrictStr] = None,
        profile_headline_query: Optional[StrictStr] = None,
        profile_headline_weight: Optional[StrictInt] = None,
        profile_industry_query: Optional[StrictStr] = None,
        profile_industry_weight: Optional[StrictInt] = None,
        profile_last_name_query: Optional[StrictStr] = None,
        profile_last_name_weight: Optional[StrictInt] = None,
        profile_pitch_query: Optional[StrictStr] = None,
        profile_pitch_weight: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """users_searches_post

        Filter and perform a weighted search against user profile fields, CV fields, and metadata by specifying a string to search on for each individual field. By default, results are filtered such that all words in the string must exist, unless you seprate the words with OR. To perform a weighted search (as opposed to filtering), specify the weight (from 0-100) the search algorithm should assign to the field. You can optionally exclude users who you are already in or not in conversations with, exclude users who you previously skipped, or exclude users who you are muting. By doing so, you can effectively customize your own matching algorithm. You can specify geo coordinates to only find users a certain distance away from a specific location, or only find users within a certain distance from the OAuth'ed end-user's last known location. If your app utilizes multiple audience segments, you can specify which audiences you would like to search. You can also limit users to just those who have been recently active. You can also choose to only receive users originating from the current access token's bubble. Only users existing within the current access token's bubble will be matched, and you can only search within a group created by a bubbled user.

        :param active_within_x_days:
        :type active_within_x_days: int
        :param audience_ids:
        :type audience_ids: List[int]
        :param bubbled:
        :type bubbled: bool
        :param exclude_connections:
        :type exclude_connections: bool
        :param exclude_matches:
        :type exclude_matches: bool
        :param exclude_muted:
        :type exclude_muted: bool
        :param exclude_skipped:
        :type exclude_skipped: bool
        :param geo_latitude:
        :type geo_latitude: float
        :param geo_longitude:
        :type geo_longitude: float
        :param geo_miles_away:
        :type geo_miles_away: float
        :param group_id:
        :type group_id: int
        :param limit:
        :type limit: int
        :param location_city_query:
        :type location_city_query: str
        :param location_city_weight:
        :type location_city_weight: int
        :param location_country_query:
        :type location_country_query: str
        :param location_country_weight:
        :type location_country_weight: int
        :param location_region_query:
        :type location_region_query: str
        :param location_region_weight:
        :type location_region_weight: int
        :param metadata_0_key:
        :type metadata_0_key: str
        :param metadata_0_query:
        :type metadata_0_query: str
        :param metadata_0_weight:
        :type metadata_0_weight: int
        :param metadata_1_key:
        :type metadata_1_key: str
        :param metadata_1_query:
        :type metadata_1_query: str
        :param metadata_1_weight:
        :type metadata_1_weight: int
        :param metadata_2_key:
        :type metadata_2_key: str
        :param metadata_2_query:
        :type metadata_2_query: str
        :param metadata_2_weight:
        :type metadata_2_weight: int
        :param offset:
        :type offset: int
        :param position_organization_query:
        :type position_organization_query: str
        :param position_organization_weight:
        :type position_organization_weight: int
        :param position_role_query:
        :type position_role_query: str
        :param position_role_weight:
        :type position_role_weight: int
        :param position_summary_query:
        :type position_summary_query: str
        :param position_summary_weight:
        :type position_summary_weight: int
        :param profile_first_name_query:
        :type profile_first_name_query: str
        :param profile_first_name_weight:
        :type profile_first_name_weight: int
        :param profile_goals_query:
        :type profile_goals_query: str
        :param profile_goals_weight:
        :type profile_goals_weight: str
        :param profile_headline_query:
        :type profile_headline_query: str
        :param profile_headline_weight:
        :type profile_headline_weight: int
        :param profile_industry_query:
        :type profile_industry_query: str
        :param profile_industry_weight:
        :type profile_industry_weight: int
        :param profile_last_name_query:
        :type profile_last_name_query: str
        :param profile_last_name_weight:
        :type profile_last_name_weight: int
        :param profile_pitch_query:
        :type profile_pitch_query: str
        :param profile_pitch_weight:
        :type profile_pitch_weight: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._users_searches_post_serialize(
            active_within_x_days=active_within_x_days,
            audience_ids=audience_ids,
            bubbled=bubbled,
            exclude_connections=exclude_connections,
            exclude_matches=exclude_matches,
            exclude_muted=exclude_muted,
            exclude_skipped=exclude_skipped,
            geo_latitude=geo_latitude,
            geo_longitude=geo_longitude,
            geo_miles_away=geo_miles_away,
            group_id=group_id,
            limit=limit,
            location_city_query=location_city_query,
            location_city_weight=location_city_weight,
            location_country_query=location_country_query,
            location_country_weight=location_country_weight,
            location_region_query=location_region_query,
            location_region_weight=location_region_weight,
            metadata_0_key=metadata_0_key,
            metadata_0_query=metadata_0_query,
            metadata_0_weight=metadata_0_weight,
            metadata_1_key=metadata_1_key,
            metadata_1_query=metadata_1_query,
            metadata_1_weight=metadata_1_weight,
            metadata_2_key=metadata_2_key,
            metadata_2_query=metadata_2_query,
            metadata_2_weight=metadata_2_weight,
            offset=offset,
            position_organization_query=position_organization_query,
            position_organization_weight=position_organization_weight,
            position_role_query=position_role_query,
            position_role_weight=position_role_weight,
            position_summary_query=position_summary_query,
            position_summary_weight=position_summary_weight,
            profile_first_name_query=profile_first_name_query,
            profile_first_name_weight=profile_first_name_weight,
            profile_goals_query=profile_goals_query,
            profile_goals_weight=profile_goals_weight,
            profile_headline_query=profile_headline_query,
            profile_headline_weight=profile_headline_weight,
            profile_industry_query=profile_industry_query,
            profile_industry_weight=profile_industry_weight,
            profile_last_name_query=profile_last_name_query,
            profile_last_name_weight=profile_last_name_weight,
            profile_pitch_query=profile_pitch_query,
            profile_pitch_weight=profile_pitch_weight,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EndpointPostUsersSearches",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _users_searches_post_serialize(
        self,
        active_within_x_days,
        audience_ids,
        bubbled,
        exclude_connections,
        exclude_matches,
        exclude_muted,
        exclude_skipped,
        geo_latitude,
        geo_longitude,
        geo_miles_away,
        group_id,
        limit,
        location_city_query,
        location_city_weight,
        location_country_query,
        location_country_weight,
        location_region_query,
        location_region_weight,
        metadata_0_key,
        metadata_0_query,
        metadata_0_weight,
        metadata_1_key,
        metadata_1_query,
        metadata_1_weight,
        metadata_2_key,
        metadata_2_query,
        metadata_2_weight,
        offset,
        position_organization_query,
        position_organization_weight,
        position_role_query,
        position_role_weight,
        position_summary_query,
        position_summary_weight,
        profile_first_name_query,
        profile_first_name_weight,
        profile_goals_query,
        profile_goals_weight,
        profile_headline_query,
        profile_headline_weight,
        profile_industry_query,
        profile_industry_weight,
        profile_last_name_query,
        profile_last_name_weight,
        profile_pitch_query,
        profile_pitch_weight,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'audience_ids[]': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if active_within_x_days is not None:
            _form_params.append(('active_within_x_days', active_within_x_days))
        if audience_ids is not None:
            _form_params.append(('audience_ids[]', audience_ids))
        if bubbled is not None:
            _form_params.append(('bubbled', bubbled))
        if exclude_connections is not None:
            _form_params.append(('exclude_connections', exclude_connections))
        if exclude_matches is not None:
            _form_params.append(('exclude_matches', exclude_matches))
        if exclude_muted is not None:
            _form_params.append(('exclude_muted', exclude_muted))
        if exclude_skipped is not None:
            _form_params.append(('exclude_skipped', exclude_skipped))
        if geo_latitude is not None:
            _form_params.append(('geo_latitude', geo_latitude))
        if geo_longitude is not None:
            _form_params.append(('geo_longitude', geo_longitude))
        if geo_miles_away is not None:
            _form_params.append(('geo_miles_away', geo_miles_away))
        if group_id is not None:
            _form_params.append(('group_id', group_id))
        if limit is not None:
            _form_params.append(('limit', limit))
        if location_city_query is not None:
            _form_params.append(('location_city_query', location_city_query))
        if location_city_weight is not None:
            _form_params.append(('location_city_weight', location_city_weight))
        if location_country_query is not None:
            _form_params.append(('location_country_query', location_country_query))
        if location_country_weight is not None:
            _form_params.append(('location_country_weight', location_country_weight))
        if location_region_query is not None:
            _form_params.append(('location_region_query', location_region_query))
        if location_region_weight is not None:
            _form_params.append(('location_region_weight', location_region_weight))
        if metadata_0_key is not None:
            _form_params.append(('metadata_0_key', metadata_0_key))
        if metadata_0_query is not None:
            _form_params.append(('metadata_0_query', metadata_0_query))
        if metadata_0_weight is not None:
            _form_params.append(('metadata_0_weight', metadata_0_weight))
        if metadata_1_key is not None:
            _form_params.append(('metadata_1_key', metadata_1_key))
        if metadata_1_query is not None:
            _form_params.append(('metadata_1_query', metadata_1_query))
        if metadata_1_weight is not None:
            _form_params.append(('metadata_1_weight', metadata_1_weight))
        if metadata_2_key is not None:
            _form_params.append(('metadata_2_key', metadata_2_key))
        if metadata_2_query is not None:
            _form_params.append(('metadata_2_query', metadata_2_query))
        if metadata_2_weight is not None:
            _form_params.append(('metadata_2_weight', metadata_2_weight))
        if offset is not None:
            _form_params.append(('offset', offset))
        if position_organization_query is not None:
            _form_params.append(('position_organization_query', position_organization_query))
        if position_organization_weight is not None:
            _form_params.append(('position_organization_weight', position_organization_weight))
        if position_role_query is not None:
            _form_params.append(('position_role_query', position_role_query))
        if position_role_weight is not None:
            _form_params.append(('position_role_weight', position_role_weight))
        if position_summary_query is not None:
            _form_params.append(('position_summary_query', position_summary_query))
        if position_summary_weight is not None:
            _form_params.append(('position_summary_weight', position_summary_weight))
        if profile_first_name_query is not None:
            _form_params.append(('profile_first_name_query', profile_first_name_query))
        if profile_first_name_weight is not None:
            _form_params.append(('profile_first_name_weight', profile_first_name_weight))
        if profile_goals_query is not None:
            _form_params.append(('profile_goals_query', profile_goals_query))
        if profile_goals_weight is not None:
            _form_params.append(('profile_goals_weight', profile_goals_weight))
        if profile_headline_query is not None:
            _form_params.append(('profile_headline_query', profile_headline_query))
        if profile_headline_weight is not None:
            _form_params.append(('profile_headline_weight', profile_headline_weight))
        if profile_industry_query is not None:
            _form_params.append(('profile_industry_query', profile_industry_query))
        if profile_industry_weight is not None:
            _form_params.append(('profile_industry_weight', profile_industry_weight))
        if profile_last_name_query is not None:
            _form_params.append(('profile_last_name_query', profile_last_name_query))
        if profile_last_name_weight is not None:
            _form_params.append(('profile_last_name_weight', profile_last_name_weight))
        if profile_pitch_query is not None:
            _form_params.append(('profile_pitch_query', profile_pitch_query))
        if profile_pitch_weight is not None:
            _form_params.append(('profile_pitch_weight', profile_pitch_weight))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'implicit_flow', 
            'explicit_flow'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/users/searches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


