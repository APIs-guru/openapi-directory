# coding: utf-8

"""
    GuestConfiguration

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2018-11-20
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class ConfigurationSetting(BaseModel):
    """
    Configuration setting of LCM (Local Configuration Manager).
    """ # noqa: E501
    action_after_reboot: Optional[StrictStr] = Field(default=None, description="Specifies what happens after a reboot during the application of a configuration. The possible values are ContinueConfiguration and StopConfiguration", alias="actionAfterReboot")
    allow_module_overwrite: Optional[StrictStr] = Field(default=None, description="If true - new configurations downloaded from the pull service are allowed to overwrite the old ones on the target node. Otherwise, false", alias="allowModuleOverwrite")
    configuration_mode: Optional[StrictStr] = Field(default=None, description="Specifies how the LCM(Local Configuration Manager) actually applies the configuration to the target nodes. Possible values are ApplyOnly, ApplyAndMonitor, and ApplyAndAutoCorrect.", alias="configurationMode")
    configuration_mode_frequency_mins: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="How often, in minutes, the current configuration is checked and applied. This property is ignored if the ConfigurationMode property is set to ApplyOnly. The default value is 15.", alias="configurationModeFrequencyMins")
    reboot_if_needed: Optional[StrictStr] = Field(default='False', description="Set this to true to automatically reboot the node after a configuration that requires reboot is applied. Otherwise, you will have to manually reboot the node for any configuration that requires it. The default value is false. To use this setting when a reboot condition is enacted by something other than DSC (such as Windows Installer), combine this setting with the xPendingReboot module.", alias="rebootIfNeeded")
    refresh_frequency_mins: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The time interval, in minutes, at which the LCM checks a pull service to get updated configurations. This value is ignored if the LCM is not configured in pull mode. The default value is 30.", alias="refreshFrequencyMins")
    __properties: ClassVar[List[str]] = ["actionAfterReboot", "allowModuleOverwrite", "configurationMode", "configurationModeFrequencyMins", "rebootIfNeeded", "refreshFrequencyMins"]

    @field_validator('action_after_reboot')
    def action_after_reboot_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ContinueConfiguration', 'StopConfiguration']):
            raise ValueError("must be one of enum values ('ContinueConfiguration', 'StopConfiguration')")
        return value

    @field_validator('allow_module_overwrite')
    def allow_module_overwrite_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['True', 'False']):
            raise ValueError("must be one of enum values ('True', 'False')")
        return value

    @field_validator('configuration_mode')
    def configuration_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ApplyOnly', 'ApplyAndMonitor', 'ApplyAndAutoCorrect']):
            raise ValueError("must be one of enum values ('ApplyOnly', 'ApplyAndMonitor', 'ApplyAndAutoCorrect')")
        return value

    @field_validator('reboot_if_needed')
    def reboot_if_needed_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['True', 'False']):
            raise ValueError("must be one of enum values ('True', 'False')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ConfigurationSetting from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "action_after_reboot",
            "configuration_mode",
            "configuration_mode_frequency_mins",
            "reboot_if_needed",
            "refresh_frequency_mins",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ConfigurationSetting from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "actionAfterReboot": obj.get("actionAfterReboot"),
            "allowModuleOverwrite": obj.get("allowModuleOverwrite"),
            "configurationMode": obj.get("configurationMode"),
            "configurationModeFrequencyMins": obj.get("configurationModeFrequencyMins"),
            "rebootIfNeeded": obj.get("rebootIfNeeded") if obj.get("rebootIfNeeded") is not None else 'False',
            "refreshFrequencyMins": obj.get("refreshFrequencyMins")
        })
        return _obj


