# coding: utf-8

"""
    Azure ML Web Services Management Client

    These APIs allow end users to operate on Azure Machine Learning Web Services resources. They support the following operations:<ul><li>Create or update a web service</li><li>Get a web service</li><li>Patch a web service</li><li>Delete a web service</li><li>Get All Web Services in a Resource Group </li><li>Get All Web Services in a Subscription</li><li>Get Web Services Keys</li></ul>

    The version of the OpenAPI document: 2017-01-01
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import ConfigDict
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.asset_item import AssetItem
from openapi_client.models.blob_location import BlobLocation
from openapi_client.models.commitment_plan import CommitmentPlan
from openapi_client.models.diagnostics_configuration import DiagnosticsConfiguration
from openapi_client.models.example_request import ExampleRequest
from openapi_client.models.graph_package import GraphPackage
from openapi_client.models.machine_learning_workspace import MachineLearningWorkspace
from openapi_client.models.realtime_configuration import RealtimeConfiguration
from openapi_client.models.service_input_output_specification import ServiceInputOutputSpecification
from openapi_client.models.storage_account import StorageAccount
from openapi_client.models.web_service_keys import WebServiceKeys
from openapi_client.models.web_service_parameter import WebServiceParameter
from openapi_client.models.web_service_properties import WebServiceProperties
from typing import Optional, Set
from typing_extensions import Self

class WebServicePropertiesForGraph(WebServiceProperties):
    """
    Properties specific to a Graph based web service.
    """ # noqa: E501
    package: Optional[GraphPackage] = None
    __properties: ClassVar[List[str]] = ["assets", "commitmentPlan", "createdOn", "description", "diagnostics", "exampleRequest", "exposeSampleData", "input", "keys", "machineLearningWorkspace", "modifiedOn", "output", "packageType", "parameters", "payloadsInBlobStorage", "payloadsLocation", "provisioningState", "readOnly", "realtimeConfiguration", "storageAccount", "swaggerLocation", "title"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of WebServicePropertiesForGraph from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in assets (dict)
        _field_dict = {}
        if self.assets:
            for _key_assets in self.assets:
                if self.assets[_key_assets]:
                    _field_dict[_key_assets] = self.assets[_key_assets].to_dict()
            _dict['assets'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of commitment_plan
        if self.commitment_plan:
            _dict['commitmentPlan'] = self.commitment_plan.to_dict()
        # override the default output from pydantic by calling `to_dict()` of diagnostics
        if self.diagnostics:
            _dict['diagnostics'] = self.diagnostics.to_dict()
        # override the default output from pydantic by calling `to_dict()` of example_request
        if self.example_request:
            _dict['exampleRequest'] = self.example_request.to_dict()
        # override the default output from pydantic by calling `to_dict()` of input
        if self.input:
            _dict['input'] = self.input.to_dict()
        # override the default output from pydantic by calling `to_dict()` of keys
        if self.keys:
            _dict['keys'] = self.keys.to_dict()
        # override the default output from pydantic by calling `to_dict()` of machine_learning_workspace
        if self.machine_learning_workspace:
            _dict['machineLearningWorkspace'] = self.machine_learning_workspace.to_dict()
        # override the default output from pydantic by calling `to_dict()` of output
        if self.output:
            _dict['output'] = self.output.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in parameters (dict)
        _field_dict = {}
        if self.parameters:
            for _key_parameters in self.parameters:
                if self.parameters[_key_parameters]:
                    _field_dict[_key_parameters] = self.parameters[_key_parameters].to_dict()
            _dict['parameters'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of payloads_location
        if self.payloads_location:
            _dict['payloadsLocation'] = self.payloads_location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of realtime_configuration
        if self.realtime_configuration:
            _dict['realtimeConfiguration'] = self.realtime_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of storage_account
        if self.storage_account:
            _dict['storageAccount'] = self.storage_account.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of WebServicePropertiesForGraph from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "assets": dict(
                (_k, AssetItem.from_dict(_v))
                for _k, _v in obj["assets"].items()
            )
            if obj.get("assets") is not None
            else None,
            "commitmentPlan": CommitmentPlan.from_dict(obj["commitmentPlan"]) if obj.get("commitmentPlan") is not None else None,
            "createdOn": obj.get("createdOn"),
            "description": obj.get("description"),
            "diagnostics": DiagnosticsConfiguration.from_dict(obj["diagnostics"]) if obj.get("diagnostics") is not None else None,
            "exampleRequest": ExampleRequest.from_dict(obj["exampleRequest"]) if obj.get("exampleRequest") is not None else None,
            "exposeSampleData": obj.get("exposeSampleData"),
            "input": ServiceInputOutputSpecification.from_dict(obj["input"]) if obj.get("input") is not None else None,
            "keys": WebServiceKeys.from_dict(obj["keys"]) if obj.get("keys") is not None else None,
            "machineLearningWorkspace": MachineLearningWorkspace.from_dict(obj["machineLearningWorkspace"]) if obj.get("machineLearningWorkspace") is not None else None,
            "modifiedOn": obj.get("modifiedOn"),
            "output": ServiceInputOutputSpecification.from_dict(obj["output"]) if obj.get("output") is not None else None,
            "packageType": obj.get("packageType"),
            "parameters": dict(
                (_k, WebServiceParameter.from_dict(_v))
                for _k, _v in obj["parameters"].items()
            )
            if obj.get("parameters") is not None
            else None,
            "payloadsInBlobStorage": obj.get("payloadsInBlobStorage"),
            "payloadsLocation": BlobLocation.from_dict(obj["payloadsLocation"]) if obj.get("payloadsLocation") is not None else None,
            "provisioningState": obj.get("provisioningState"),
            "readOnly": obj.get("readOnly"),
            "realtimeConfiguration": RealtimeConfiguration.from_dict(obj["realtimeConfiguration"]) if obj.get("realtimeConfiguration") is not None else None,
            "storageAccount": StorageAccount.from_dict(obj["storageAccount"]) if obj.get("storageAccount") is not None else None,
            "swaggerLocation": obj.get("swaggerLocation"),
            "title": obj.get("title")
        })
        return _obj


