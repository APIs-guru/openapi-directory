# coding: utf-8

"""
    Application Insights Data Plane

    This API exposes AI metric & event information and associated metadata

    The version of the OpenAPI document: 2018-04-20
    Contact: aiapi@microsoft.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.metric_id import MetricId
from typing import Optional, Set
from typing_extensions import Self

class MetricsPostBodySchemaParameters(BaseModel):
    """
    The parameters for a single metrics query
    """ # noqa: E501
    aggregation: Optional[Annotated[List[StrictStr], Field(min_length=1)]] = Field(default=None, description="The aggregation to use when computing the metric values. To retrieve more than one aggregation at a time, separate them with a comma. If no aggregation is specified, then the default aggregation for the metric is used.")
    filter: Optional[StrictStr] = Field(default=None, description="An expression used to filter the results.  This value should be a valid OData filter expression where the keys of each clause should be applicable dimensions for the metric you are retrieving.")
    interval: Optional[StrictStr] = Field(default=None, description="The time interval to use when retrieving metric values. This is an ISO8601 duration. If interval is omitted, the metric value is aggregated across the entire timespan. If interval is supplied, the server may adjust the interval to a more appropriate size based on the timespan used for the query. In all cases, the actual interval used for the query is included in the response.")
    metric_id: MetricId = Field(alias="metricId")
    orderby: Optional[StrictStr] = Field(default=None, description="The aggregation function and direction to sort the segments by.  This value is only valid when segment is specified.")
    segment: Optional[Annotated[List[StrictStr], Field(min_length=1)]] = Field(default=None, description="The name of the dimension to segment the metric values by. This dimension must be applicable to the metric you are retrieving. To segment by more than one dimension at a time, separate them with a comma (,). In this case, the metric data will be segmented in the order the dimensions are listed in the parameter.")
    timespan: Optional[StrictStr] = Field(default=None, description="The timespan over which to retrieve metric values. This is an ISO8601 time period value. If timespan is omitted, a default time range of `PT12H` (\"last 12 hours\") is used. The actual timespan that is queried may be adjusted by the server based. In all cases, the actual time span used for the query is included in the response.")
    top: Optional[StrictInt] = Field(default=None, description="The number of segments to return.  This value is only valid when segment is specified.")
    __properties: ClassVar[List[str]] = ["aggregation", "filter", "interval", "metricId", "orderby", "segment", "timespan", "top"]

    @field_validator('aggregation')
    def aggregation_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['min', 'max', 'avg', 'sum', 'count', 'unique']):
                raise ValueError("each list item must be one of ('min', 'max', 'avg', 'sum', 'count', 'unique')")
        return value

    @field_validator('segment')
    def segment_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['applicationBuild', 'applicationVersion', 'authenticatedOrAnonymousTraffic', 'browser', 'browserVersion', 'city', 'cloudRoleName', 'cloudServiceName', 'continent', 'countryOrRegion', 'deploymentId', 'deploymentUnit', 'deviceType', 'environment', 'hostingLocation', 'instanceName']):
                raise ValueError("each list item must be one of ('applicationBuild', 'applicationVersion', 'authenticatedOrAnonymousTraffic', 'browser', 'browserVersion', 'city', 'cloudRoleName', 'cloudServiceName', 'continent', 'countryOrRegion', 'deploymentId', 'deploymentUnit', 'deviceType', 'environment', 'hostingLocation', 'instanceName')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MetricsPostBodySchemaParameters from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MetricsPostBodySchemaParameters from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "aggregation": obj.get("aggregation"),
            "filter": obj.get("filter"),
            "interval": obj.get("interval"),
            "metricId": obj.get("metricId"),
            "orderby": obj.get("orderby"),
            "segment": obj.get("segment"),
            "timespan": obj.get("timespan"),
            "top": obj.get("top")
        })
        return _obj


