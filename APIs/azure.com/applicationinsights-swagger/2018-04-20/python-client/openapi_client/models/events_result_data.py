# coding: utf-8

"""
    Application Insights Data Plane

    This API exposes AI metric & event information and associated metadata

    The version of the OpenAPI document: 2018-04-20
    Contact: aiapi@microsoft.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from importlib import import_module
from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.event_type import EventType
from openapi_client.models.events_ai_info import EventsAiInfo
from openapi_client.models.events_application_info import EventsApplicationInfo
from openapi_client.models.events_client_info import EventsClientInfo
from openapi_client.models.events_cloud_info import EventsCloudInfo
from openapi_client.models.events_operation_info import EventsOperationInfo
from openapi_client.models.events_result_data_custom_dimensions import EventsResultDataCustomDimensions
from openapi_client.models.events_result_data_custom_measurements import EventsResultDataCustomMeasurements
from openapi_client.models.events_session_info import EventsSessionInfo
from openapi_client.models.events_user_info import EventsUserInfo
from typing import Optional, Set
from typing_extensions import Self

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from openapi_client.models.events_availability_result_result import EventsAvailabilityResultResult
    from openapi_client.models.events_browser_timing_result import EventsBrowserTimingResult
    from openapi_client.models.events_custom_event_result import EventsCustomEventResult
    from openapi_client.models.events_custom_metric_result import EventsCustomMetricResult
    from openapi_client.models.events_dependency_result import EventsDependencyResult
    from openapi_client.models.events_exception_result import EventsExceptionResult
    from openapi_client.models.events_page_view_result import EventsPageViewResult
    from openapi_client.models.events_performance_counter_result import EventsPerformanceCounterResult
    from openapi_client.models.events_request_result import EventsRequestResult
    from openapi_client.models.events_trace_result import EventsTraceResult

class EventsResultData(BaseModel):
    """
    Events query result data.
    """ # noqa: E501
    ai: Optional[EventsAiInfo] = None
    application: Optional[EventsApplicationInfo] = None
    client: Optional[EventsClientInfo] = None
    cloud: Optional[EventsCloudInfo] = None
    count: Optional[StrictInt] = Field(default=None, description="Count of the event")
    custom_dimensions: Optional[EventsResultDataCustomDimensions] = Field(default=None, alias="customDimensions")
    custom_measurements: Optional[EventsResultDataCustomMeasurements] = Field(default=None, alias="customMeasurements")
    id: Optional[StrictStr] = Field(default=None, description="The unique ID for this event.")
    operation: Optional[EventsOperationInfo] = None
    session: Optional[EventsSessionInfo] = None
    timestamp: Optional[datetime] = Field(default=None, description="Timestamp of the event")
    type: Optional[EventType] = None
    user: Optional[EventsUserInfo] = None
    __properties: ClassVar[List[str]] = ["ai", "application", "client", "cloud", "count", "customDimensions", "customMeasurements", "id", "operation", "session", "timestamp", "type", "user"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    # JSON field name that stores the object type
    __discriminator_property_name: ClassVar[str] = 'type'

    # discriminator mappings
    __discriminator_value_class_map: ClassVar[Dict[str, str]] = {
        'eventsAvailabilityResultResult': 'EventsAvailabilityResultResult','eventsBrowserTimingResult': 'EventsBrowserTimingResult','eventsCustomEventResult': 'EventsCustomEventResult','eventsCustomMetricResult': 'EventsCustomMetricResult','eventsDependencyResult': 'EventsDependencyResult','eventsExceptionResult': 'EventsExceptionResult','eventsPageViewResult': 'EventsPageViewResult','eventsPerformanceCounterResult': 'EventsPerformanceCounterResult','eventsRequestResult': 'EventsRequestResult','eventsTraceResult': 'EventsTraceResult'
    }

    @classmethod
    def get_discriminator_value(cls, obj: Dict[str, Any]) -> Optional[str]:
        """Returns the discriminator value (object type) of the data"""
        discriminator_value = obj[cls.__discriminator_property_name]
        if discriminator_value:
            return cls.__discriminator_value_class_map.get(discriminator_value)
        else:
            return None

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Union[EventsAvailabilityResultResult, EventsBrowserTimingResult, EventsCustomEventResult, EventsCustomMetricResult, EventsDependencyResult, EventsExceptionResult, EventsPageViewResult, EventsPerformanceCounterResult, EventsRequestResult, EventsTraceResult]]:
        """Create an instance of EventsResultData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of ai
        if self.ai:
            _dict['ai'] = self.ai.to_dict()
        # override the default output from pydantic by calling `to_dict()` of application
        if self.application:
            _dict['application'] = self.application.to_dict()
        # override the default output from pydantic by calling `to_dict()` of client
        if self.client:
            _dict['client'] = self.client.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud
        if self.cloud:
            _dict['cloud'] = self.cloud.to_dict()
        # override the default output from pydantic by calling `to_dict()` of custom_dimensions
        if self.custom_dimensions:
            _dict['customDimensions'] = self.custom_dimensions.to_dict()
        # override the default output from pydantic by calling `to_dict()` of custom_measurements
        if self.custom_measurements:
            _dict['customMeasurements'] = self.custom_measurements.to_dict()
        # override the default output from pydantic by calling `to_dict()` of operation
        if self.operation:
            _dict['operation'] = self.operation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of session
        if self.session:
            _dict['session'] = self.session.to_dict()
        # override the default output from pydantic by calling `to_dict()` of user
        if self.user:
            _dict['user'] = self.user.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict[str, Any]) -> Optional[Union[EventsAvailabilityResultResult, EventsBrowserTimingResult, EventsCustomEventResult, EventsCustomMetricResult, EventsDependencyResult, EventsExceptionResult, EventsPageViewResult, EventsPerformanceCounterResult, EventsRequestResult, EventsTraceResult]]:
        """Create an instance of EventsResultData from a dict"""
        # look up the object type based on discriminator mapping
        object_type = cls.get_discriminator_value(obj)
        if object_type ==  'EventsAvailabilityResultResult':
            return import_module("openapi_client.models.events_availability_result_result").EventsAvailabilityResultResult.from_dict(obj)
        if object_type ==  'EventsBrowserTimingResult':
            return import_module("openapi_client.models.events_browser_timing_result").EventsBrowserTimingResult.from_dict(obj)
        if object_type ==  'EventsCustomEventResult':
            return import_module("openapi_client.models.events_custom_event_result").EventsCustomEventResult.from_dict(obj)
        if object_type ==  'EventsCustomMetricResult':
            return import_module("openapi_client.models.events_custom_metric_result").EventsCustomMetricResult.from_dict(obj)
        if object_type ==  'EventsDependencyResult':
            return import_module("openapi_client.models.events_dependency_result").EventsDependencyResult.from_dict(obj)
        if object_type ==  'EventsExceptionResult':
            return import_module("openapi_client.models.events_exception_result").EventsExceptionResult.from_dict(obj)
        if object_type ==  'EventsPageViewResult':
            return import_module("openapi_client.models.events_page_view_result").EventsPageViewResult.from_dict(obj)
        if object_type ==  'EventsPerformanceCounterResult':
            return import_module("openapi_client.models.events_performance_counter_result").EventsPerformanceCounterResult.from_dict(obj)
        if object_type ==  'EventsRequestResult':
            return import_module("openapi_client.models.events_request_result").EventsRequestResult.from_dict(obj)
        if object_type ==  'EventsTraceResult':
            return import_module("openapi_client.models.events_trace_result").EventsTraceResult.from_dict(obj)

        raise ValueError("EventsResultData failed to lookup discriminator value from " +
                            json.dumps(obj) + ". Discriminator property name: " + cls.__discriminator_property_name +
                            ", mapping: " + json.dumps(cls.__discriminator_value_class_map))


