# coding: utf-8

"""
    DataLakeStoreFileSystemManagementClient

    Creates an Azure Data Lake Store filesystem client.

    The version of the OpenAPI document: 2015-10-01-preview
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Any, Dict, Optional
from typing_extensions import Annotated
from openapi_client.models.file_operation_result import FileOperationResult

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class FileSystemApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def file_system_check_access(
        self,
        path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the file or directory for which to check access.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        fsaction: Annotated[Optional[StrictStr], Field(description="File system operation read/write/execute in string form, matching regex pattern '[rwx-]{3}'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """file_system_check_access

        Checks if the specified access is available at the given path.

        :param path: The Data Lake Store path (starting with '/') of the file or directory for which to check access. (required)
        :type path: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param fsaction: File system operation read/write/execute in string form, matching regex pattern '[rwx-]{3}'
        :type fsaction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_check_access_serialize(
            path=path,
            op=op,
            api_version=api_version,
            fsaction=fsaction,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def file_system_check_access_with_http_info(
        self,
        path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the file or directory for which to check access.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        fsaction: Annotated[Optional[StrictStr], Field(description="File system operation read/write/execute in string form, matching regex pattern '[rwx-]{3}'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """file_system_check_access

        Checks if the specified access is available at the given path.

        :param path: The Data Lake Store path (starting with '/') of the file or directory for which to check access. (required)
        :type path: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param fsaction: File system operation read/write/execute in string form, matching regex pattern '[rwx-]{3}'
        :type fsaction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_check_access_serialize(
            path=path,
            op=op,
            api_version=api_version,
            fsaction=fsaction,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def file_system_check_access_without_preload_content(
        self,
        path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the file or directory for which to check access.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        fsaction: Annotated[Optional[StrictStr], Field(description="File system operation read/write/execute in string form, matching regex pattern '[rwx-]{3}'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """file_system_check_access

        Checks if the specified access is available at the given path.

        :param path: The Data Lake Store path (starting with '/') of the file or directory for which to check access. (required)
        :type path: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param fsaction: File system operation read/write/execute in string form, matching regex pattern '[rwx-]{3}'
        :type fsaction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_check_access_serialize(
            path=path,
            op=op,
            api_version=api_version,
            fsaction=fsaction,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _file_system_check_access_serialize(
        self,
        path,
        op,
        api_version,
        fsaction,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if path is not None:
            _path_params['path'] = path
        # process the query parameters
        if fsaction is not None:
            
            _query_params.append(('fsaction', fsaction))
            
        if op is not None:
            
            _query_params.append(('op', op))
            
        if api_version is not None:
            
            _query_params.append(('api-version', api_version))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/json', 
                    'application/octet-stream'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/webhdfs/v1/{path}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def file_system_concurrent_append(
        self,
        file_path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the file to which to append using concurrent append.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        transfer_encoding: Annotated[StrictStr, Field(description="Indicates the data being sent to the server is being streamed in chunks.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        stream_contents: Annotated[Dict[str, Any], Field(description="The file contents to include when appending to the file.  The maximum content size is 4MB.  For content larger than 4MB you must append the content in 4MB chunks.")],
        append_mode: Annotated[Optional[StrictStr], Field(description="Indicates the concurrent append call should create the file if it doesn't exist or just open the existing file for append")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """file_system_concurrent_append

        Appends to the specified file. This method supports multiple concurrent appends to the file. NOTE: ConcurrentAppend and normal (serial) Append CANNOT be used interchangeably; once a file has been appended to using either of these append options, it can only be appended to using that append option. ConcurrentAppend DOES NOT guarantee order and can result in duplicated data landing in the target file. In order to close a file after using ConcurrentAppend, call the Flush method.

        :param file_path: The Data Lake Store path (starting with '/') of the file to which to append using concurrent append. (required)
        :type file_path: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param transfer_encoding: Indicates the data being sent to the server is being streamed in chunks. (required)
        :type transfer_encoding: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param stream_contents: The file contents to include when appending to the file.  The maximum content size is 4MB.  For content larger than 4MB you must append the content in 4MB chunks. (required)
        :type stream_contents: object
        :param append_mode: Indicates the concurrent append call should create the file if it doesn't exist or just open the existing file for append
        :type append_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_concurrent_append_serialize(
            file_path=file_path,
            op=op,
            transfer_encoding=transfer_encoding,
            api_version=api_version,
            stream_contents=stream_contents,
            append_mode=append_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def file_system_concurrent_append_with_http_info(
        self,
        file_path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the file to which to append using concurrent append.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        transfer_encoding: Annotated[StrictStr, Field(description="Indicates the data being sent to the server is being streamed in chunks.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        stream_contents: Annotated[Dict[str, Any], Field(description="The file contents to include when appending to the file.  The maximum content size is 4MB.  For content larger than 4MB you must append the content in 4MB chunks.")],
        append_mode: Annotated[Optional[StrictStr], Field(description="Indicates the concurrent append call should create the file if it doesn't exist or just open the existing file for append")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """file_system_concurrent_append

        Appends to the specified file. This method supports multiple concurrent appends to the file. NOTE: ConcurrentAppend and normal (serial) Append CANNOT be used interchangeably; once a file has been appended to using either of these append options, it can only be appended to using that append option. ConcurrentAppend DOES NOT guarantee order and can result in duplicated data landing in the target file. In order to close a file after using ConcurrentAppend, call the Flush method.

        :param file_path: The Data Lake Store path (starting with '/') of the file to which to append using concurrent append. (required)
        :type file_path: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param transfer_encoding: Indicates the data being sent to the server is being streamed in chunks. (required)
        :type transfer_encoding: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param stream_contents: The file contents to include when appending to the file.  The maximum content size is 4MB.  For content larger than 4MB you must append the content in 4MB chunks. (required)
        :type stream_contents: object
        :param append_mode: Indicates the concurrent append call should create the file if it doesn't exist or just open the existing file for append
        :type append_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_concurrent_append_serialize(
            file_path=file_path,
            op=op,
            transfer_encoding=transfer_encoding,
            api_version=api_version,
            stream_contents=stream_contents,
            append_mode=append_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def file_system_concurrent_append_without_preload_content(
        self,
        file_path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the file to which to append using concurrent append.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        transfer_encoding: Annotated[StrictStr, Field(description="Indicates the data being sent to the server is being streamed in chunks.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        stream_contents: Annotated[Dict[str, Any], Field(description="The file contents to include when appending to the file.  The maximum content size is 4MB.  For content larger than 4MB you must append the content in 4MB chunks.")],
        append_mode: Annotated[Optional[StrictStr], Field(description="Indicates the concurrent append call should create the file if it doesn't exist or just open the existing file for append")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """file_system_concurrent_append

        Appends to the specified file. This method supports multiple concurrent appends to the file. NOTE: ConcurrentAppend and normal (serial) Append CANNOT be used interchangeably; once a file has been appended to using either of these append options, it can only be appended to using that append option. ConcurrentAppend DOES NOT guarantee order and can result in duplicated data landing in the target file. In order to close a file after using ConcurrentAppend, call the Flush method.

        :param file_path: The Data Lake Store path (starting with '/') of the file to which to append using concurrent append. (required)
        :type file_path: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param transfer_encoding: Indicates the data being sent to the server is being streamed in chunks. (required)
        :type transfer_encoding: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param stream_contents: The file contents to include when appending to the file.  The maximum content size is 4MB.  For content larger than 4MB you must append the content in 4MB chunks. (required)
        :type stream_contents: object
        :param append_mode: Indicates the concurrent append call should create the file if it doesn't exist or just open the existing file for append
        :type append_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_concurrent_append_serialize(
            file_path=file_path,
            op=op,
            transfer_encoding=transfer_encoding,
            api_version=api_version,
            stream_contents=stream_contents,
            append_mode=append_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _file_system_concurrent_append_serialize(
        self,
        file_path,
        op,
        transfer_encoding,
        api_version,
        stream_contents,
        append_mode,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_path is not None:
            _path_params['filePath'] = file_path
        # process the query parameters
        if append_mode is not None:
            
            _query_params.append(('appendMode', append_mode))
            
        if op is not None:
            
            _query_params.append(('op', op))
            
        if api_version is not None:
            
            _query_params.append(('api-version', api_version))
            
        # process the header parameters
        if transfer_encoding is not None:
            _header_params['Transfer-Encoding'] = transfer_encoding
        # process the form parameters
        # process the body parameter
        if stream_contents is not None:
            _body_params = stream_contents


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/json', 
                    'application/octet-stream'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/octet-stream'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/WebHdfsExt/{filePath}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def file_system_mkdirs(
        self,
        path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the directory to create.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileOperationResult:
        """file_system_mkdirs

        Creates a directory.

        :param path: The Data Lake Store path (starting with '/') of the directory to create. (required)
        :type path: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_mkdirs_serialize(
            path=path,
            op=op,
            api_version=api_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileOperationResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def file_system_mkdirs_with_http_info(
        self,
        path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the directory to create.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileOperationResult]:
        """file_system_mkdirs

        Creates a directory.

        :param path: The Data Lake Store path (starting with '/') of the directory to create. (required)
        :type path: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_mkdirs_serialize(
            path=path,
            op=op,
            api_version=api_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileOperationResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def file_system_mkdirs_without_preload_content(
        self,
        path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the directory to create.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """file_system_mkdirs

        Creates a directory.

        :param path: The Data Lake Store path (starting with '/') of the directory to create. (required)
        :type path: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_mkdirs_serialize(
            path=path,
            op=op,
            api_version=api_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileOperationResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _file_system_mkdirs_serialize(
        self,
        path,
        op,
        api_version,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if path is not None:
            _path_params['path'] = path
        # process the query parameters
        if op is not None:
            
            _query_params.append(('op', op))
            
        if api_version is not None:
            
            _query_params.append(('api-version', api_version))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/json', 
                    'application/octet-stream'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/webhdfs/v1/{path}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def file_system_set_file_expiry(
        self,
        file_path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the file on which to set or remove the expiration time.")],
        expiry_option: Annotated[StrictStr, Field(description="Indicates the type of expiration to use for the file: 1. NeverExpire: ExpireTime is ignored. 2. RelativeToNow: ExpireTime is an integer in milliseconds representing the expiration date relative to when file expiration is updated. 3. RelativeToCreationDate: ExpireTime is an integer in milliseconds representing the expiration date relative to file creation. 4. Absolute: ExpireTime is an integer in milliseconds, as a Unix timestamp relative to 1/1/1970 00:00:00.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        expire_time: Annotated[Optional[StrictInt], Field(description="The time that the file will expire, corresponding to the ExpiryOption that was set.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """file_system_set_file_expiry

        Sets or removes the expiration time on the specified file. This operation can only be executed against files. Folders are not supported.

        :param file_path: The Data Lake Store path (starting with '/') of the file on which to set or remove the expiration time. (required)
        :type file_path: str
        :param expiry_option: Indicates the type of expiration to use for the file: 1. NeverExpire: ExpireTime is ignored. 2. RelativeToNow: ExpireTime is an integer in milliseconds representing the expiration date relative to when file expiration is updated. 3. RelativeToCreationDate: ExpireTime is an integer in milliseconds representing the expiration date relative to file creation. 4. Absolute: ExpireTime is an integer in milliseconds, as a Unix timestamp relative to 1/1/1970 00:00:00. (required)
        :type expiry_option: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param expire_time: The time that the file will expire, corresponding to the ExpiryOption that was set.
        :type expire_time: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_set_file_expiry_serialize(
            file_path=file_path,
            expiry_option=expiry_option,
            op=op,
            api_version=api_version,
            expire_time=expire_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def file_system_set_file_expiry_with_http_info(
        self,
        file_path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the file on which to set or remove the expiration time.")],
        expiry_option: Annotated[StrictStr, Field(description="Indicates the type of expiration to use for the file: 1. NeverExpire: ExpireTime is ignored. 2. RelativeToNow: ExpireTime is an integer in milliseconds representing the expiration date relative to when file expiration is updated. 3. RelativeToCreationDate: ExpireTime is an integer in milliseconds representing the expiration date relative to file creation. 4. Absolute: ExpireTime is an integer in milliseconds, as a Unix timestamp relative to 1/1/1970 00:00:00.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        expire_time: Annotated[Optional[StrictInt], Field(description="The time that the file will expire, corresponding to the ExpiryOption that was set.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """file_system_set_file_expiry

        Sets or removes the expiration time on the specified file. This operation can only be executed against files. Folders are not supported.

        :param file_path: The Data Lake Store path (starting with '/') of the file on which to set or remove the expiration time. (required)
        :type file_path: str
        :param expiry_option: Indicates the type of expiration to use for the file: 1. NeverExpire: ExpireTime is ignored. 2. RelativeToNow: ExpireTime is an integer in milliseconds representing the expiration date relative to when file expiration is updated. 3. RelativeToCreationDate: ExpireTime is an integer in milliseconds representing the expiration date relative to file creation. 4. Absolute: ExpireTime is an integer in milliseconds, as a Unix timestamp relative to 1/1/1970 00:00:00. (required)
        :type expiry_option: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param expire_time: The time that the file will expire, corresponding to the ExpiryOption that was set.
        :type expire_time: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_set_file_expiry_serialize(
            file_path=file_path,
            expiry_option=expiry_option,
            op=op,
            api_version=api_version,
            expire_time=expire_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def file_system_set_file_expiry_without_preload_content(
        self,
        file_path: Annotated[StrictStr, Field(description="The Data Lake Store path (starting with '/') of the file on which to set or remove the expiration time.")],
        expiry_option: Annotated[StrictStr, Field(description="Indicates the type of expiration to use for the file: 1. NeverExpire: ExpireTime is ignored. 2. RelativeToNow: ExpireTime is an integer in milliseconds representing the expiration date relative to when file expiration is updated. 3. RelativeToCreationDate: ExpireTime is an integer in milliseconds representing the expiration date relative to file creation. 4. Absolute: ExpireTime is an integer in milliseconds, as a Unix timestamp relative to 1/1/1970 00:00:00.")],
        op: Annotated[StrictStr, Field(description="The constant value for the operation.")],
        api_version: Annotated[StrictStr, Field(description="Client Api Version.")],
        expire_time: Annotated[Optional[StrictInt], Field(description="The time that the file will expire, corresponding to the ExpiryOption that was set.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """file_system_set_file_expiry

        Sets or removes the expiration time on the specified file. This operation can only be executed against files. Folders are not supported.

        :param file_path: The Data Lake Store path (starting with '/') of the file on which to set or remove the expiration time. (required)
        :type file_path: str
        :param expiry_option: Indicates the type of expiration to use for the file: 1. NeverExpire: ExpireTime is ignored. 2. RelativeToNow: ExpireTime is an integer in milliseconds representing the expiration date relative to when file expiration is updated. 3. RelativeToCreationDate: ExpireTime is an integer in milliseconds representing the expiration date relative to file creation. 4. Absolute: ExpireTime is an integer in milliseconds, as a Unix timestamp relative to 1/1/1970 00:00:00. (required)
        :type expiry_option: str
        :param op: The constant value for the operation. (required)
        :type op: str
        :param api_version: Client Api Version. (required)
        :type api_version: str
        :param expire_time: The time that the file will expire, corresponding to the ExpiryOption that was set.
        :type expire_time: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._file_system_set_file_expiry_serialize(
            file_path=file_path,
            expiry_option=expiry_option,
            op=op,
            api_version=api_version,
            expire_time=expire_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _file_system_set_file_expiry_serialize(
        self,
        file_path,
        expiry_option,
        op,
        api_version,
        expire_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_path is not None:
            _path_params['filePath'] = file_path
        # process the query parameters
        if expiry_option is not None:
            
            _query_params.append(('expiryOption', expiry_option))
            
        if expire_time is not None:
            
            _query_params.append(('expireTime', expire_time))
            
        if op is not None:
            
            _query_params.append(('op', op))
            
        if api_version is not None:
            
            _query_params.append(('api-version', api_version))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/json', 
                    'application/octet-stream'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/WebHdfsExt/{filePath}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


