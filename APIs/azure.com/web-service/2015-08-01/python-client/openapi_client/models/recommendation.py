# coding: utf-8

"""
    WebSite Management Client

    Use these APIs to manage Azure Websites resources through the Azure Resource Manager. All task operations conform to the HTTP/1.1 protocol specification and each operation returns an x-ms-request-id header that can be used to obtain information about the request. You must make sure that requests made to these resources are secure. For more information, see https://msdn.microsoft.com/en-us/library/azure/dn790557.aspx.

    The version of the OpenAPI document: 2015-08-01
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class Recommendation(BaseModel):
    """
    Represents a recommendation result generated by the recommendation engine
    """ # noqa: E501
    action_name: Optional[StrictStr] = Field(default=None, description="Name of action recommended by this object.", alias="actionName")
    channels: StrictStr = Field(description="List of channels that this recommendation can apply.")
    creation_time: Optional[datetime] = Field(default=None, description="Timestamp when this instance was created.", alias="creationTime")
    display_name: Optional[StrictStr] = Field(default=None, description="UI friendly name of the rule (may not be unique)", alias="displayName")
    enabled: Optional[StrictInt] = Field(default=None, description="On/off flag indicating the rule is currently enabled or disabled.")
    end_time: Optional[datetime] = Field(default=None, description="The end time of a range that the recommendation refers to.", alias="endTime")
    level: StrictStr = Field(description="Level indicating how critical this recommendation can impact.")
    message: Optional[StrictStr] = Field(default=None, description="Localized text of recommendation, good for UI.")
    next_notification_time: Optional[datetime] = Field(default=None, description="When to notify this recommendation next. Null means that this will never be notified anymore.", alias="nextNotificationTime")
    notification_expiration_time: Optional[datetime] = Field(default=None, description="Date and time when this notification expires.", alias="notificationExpirationTime")
    notified_time: Optional[datetime] = Field(default=None, description="Last timestamp this instance was actually notified. Null means that this recommendation hasn't been notified yet.", alias="notifiedTime")
    recommendation_id: Optional[StrictStr] = Field(default=None, description="A GUID value that each recommendation object is associated with.", alias="recommendationId")
    resource_id: Optional[StrictStr] = Field(default=None, description="Full ARM resource ID string that this recommendation object is associated with.", alias="resourceId")
    resource_scope: Optional[StrictStr] = Field(default=None, description="Name of a resource type this recommendation applies, e.g. Subscription, ServerFarm, Site.", alias="resourceScope")
    rule_name: Optional[StrictStr] = Field(default=None, description="Unique name of the rule", alias="ruleName")
    score: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="A metric value measured by the rule.")
    start_time: Optional[datetime] = Field(default=None, description="The beginning time of a range that the recommendation refers to.", alias="startTime")
    tags: Optional[List[StrictStr]] = Field(default=None, description="The list of category tags that this recommendation belongs to.")
    __properties: ClassVar[List[str]] = ["actionName", "channels", "creationTime", "displayName", "enabled", "endTime", "level", "message", "nextNotificationTime", "notificationExpirationTime", "notifiedTime", "recommendationId", "resourceId", "resourceScope", "ruleName", "score", "startTime", "tags"]

    @field_validator('channels')
    def channels_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Notification', 'Api', 'Email', 'All']):
            raise ValueError("must be one of enum values ('Notification', 'Api', 'Email', 'All')")
        return value

    @field_validator('level')
    def level_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Critical', 'Warning', 'Information', 'NonUrgentSuggestion']):
            raise ValueError("must be one of enum values ('Critical', 'Warning', 'Information', 'NonUrgentSuggestion')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Recommendation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Recommendation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "actionName": obj.get("actionName"),
            "channels": obj.get("channels"),
            "creationTime": obj.get("creationTime"),
            "displayName": obj.get("displayName"),
            "enabled": obj.get("enabled"),
            "endTime": obj.get("endTime"),
            "level": obj.get("level"),
            "message": obj.get("message"),
            "nextNotificationTime": obj.get("nextNotificationTime"),
            "notificationExpirationTime": obj.get("notificationExpirationTime"),
            "notifiedTime": obj.get("notifiedTime"),
            "recommendationId": obj.get("recommendationId"),
            "resourceId": obj.get("resourceId"),
            "resourceScope": obj.get("resourceScope"),
            "ruleName": obj.get("ruleName"),
            "score": obj.get("score"),
            "startTime": obj.get("startTime"),
            "tags": obj.get("tags")
        })
        return _obj


