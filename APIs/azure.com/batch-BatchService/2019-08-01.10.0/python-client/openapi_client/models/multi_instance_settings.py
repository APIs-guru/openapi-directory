# coding: utf-8

"""
    BatchService

    A client for issuing REST requests to the Azure Batch service.

    The version of the OpenAPI document: 2019-08-01.10.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.resource_file import ResourceFile
from typing import Optional, Set
from typing_extensions import Self

class MultiInstanceSettings(BaseModel):
    """
    Multi-instance Tasks are commonly used to support MPI Tasks. In the MPI case, if any of the subtasks fail (for example due to exiting with a non-zero exit code) the entire multi-instance Task fails. The multi-instance Task is then terminated and retried, up to its retry limit.
    """ # noqa: E501
    common_resource_files: Optional[List[ResourceFile]] = Field(default=None, description="The difference between common resource files and Task resource files is that common resource files are downloaded for all subtasks including the primary, whereas Task resource files are downloaded only for the primary. Also note that these resource files are not downloaded to the Task working directory, but instead are downloaded to the Task root directory (one directory above the working directory).  There is a maximum size for the list of resource files.  When the max size is exceeded, the request will fail and the response error code will be RequestEntityTooLarge. If this occurs, the collection of ResourceFiles must be reduced in size. This can be achieved using .zip files, Application Packages, or Docker Containers.", alias="commonResourceFiles")
    coordination_command_line: StrictStr = Field(description="A typical coordination command line launches a background service and verifies that the service is ready to process inter-node messages.", alias="coordinationCommandLine")
    number_of_instances: Optional[StrictInt] = Field(default=None, description="If omitted, the default is 1.", alias="numberOfInstances")
    __properties: ClassVar[List[str]] = ["commonResourceFiles", "coordinationCommandLine", "numberOfInstances"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MultiInstanceSettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in common_resource_files (list)
        _items = []
        if self.common_resource_files:
            for _item_common_resource_files in self.common_resource_files:
                if _item_common_resource_files:
                    _items.append(_item_common_resource_files.to_dict())
            _dict['commonResourceFiles'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MultiInstanceSettings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "commonResourceFiles": [ResourceFile.from_dict(_item) for _item in obj["commonResourceFiles"]] if obj.get("commonResourceFiles") is not None else None,
            "coordinationCommandLine": obj.get("coordinationCommandLine"),
            "numberOfInstances": obj.get("numberOfInstances")
        })
        return _obj


