# coding: utf-8

"""
    BatchService

    A client for issuing REST requests to the Azure Batch service.

    The version of the OpenAPI document: 2019-06-01.9.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.container_configuration import ContainerConfiguration
from openapi_client.models.data_disk import DataDisk
from openapi_client.models.image_reference import ImageReference
from openapi_client.models.windows_configuration import WindowsConfiguration
from typing import Optional, Set
from typing_extensions import Self

class VirtualMachineConfiguration(BaseModel):
    """
    VirtualMachineConfiguration
    """ # noqa: E501
    container_configuration: Optional[ContainerConfiguration] = Field(default=None, alias="containerConfiguration")
    data_disks: Optional[List[DataDisk]] = Field(default=None, description="This property must be specified if the Compute Nodes in the Pool need to have empty data disks attached to them. This cannot be updated. Each Compute Node gets its own disk (the disk is not a file share). Existing disks cannot be attached, each attached disk is empty. When the Compute Node is removed from the Pool, the disk and all data associated with it is also deleted. The disk is not formatted after being attached, it must be formatted before use - for more information see https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux and https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.", alias="dataDisks")
    image_reference: ImageReference = Field(alias="imageReference")
    license_type: Optional[StrictStr] = Field(default=None, description="This only applies to Images that contain the Windows operating system, and should only be used when you hold valid on-premises licenses for the Compute Nodes which will be deployed. If omitted, no on-premises licensing discount is applied. Values are:   Windows_Server - The on-premises license is for Windows Server.  Windows_Client - The on-premises license is for Windows Client. ", alias="licenseType")
    node_agent_skuid: StrictStr = Field(description="The Batch Compute Node agent is a program that runs on each Compute Node in the Pool, and provides the command-and-control interface between the Compute Node and the Batch service. There are different implementations of the Compute Node agent, known as SKUs, for different operating systems. You must specify a Compute Node agent SKU which matches the selected Image reference. To get the list of supported Compute Node agent SKUs along with their list of verified Image references, see the 'List supported Compute Node agent SKUs' operation.", alias="nodeAgentSKUId")
    windows_configuration: Optional[WindowsConfiguration] = Field(default=None, alias="windowsConfiguration")
    __properties: ClassVar[List[str]] = ["containerConfiguration", "dataDisks", "imageReference", "licenseType", "nodeAgentSKUId", "windowsConfiguration"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VirtualMachineConfiguration from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of container_configuration
        if self.container_configuration:
            _dict['containerConfiguration'] = self.container_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in data_disks (list)
        _items = []
        if self.data_disks:
            for _item_data_disks in self.data_disks:
                if _item_data_disks:
                    _items.append(_item_data_disks.to_dict())
            _dict['dataDisks'] = _items
        # override the default output from pydantic by calling `to_dict()` of image_reference
        if self.image_reference:
            _dict['imageReference'] = self.image_reference.to_dict()
        # override the default output from pydantic by calling `to_dict()` of windows_configuration
        if self.windows_configuration:
            _dict['windowsConfiguration'] = self.windows_configuration.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VirtualMachineConfiguration from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "containerConfiguration": ContainerConfiguration.from_dict(obj["containerConfiguration"]) if obj.get("containerConfiguration") is not None else None,
            "dataDisks": [DataDisk.from_dict(_item) for _item in obj["dataDisks"]] if obj.get("dataDisks") is not None else None,
            "imageReference": ImageReference.from_dict(obj["imageReference"]) if obj.get("imageReference") is not None else None,
            "licenseType": obj.get("licenseType"),
            "nodeAgentSKUId": obj.get("nodeAgentSKUId"),
            "windowsConfiguration": WindowsConfiguration.from_dict(obj["windowsConfiguration"]) if obj.get("windowsConfiguration") is not None else None
        })
        return _obj


