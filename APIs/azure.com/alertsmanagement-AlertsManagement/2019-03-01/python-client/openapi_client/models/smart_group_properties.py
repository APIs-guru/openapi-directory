# coding: utf-8

"""
    Azure Alerts Management Service Resource Provider

    Azure Alerts Management Service provides a single pane of glass of alerts across Azure Monitor.

    The version of the OpenAPI document: 2019-03-01
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.smart_group_aggregated_property import SmartGroupAggregatedProperty
from typing import Optional, Set
from typing_extensions import Self

class SmartGroupProperties(BaseModel):
    """
    Properties of smart group.
    """ # noqa: E501
    alert_severities: Optional[List[SmartGroupAggregatedProperty]] = Field(default=None, description="Summary of alertSeverities in the smart group", alias="alertSeverities")
    alert_states: Optional[List[SmartGroupAggregatedProperty]] = Field(default=None, description="Summary of alertStates in the smart group", alias="alertStates")
    alerts_count: Optional[StrictInt] = Field(default=None, description="Total number of alerts in smart group", alias="alertsCount")
    last_modified_date_time: Optional[datetime] = Field(default=None, description="Last updated time of smart group. Date-Time in ISO-8601 format.", alias="lastModifiedDateTime")
    last_modified_user_name: Optional[StrictStr] = Field(default=None, description="Last modified by user name.", alias="lastModifiedUserName")
    monitor_conditions: Optional[List[SmartGroupAggregatedProperty]] = Field(default=None, description="Summary of monitorConditions in the smart group", alias="monitorConditions")
    monitor_services: Optional[List[SmartGroupAggregatedProperty]] = Field(default=None, description="Summary of monitorServices in the smart group", alias="monitorServices")
    next_link: Optional[StrictStr] = Field(default=None, description="The URI to fetch the next page of alerts. Call ListNext() with this URI to fetch the next page alerts.", alias="nextLink")
    resource_groups: Optional[List[SmartGroupAggregatedProperty]] = Field(default=None, description="Summary of target resource groups in the smart group", alias="resourceGroups")
    resource_types: Optional[List[SmartGroupAggregatedProperty]] = Field(default=None, description="Summary of target resource types in the smart group", alias="resourceTypes")
    resources: Optional[List[SmartGroupAggregatedProperty]] = Field(default=None, description="Summary of target resources in the smart group")
    severity: Optional[StrictStr] = Field(default=None, description="Severity of smart group is the highest(Sev0 >... > Sev4) severity of all the alerts in the group.")
    smart_group_state: Optional[StrictStr] = Field(default=None, description="Smart group state", alias="smartGroupState")
    start_date_time: Optional[datetime] = Field(default=None, description="Creation time of smart group. Date-Time in ISO-8601 format.", alias="startDateTime")
    __properties: ClassVar[List[str]] = ["alertSeverities", "alertStates", "alertsCount", "lastModifiedDateTime", "lastModifiedUserName", "monitorConditions", "monitorServices", "nextLink", "resourceGroups", "resourceTypes", "resources", "severity", "smartGroupState", "startDateTime"]

    @field_validator('severity')
    def severity_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Sev0', 'Sev1', 'Sev2', 'Sev3', 'Sev4']):
            raise ValueError("must be one of enum values ('Sev0', 'Sev1', 'Sev2', 'Sev3', 'Sev4')")
        return value

    @field_validator('smart_group_state')
    def smart_group_state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['New', 'Acknowledged', 'Closed']):
            raise ValueError("must be one of enum values ('New', 'Acknowledged', 'Closed')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SmartGroupProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "last_modified_date_time",
            "last_modified_user_name",
            "severity",
            "smart_group_state",
            "start_date_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in alert_severities (list)
        _items = []
        if self.alert_severities:
            for _item_alert_severities in self.alert_severities:
                if _item_alert_severities:
                    _items.append(_item_alert_severities.to_dict())
            _dict['alertSeverities'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in alert_states (list)
        _items = []
        if self.alert_states:
            for _item_alert_states in self.alert_states:
                if _item_alert_states:
                    _items.append(_item_alert_states.to_dict())
            _dict['alertStates'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in monitor_conditions (list)
        _items = []
        if self.monitor_conditions:
            for _item_monitor_conditions in self.monitor_conditions:
                if _item_monitor_conditions:
                    _items.append(_item_monitor_conditions.to_dict())
            _dict['monitorConditions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in monitor_services (list)
        _items = []
        if self.monitor_services:
            for _item_monitor_services in self.monitor_services:
                if _item_monitor_services:
                    _items.append(_item_monitor_services.to_dict())
            _dict['monitorServices'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in resource_groups (list)
        _items = []
        if self.resource_groups:
            for _item_resource_groups in self.resource_groups:
                if _item_resource_groups:
                    _items.append(_item_resource_groups.to_dict())
            _dict['resourceGroups'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in resource_types (list)
        _items = []
        if self.resource_types:
            for _item_resource_types in self.resource_types:
                if _item_resource_types:
                    _items.append(_item_resource_types.to_dict())
            _dict['resourceTypes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in resources (list)
        _items = []
        if self.resources:
            for _item_resources in self.resources:
                if _item_resources:
                    _items.append(_item_resources.to_dict())
            _dict['resources'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SmartGroupProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "alertSeverities": [SmartGroupAggregatedProperty.from_dict(_item) for _item in obj["alertSeverities"]] if obj.get("alertSeverities") is not None else None,
            "alertStates": [SmartGroupAggregatedProperty.from_dict(_item) for _item in obj["alertStates"]] if obj.get("alertStates") is not None else None,
            "alertsCount": obj.get("alertsCount"),
            "lastModifiedDateTime": obj.get("lastModifiedDateTime"),
            "lastModifiedUserName": obj.get("lastModifiedUserName"),
            "monitorConditions": [SmartGroupAggregatedProperty.from_dict(_item) for _item in obj["monitorConditions"]] if obj.get("monitorConditions") is not None else None,
            "monitorServices": [SmartGroupAggregatedProperty.from_dict(_item) for _item in obj["monitorServices"]] if obj.get("monitorServices") is not None else None,
            "nextLink": obj.get("nextLink"),
            "resourceGroups": [SmartGroupAggregatedProperty.from_dict(_item) for _item in obj["resourceGroups"]] if obj.get("resourceGroups") is not None else None,
            "resourceTypes": [SmartGroupAggregatedProperty.from_dict(_item) for _item in obj["resourceTypes"]] if obj.get("resourceTypes") is not None else None,
            "resources": [SmartGroupAggregatedProperty.from_dict(_item) for _item in obj["resources"]] if obj.get("resources") is not None else None,
            "severity": obj.get("severity"),
            "smartGroupState": obj.get("smartGroupState"),
            "startDateTime": obj.get("startDateTime")
        })
        return _obj


