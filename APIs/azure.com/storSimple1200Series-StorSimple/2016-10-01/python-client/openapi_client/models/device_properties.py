# coding: utf-8

"""
    StorSimpleManagementClient

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2016-10-01
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.device_details import DeviceDetails
from typing import Optional, Set
from typing_extensions import Self

class DeviceProperties(BaseModel):
    """
    Encases all the properties of the Device
    """ # noqa: E501
    activation_time: Optional[datetime] = Field(default=None, description="The UTC time at which the device was activated", alias="activationTime")
    allowed_device_operations: Optional[List[StrictStr]] = Field(default=None, description="Operations that are allowed on the device based on its current state", alias="allowedDeviceOperations")
    culture: Optional[StrictStr] = Field(default=None, description="Language culture setting on the device. For eg: \"en-US\"")
    details: Optional[DeviceDetails] = None
    device_capabilities: Optional[List[StrictStr]] = Field(default=None, description="Device can be configured either as FileServer or IscsiServer", alias="deviceCapabilities")
    device_configuration_status: Optional[StrictStr] = Field(default=None, description="\"Complete\" if the device has been successfully registered as File/IscsiServer and the creation of share/volume is complete, \"Pending\" if the device is only registered but the creation of share/volume is complete is still pending", alias="deviceConfigurationStatus")
    device_description: Optional[StrictStr] = Field(default=None, description="Short description given for the device", alias="deviceDescription")
    device_software_version: Optional[StrictStr] = Field(default=None, description="Version number of the software running on the device", alias="deviceSoftwareVersion")
    domain_name: Optional[StrictStr] = Field(default=None, description="Fully qualified name of the domain to which the device is attached", alias="domainName")
    friendly_software_name: Optional[StrictStr] = Field(default=None, description="Friendly name for the software version", alias="friendlySoftwareName")
    model_description: Optional[StrictStr] = Field(default=None, description="Name of the device model", alias="modelDescription")
    status: Optional[StrictStr] = Field(default=None, description="Current status of the device")
    type: Optional[StrictStr] = Field(default=None, description="Type of the device")
    __properties: ClassVar[List[str]] = ["activationTime", "allowedDeviceOperations", "culture", "details", "deviceCapabilities", "deviceConfigurationStatus", "deviceDescription", "deviceSoftwareVersion", "domainName", "friendlySoftwareName", "modelDescription", "status", "type"]

    @field_validator('allowed_device_operations')
    def allowed_device_operations_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['None', 'Delete', 'DeleteWithWarning', 'DRSource', 'DRTarget', 'Browsable', 'ReadOnlyForDR', 'Deactivate']):
                raise ValueError("each list item must be one of ('None', 'Delete', 'DeleteWithWarning', 'DRSource', 'DRTarget', 'Browsable', 'ReadOnlyForDR', 'Deactivate')")
        return value

    @field_validator('device_capabilities')
    def device_capabilities_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Invalid', 'FileServer', 'IscsiServer']):
                raise ValueError("each list item must be one of ('Invalid', 'FileServer', 'IscsiServer')")
        return value

    @field_validator('device_configuration_status')
    def device_configuration_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Complete', 'Pending']):
            raise ValueError("must be one of enum values ('Complete', 'Pending')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Unknown', 'Online', 'Offline', 'RequiresAttention', 'MaintenanceMode', 'Creating', 'Provisioning', 'Deleted', 'ReadyToSetup', 'Deactivated', 'Deactivating']):
            raise ValueError("must be one of enum values ('Unknown', 'Online', 'Offline', 'RequiresAttention', 'MaintenanceMode', 'Creating', 'Provisioning', 'Deleted', 'ReadyToSetup', 'Deactivated', 'Deactivating')")
        return value

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Invalid', 'Appliance', 'VirtualAppliance', 'Series9000OnPremVirtualAppliance', 'Series9000VirtualAppliance', 'Series9000PhysicalAppliance']):
            raise ValueError("must be one of enum values ('Invalid', 'Appliance', 'VirtualAppliance', 'Series9000OnPremVirtualAppliance', 'Series9000VirtualAppliance', 'Series9000PhysicalAppliance')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DeviceProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of details
        if self.details:
            _dict['details'] = self.details.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DeviceProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "activationTime": obj.get("activationTime"),
            "allowedDeviceOperations": obj.get("allowedDeviceOperations"),
            "culture": obj.get("culture"),
            "details": DeviceDetails.from_dict(obj["details"]) if obj.get("details") is not None else None,
            "deviceCapabilities": obj.get("deviceCapabilities"),
            "deviceConfigurationStatus": obj.get("deviceConfigurationStatus"),
            "deviceDescription": obj.get("deviceDescription"),
            "deviceSoftwareVersion": obj.get("deviceSoftwareVersion"),
            "domainName": obj.get("domainName"),
            "friendlySoftwareName": obj.get("friendlySoftwareName"),
            "modelDescription": obj.get("modelDescription"),
            "status": obj.get("status"),
            "type": obj.get("type")
        })
        return _obj


