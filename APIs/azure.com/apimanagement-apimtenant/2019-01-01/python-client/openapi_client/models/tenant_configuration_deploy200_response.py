# coding: utf-8

"""
    ApiManagementClient

    Use these REST APIs for performing operations on tenant entity associated with your Azure API Management deployment. Using this entity you can manage properties and configuration that apply to the entire API Management service instance.

    The version of the OpenAPI document: 2019-01-01
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.tenant_access_get_default_response_error import TenantAccessGetDefaultResponseError
from openapi_client.models.tenant_configuration_deploy200_response_action_log_inner import TenantConfigurationDeploy200ResponseActionLogInner
from typing import Optional, Set
from typing_extensions import Self

class TenantConfigurationDeploy200Response(BaseModel):
    """
    Operation Result.
    """ # noqa: E501
    action_log: Optional[List[TenantConfigurationDeploy200ResponseActionLogInner]] = Field(default=None, description="This property if only provided as part of the TenantConfiguration_Validate operation. It contains the log the entities which will be updated/created/deleted as part of the TenantConfiguration_Deploy operation.", alias="actionLog")
    error: Optional[TenantAccessGetDefaultResponseError] = None
    id: Optional[StrictStr] = Field(default=None, description="Operation result identifier.")
    result_info: Optional[StrictStr] = Field(default=None, description="Optional result info.", alias="resultInfo")
    started: Optional[datetime] = Field(default=None, description="Start time of an async operation. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard. ")
    status: Optional[StrictStr] = Field(default=None, description="Status of an async operation.")
    updated: Optional[datetime] = Field(default=None, description="Last update time of an async operation. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard. ")
    __properties: ClassVar[List[str]] = ["actionLog", "error", "id", "resultInfo", "started", "status", "updated"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Started', 'InProgress', 'Succeeded', 'Failed']):
            raise ValueError("must be one of enum values ('Started', 'InProgress', 'Succeeded', 'Failed')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TenantConfigurationDeploy200Response from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "action_log",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in action_log (list)
        _items = []
        if self.action_log:
            for _item_action_log in self.action_log:
                if _item_action_log:
                    _items.append(_item_action_log.to_dict())
            _dict['actionLog'] = _items
        # override the default output from pydantic by calling `to_dict()` of error
        if self.error:
            _dict['error'] = self.error.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TenantConfigurationDeploy200Response from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "actionLog": [TenantConfigurationDeploy200ResponseActionLogInner.from_dict(_item) for _item in obj["actionLog"]] if obj.get("actionLog") is not None else None,
            "error": TenantAccessGetDefaultResponseError.from_dict(obj["error"]) if obj.get("error") is not None else None,
            "id": obj.get("id"),
            "resultInfo": obj.get("resultInfo"),
            "started": obj.get("started"),
            "status": obj.get("status"),
            "updated": obj.get("updated")
        })
        return _obj


