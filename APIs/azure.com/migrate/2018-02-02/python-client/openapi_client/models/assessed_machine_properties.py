# coding: utf-8

"""
    Azure Migrate

    Move your workloads to Azure.

    The version of the OpenAPI document: 2018-02-02
    Contact: azuremigrate@microsoft.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.assessed_disk import AssessedDisk
from openapi_client.models.assessed_network_adapter import AssessedNetworkAdapter
from typing import Optional, Set
from typing_extensions import Self

class AssessedMachineProperties(BaseModel):
    """
    Properties of an assessed machine.
    """ # noqa: E501
    boot_type: Optional[StrictStr] = Field(default=None, description="Boot type of the machine.", alias="bootType")
    created_timestamp: Optional[datetime] = Field(default=None, description="Time when this machine was created. Date-Time represented in ISO-8601 format.", alias="createdTimestamp")
    datacenter_container: Optional[StrictStr] = Field(default=None, description="Container defined in the management solution that this machine is part of in the datacenter.", alias="datacenterContainer")
    datacenter_machine_id: Optional[StrictStr] = Field(default=None, description="ID of the machine as tracked by the datacenter management solution.", alias="datacenterMachineId")
    datacenter_management_server: Optional[StrictStr] = Field(default=None, description="Name of the server hosting the datacenter management solution.", alias="datacenterManagementServer")
    datacenter_management_server_id: Optional[StrictStr] = Field(default=None, description="ID of the server hosting the datacenter management solution.", alias="datacenterManagementServerId")
    description: Optional[StrictStr] = Field(default=None, description="Description of the machine")
    discovered_timestamp: Optional[datetime] = Field(default=None, description="Time when this machine was discovered by Azure Migrate agent. Date-Time represented in ISO-8601 format.", alias="discoveredTimestamp")
    disks: Optional[Dict[str, AssessedDisk]] = Field(default=None, description="Dictionary of disks attached to the machine. Key is ID of disk. Value is a disk object.")
    display_name: Optional[StrictStr] = Field(default=None, description="User readable name of the machine as defined by the user in their private datacenter.", alias="displayName")
    groups: Optional[List[StrictStr]] = Field(default=None, description="List of references to the groups that the machine is member of.")
    megabytes_of_memory: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Memory in Megabytes.", alias="megabytesOfMemory")
    megabytes_of_memory_for_recommended_size: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Megabytes of memory in the Recommended Azure VM Size.", alias="megabytesOfMemoryForRecommendedSize")
    monthly_bandwidth_cost: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Monthly network cost estimate for the network adapters that are attached to this machine as a group, for a 31-day month.", alias="monthlyBandwidthCost")
    monthly_compute_cost_for_recommended_size: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Compute Cost for a 31-day month, if the machine is migrated to Azure with the Recommended Size.", alias="monthlyComputeCostForRecommendedSize")
    monthly_storage_cost: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Monthly storage cost estimate for the disks that are attached to this machine as a group, for a 31-day month.", alias="monthlyStorageCost")
    network_adapters: Optional[Dict[str, AssessedNetworkAdapter]] = Field(default=None, description="Dictionary of network adapters attached to the machine. Key is name of the adapter. Value is a network adapter object.", alias="networkAdapters")
    number_of_cores: Optional[StrictInt] = Field(default=None, description="Processor count.", alias="numberOfCores")
    number_of_cores_for_recommended_size: Optional[StrictInt] = Field(default=None, description="Number of CPU cores in the Recommended Azure VM Size.", alias="numberOfCoresForRecommendedSize")
    operating_system: Optional[StrictStr] = Field(default=None, description="Operating System of the machine.", alias="operatingSystem")
    percentage_cores_utilization: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Utilization percentage of the processor core as observed in the private data center, in the Time Range selected on Assessment, reported as the Percentile value based on the percentile number selected in assessment.", alias="percentageCoresUtilization")
    percentage_cores_utilization_data_points_expected: Optional[StrictInt] = Field(default=None, description="Expected data points for percentage of cores utilization.", alias="percentageCoresUtilizationDataPointsExpected")
    percentage_cores_utilization_data_points_received: Optional[StrictInt] = Field(default=None, description="Received data points for percentage of cores utilization.", alias="percentageCoresUtilizationDataPointsReceived")
    percentage_memory_utilization: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Utilization percentage of the memory as observed in the private data center, in the Time Range selected on Assessment, reported as the Percentile value based on the percentile number selected in assessment.", alias="percentageMemoryUtilization")
    percentage_memory_utilization_data_points_expected: Optional[StrictInt] = Field(default=None, description="Expected data points for percentage of memory utilization.", alias="percentageMemoryUtilizationDataPointsExpected")
    percentage_memory_utilization_data_points_received: Optional[StrictInt] = Field(default=None, description="Received data points for percentage of memory utilization.", alias="percentageMemoryUtilizationDataPointsReceived")
    recommended_size: Optional[StrictStr] = Field(default=None, description="Recommended Azure size for this machine.", alias="recommendedSize")
    suitability: Optional[StrictStr] = Field(default=None, description="Whether machine is suitable for migration to Azure.")
    suitability_explanation: Optional[StrictStr] = Field(default=None, description="If machine is not ready to be migrated, this explains the reasons and mitigation steps.", alias="suitabilityExplanation")
    updated_timestamp: Optional[datetime] = Field(default=None, description="Time when this machine was last updated. Date-Time represented in ISO-8601 format.", alias="updatedTimestamp")
    __properties: ClassVar[List[str]] = ["bootType", "createdTimestamp", "datacenterContainer", "datacenterMachineId", "datacenterManagementServer", "datacenterManagementServerId", "description", "discoveredTimestamp", "disks", "displayName", "groups", "megabytesOfMemory", "megabytesOfMemoryForRecommendedSize", "monthlyBandwidthCost", "monthlyComputeCostForRecommendedSize", "monthlyStorageCost", "networkAdapters", "numberOfCores", "numberOfCoresForRecommendedSize", "operatingSystem", "percentageCoresUtilization", "percentageCoresUtilizationDataPointsExpected", "percentageCoresUtilizationDataPointsReceived", "percentageMemoryUtilization", "percentageMemoryUtilizationDataPointsExpected", "percentageMemoryUtilizationDataPointsReceived", "recommendedSize", "suitability", "suitabilityExplanation", "updatedTimestamp"]

    @field_validator('boot_type')
    def boot_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Unknown', 'EFI', 'BIOS']):
            raise ValueError("must be one of enum values ('Unknown', 'EFI', 'BIOS')")
        return value

    @field_validator('recommended_size')
    def recommended_size_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Unknown', 'Basic_A0', 'Basic_A1', 'Basic_A2', 'Basic_A3', 'Basic_A4', 'Standard_A0', 'Standard_A1', 'Standard_A2', 'Standard_A3', 'Standard_A4', 'Standard_A5', 'Standard_A6', 'Standard_A7', 'Standard_A8', 'Standard_A9', 'Standard_A10', 'Standard_A11', 'Standard_A1_v2', 'Standard_A2_v2', 'Standard_A4_v2', 'Standard_A8_v2', 'Standard_A2m_v2', 'Standard_A4m_v2', 'Standard_A8m_v2', 'Standard_D1', 'Standard_D2', 'Standard_D3', 'Standard_D4', 'Standard_D11', 'Standard_D12', 'Standard_D13', 'Standard_D14', 'Standard_D1_v2', 'Standard_D2_v2', 'Standard_D3_v2', 'Standard_D4_v2', 'Standard_D5_v2', 'Standard_D11_v2', 'Standard_D12_v2', 'Standard_D13_v2', 'Standard_D14_v2', 'Standard_D15_v2', 'Standard_DS1', 'Standard_DS2', 'Standard_DS3', 'Standard_DS4', 'Standard_DS11', 'Standard_DS12', 'Standard_DS13', 'Standard_DS14', 'Standard_DS1_v2', 'Standard_DS2_v2', 'Standard_DS3_v2', 'Standard_DS4_v2', 'Standard_DS5_v2', 'Standard_DS11_v2', 'Standard_DS12_v2', 'Standard_DS13_v2', 'Standard_DS14_v2', 'Standard_DS15_v2', 'Standard_F1', 'Standard_F2', 'Standard_F4', 'Standard_F8', 'Standard_F16', 'Standard_F1s', 'Standard_F2s', 'Standard_F4s', 'Standard_F8s', 'Standard_F16s', 'Standard_G1', 'Standard_G2', 'Standard_G3', 'Standard_G4', 'Standard_G5', 'Standard_GS1', 'Standard_GS2', 'Standard_GS3', 'Standard_GS4', 'Standard_GS5', 'Standard_H8', 'Standard_H16', 'Standard_H8m', 'Standard_H16m', 'Standard_H16r', 'Standard_H16mr', 'Standard_L4s', 'Standard_L8s', 'Standard_L16s', 'Standard_L32s']):
            raise ValueError("must be one of enum values ('Unknown', 'Basic_A0', 'Basic_A1', 'Basic_A2', 'Basic_A3', 'Basic_A4', 'Standard_A0', 'Standard_A1', 'Standard_A2', 'Standard_A3', 'Standard_A4', 'Standard_A5', 'Standard_A6', 'Standard_A7', 'Standard_A8', 'Standard_A9', 'Standard_A10', 'Standard_A11', 'Standard_A1_v2', 'Standard_A2_v2', 'Standard_A4_v2', 'Standard_A8_v2', 'Standard_A2m_v2', 'Standard_A4m_v2', 'Standard_A8m_v2', 'Standard_D1', 'Standard_D2', 'Standard_D3', 'Standard_D4', 'Standard_D11', 'Standard_D12', 'Standard_D13', 'Standard_D14', 'Standard_D1_v2', 'Standard_D2_v2', 'Standard_D3_v2', 'Standard_D4_v2', 'Standard_D5_v2', 'Standard_D11_v2', 'Standard_D12_v2', 'Standard_D13_v2', 'Standard_D14_v2', 'Standard_D15_v2', 'Standard_DS1', 'Standard_DS2', 'Standard_DS3', 'Standard_DS4', 'Standard_DS11', 'Standard_DS12', 'Standard_DS13', 'Standard_DS14', 'Standard_DS1_v2', 'Standard_DS2_v2', 'Standard_DS3_v2', 'Standard_DS4_v2', 'Standard_DS5_v2', 'Standard_DS11_v2', 'Standard_DS12_v2', 'Standard_DS13_v2', 'Standard_DS14_v2', 'Standard_DS15_v2', 'Standard_F1', 'Standard_F2', 'Standard_F4', 'Standard_F8', 'Standard_F16', 'Standard_F1s', 'Standard_F2s', 'Standard_F4s', 'Standard_F8s', 'Standard_F16s', 'Standard_G1', 'Standard_G2', 'Standard_G3', 'Standard_G4', 'Standard_G5', 'Standard_GS1', 'Standard_GS2', 'Standard_GS3', 'Standard_GS4', 'Standard_GS5', 'Standard_H8', 'Standard_H16', 'Standard_H8m', 'Standard_H16m', 'Standard_H16r', 'Standard_H16mr', 'Standard_L4s', 'Standard_L8s', 'Standard_L16s', 'Standard_L32s')")
        return value

    @field_validator('suitability')
    def suitability_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Unknown', 'NotSuitable', 'Suitable', 'ConditionallySuitable', 'ReadinessUnknown']):
            raise ValueError("must be one of enum values ('Unknown', 'NotSuitable', 'Suitable', 'ConditionallySuitable', 'ReadinessUnknown')")
        return value

    @field_validator('suitability_explanation')
    def suitability_explanation_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Unknown', 'NotApplicable', 'GuestOperatingSystemArchitectureNotSupported', 'GuestOperatingSystemNotSupported', 'BootTypeNotSupported', 'MoreDisksThanSupported', 'NoSuitableVmSizeFound', 'OneOrMoreDisksNotSuitable', 'OneOrMoreAdaptersNotSuitable', 'InternalErrorOccuredDuringComputeEvaluation', 'InternalErrorOccuredDuringStorageEvaluation', 'InternalErrorOccuredDuringNetworkEvaluation', 'NoVmSizeSupportsStoragePerformance', 'NoVmSizeSupportsNetworkPerformance', 'NoVmSizeForSelectedPricingTier', 'NoVmSizeForSelectedAzureLocation', 'CheckRedHatLinuxVersion', 'CheckOpenSuseLinuxVersion', 'CheckWindowsServer2008R2Version', 'CheckCentOsVersion', 'CheckDebianLinuxVersion', 'CheckSuseLinuxVersion', 'CheckOracleLinuxVersion', 'CheckUbuntuLinuxVersion', 'CheckCoreOsLinuxVersion', 'WindowsServerVersionConditionallySupported', 'NoGuestOperatingSystemConditionallySupported', 'WindowsClientVersionsConditionallySupported', 'BootTypeUnknown', 'GuestOperatingSystemUnknown', 'WindowsServerVersionsSupportedWithCaveat', 'WindowsOSNoLongerUnderMSSupport', 'EndorsedWithConditionsLinuxDistributions', 'UnendorsedLinuxDistributions', 'NoVmSizeForStandardPricingTier', 'NoVmSizeForBasicPricingTier']):
            raise ValueError("must be one of enum values ('Unknown', 'NotApplicable', 'GuestOperatingSystemArchitectureNotSupported', 'GuestOperatingSystemNotSupported', 'BootTypeNotSupported', 'MoreDisksThanSupported', 'NoSuitableVmSizeFound', 'OneOrMoreDisksNotSuitable', 'OneOrMoreAdaptersNotSuitable', 'InternalErrorOccuredDuringComputeEvaluation', 'InternalErrorOccuredDuringStorageEvaluation', 'InternalErrorOccuredDuringNetworkEvaluation', 'NoVmSizeSupportsStoragePerformance', 'NoVmSizeSupportsNetworkPerformance', 'NoVmSizeForSelectedPricingTier', 'NoVmSizeForSelectedAzureLocation', 'CheckRedHatLinuxVersion', 'CheckOpenSuseLinuxVersion', 'CheckWindowsServer2008R2Version', 'CheckCentOsVersion', 'CheckDebianLinuxVersion', 'CheckSuseLinuxVersion', 'CheckOracleLinuxVersion', 'CheckUbuntuLinuxVersion', 'CheckCoreOsLinuxVersion', 'WindowsServerVersionConditionallySupported', 'NoGuestOperatingSystemConditionallySupported', 'WindowsClientVersionsConditionallySupported', 'BootTypeUnknown', 'GuestOperatingSystemUnknown', 'WindowsServerVersionsSupportedWithCaveat', 'WindowsOSNoLongerUnderMSSupport', 'EndorsedWithConditionsLinuxDistributions', 'UnendorsedLinuxDistributions', 'NoVmSizeForStandardPricingTier', 'NoVmSizeForBasicPricingTier')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AssessedMachineProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "boot_type",
            "created_timestamp",
            "datacenter_container",
            "datacenter_machine_id",
            "datacenter_management_server",
            "datacenter_management_server_id",
            "description",
            "discovered_timestamp",
            "disks",
            "display_name",
            "groups",
            "megabytes_of_memory",
            "megabytes_of_memory_for_recommended_size",
            "monthly_bandwidth_cost",
            "monthly_compute_cost_for_recommended_size",
            "monthly_storage_cost",
            "network_adapters",
            "number_of_cores",
            "number_of_cores_for_recommended_size",
            "operating_system",
            "percentage_cores_utilization",
            "percentage_cores_utilization_data_points_expected",
            "percentage_cores_utilization_data_points_received",
            "percentage_memory_utilization",
            "percentage_memory_utilization_data_points_expected",
            "percentage_memory_utilization_data_points_received",
            "recommended_size",
            "suitability",
            "suitability_explanation",
            "updated_timestamp",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in disks (dict)
        _field_dict = {}
        if self.disks:
            for _key_disks in self.disks:
                if self.disks[_key_disks]:
                    _field_dict[_key_disks] = self.disks[_key_disks].to_dict()
            _dict['disks'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in network_adapters (dict)
        _field_dict = {}
        if self.network_adapters:
            for _key_network_adapters in self.network_adapters:
                if self.network_adapters[_key_network_adapters]:
                    _field_dict[_key_network_adapters] = self.network_adapters[_key_network_adapters].to_dict()
            _dict['networkAdapters'] = _field_dict
        # set to None if percentage_cores_utilization_data_points_expected (nullable) is None
        # and model_fields_set contains the field
        if self.percentage_cores_utilization_data_points_expected is None and "percentage_cores_utilization_data_points_expected" in self.model_fields_set:
            _dict['percentageCoresUtilizationDataPointsExpected'] = None

        # set to None if percentage_cores_utilization_data_points_received (nullable) is None
        # and model_fields_set contains the field
        if self.percentage_cores_utilization_data_points_received is None and "percentage_cores_utilization_data_points_received" in self.model_fields_set:
            _dict['percentageCoresUtilizationDataPointsReceived'] = None

        # set to None if percentage_memory_utilization_data_points_expected (nullable) is None
        # and model_fields_set contains the field
        if self.percentage_memory_utilization_data_points_expected is None and "percentage_memory_utilization_data_points_expected" in self.model_fields_set:
            _dict['percentageMemoryUtilizationDataPointsExpected'] = None

        # set to None if percentage_memory_utilization_data_points_received (nullable) is None
        # and model_fields_set contains the field
        if self.percentage_memory_utilization_data_points_received is None and "percentage_memory_utilization_data_points_received" in self.model_fields_set:
            _dict['percentageMemoryUtilizationDataPointsReceived'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AssessedMachineProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "bootType": obj.get("bootType"),
            "createdTimestamp": obj.get("createdTimestamp"),
            "datacenterContainer": obj.get("datacenterContainer"),
            "datacenterMachineId": obj.get("datacenterMachineId"),
            "datacenterManagementServer": obj.get("datacenterManagementServer"),
            "datacenterManagementServerId": obj.get("datacenterManagementServerId"),
            "description": obj.get("description"),
            "discoveredTimestamp": obj.get("discoveredTimestamp"),
            "disks": dict(
                (_k, AssessedDisk.from_dict(_v))
                for _k, _v in obj["disks"].items()
            )
            if obj.get("disks") is not None
            else None,
            "displayName": obj.get("displayName"),
            "groups": obj.get("groups"),
            "megabytesOfMemory": obj.get("megabytesOfMemory"),
            "megabytesOfMemoryForRecommendedSize": obj.get("megabytesOfMemoryForRecommendedSize"),
            "monthlyBandwidthCost": obj.get("monthlyBandwidthCost"),
            "monthlyComputeCostForRecommendedSize": obj.get("monthlyComputeCostForRecommendedSize"),
            "monthlyStorageCost": obj.get("monthlyStorageCost"),
            "networkAdapters": dict(
                (_k, AssessedNetworkAdapter.from_dict(_v))
                for _k, _v in obj["networkAdapters"].items()
            )
            if obj.get("networkAdapters") is not None
            else None,
            "numberOfCores": obj.get("numberOfCores"),
            "numberOfCoresForRecommendedSize": obj.get("numberOfCoresForRecommendedSize"),
            "operatingSystem": obj.get("operatingSystem"),
            "percentageCoresUtilization": obj.get("percentageCoresUtilization"),
            "percentageCoresUtilizationDataPointsExpected": obj.get("percentageCoresUtilizationDataPointsExpected"),
            "percentageCoresUtilizationDataPointsReceived": obj.get("percentageCoresUtilizationDataPointsReceived"),
            "percentageMemoryUtilization": obj.get("percentageMemoryUtilization"),
            "percentageMemoryUtilizationDataPointsExpected": obj.get("percentageMemoryUtilizationDataPointsExpected"),
            "percentageMemoryUtilizationDataPointsReceived": obj.get("percentageMemoryUtilizationDataPointsReceived"),
            "recommendedSize": obj.get("recommendedSize"),
            "suitability": obj.get("suitability"),
            "suitabilityExplanation": obj.get("suitabilityExplanation"),
            "updatedTimestamp": obj.get("updatedTimestamp")
        })
        return _obj


