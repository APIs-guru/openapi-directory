# coding: utf-8

"""
    Azure Migrate V2

    Assess your workloads for Azure.

    The version of the OpenAPI document: 2019-10-01
    Contact: azuremigrate@microsoft.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.assessed_disk import AssessedDisk
from openapi_client.models.assessed_network_adapter import AssessedNetworkAdapter
from typing import Optional, Set
from typing_extensions import Self

class AssessedMachineProperties(BaseModel):
    """
    Properties of an assessed machine.
    """ # noqa: E501
    boot_type: Optional[StrictStr] = Field(default=None, description="Boot type of the machine.", alias="bootType")
    confidence_rating_in_percentage: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Confidence rating of assessed machine.", alias="confidenceRatingInPercentage")
    created_timestamp: Optional[datetime] = Field(default=None, description="Time when this machine was created. Date-Time represented in ISO-8601 format.", alias="createdTimestamp")
    datacenter_machine_arm_id: Optional[StrictStr] = Field(default=None, description="ARM ID of the discovered machine.", alias="datacenterMachineArmId")
    datacenter_management_server_arm_id: Optional[StrictStr] = Field(default=None, description="ARM ID of the discovered datacenter.", alias="datacenterManagementServerArmId")
    datacenter_management_server_name: Optional[StrictStr] = Field(default=None, description="Name of the server hosting the datacenter management solution.", alias="datacenterManagementServerName")
    description: Optional[StrictStr] = Field(default=None, description="Description of the machine")
    disks: Optional[Dict[str, AssessedDisk]] = Field(default=None, description="Dictionary of disks attached to the machine. Key is ID of disk. Value is a disk object.")
    display_name: Optional[StrictStr] = Field(default=None, description="User readable name of the machine as defined by the user in their private datacenter.", alias="displayName")
    megabytes_of_memory: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Memory in Megabytes.", alias="megabytesOfMemory")
    megabytes_of_memory_for_recommended_size: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Megabytes of memory in the Recommended Azure VM Size.", alias="megabytesOfMemoryForRecommendedSize")
    monthly_bandwidth_cost: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Monthly network cost estimate for the network adapters that are attached to this machine as a group, for a 31-day month.", alias="monthlyBandwidthCost")
    monthly_compute_cost_for_recommended_size: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Compute Cost for a 31-day month, if the machine is migrated to Azure with the Recommended Size.", alias="monthlyComputeCostForRecommendedSize")
    monthly_premium_storage_cost: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Monthly premium storage cost estimate for the disks that are attached to this machine as a group, for a 31-day month.", alias="monthlyPremiumStorageCost")
    monthly_standard_ssd_storage_cost: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Monthly standard SSD storage cost estimate for the disks that are attached to this machine as a group, for a 31-day month.", alias="monthlyStandardSSDStorageCost")
    monthly_storage_cost: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Monthly storage cost estimate for the disks that are attached to this machine as a group, for a 31-day month.", alias="monthlyStorageCost")
    network_adapters: Optional[Dict[str, AssessedNetworkAdapter]] = Field(default=None, description="Dictionary of network adapters attached to the machine. Key is name of the adapter. Value is a network adapter object.", alias="networkAdapters")
    number_of_cores: Optional[StrictInt] = Field(default=None, description="Processor count.", alias="numberOfCores")
    number_of_cores_for_recommended_size: Optional[StrictInt] = Field(default=None, description="Number of CPU cores in the Recommended Azure VM Size.", alias="numberOfCoresForRecommendedSize")
    operating_system_name: Optional[StrictStr] = Field(default=None, description="Operating System name of the machine.", alias="operatingSystemName")
    operating_system_type: Optional[StrictStr] = Field(default=None, description="Operating System type of the machine.", alias="operatingSystemType")
    operating_system_version: Optional[StrictStr] = Field(default=None, description="Operating System version of the machine.", alias="operatingSystemVersion")
    percentage_cores_utilization: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Utilization percentage of the processor core as observed in the private data center, in the Time Range selected on Assessment, reported as the Percentile value based on the percentile number selected in assessment.", alias="percentageCoresUtilization")
    percentage_memory_utilization: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Utilization percentage of the memory as observed in the private data center, in the Time Range selected on Assessment, reported as the Percentile value based on the percentile number selected in assessment.", alias="percentageMemoryUtilization")
    recommended_size: Optional[StrictStr] = Field(default=None, description="Recommended Azure size for this machine.", alias="recommendedSize")
    suitability: Optional[StrictStr] = Field(default=None, description="Whether machine is suitable for migration to Azure.")
    suitability_detail: Optional[StrictStr] = Field(default=None, description="If machine is not suitable for cloud, this explains the reasons.", alias="suitabilityDetail")
    suitability_explanation: Optional[StrictStr] = Field(default=None, description="If machine is not ready to be migrated, this explains the reasons and mitigation steps.", alias="suitabilityExplanation")
    updated_timestamp: Optional[datetime] = Field(default=None, description="Time when this machine was last updated. Date-Time represented in ISO-8601 format.", alias="updatedTimestamp")
    __properties: ClassVar[List[str]] = ["bootType", "confidenceRatingInPercentage", "createdTimestamp", "datacenterMachineArmId", "datacenterManagementServerArmId", "datacenterManagementServerName", "description", "disks", "displayName", "megabytesOfMemory", "megabytesOfMemoryForRecommendedSize", "monthlyBandwidthCost", "monthlyComputeCostForRecommendedSize", "monthlyPremiumStorageCost", "monthlyStandardSSDStorageCost", "monthlyStorageCost", "networkAdapters", "numberOfCores", "numberOfCoresForRecommendedSize", "operatingSystemName", "operatingSystemType", "operatingSystemVersion", "percentageCoresUtilization", "percentageMemoryUtilization", "recommendedSize", "suitability", "suitabilityDetail", "suitabilityExplanation", "updatedTimestamp"]

    @field_validator('boot_type')
    def boot_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Unknown', 'EFI', 'BIOS']):
            raise ValueError("must be one of enum values ('Unknown', 'EFI', 'BIOS')")
        return value

    @field_validator('recommended_size')
    def recommended_size_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Unknown', 'Basic_A0', 'Basic_A1', 'Basic_A2', 'Basic_A3', 'Basic_A4', 'Standard_A0', 'Standard_A1', 'Standard_A2', 'Standard_A3', 'Standard_A4', 'Standard_A5', 'Standard_A6', 'Standard_A7', 'Standard_A8', 'Standard_A9', 'Standard_A10', 'Standard_A11', 'Standard_A1_v2', 'Standard_A2_v2', 'Standard_A4_v2', 'Standard_A8_v2', 'Standard_A2m_v2', 'Standard_A4m_v2', 'Standard_A8m_v2', 'Standard_D1', 'Standard_D2', 'Standard_D3', 'Standard_D4', 'Standard_D11', 'Standard_D12', 'Standard_D13', 'Standard_D14', 'Standard_D1_v2', 'Standard_D2_v2', 'Standard_D3_v2', 'Standard_D4_v2', 'Standard_D5_v2', 'Standard_D11_v2', 'Standard_D12_v2', 'Standard_D13_v2', 'Standard_D14_v2', 'Standard_D15_v2', 'Standard_DS1', 'Standard_DS2', 'Standard_DS3', 'Standard_DS4', 'Standard_DS11', 'Standard_DS12', 'Standard_DS13', 'Standard_DS14', 'Standard_DS1_v2', 'Standard_DS2_v2', 'Standard_DS3_v2', 'Standard_DS4_v2', 'Standard_DS5_v2', 'Standard_DS11_v2', 'Standard_DS12_v2', 'Standard_DS13_v2', 'Standard_DS14_v2', 'Standard_DS15_v2', 'Standard_F1', 'Standard_F2', 'Standard_F4', 'Standard_F8', 'Standard_F16', 'Standard_F1s', 'Standard_F2s', 'Standard_F4s', 'Standard_F8s', 'Standard_F16s', 'Standard_G1', 'Standard_G2', 'Standard_G3', 'Standard_G4', 'Standard_G5', 'Standard_GS1', 'Standard_GS2', 'Standard_GS3', 'Standard_GS4', 'Standard_GS5', 'Standard_H8', 'Standard_H16', 'Standard_H8m', 'Standard_H16m', 'Standard_H16r', 'Standard_H16mr', 'Standard_L4s', 'Standard_L8s', 'Standard_L16s', 'Standard_L32s', 'Standard_D2s_v3', 'Standard_D4s_v3', 'Standard_D8s_v3', 'Standard_D16s_v3', 'Standard_D32s_v3', 'Standard_D64s_v3', 'Standard_D2_v3', 'Standard_D4_v3', 'Standard_D8_v3', 'Standard_D16_v3', 'Standard_D32_v3', 'Standard_D64_v3', 'Standard_F2s_v2', 'Standard_F4s_v2', 'Standard_F8s_v2', 'Standard_F16s_v2', 'Standard_F32s_v2', 'Standard_F64s_v2', 'Standard_F72s_v2', 'Standard_E2_v3', 'Standard_E4_v3', 'Standard_E8_v3', 'Standard_E16_v3', 'Standard_E32_v3', 'Standard_E64_v3', 'Standard_E2s_v3', 'Standard_E4s_v3', 'Standard_E8s_v3', 'Standard_E16s_v3', 'Standard_E32s_v3', 'Standard_E64s_v3', 'Standard_M64s', 'Standard_M64ms', 'Standard_M128s', 'Standard_M128ms']):
            raise ValueError("must be one of enum values ('Unknown', 'Basic_A0', 'Basic_A1', 'Basic_A2', 'Basic_A3', 'Basic_A4', 'Standard_A0', 'Standard_A1', 'Standard_A2', 'Standard_A3', 'Standard_A4', 'Standard_A5', 'Standard_A6', 'Standard_A7', 'Standard_A8', 'Standard_A9', 'Standard_A10', 'Standard_A11', 'Standard_A1_v2', 'Standard_A2_v2', 'Standard_A4_v2', 'Standard_A8_v2', 'Standard_A2m_v2', 'Standard_A4m_v2', 'Standard_A8m_v2', 'Standard_D1', 'Standard_D2', 'Standard_D3', 'Standard_D4', 'Standard_D11', 'Standard_D12', 'Standard_D13', 'Standard_D14', 'Standard_D1_v2', 'Standard_D2_v2', 'Standard_D3_v2', 'Standard_D4_v2', 'Standard_D5_v2', 'Standard_D11_v2', 'Standard_D12_v2', 'Standard_D13_v2', 'Standard_D14_v2', 'Standard_D15_v2', 'Standard_DS1', 'Standard_DS2', 'Standard_DS3', 'Standard_DS4', 'Standard_DS11', 'Standard_DS12', 'Standard_DS13', 'Standard_DS14', 'Standard_DS1_v2', 'Standard_DS2_v2', 'Standard_DS3_v2', 'Standard_DS4_v2', 'Standard_DS5_v2', 'Standard_DS11_v2', 'Standard_DS12_v2', 'Standard_DS13_v2', 'Standard_DS14_v2', 'Standard_DS15_v2', 'Standard_F1', 'Standard_F2', 'Standard_F4', 'Standard_F8', 'Standard_F16', 'Standard_F1s', 'Standard_F2s', 'Standard_F4s', 'Standard_F8s', 'Standard_F16s', 'Standard_G1', 'Standard_G2', 'Standard_G3', 'Standard_G4', 'Standard_G5', 'Standard_GS1', 'Standard_GS2', 'Standard_GS3', 'Standard_GS4', 'Standard_GS5', 'Standard_H8', 'Standard_H16', 'Standard_H8m', 'Standard_H16m', 'Standard_H16r', 'Standard_H16mr', 'Standard_L4s', 'Standard_L8s', 'Standard_L16s', 'Standard_L32s', 'Standard_D2s_v3', 'Standard_D4s_v3', 'Standard_D8s_v3', 'Standard_D16s_v3', 'Standard_D32s_v3', 'Standard_D64s_v3', 'Standard_D2_v3', 'Standard_D4_v3', 'Standard_D8_v3', 'Standard_D16_v3', 'Standard_D32_v3', 'Standard_D64_v3', 'Standard_F2s_v2', 'Standard_F4s_v2', 'Standard_F8s_v2', 'Standard_F16s_v2', 'Standard_F32s_v2', 'Standard_F64s_v2', 'Standard_F72s_v2', 'Standard_E2_v3', 'Standard_E4_v3', 'Standard_E8_v3', 'Standard_E16_v3', 'Standard_E32_v3', 'Standard_E64_v3', 'Standard_E2s_v3', 'Standard_E4s_v3', 'Standard_E8s_v3', 'Standard_E16s_v3', 'Standard_E32s_v3', 'Standard_E64s_v3', 'Standard_M64s', 'Standard_M64ms', 'Standard_M128s', 'Standard_M128ms')")
        return value

    @field_validator('suitability')
    def suitability_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Unknown', 'NotSuitable', 'Suitable', 'ConditionallySuitable', 'ReadinessUnknown']):
            raise ValueError("must be one of enum values ('Unknown', 'NotSuitable', 'Suitable', 'ConditionallySuitable', 'ReadinessUnknown')")
        return value

    @field_validator('suitability_detail')
    def suitability_detail_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['None', 'RecommendedSizeHasLessNetworkAdapters', 'CannotReportComputeCost', 'CannotReportStorageCost', 'CannotReportBandwidthCosts', 'PercentageOfCoresUtilizedMissing', 'PercentageOfMemoryUtilizedMissing', 'PercentageOfCoresUtilizedOutOfRange', 'PercentageOfMemoryUtilizedOutOfRange']):
            raise ValueError("must be one of enum values ('None', 'RecommendedSizeHasLessNetworkAdapters', 'CannotReportComputeCost', 'CannotReportStorageCost', 'CannotReportBandwidthCosts', 'PercentageOfCoresUtilizedMissing', 'PercentageOfMemoryUtilizedMissing', 'PercentageOfCoresUtilizedOutOfRange', 'PercentageOfMemoryUtilizedOutOfRange')")
        return value

    @field_validator('suitability_explanation')
    def suitability_explanation_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Unknown', 'NotApplicable', 'GuestOperatingSystemArchitectureNotSupported', 'GuestOperatingSystemNotSupported', 'BootTypeNotSupported', 'MoreDisksThanSupported', 'NoSuitableVmSizeFound', 'OneOrMoreDisksNotSuitable', 'OneOrMoreAdaptersNotSuitable', 'InternalErrorOccurredDuringComputeEvaluation', 'InternalErrorOccurredDuringStorageEvaluation', 'InternalErrorOccurredDuringNetworkEvaluation', 'NoVmSizeSupportsStoragePerformance', 'NoVmSizeSupportsNetworkPerformance', 'NoVmSizeForSelectedPricingTier', 'NoVmSizeForSelectedAzureLocation', 'CheckRedHatLinuxVersion', 'CheckOpenSuseLinuxVersion', 'CheckWindowsServer2008R2Version', 'CheckCentOsVersion', 'CheckDebianLinuxVersion', 'CheckSuseLinuxVersion', 'CheckOracleLinuxVersion', 'CheckUbuntuLinuxVersion', 'CheckCoreOsLinuxVersion', 'WindowsServerVersionConditionallySupported', 'NoGuestOperatingSystemConditionallySupported', 'WindowsClientVersionsConditionallySupported', 'BootTypeUnknown', 'GuestOperatingSystemUnknown', 'WindowsServerVersionsSupportedWithCaveat', 'WindowsOSNoLongerUnderMSSupport', 'EndorsedWithConditionsLinuxDistributions', 'UnendorsedLinuxDistributions', 'NoVmSizeForStandardPricingTier', 'NoVmSizeForBasicPricingTier']):
            raise ValueError("must be one of enum values ('Unknown', 'NotApplicable', 'GuestOperatingSystemArchitectureNotSupported', 'GuestOperatingSystemNotSupported', 'BootTypeNotSupported', 'MoreDisksThanSupported', 'NoSuitableVmSizeFound', 'OneOrMoreDisksNotSuitable', 'OneOrMoreAdaptersNotSuitable', 'InternalErrorOccurredDuringComputeEvaluation', 'InternalErrorOccurredDuringStorageEvaluation', 'InternalErrorOccurredDuringNetworkEvaluation', 'NoVmSizeSupportsStoragePerformance', 'NoVmSizeSupportsNetworkPerformance', 'NoVmSizeForSelectedPricingTier', 'NoVmSizeForSelectedAzureLocation', 'CheckRedHatLinuxVersion', 'CheckOpenSuseLinuxVersion', 'CheckWindowsServer2008R2Version', 'CheckCentOsVersion', 'CheckDebianLinuxVersion', 'CheckSuseLinuxVersion', 'CheckOracleLinuxVersion', 'CheckUbuntuLinuxVersion', 'CheckCoreOsLinuxVersion', 'WindowsServerVersionConditionallySupported', 'NoGuestOperatingSystemConditionallySupported', 'WindowsClientVersionsConditionallySupported', 'BootTypeUnknown', 'GuestOperatingSystemUnknown', 'WindowsServerVersionsSupportedWithCaveat', 'WindowsOSNoLongerUnderMSSupport', 'EndorsedWithConditionsLinuxDistributions', 'UnendorsedLinuxDistributions', 'NoVmSizeForStandardPricingTier', 'NoVmSizeForBasicPricingTier')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AssessedMachineProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "boot_type",
            "confidence_rating_in_percentage",
            "created_timestamp",
            "datacenter_machine_arm_id",
            "datacenter_management_server_arm_id",
            "datacenter_management_server_name",
            "description",
            "disks",
            "display_name",
            "megabytes_of_memory",
            "megabytes_of_memory_for_recommended_size",
            "monthly_bandwidth_cost",
            "monthly_compute_cost_for_recommended_size",
            "monthly_premium_storage_cost",
            "monthly_standard_ssd_storage_cost",
            "monthly_storage_cost",
            "network_adapters",
            "number_of_cores",
            "number_of_cores_for_recommended_size",
            "operating_system_name",
            "operating_system_type",
            "operating_system_version",
            "percentage_cores_utilization",
            "percentage_memory_utilization",
            "recommended_size",
            "suitability",
            "suitability_detail",
            "suitability_explanation",
            "updated_timestamp",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in disks (dict)
        _field_dict = {}
        if self.disks:
            for _key_disks in self.disks:
                if self.disks[_key_disks]:
                    _field_dict[_key_disks] = self.disks[_key_disks].to_dict()
            _dict['disks'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in network_adapters (dict)
        _field_dict = {}
        if self.network_adapters:
            for _key_network_adapters in self.network_adapters:
                if self.network_adapters[_key_network_adapters]:
                    _field_dict[_key_network_adapters] = self.network_adapters[_key_network_adapters].to_dict()
            _dict['networkAdapters'] = _field_dict
        # set to None if confidence_rating_in_percentage (nullable) is None
        # and model_fields_set contains the field
        if self.confidence_rating_in_percentage is None and "confidence_rating_in_percentage" in self.model_fields_set:
            _dict['confidenceRatingInPercentage'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AssessedMachineProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "bootType": obj.get("bootType"),
            "confidenceRatingInPercentage": obj.get("confidenceRatingInPercentage"),
            "createdTimestamp": obj.get("createdTimestamp"),
            "datacenterMachineArmId": obj.get("datacenterMachineArmId"),
            "datacenterManagementServerArmId": obj.get("datacenterManagementServerArmId"),
            "datacenterManagementServerName": obj.get("datacenterManagementServerName"),
            "description": obj.get("description"),
            "disks": dict(
                (_k, AssessedDisk.from_dict(_v))
                for _k, _v in obj["disks"].items()
            )
            if obj.get("disks") is not None
            else None,
            "displayName": obj.get("displayName"),
            "megabytesOfMemory": obj.get("megabytesOfMemory"),
            "megabytesOfMemoryForRecommendedSize": obj.get("megabytesOfMemoryForRecommendedSize"),
            "monthlyBandwidthCost": obj.get("monthlyBandwidthCost"),
            "monthlyComputeCostForRecommendedSize": obj.get("monthlyComputeCostForRecommendedSize"),
            "monthlyPremiumStorageCost": obj.get("monthlyPremiumStorageCost"),
            "monthlyStandardSSDStorageCost": obj.get("monthlyStandardSSDStorageCost"),
            "monthlyStorageCost": obj.get("monthlyStorageCost"),
            "networkAdapters": dict(
                (_k, AssessedNetworkAdapter.from_dict(_v))
                for _k, _v in obj["networkAdapters"].items()
            )
            if obj.get("networkAdapters") is not None
            else None,
            "numberOfCores": obj.get("numberOfCores"),
            "numberOfCoresForRecommendedSize": obj.get("numberOfCoresForRecommendedSize"),
            "operatingSystemName": obj.get("operatingSystemName"),
            "operatingSystemType": obj.get("operatingSystemType"),
            "operatingSystemVersion": obj.get("operatingSystemVersion"),
            "percentageCoresUtilization": obj.get("percentageCoresUtilization"),
            "percentageMemoryUtilization": obj.get("percentageMemoryUtilization"),
            "recommendedSize": obj.get("recommendedSize"),
            "suitability": obj.get("suitability"),
            "suitabilityDetail": obj.get("suitabilityDetail"),
            "suitabilityExplanation": obj.get("suitabilityExplanation"),
            "updatedTimestamp": obj.get("updatedTimestamp")
        })
        return _obj


