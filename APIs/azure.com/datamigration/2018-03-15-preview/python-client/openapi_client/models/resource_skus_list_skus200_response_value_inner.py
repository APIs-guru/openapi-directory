# coding: utf-8

"""
    Azure Data Migration Service Resource Provider

    The Data Migration Service helps people migrate their data from on-premise database servers to Azure, or from older database software to newer software. The service manages one or more workers that are joined to a customer's virtual network, which is assumed to provide connectivity to their databases. To avoid frequent updates to the resource provider, data migration tasks are implemented by the resource provider in a generic way as task resources, each of which has a task type (which identifies the type of work to run), input, and output. The client is responsible for providing appropriate task type and inputs, which will be passed through unexamined to the machines that implement the functionality, and for understanding the output, which is passed back unexamined to the client.

    The version of the OpenAPI document: 2018-03-15-preview
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.resource_skus_list_skus200_response_value_inner_capabilities_inner import ResourceSkusListSkus200ResponseValueInnerCapabilitiesInner
from openapi_client.models.resource_skus_list_skus200_response_value_inner_capacity import ResourceSkusListSkus200ResponseValueInnerCapacity
from openapi_client.models.resource_skus_list_skus200_response_value_inner_costs_inner import ResourceSkusListSkus200ResponseValueInnerCostsInner
from openapi_client.models.resource_skus_list_skus200_response_value_inner_restrictions_inner import ResourceSkusListSkus200ResponseValueInnerRestrictionsInner
from typing import Optional, Set
from typing_extensions import Self

class ResourceSkusListSkus200ResponseValueInner(BaseModel):
    """
    Describes an available DMS SKU.
    """ # noqa: E501
    api_versions: Optional[List[StrictStr]] = Field(default=None, description="The api versions that support this SKU.", alias="apiVersions")
    capabilities: Optional[List[ResourceSkusListSkus200ResponseValueInnerCapabilitiesInner]] = Field(default=None, description="A name value pair to describe the capability.")
    capacity: Optional[ResourceSkusListSkus200ResponseValueInnerCapacity] = None
    costs: Optional[List[ResourceSkusListSkus200ResponseValueInnerCostsInner]] = Field(default=None, description="Metadata for retrieving price info.")
    family: Optional[StrictStr] = Field(default=None, description="The Family of this particular SKU.")
    kind: Optional[StrictStr] = Field(default=None, description="The Kind of resources that are supported in this SKU.")
    locations: Optional[List[StrictStr]] = Field(default=None, description="The set of locations that the SKU is available.")
    name: Optional[StrictStr] = Field(default=None, description="The name of SKU.")
    resource_type: Optional[StrictStr] = Field(default=None, description="The type of resource the SKU applies to.", alias="resourceType")
    restrictions: Optional[List[ResourceSkusListSkus200ResponseValueInnerRestrictionsInner]] = Field(default=None, description="The restrictions because of which SKU cannot be used. This is empty if there are no restrictions.")
    size: Optional[StrictStr] = Field(default=None, description="The Size of the SKU.")
    tier: Optional[StrictStr] = Field(default=None, description="Specifies the tier of DMS in a scale set.")
    __properties: ClassVar[List[str]] = ["apiVersions", "capabilities", "capacity", "costs", "family", "kind", "locations", "name", "resourceType", "restrictions", "size", "tier"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ResourceSkusListSkus200ResponseValueInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "api_versions",
            "capabilities",
            "costs",
            "family",
            "kind",
            "locations",
            "name",
            "resource_type",
            "restrictions",
            "size",
            "tier",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in capabilities (list)
        _items = []
        if self.capabilities:
            for _item_capabilities in self.capabilities:
                if _item_capabilities:
                    _items.append(_item_capabilities.to_dict())
            _dict['capabilities'] = _items
        # override the default output from pydantic by calling `to_dict()` of capacity
        if self.capacity:
            _dict['capacity'] = self.capacity.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in costs (list)
        _items = []
        if self.costs:
            for _item_costs in self.costs:
                if _item_costs:
                    _items.append(_item_costs.to_dict())
            _dict['costs'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in restrictions (list)
        _items = []
        if self.restrictions:
            for _item_restrictions in self.restrictions:
                if _item_restrictions:
                    _items.append(_item_restrictions.to_dict())
            _dict['restrictions'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ResourceSkusListSkus200ResponseValueInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "apiVersions": obj.get("apiVersions"),
            "capabilities": [ResourceSkusListSkus200ResponseValueInnerCapabilitiesInner.from_dict(_item) for _item in obj["capabilities"]] if obj.get("capabilities") is not None else None,
            "capacity": ResourceSkusListSkus200ResponseValueInnerCapacity.from_dict(obj["capacity"]) if obj.get("capacity") is not None else None,
            "costs": [ResourceSkusListSkus200ResponseValueInnerCostsInner.from_dict(_item) for _item in obj["costs"]] if obj.get("costs") is not None else None,
            "family": obj.get("family"),
            "kind": obj.get("kind"),
            "locations": obj.get("locations"),
            "name": obj.get("name"),
            "resourceType": obj.get("resourceType"),
            "restrictions": [ResourceSkusListSkus200ResponseValueInnerRestrictionsInner.from_dict(_item) for _item in obj["restrictions"]] if obj.get("restrictions") is not None else None,
            "size": obj.get("size"),
            "tier": obj.get("tier")
        })
        return _obj


