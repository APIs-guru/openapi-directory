# coding: utf-8

"""
    Azure Data Lake Storage

    Azure Data Lake Storage provides storage for Hadoop and other big data workloads.

    The version of the OpenAPI document: 2018-06-17
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr, field_validator
from typing import Any, Dict, Optional, Tuple, Union
from typing_extensions import Annotated

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class FileAndDirectoryOperationsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def path_create(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        resource: Annotated[Optional[StrictStr], Field(description="Required only for Create File and Create Directory. The value must be \"file\" or \"directory\".")] = None,
        continuation: Annotated[Optional[StrictStr], Field(description="Optional.  When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.")] = None,
        mode: Annotated[Optional[StrictStr], Field(description="Optional. Valid only when namespace is enabled. This parameter determines the behavior of the rename operation. The value must be \"legacy\" or \"posix\", and the default value will be \"posix\". ")] = None,
        cache_control: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations for \"Read File\" operations.")] = None,
        content_encoding: Annotated[Optional[StrictStr], Field(description="Optional.  Specifies which content encodings have been applied to the file. This value is returned to the client when the \"Read File\" operation is performed.")] = None,
        content_language: Annotated[Optional[StrictStr], Field(description="Optional.  Specifies the natural language used by the intended audience for the file.")] = None,
        content_disposition: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.")] = None,
        x_ms_cache_control: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.")] = None,
        x_ms_content_type: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.")] = None,
        x_ms_content_encoding: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.")] = None,
        x_ms_content_language: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.")] = None,
        x_ms_content_disposition: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.")] = None,
        x_ms_rename_source: Annotated[Optional[StrictStr], Field(description="An optional file or directory to be renamed.  The value must have the following format: \"/{filesystem}/{path}\".  If \"x-ms-properties\" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Optional.  A lease ID for the path specified in the URI.  The path to be overwritten must have an active lease and the lease ID must match.")] = None,
        x_ms_proposed_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Optional for create operations.  Required when \"x-ms-lease-action\" is used.  A lease will be acquired using the proposed ID when the resource is created.")] = None,
        x_ms_source_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Optional for rename operations.  A lease ID for the source path.  The source path must have an active lease and the lease ID must match.")] = None,
        x_ms_properties: Annotated[Optional[StrictStr], Field(description="Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.")] = None,
        x_ms_permissions: Annotated[Optional[StrictStr], Field(description="Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        x_ms_source_if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the rename operation only if the source's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        x_ms_source_if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the rename operation only if the source's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        x_ms_source_if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the rename operation only if the source has been modified since the specified date and time.")] = None,
        x_ms_source_if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the rename operation only if the source has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Create File | Create Directory | Rename File | Rename Directory

        Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: \"*\".

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param resource: Required only for Create File and Create Directory. The value must be \"file\" or \"directory\".
        :type resource: str
        :param continuation: Optional.  When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.
        :type continuation: str
        :param mode: Optional. Valid only when namespace is enabled. This parameter determines the behavior of the rename operation. The value must be \"legacy\" or \"posix\", and the default value will be \"posix\". 
        :type mode: str
        :param cache_control: Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations for \"Read File\" operations.
        :type cache_control: str
        :param content_encoding: Optional.  Specifies which content encodings have been applied to the file. This value is returned to the client when the \"Read File\" operation is performed.
        :type content_encoding: str
        :param content_language: Optional.  Specifies the natural language used by the intended audience for the file.
        :type content_language: str
        :param content_disposition: Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.
        :type content_disposition: str
        :param x_ms_cache_control: Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.
        :type x_ms_cache_control: str
        :param x_ms_content_type: Optional.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.
        :type x_ms_content_type: str
        :param x_ms_content_encoding: Optional.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.
        :type x_ms_content_encoding: str
        :param x_ms_content_language: Optional.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.
        :type x_ms_content_language: str
        :param x_ms_content_disposition: Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.
        :type x_ms_content_disposition: str
        :param x_ms_rename_source: An optional file or directory to be renamed.  The value must have the following format: \"/{filesystem}/{path}\".  If \"x-ms-properties\" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved.
        :type x_ms_rename_source: str
        :param x_ms_lease_id: Optional.  A lease ID for the path specified in the URI.  The path to be overwritten must have an active lease and the lease ID must match.
        :type x_ms_lease_id: str
        :param x_ms_proposed_lease_id: Optional for create operations.  Required when \"x-ms-lease-action\" is used.  A lease will be acquired using the proposed ID when the resource is created.
        :type x_ms_proposed_lease_id: str
        :param x_ms_source_lease_id: Optional for rename operations.  A lease ID for the source path.  The source path must have an active lease and the lease ID must match.
        :type x_ms_source_lease_id: str
        :param x_ms_properties: Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.
        :type x_ms_properties: str
        :param x_ms_permissions: Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.
        :type x_ms_permissions: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param x_ms_source_if_match: Optional.  An ETag value. Specify this header to perform the rename operation only if the source's ETag matches the value specified. The ETag must be specified in quotes.
        :type x_ms_source_if_match: str
        :param x_ms_source_if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the rename operation only if the source's ETag does not match the value specified. The ETag must be specified in quotes.
        :type x_ms_source_if_none_match: str
        :param x_ms_source_if_modified_since: Optional. A date and time value. Specify this header to perform the rename operation only if the source has been modified since the specified date and time.
        :type x_ms_source_if_modified_since: str
        :param x_ms_source_if_unmodified_since: Optional. A date and time value. Specify this header to perform the rename operation only if the source has not been modified since the specified date and time.
        :type x_ms_source_if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_create_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            resource=resource,
            continuation=continuation,
            mode=mode,
            cache_control=cache_control,
            content_encoding=content_encoding,
            content_language=content_language,
            content_disposition=content_disposition,
            x_ms_cache_control=x_ms_cache_control,
            x_ms_content_type=x_ms_content_type,
            x_ms_content_encoding=x_ms_content_encoding,
            x_ms_content_language=x_ms_content_language,
            x_ms_content_disposition=x_ms_content_disposition,
            x_ms_rename_source=x_ms_rename_source,
            x_ms_lease_id=x_ms_lease_id,
            x_ms_proposed_lease_id=x_ms_proposed_lease_id,
            x_ms_source_lease_id=x_ms_source_lease_id,
            x_ms_properties=x_ms_properties,
            x_ms_permissions=x_ms_permissions,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            x_ms_source_if_match=x_ms_source_if_match,
            x_ms_source_if_none_match=x_ms_source_if_none_match,
            x_ms_source_if_modified_since=x_ms_source_if_modified_since,
            x_ms_source_if_unmodified_since=x_ms_source_if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def path_create_with_http_info(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        resource: Annotated[Optional[StrictStr], Field(description="Required only for Create File and Create Directory. The value must be \"file\" or \"directory\".")] = None,
        continuation: Annotated[Optional[StrictStr], Field(description="Optional.  When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.")] = None,
        mode: Annotated[Optional[StrictStr], Field(description="Optional. Valid only when namespace is enabled. This parameter determines the behavior of the rename operation. The value must be \"legacy\" or \"posix\", and the default value will be \"posix\". ")] = None,
        cache_control: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations for \"Read File\" operations.")] = None,
        content_encoding: Annotated[Optional[StrictStr], Field(description="Optional.  Specifies which content encodings have been applied to the file. This value is returned to the client when the \"Read File\" operation is performed.")] = None,
        content_language: Annotated[Optional[StrictStr], Field(description="Optional.  Specifies the natural language used by the intended audience for the file.")] = None,
        content_disposition: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.")] = None,
        x_ms_cache_control: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.")] = None,
        x_ms_content_type: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.")] = None,
        x_ms_content_encoding: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.")] = None,
        x_ms_content_language: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.")] = None,
        x_ms_content_disposition: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.")] = None,
        x_ms_rename_source: Annotated[Optional[StrictStr], Field(description="An optional file or directory to be renamed.  The value must have the following format: \"/{filesystem}/{path}\".  If \"x-ms-properties\" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Optional.  A lease ID for the path specified in the URI.  The path to be overwritten must have an active lease and the lease ID must match.")] = None,
        x_ms_proposed_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Optional for create operations.  Required when \"x-ms-lease-action\" is used.  A lease will be acquired using the proposed ID when the resource is created.")] = None,
        x_ms_source_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Optional for rename operations.  A lease ID for the source path.  The source path must have an active lease and the lease ID must match.")] = None,
        x_ms_properties: Annotated[Optional[StrictStr], Field(description="Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.")] = None,
        x_ms_permissions: Annotated[Optional[StrictStr], Field(description="Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        x_ms_source_if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the rename operation only if the source's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        x_ms_source_if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the rename operation only if the source's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        x_ms_source_if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the rename operation only if the source has been modified since the specified date and time.")] = None,
        x_ms_source_if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the rename operation only if the source has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Create File | Create Directory | Rename File | Rename Directory

        Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: \"*\".

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param resource: Required only for Create File and Create Directory. The value must be \"file\" or \"directory\".
        :type resource: str
        :param continuation: Optional.  When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.
        :type continuation: str
        :param mode: Optional. Valid only when namespace is enabled. This parameter determines the behavior of the rename operation. The value must be \"legacy\" or \"posix\", and the default value will be \"posix\". 
        :type mode: str
        :param cache_control: Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations for \"Read File\" operations.
        :type cache_control: str
        :param content_encoding: Optional.  Specifies which content encodings have been applied to the file. This value is returned to the client when the \"Read File\" operation is performed.
        :type content_encoding: str
        :param content_language: Optional.  Specifies the natural language used by the intended audience for the file.
        :type content_language: str
        :param content_disposition: Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.
        :type content_disposition: str
        :param x_ms_cache_control: Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.
        :type x_ms_cache_control: str
        :param x_ms_content_type: Optional.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.
        :type x_ms_content_type: str
        :param x_ms_content_encoding: Optional.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.
        :type x_ms_content_encoding: str
        :param x_ms_content_language: Optional.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.
        :type x_ms_content_language: str
        :param x_ms_content_disposition: Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.
        :type x_ms_content_disposition: str
        :param x_ms_rename_source: An optional file or directory to be renamed.  The value must have the following format: \"/{filesystem}/{path}\".  If \"x-ms-properties\" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved.
        :type x_ms_rename_source: str
        :param x_ms_lease_id: Optional.  A lease ID for the path specified in the URI.  The path to be overwritten must have an active lease and the lease ID must match.
        :type x_ms_lease_id: str
        :param x_ms_proposed_lease_id: Optional for create operations.  Required when \"x-ms-lease-action\" is used.  A lease will be acquired using the proposed ID when the resource is created.
        :type x_ms_proposed_lease_id: str
        :param x_ms_source_lease_id: Optional for rename operations.  A lease ID for the source path.  The source path must have an active lease and the lease ID must match.
        :type x_ms_source_lease_id: str
        :param x_ms_properties: Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.
        :type x_ms_properties: str
        :param x_ms_permissions: Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.
        :type x_ms_permissions: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param x_ms_source_if_match: Optional.  An ETag value. Specify this header to perform the rename operation only if the source's ETag matches the value specified. The ETag must be specified in quotes.
        :type x_ms_source_if_match: str
        :param x_ms_source_if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the rename operation only if the source's ETag does not match the value specified. The ETag must be specified in quotes.
        :type x_ms_source_if_none_match: str
        :param x_ms_source_if_modified_since: Optional. A date and time value. Specify this header to perform the rename operation only if the source has been modified since the specified date and time.
        :type x_ms_source_if_modified_since: str
        :param x_ms_source_if_unmodified_since: Optional. A date and time value. Specify this header to perform the rename operation only if the source has not been modified since the specified date and time.
        :type x_ms_source_if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_create_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            resource=resource,
            continuation=continuation,
            mode=mode,
            cache_control=cache_control,
            content_encoding=content_encoding,
            content_language=content_language,
            content_disposition=content_disposition,
            x_ms_cache_control=x_ms_cache_control,
            x_ms_content_type=x_ms_content_type,
            x_ms_content_encoding=x_ms_content_encoding,
            x_ms_content_language=x_ms_content_language,
            x_ms_content_disposition=x_ms_content_disposition,
            x_ms_rename_source=x_ms_rename_source,
            x_ms_lease_id=x_ms_lease_id,
            x_ms_proposed_lease_id=x_ms_proposed_lease_id,
            x_ms_source_lease_id=x_ms_source_lease_id,
            x_ms_properties=x_ms_properties,
            x_ms_permissions=x_ms_permissions,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            x_ms_source_if_match=x_ms_source_if_match,
            x_ms_source_if_none_match=x_ms_source_if_none_match,
            x_ms_source_if_modified_since=x_ms_source_if_modified_since,
            x_ms_source_if_unmodified_since=x_ms_source_if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def path_create_without_preload_content(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        resource: Annotated[Optional[StrictStr], Field(description="Required only for Create File and Create Directory. The value must be \"file\" or \"directory\".")] = None,
        continuation: Annotated[Optional[StrictStr], Field(description="Optional.  When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.")] = None,
        mode: Annotated[Optional[StrictStr], Field(description="Optional. Valid only when namespace is enabled. This parameter determines the behavior of the rename operation. The value must be \"legacy\" or \"posix\", and the default value will be \"posix\". ")] = None,
        cache_control: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations for \"Read File\" operations.")] = None,
        content_encoding: Annotated[Optional[StrictStr], Field(description="Optional.  Specifies which content encodings have been applied to the file. This value is returned to the client when the \"Read File\" operation is performed.")] = None,
        content_language: Annotated[Optional[StrictStr], Field(description="Optional.  Specifies the natural language used by the intended audience for the file.")] = None,
        content_disposition: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.")] = None,
        x_ms_cache_control: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.")] = None,
        x_ms_content_type: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.")] = None,
        x_ms_content_encoding: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.")] = None,
        x_ms_content_language: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.")] = None,
        x_ms_content_disposition: Annotated[Optional[StrictStr], Field(description="Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.")] = None,
        x_ms_rename_source: Annotated[Optional[StrictStr], Field(description="An optional file or directory to be renamed.  The value must have the following format: \"/{filesystem}/{path}\".  If \"x-ms-properties\" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Optional.  A lease ID for the path specified in the URI.  The path to be overwritten must have an active lease and the lease ID must match.")] = None,
        x_ms_proposed_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Optional for create operations.  Required when \"x-ms-lease-action\" is used.  A lease will be acquired using the proposed ID when the resource is created.")] = None,
        x_ms_source_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Optional for rename operations.  A lease ID for the source path.  The source path must have an active lease and the lease ID must match.")] = None,
        x_ms_properties: Annotated[Optional[StrictStr], Field(description="Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.")] = None,
        x_ms_permissions: Annotated[Optional[StrictStr], Field(description="Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        x_ms_source_if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the rename operation only if the source's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        x_ms_source_if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the rename operation only if the source's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        x_ms_source_if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the rename operation only if the source has been modified since the specified date and time.")] = None,
        x_ms_source_if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the rename operation only if the source has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create File | Create Directory | Rename File | Rename Directory

        Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: \"*\".

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param resource: Required only for Create File and Create Directory. The value must be \"file\" or \"directory\".
        :type resource: str
        :param continuation: Optional.  When renaming a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the rename operation to continue renaming the directory.
        :type continuation: str
        :param mode: Optional. Valid only when namespace is enabled. This parameter determines the behavior of the rename operation. The value must be \"legacy\" or \"posix\", and the default value will be \"posix\". 
        :type mode: str
        :param cache_control: Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations for \"Read File\" operations.
        :type cache_control: str
        :param content_encoding: Optional.  Specifies which content encodings have been applied to the file. This value is returned to the client when the \"Read File\" operation is performed.
        :type content_encoding: str
        :param content_language: Optional.  Specifies the natural language used by the intended audience for the file.
        :type content_language: str
        :param content_disposition: Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.
        :type content_disposition: str
        :param x_ms_cache_control: Optional.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.
        :type x_ms_cache_control: str
        :param x_ms_content_type: Optional.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.
        :type x_ms_content_type: str
        :param x_ms_content_encoding: Optional.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.
        :type x_ms_content_encoding: str
        :param x_ms_content_language: Optional.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.
        :type x_ms_content_language: str
        :param x_ms_content_disposition: Optional.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.
        :type x_ms_content_disposition: str
        :param x_ms_rename_source: An optional file or directory to be renamed.  The value must have the following format: \"/{filesystem}/{path}\".  If \"x-ms-properties\" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be preserved.
        :type x_ms_rename_source: str
        :param x_ms_lease_id: Optional.  A lease ID for the path specified in the URI.  The path to be overwritten must have an active lease and the lease ID must match.
        :type x_ms_lease_id: str
        :param x_ms_proposed_lease_id: Optional for create operations.  Required when \"x-ms-lease-action\" is used.  A lease will be acquired using the proposed ID when the resource is created.
        :type x_ms_proposed_lease_id: str
        :param x_ms_source_lease_id: Optional for rename operations.  A lease ID for the source path.  The source path must have an active lease and the lease ID must match.
        :type x_ms_source_lease_id: str
        :param x_ms_properties: Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.
        :type x_ms_properties: str
        :param x_ms_permissions: Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.
        :type x_ms_permissions: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param x_ms_source_if_match: Optional.  An ETag value. Specify this header to perform the rename operation only if the source's ETag matches the value specified. The ETag must be specified in quotes.
        :type x_ms_source_if_match: str
        :param x_ms_source_if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the rename operation only if the source's ETag does not match the value specified. The ETag must be specified in quotes.
        :type x_ms_source_if_none_match: str
        :param x_ms_source_if_modified_since: Optional. A date and time value. Specify this header to perform the rename operation only if the source has been modified since the specified date and time.
        :type x_ms_source_if_modified_since: str
        :param x_ms_source_if_unmodified_since: Optional. A date and time value. Specify this header to perform the rename operation only if the source has not been modified since the specified date and time.
        :type x_ms_source_if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_create_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            resource=resource,
            continuation=continuation,
            mode=mode,
            cache_control=cache_control,
            content_encoding=content_encoding,
            content_language=content_language,
            content_disposition=content_disposition,
            x_ms_cache_control=x_ms_cache_control,
            x_ms_content_type=x_ms_content_type,
            x_ms_content_encoding=x_ms_content_encoding,
            x_ms_content_language=x_ms_content_language,
            x_ms_content_disposition=x_ms_content_disposition,
            x_ms_rename_source=x_ms_rename_source,
            x_ms_lease_id=x_ms_lease_id,
            x_ms_proposed_lease_id=x_ms_proposed_lease_id,
            x_ms_source_lease_id=x_ms_source_lease_id,
            x_ms_properties=x_ms_properties,
            x_ms_permissions=x_ms_permissions,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            x_ms_source_if_match=x_ms_source_if_match,
            x_ms_source_if_none_match=x_ms_source_if_none_match,
            x_ms_source_if_modified_since=x_ms_source_if_modified_since,
            x_ms_source_if_unmodified_since=x_ms_source_if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _path_create_serialize(
        self,
        filesystem,
        path,
        x_ms_client_request_id,
        timeout,
        x_ms_date,
        x_ms_version,
        resource,
        continuation,
        mode,
        cache_control,
        content_encoding,
        content_language,
        content_disposition,
        x_ms_cache_control,
        x_ms_content_type,
        x_ms_content_encoding,
        x_ms_content_language,
        x_ms_content_disposition,
        x_ms_rename_source,
        x_ms_lease_id,
        x_ms_proposed_lease_id,
        x_ms_source_lease_id,
        x_ms_properties,
        x_ms_permissions,
        if_match,
        if_none_match,
        if_modified_since,
        if_unmodified_since,
        x_ms_source_if_match,
        x_ms_source_if_none_match,
        x_ms_source_if_modified_since,
        x_ms_source_if_unmodified_since,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if filesystem is not None:
            _path_params['filesystem'] = filesystem
        if path is not None:
            _path_params['path'] = path
        # process the query parameters
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        if resource is not None:
            
            _query_params.append(('resource', resource))
            
        if continuation is not None:
            
            _query_params.append(('continuation', continuation))
            
        if mode is not None:
            
            _query_params.append(('mode', mode))
            
        # process the header parameters
        if x_ms_client_request_id is not None:
            _header_params['x-ms-client-request-id'] = x_ms_client_request_id
        if x_ms_date is not None:
            _header_params['x-ms-date'] = x_ms_date
        if x_ms_version is not None:
            _header_params['x-ms-version'] = x_ms_version
        if cache_control is not None:
            _header_params['Cache-Control'] = cache_control
        if content_encoding is not None:
            _header_params['Content-Encoding'] = content_encoding
        if content_language is not None:
            _header_params['Content-Language'] = content_language
        if content_disposition is not None:
            _header_params['Content-Disposition'] = content_disposition
        if x_ms_cache_control is not None:
            _header_params['x-ms-cache-control'] = x_ms_cache_control
        if x_ms_content_type is not None:
            _header_params['x-ms-content-type'] = x_ms_content_type
        if x_ms_content_encoding is not None:
            _header_params['x-ms-content-encoding'] = x_ms_content_encoding
        if x_ms_content_language is not None:
            _header_params['x-ms-content-language'] = x_ms_content_language
        if x_ms_content_disposition is not None:
            _header_params['x-ms-content-disposition'] = x_ms_content_disposition
        if x_ms_rename_source is not None:
            _header_params['x-ms-rename-source'] = x_ms_rename_source
        if x_ms_lease_id is not None:
            _header_params['x-ms-lease-id'] = x_ms_lease_id
        if x_ms_proposed_lease_id is not None:
            _header_params['x-ms-proposed-lease-id'] = x_ms_proposed_lease_id
        if x_ms_source_lease_id is not None:
            _header_params['x-ms-source-lease-id'] = x_ms_source_lease_id
        if x_ms_properties is not None:
            _header_params['x-ms-properties'] = x_ms_properties
        if x_ms_permissions is not None:
            _header_params['x-ms-permissions'] = x_ms_permissions
        if if_match is not None:
            _header_params['If-Match'] = if_match
        if if_none_match is not None:
            _header_params['If-None-Match'] = if_none_match
        if if_modified_since is not None:
            _header_params['If-Modified-Since'] = if_modified_since
        if if_unmodified_since is not None:
            _header_params['If-Unmodified-Since'] = if_unmodified_since
        if x_ms_source_if_match is not None:
            _header_params['x-ms-source-if-match'] = x_ms_source_if_match
        if x_ms_source_if_none_match is not None:
            _header_params['x-ms-source-if-none-match'] = x_ms_source_if_none_match
        if x_ms_source_if_modified_since is not None:
            _header_params['x-ms-source-if-modified-since'] = x_ms_source_if_modified_since
        if x_ms_source_if_unmodified_since is not None:
            _header_params['x-ms-source-if-unmodified-since'] = x_ms_source_if_unmodified_since
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/{filesystem}/{path}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def path_delete(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        recursive: Annotated[Optional[StrictBool], Field(description="Required and valid only when the resource is a directory.  If \"true\", all paths beneath the directory will be deleted. If \"false\" and the directory is non-empty, an error occurs.")] = None,
        continuation: Annotated[Optional[StrictStr], Field(description="Optional.  When deleting a directory, the number of paths that are deleted with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the delete operation to continue deleting the directory.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The lease ID must be specified if there is an active lease.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete File | Delete Directory

        Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param recursive: Required and valid only when the resource is a directory.  If \"true\", all paths beneath the directory will be deleted. If \"false\" and the directory is non-empty, an error occurs.
        :type recursive: bool
        :param continuation: Optional.  When deleting a directory, the number of paths that are deleted with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the delete operation to continue deleting the directory.
        :type continuation: str
        :param x_ms_lease_id: The lease ID must be specified if there is an active lease.
        :type x_ms_lease_id: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_delete_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            recursive=recursive,
            continuation=continuation,
            x_ms_lease_id=x_ms_lease_id,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def path_delete_with_http_info(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        recursive: Annotated[Optional[StrictBool], Field(description="Required and valid only when the resource is a directory.  If \"true\", all paths beneath the directory will be deleted. If \"false\" and the directory is non-empty, an error occurs.")] = None,
        continuation: Annotated[Optional[StrictStr], Field(description="Optional.  When deleting a directory, the number of paths that are deleted with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the delete operation to continue deleting the directory.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The lease ID must be specified if there is an active lease.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete File | Delete Directory

        Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param recursive: Required and valid only when the resource is a directory.  If \"true\", all paths beneath the directory will be deleted. If \"false\" and the directory is non-empty, an error occurs.
        :type recursive: bool
        :param continuation: Optional.  When deleting a directory, the number of paths that are deleted with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the delete operation to continue deleting the directory.
        :type continuation: str
        :param x_ms_lease_id: The lease ID must be specified if there is an active lease.
        :type x_ms_lease_id: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_delete_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            recursive=recursive,
            continuation=continuation,
            x_ms_lease_id=x_ms_lease_id,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def path_delete_without_preload_content(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        recursive: Annotated[Optional[StrictBool], Field(description="Required and valid only when the resource is a directory.  If \"true\", all paths beneath the directory will be deleted. If \"false\" and the directory is non-empty, an error occurs.")] = None,
        continuation: Annotated[Optional[StrictStr], Field(description="Optional.  When deleting a directory, the number of paths that are deleted with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the delete operation to continue deleting the directory.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The lease ID must be specified if there is an active lease.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete File | Delete Directory

        Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param recursive: Required and valid only when the resource is a directory.  If \"true\", all paths beneath the directory will be deleted. If \"false\" and the directory is non-empty, an error occurs.
        :type recursive: bool
        :param continuation: Optional.  When deleting a directory, the number of paths that are deleted with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a continuation token is returned in this response header.  When a continuation token is returned in the response, it must be specified in a subsequent invocation of the delete operation to continue deleting the directory.
        :type continuation: str
        :param x_ms_lease_id: The lease ID must be specified if there is an active lease.
        :type x_ms_lease_id: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_delete_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            recursive=recursive,
            continuation=continuation,
            x_ms_lease_id=x_ms_lease_id,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _path_delete_serialize(
        self,
        filesystem,
        path,
        x_ms_client_request_id,
        timeout,
        x_ms_date,
        x_ms_version,
        recursive,
        continuation,
        x_ms_lease_id,
        if_match,
        if_none_match,
        if_modified_since,
        if_unmodified_since,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if filesystem is not None:
            _path_params['filesystem'] = filesystem
        if path is not None:
            _path_params['path'] = path
        # process the query parameters
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        if recursive is not None:
            
            _query_params.append(('recursive', recursive))
            
        if continuation is not None:
            
            _query_params.append(('continuation', continuation))
            
        # process the header parameters
        if x_ms_client_request_id is not None:
            _header_params['x-ms-client-request-id'] = x_ms_client_request_id
        if x_ms_date is not None:
            _header_params['x-ms-date'] = x_ms_date
        if x_ms_version is not None:
            _header_params['x-ms-version'] = x_ms_version
        if x_ms_lease_id is not None:
            _header_params['x-ms-lease-id'] = x_ms_lease_id
        if if_match is not None:
            _header_params['If-Match'] = if_match
        if if_none_match is not None:
            _header_params['If-None-Match'] = if_none_match
        if if_modified_since is not None:
            _header_params['If-Modified-Since'] = if_modified_since
        if if_unmodified_since is not None:
            _header_params['If-Unmodified-Since'] = if_unmodified_since
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/{filesystem}/{path}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def path_get_properties(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        action: Annotated[Optional[StrictStr], Field(description="Optional. If the value is \"getAccessControl\" the access control list is returned in the response headers (Hierarchical Namespace must be enabled for the account).")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get Properties | Get Access Control List

        Get the properties for a file or directory, and optionally include the access control list.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param action: Optional. If the value is \"getAccessControl\" the access control list is returned in the response headers (Hierarchical Namespace must be enabled for the account).
        :type action: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_get_properties_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            action=action,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def path_get_properties_with_http_info(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        action: Annotated[Optional[StrictStr], Field(description="Optional. If the value is \"getAccessControl\" the access control list is returned in the response headers (Hierarchical Namespace must be enabled for the account).")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get Properties | Get Access Control List

        Get the properties for a file or directory, and optionally include the access control list.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param action: Optional. If the value is \"getAccessControl\" the access control list is returned in the response headers (Hierarchical Namespace must be enabled for the account).
        :type action: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_get_properties_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            action=action,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def path_get_properties_without_preload_content(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        action: Annotated[Optional[StrictStr], Field(description="Optional. If the value is \"getAccessControl\" the access control list is returned in the response headers (Hierarchical Namespace must be enabled for the account).")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Properties | Get Access Control List

        Get the properties for a file or directory, and optionally include the access control list.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param action: Optional. If the value is \"getAccessControl\" the access control list is returned in the response headers (Hierarchical Namespace must be enabled for the account).
        :type action: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_get_properties_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            action=action,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _path_get_properties_serialize(
        self,
        filesystem,
        path,
        x_ms_client_request_id,
        timeout,
        x_ms_date,
        x_ms_version,
        action,
        if_match,
        if_none_match,
        if_modified_since,
        if_unmodified_since,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if filesystem is not None:
            _path_params['filesystem'] = filesystem
        if path is not None:
            _path_params['path'] = path
        # process the query parameters
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        if action is not None:
            
            _query_params.append(('action', action))
            
        # process the header parameters
        if x_ms_client_request_id is not None:
            _header_params['x-ms-client-request-id'] = x_ms_client_request_id
        if x_ms_date is not None:
            _header_params['x-ms-date'] = x_ms_date
        if x_ms_version is not None:
            _header_params['x-ms-version'] = x_ms_version
        if if_match is not None:
            _header_params['If-Match'] = if_match
        if if_none_match is not None:
            _header_params['If-None-Match'] = if_none_match
        if if_modified_since is not None:
            _header_params['If-Modified-Since'] = if_modified_since
        if if_unmodified_since is not None:
            _header_params['If-Unmodified-Since'] = if_unmodified_since
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='HEAD',
            resource_path='/{filesystem}/{path}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def path_lease(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_lease_action: Annotated[StrictStr, Field(description="There are five lease actions: \"acquire\", \"break\", \"change\", \"renew\", and \"release\". Use \"acquire\" and specify the \"x-ms-proposed-lease-id\" and \"x-ms-lease-duration\" to acquire a new lease. Use \"break\" to break an existing lease. When a lease is broken, the lease break period is allowed to elapse, during which time no lease operation except break and release can be performed on the file. When a lease is successfully broken, the response indicates the interval in seconds until a new lease can be acquired. Use \"change\" and specify the current lease ID in \"x-ms-lease-id\" and the new lease ID in \"x-ms-proposed-lease-id\" to change the lease ID of an active lease. Use \"renew\" and specify the \"x-ms-lease-id\" to renew an existing lease. Use \"release\" and specify the \"x-ms-lease-id\" to release a lease.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        x_ms_lease_duration: Annotated[Optional[StrictInt], Field(description="The lease duration is required to acquire a lease, and specifies the duration of the lease in seconds.  The lease duration must be between 15 and 60 seconds or -1 for infinite lease.")] = None,
        x_ms_lease_break_period: Annotated[Optional[StrictInt], Field(description="The lease break period duration is optional to break a lease, and  specifies the break period of the lease in seconds.  The lease break  duration must be between 0 and 60 seconds.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Required when \"x-ms-lease-action\" is \"renew\", \"change\" or \"release\". For the renew and release actions, this must match the current lease ID.")] = None,
        x_ms_proposed_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Required when \"x-ms-lease-action\" is \"acquire\" or \"change\".  A lease will be acquired with this lease ID if the operation is successful.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Lease Path

        Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_lease_action: There are five lease actions: \"acquire\", \"break\", \"change\", \"renew\", and \"release\". Use \"acquire\" and specify the \"x-ms-proposed-lease-id\" and \"x-ms-lease-duration\" to acquire a new lease. Use \"break\" to break an existing lease. When a lease is broken, the lease break period is allowed to elapse, during which time no lease operation except break and release can be performed on the file. When a lease is successfully broken, the response indicates the interval in seconds until a new lease can be acquired. Use \"change\" and specify the current lease ID in \"x-ms-lease-id\" and the new lease ID in \"x-ms-proposed-lease-id\" to change the lease ID of an active lease. Use \"renew\" and specify the \"x-ms-lease-id\" to renew an existing lease. Use \"release\" and specify the \"x-ms-lease-id\" to release a lease. (required)
        :type x_ms_lease_action: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param x_ms_lease_duration: The lease duration is required to acquire a lease, and specifies the duration of the lease in seconds.  The lease duration must be between 15 and 60 seconds or -1 for infinite lease.
        :type x_ms_lease_duration: int
        :param x_ms_lease_break_period: The lease break period duration is optional to break a lease, and  specifies the break period of the lease in seconds.  The lease break  duration must be between 0 and 60 seconds.
        :type x_ms_lease_break_period: int
        :param x_ms_lease_id: Required when \"x-ms-lease-action\" is \"renew\", \"change\" or \"release\". For the renew and release actions, this must match the current lease ID.
        :type x_ms_lease_id: str
        :param x_ms_proposed_lease_id: Required when \"x-ms-lease-action\" is \"acquire\" or \"change\".  A lease will be acquired with this lease ID if the operation is successful.
        :type x_ms_proposed_lease_id: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_lease_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_lease_action=x_ms_lease_action,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            x_ms_lease_duration=x_ms_lease_duration,
            x_ms_lease_break_period=x_ms_lease_break_period,
            x_ms_lease_id=x_ms_lease_id,
            x_ms_proposed_lease_id=x_ms_proposed_lease_id,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '201': None,
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def path_lease_with_http_info(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_lease_action: Annotated[StrictStr, Field(description="There are five lease actions: \"acquire\", \"break\", \"change\", \"renew\", and \"release\". Use \"acquire\" and specify the \"x-ms-proposed-lease-id\" and \"x-ms-lease-duration\" to acquire a new lease. Use \"break\" to break an existing lease. When a lease is broken, the lease break period is allowed to elapse, during which time no lease operation except break and release can be performed on the file. When a lease is successfully broken, the response indicates the interval in seconds until a new lease can be acquired. Use \"change\" and specify the current lease ID in \"x-ms-lease-id\" and the new lease ID in \"x-ms-proposed-lease-id\" to change the lease ID of an active lease. Use \"renew\" and specify the \"x-ms-lease-id\" to renew an existing lease. Use \"release\" and specify the \"x-ms-lease-id\" to release a lease.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        x_ms_lease_duration: Annotated[Optional[StrictInt], Field(description="The lease duration is required to acquire a lease, and specifies the duration of the lease in seconds.  The lease duration must be between 15 and 60 seconds or -1 for infinite lease.")] = None,
        x_ms_lease_break_period: Annotated[Optional[StrictInt], Field(description="The lease break period duration is optional to break a lease, and  specifies the break period of the lease in seconds.  The lease break  duration must be between 0 and 60 seconds.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Required when \"x-ms-lease-action\" is \"renew\", \"change\" or \"release\". For the renew and release actions, this must match the current lease ID.")] = None,
        x_ms_proposed_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Required when \"x-ms-lease-action\" is \"acquire\" or \"change\".  A lease will be acquired with this lease ID if the operation is successful.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Lease Path

        Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_lease_action: There are five lease actions: \"acquire\", \"break\", \"change\", \"renew\", and \"release\". Use \"acquire\" and specify the \"x-ms-proposed-lease-id\" and \"x-ms-lease-duration\" to acquire a new lease. Use \"break\" to break an existing lease. When a lease is broken, the lease break period is allowed to elapse, during which time no lease operation except break and release can be performed on the file. When a lease is successfully broken, the response indicates the interval in seconds until a new lease can be acquired. Use \"change\" and specify the current lease ID in \"x-ms-lease-id\" and the new lease ID in \"x-ms-proposed-lease-id\" to change the lease ID of an active lease. Use \"renew\" and specify the \"x-ms-lease-id\" to renew an existing lease. Use \"release\" and specify the \"x-ms-lease-id\" to release a lease. (required)
        :type x_ms_lease_action: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param x_ms_lease_duration: The lease duration is required to acquire a lease, and specifies the duration of the lease in seconds.  The lease duration must be between 15 and 60 seconds or -1 for infinite lease.
        :type x_ms_lease_duration: int
        :param x_ms_lease_break_period: The lease break period duration is optional to break a lease, and  specifies the break period of the lease in seconds.  The lease break  duration must be between 0 and 60 seconds.
        :type x_ms_lease_break_period: int
        :param x_ms_lease_id: Required when \"x-ms-lease-action\" is \"renew\", \"change\" or \"release\". For the renew and release actions, this must match the current lease ID.
        :type x_ms_lease_id: str
        :param x_ms_proposed_lease_id: Required when \"x-ms-lease-action\" is \"acquire\" or \"change\".  A lease will be acquired with this lease ID if the operation is successful.
        :type x_ms_proposed_lease_id: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_lease_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_lease_action=x_ms_lease_action,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            x_ms_lease_duration=x_ms_lease_duration,
            x_ms_lease_break_period=x_ms_lease_break_period,
            x_ms_lease_id=x_ms_lease_id,
            x_ms_proposed_lease_id=x_ms_proposed_lease_id,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '201': None,
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def path_lease_without_preload_content(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_lease_action: Annotated[StrictStr, Field(description="There are five lease actions: \"acquire\", \"break\", \"change\", \"renew\", and \"release\". Use \"acquire\" and specify the \"x-ms-proposed-lease-id\" and \"x-ms-lease-duration\" to acquire a new lease. Use \"break\" to break an existing lease. When a lease is broken, the lease break period is allowed to elapse, during which time no lease operation except break and release can be performed on the file. When a lease is successfully broken, the response indicates the interval in seconds until a new lease can be acquired. Use \"change\" and specify the current lease ID in \"x-ms-lease-id\" and the new lease ID in \"x-ms-proposed-lease-id\" to change the lease ID of an active lease. Use \"renew\" and specify the \"x-ms-lease-id\" to renew an existing lease. Use \"release\" and specify the \"x-ms-lease-id\" to release a lease.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        x_ms_lease_duration: Annotated[Optional[StrictInt], Field(description="The lease duration is required to acquire a lease, and specifies the duration of the lease in seconds.  The lease duration must be between 15 and 60 seconds or -1 for infinite lease.")] = None,
        x_ms_lease_break_period: Annotated[Optional[StrictInt], Field(description="The lease break period duration is optional to break a lease, and  specifies the break period of the lease in seconds.  The lease break  duration must be between 0 and 60 seconds.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Required when \"x-ms-lease-action\" is \"renew\", \"change\" or \"release\". For the renew and release actions, this must match the current lease ID.")] = None,
        x_ms_proposed_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Required when \"x-ms-lease-action\" is \"acquire\" or \"change\".  A lease will be acquired with this lease ID if the operation is successful.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lease Path

        Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_lease_action: There are five lease actions: \"acquire\", \"break\", \"change\", \"renew\", and \"release\". Use \"acquire\" and specify the \"x-ms-proposed-lease-id\" and \"x-ms-lease-duration\" to acquire a new lease. Use \"break\" to break an existing lease. When a lease is broken, the lease break period is allowed to elapse, during which time no lease operation except break and release can be performed on the file. When a lease is successfully broken, the response indicates the interval in seconds until a new lease can be acquired. Use \"change\" and specify the current lease ID in \"x-ms-lease-id\" and the new lease ID in \"x-ms-proposed-lease-id\" to change the lease ID of an active lease. Use \"renew\" and specify the \"x-ms-lease-id\" to renew an existing lease. Use \"release\" and specify the \"x-ms-lease-id\" to release a lease. (required)
        :type x_ms_lease_action: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param x_ms_lease_duration: The lease duration is required to acquire a lease, and specifies the duration of the lease in seconds.  The lease duration must be between 15 and 60 seconds or -1 for infinite lease.
        :type x_ms_lease_duration: int
        :param x_ms_lease_break_period: The lease break period duration is optional to break a lease, and  specifies the break period of the lease in seconds.  The lease break  duration must be between 0 and 60 seconds.
        :type x_ms_lease_break_period: int
        :param x_ms_lease_id: Required when \"x-ms-lease-action\" is \"renew\", \"change\" or \"release\". For the renew and release actions, this must match the current lease ID.
        :type x_ms_lease_id: str
        :param x_ms_proposed_lease_id: Required when \"x-ms-lease-action\" is \"acquire\" or \"change\".  A lease will be acquired with this lease ID if the operation is successful.
        :type x_ms_proposed_lease_id: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_lease_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_lease_action=x_ms_lease_action,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            x_ms_lease_duration=x_ms_lease_duration,
            x_ms_lease_break_period=x_ms_lease_break_period,
            x_ms_lease_id=x_ms_lease_id,
            x_ms_proposed_lease_id=x_ms_proposed_lease_id,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '201': None,
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _path_lease_serialize(
        self,
        filesystem,
        path,
        x_ms_lease_action,
        x_ms_client_request_id,
        timeout,
        x_ms_date,
        x_ms_version,
        x_ms_lease_duration,
        x_ms_lease_break_period,
        x_ms_lease_id,
        x_ms_proposed_lease_id,
        if_match,
        if_none_match,
        if_modified_since,
        if_unmodified_since,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if filesystem is not None:
            _path_params['filesystem'] = filesystem
        if path is not None:
            _path_params['path'] = path
        # process the query parameters
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        if x_ms_client_request_id is not None:
            _header_params['x-ms-client-request-id'] = x_ms_client_request_id
        if x_ms_date is not None:
            _header_params['x-ms-date'] = x_ms_date
        if x_ms_version is not None:
            _header_params['x-ms-version'] = x_ms_version
        if x_ms_lease_action is not None:
            _header_params['x-ms-lease-action'] = x_ms_lease_action
        if x_ms_lease_duration is not None:
            _header_params['x-ms-lease-duration'] = x_ms_lease_duration
        if x_ms_lease_break_period is not None:
            _header_params['x-ms-lease-break-period'] = x_ms_lease_break_period
        if x_ms_lease_id is not None:
            _header_params['x-ms-lease-id'] = x_ms_lease_id
        if x_ms_proposed_lease_id is not None:
            _header_params['x-ms-proposed-lease-id'] = x_ms_proposed_lease_id
        if if_match is not None:
            _header_params['If-Match'] = if_match
        if if_none_match is not None:
            _header_params['If-None-Match'] = if_none_match
        if if_modified_since is not None:
            _header_params['If-Modified-Since'] = if_modified_since
        if if_unmodified_since is not None:
            _header_params['If-Unmodified-Since'] = if_unmodified_since
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/{filesystem}/{path}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def path_read(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        range: Annotated[Optional[StrictStr], Field(description="The HTTP Range request header specifies one or more byte ranges of the resource to be retrieved.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Read File

        Read the contents of a file.  For read operations, range requests are supported. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param range: The HTTP Range request header specifies one or more byte ranges of the resource to be retrieved.
        :type range: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_read_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            range=range,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '206': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def path_read_with_http_info(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        range: Annotated[Optional[StrictStr], Field(description="The HTTP Range request header specifies one or more byte ranges of the resource to be retrieved.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Read File

        Read the contents of a file.  For read operations, range requests are supported. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param range: The HTTP Range request header specifies one or more byte ranges of the resource to be retrieved.
        :type range: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_read_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            range=range,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '206': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def path_read_without_preload_content(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        range: Annotated[Optional[StrictStr], Field(description="The HTTP Range request header specifies one or more byte ranges of the resource to be retrieved.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Read File

        Read the contents of a file.  For read operations, range requests are supported. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param range: The HTTP Range request header specifies one or more byte ranges of the resource to be retrieved.
        :type range: str
        :param if_match: Optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_read_serialize(
            filesystem=filesystem,
            path=path,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            range=range,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '206': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _path_read_serialize(
        self,
        filesystem,
        path,
        x_ms_client_request_id,
        timeout,
        x_ms_date,
        x_ms_version,
        range,
        if_match,
        if_none_match,
        if_modified_since,
        if_unmodified_since,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if filesystem is not None:
            _path_params['filesystem'] = filesystem
        if path is not None:
            _path_params['path'] = path
        # process the query parameters
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        # process the header parameters
        if x_ms_client_request_id is not None:
            _header_params['x-ms-client-request-id'] = x_ms_client_request_id
        if x_ms_date is not None:
            _header_params['x-ms-date'] = x_ms_date
        if x_ms_version is not None:
            _header_params['x-ms-version'] = x_ms_version
        if range is not None:
            _header_params['Range'] = range
        if if_match is not None:
            _header_params['If-Match'] = if_match
        if if_none_match is not None:
            _header_params['If-None-Match'] = if_none_match
        if if_modified_since is not None:
            _header_params['If-Modified-Since'] = if_modified_since
        if if_unmodified_since is not None:
            _header_params['If-Unmodified-Since'] = if_unmodified_since
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/octet-stream', 
                    'text/plain'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{filesystem}/{path}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def path_update(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        action: Annotated[StrictStr, Field(description="The action must be \"append\" to upload data to be appended to a file, \"flush\" to flush previously uploaded data to a file, \"setProperties\" to set the properties of a file or directory, or \"setAccessControl\" to set the owner, group, permissions, or access control list for a file or directory.  Note that Hierarchical Namespace must be enabled for the account in order to use access control.  Also note that the Access Control List (ACL) includes permissions for the owner, owning group, and others, so the x-ms-permissions and x-ms-acl request headers are mutually exclusive.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        position: Annotated[Optional[StrictInt], Field(description="This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.  It is required when uploading data to be appended to the file and when flushing previously uploaded data to the file.  The value must be the position where the data is to be appended.  Uploaded data is not immediately flushed, or written, to the file.  To flush, the previously uploaded data must be contiguous, the position parameter must be specified and equal to the length of the file after all data has been written, and there must not be a request entity body included with the request.")] = None,
        retain_uncommitted_data: Annotated[Optional[StrictBool], Field(description="Valid only for flush operations.  If \"true\", uncommitted data is retained after the flush operation completes; otherwise, the uncommitted data is deleted after the flush operation.  The default is false.  Data at offsets less than the specified position are written to the file when flush succeeds, but this optional parameter allows data after the flush position to be retained for a future flush operation.")] = None,
        content_length: Annotated[Optional[StrictStr], Field(description="Required for \"Append Data\" and \"Flush Data\".  Must be 0 for \"Flush Data\".  Must be the length of the request content in bytes for \"Append Data\".")] = None,
        x_ms_lease_action: Annotated[Optional[StrictStr], Field(description="Optional.  The lease action can be \"renew\" to renew an existing lease or \"release\" to release a lease.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The lease ID must be specified if there is an active lease.")] = None,
        x_ms_cache_control: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.")] = None,
        x_ms_content_type: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.")] = None,
        x_ms_content_disposition: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.")] = None,
        x_ms_content_encoding: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.")] = None,
        x_ms_content_language: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.")] = None,
        x_ms_properties: Annotated[Optional[StrictStr], Field(description="Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.  Valid only for the setProperties operation.  If the file or directory exists, any properties not included in the list will be removed.  All properties are removed if the header is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag, then make a conditional request with the E-Tag and include values for all properties.")] = None,
        x_ms_owner: Annotated[Optional[StrictStr], Field(description="Optional and valid only for the setAccessControl operation. Sets the owner of the file or directory.")] = None,
        x_ms_group: Annotated[Optional[StrictStr], Field(description="Optional and valid only for the setAccessControl operation. Sets the owning group of the file or directory.")] = None,
        x_ms_permissions: Annotated[Optional[StrictStr], Field(description="Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. Invalid in conjunction with x-ms-acl.")] = None,
        x_ms_acl: Annotated[Optional[StrictStr], Field(description="Optional and valid only for the setAccessControl operation. Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries that fully replaces the existing access control list (ACL).  Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format \"[scope:][type]:[id]:[permissions]\". The scope must be \"default\" to indicate the ACE belongs to the default ACL for a directory; otherwise scope is implicit and the ACE belongs to the access ACL.  There are four ACE types: \"user\" grants rights to the owner or a named user, \"group\" grants rights to the owning group or a named group, \"mask\" restricts rights granted to named users and the members of groups, and \"other\" grants rights to all users not found in any of the other entries. The user or group identifier is omitted for entries of type \"mask\" and \"other\".  The user or group identifier is also omitted for the owner and owning group.  The permission field is a 3-character sequence where the first character is 'r' to grant read access, the second character is 'w' to grant write access, and the third character is 'x' to grant execute permission.  If access is not granted, the '-' character is used to denote that the permission is denied. For example, the following ACL grants read, write, and execute rights to the file owner and john.doe@contoso, the read right to the owning group, and nothing to everyone else: \"user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx\". Invalid in conjunction with x-ms-permissions.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        request_body: Annotated[Optional[Dict[str, Any]], Field(description="Valid only for append operations.  The data to be uploaded and appended to the file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Append Data | Flush Data | Set Properties | Set Access Control

        Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, sets properties for a file or directory, or sets access control for a file or directory. Data can only be appended to a file. This operation supports conditional HTTP requests. For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param action: The action must be \"append\" to upload data to be appended to a file, \"flush\" to flush previously uploaded data to a file, \"setProperties\" to set the properties of a file or directory, or \"setAccessControl\" to set the owner, group, permissions, or access control list for a file or directory.  Note that Hierarchical Namespace must be enabled for the account in order to use access control.  Also note that the Access Control List (ACL) includes permissions for the owner, owning group, and others, so the x-ms-permissions and x-ms-acl request headers are mutually exclusive. (required)
        :type action: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param position: This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.  It is required when uploading data to be appended to the file and when flushing previously uploaded data to the file.  The value must be the position where the data is to be appended.  Uploaded data is not immediately flushed, or written, to the file.  To flush, the previously uploaded data must be contiguous, the position parameter must be specified and equal to the length of the file after all data has been written, and there must not be a request entity body included with the request.
        :type position: int
        :param retain_uncommitted_data: Valid only for flush operations.  If \"true\", uncommitted data is retained after the flush operation completes; otherwise, the uncommitted data is deleted after the flush operation.  The default is false.  Data at offsets less than the specified position are written to the file when flush succeeds, but this optional parameter allows data after the flush position to be retained for a future flush operation.
        :type retain_uncommitted_data: bool
        :param content_length: Required for \"Append Data\" and \"Flush Data\".  Must be 0 for \"Flush Data\".  Must be the length of the request content in bytes for \"Append Data\".
        :type content_length: str
        :param x_ms_lease_action: Optional.  The lease action can be \"renew\" to renew an existing lease or \"release\" to release a lease.
        :type x_ms_lease_action: str
        :param x_ms_lease_id: The lease ID must be specified if there is an active lease.
        :type x_ms_lease_id: str
        :param x_ms_cache_control: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.
        :type x_ms_cache_control: str
        :param x_ms_content_type: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.
        :type x_ms_content_type: str
        :param x_ms_content_disposition: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.
        :type x_ms_content_disposition: str
        :param x_ms_content_encoding: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.
        :type x_ms_content_encoding: str
        :param x_ms_content_language: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.
        :type x_ms_content_language: str
        :param x_ms_properties: Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.  Valid only for the setProperties operation.  If the file or directory exists, any properties not included in the list will be removed.  All properties are removed if the header is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag, then make a conditional request with the E-Tag and include values for all properties.
        :type x_ms_properties: str
        :param x_ms_owner: Optional and valid only for the setAccessControl operation. Sets the owner of the file or directory.
        :type x_ms_owner: str
        :param x_ms_group: Optional and valid only for the setAccessControl operation. Sets the owning group of the file or directory.
        :type x_ms_group: str
        :param x_ms_permissions: Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. Invalid in conjunction with x-ms-acl.
        :type x_ms_permissions: str
        :param x_ms_acl: Optional and valid only for the setAccessControl operation. Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries that fully replaces the existing access control list (ACL).  Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format \"[scope:][type]:[id]:[permissions]\". The scope must be \"default\" to indicate the ACE belongs to the default ACL for a directory; otherwise scope is implicit and the ACE belongs to the access ACL.  There are four ACE types: \"user\" grants rights to the owner or a named user, \"group\" grants rights to the owning group or a named group, \"mask\" restricts rights granted to named users and the members of groups, and \"other\" grants rights to all users not found in any of the other entries. The user or group identifier is omitted for entries of type \"mask\" and \"other\".  The user or group identifier is also omitted for the owner and owning group.  The permission field is a 3-character sequence where the first character is 'r' to grant read access, the second character is 'w' to grant write access, and the third character is 'x' to grant execute permission.  If access is not granted, the '-' character is used to denote that the permission is denied. For example, the following ACL grants read, write, and execute rights to the file owner and john.doe@contoso, the read right to the owning group, and nothing to everyone else: \"user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx\". Invalid in conjunction with x-ms-permissions.
        :type x_ms_acl: str
        :param if_match: Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param request_body: Valid only for append operations.  The data to be uploaded and appended to the file.
        :type request_body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_update_serialize(
            filesystem=filesystem,
            path=path,
            action=action,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            position=position,
            retain_uncommitted_data=retain_uncommitted_data,
            content_length=content_length,
            x_ms_lease_action=x_ms_lease_action,
            x_ms_lease_id=x_ms_lease_id,
            x_ms_cache_control=x_ms_cache_control,
            x_ms_content_type=x_ms_content_type,
            x_ms_content_disposition=x_ms_content_disposition,
            x_ms_content_encoding=x_ms_content_encoding,
            x_ms_content_language=x_ms_content_language,
            x_ms_properties=x_ms_properties,
            x_ms_owner=x_ms_owner,
            x_ms_group=x_ms_group,
            x_ms_permissions=x_ms_permissions,
            x_ms_acl=x_ms_acl,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def path_update_with_http_info(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        action: Annotated[StrictStr, Field(description="The action must be \"append\" to upload data to be appended to a file, \"flush\" to flush previously uploaded data to a file, \"setProperties\" to set the properties of a file or directory, or \"setAccessControl\" to set the owner, group, permissions, or access control list for a file or directory.  Note that Hierarchical Namespace must be enabled for the account in order to use access control.  Also note that the Access Control List (ACL) includes permissions for the owner, owning group, and others, so the x-ms-permissions and x-ms-acl request headers are mutually exclusive.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        position: Annotated[Optional[StrictInt], Field(description="This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.  It is required when uploading data to be appended to the file and when flushing previously uploaded data to the file.  The value must be the position where the data is to be appended.  Uploaded data is not immediately flushed, or written, to the file.  To flush, the previously uploaded data must be contiguous, the position parameter must be specified and equal to the length of the file after all data has been written, and there must not be a request entity body included with the request.")] = None,
        retain_uncommitted_data: Annotated[Optional[StrictBool], Field(description="Valid only for flush operations.  If \"true\", uncommitted data is retained after the flush operation completes; otherwise, the uncommitted data is deleted after the flush operation.  The default is false.  Data at offsets less than the specified position are written to the file when flush succeeds, but this optional parameter allows data after the flush position to be retained for a future flush operation.")] = None,
        content_length: Annotated[Optional[StrictStr], Field(description="Required for \"Append Data\" and \"Flush Data\".  Must be 0 for \"Flush Data\".  Must be the length of the request content in bytes for \"Append Data\".")] = None,
        x_ms_lease_action: Annotated[Optional[StrictStr], Field(description="Optional.  The lease action can be \"renew\" to renew an existing lease or \"release\" to release a lease.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The lease ID must be specified if there is an active lease.")] = None,
        x_ms_cache_control: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.")] = None,
        x_ms_content_type: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.")] = None,
        x_ms_content_disposition: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.")] = None,
        x_ms_content_encoding: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.")] = None,
        x_ms_content_language: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.")] = None,
        x_ms_properties: Annotated[Optional[StrictStr], Field(description="Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.  Valid only for the setProperties operation.  If the file or directory exists, any properties not included in the list will be removed.  All properties are removed if the header is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag, then make a conditional request with the E-Tag and include values for all properties.")] = None,
        x_ms_owner: Annotated[Optional[StrictStr], Field(description="Optional and valid only for the setAccessControl operation. Sets the owner of the file or directory.")] = None,
        x_ms_group: Annotated[Optional[StrictStr], Field(description="Optional and valid only for the setAccessControl operation. Sets the owning group of the file or directory.")] = None,
        x_ms_permissions: Annotated[Optional[StrictStr], Field(description="Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. Invalid in conjunction with x-ms-acl.")] = None,
        x_ms_acl: Annotated[Optional[StrictStr], Field(description="Optional and valid only for the setAccessControl operation. Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries that fully replaces the existing access control list (ACL).  Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format \"[scope:][type]:[id]:[permissions]\". The scope must be \"default\" to indicate the ACE belongs to the default ACL for a directory; otherwise scope is implicit and the ACE belongs to the access ACL.  There are four ACE types: \"user\" grants rights to the owner or a named user, \"group\" grants rights to the owning group or a named group, \"mask\" restricts rights granted to named users and the members of groups, and \"other\" grants rights to all users not found in any of the other entries. The user or group identifier is omitted for entries of type \"mask\" and \"other\".  The user or group identifier is also omitted for the owner and owning group.  The permission field is a 3-character sequence where the first character is 'r' to grant read access, the second character is 'w' to grant write access, and the third character is 'x' to grant execute permission.  If access is not granted, the '-' character is used to denote that the permission is denied. For example, the following ACL grants read, write, and execute rights to the file owner and john.doe@contoso, the read right to the owning group, and nothing to everyone else: \"user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx\". Invalid in conjunction with x-ms-permissions.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        request_body: Annotated[Optional[Dict[str, Any]], Field(description="Valid only for append operations.  The data to be uploaded and appended to the file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Append Data | Flush Data | Set Properties | Set Access Control

        Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, sets properties for a file or directory, or sets access control for a file or directory. Data can only be appended to a file. This operation supports conditional HTTP requests. For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param action: The action must be \"append\" to upload data to be appended to a file, \"flush\" to flush previously uploaded data to a file, \"setProperties\" to set the properties of a file or directory, or \"setAccessControl\" to set the owner, group, permissions, or access control list for a file or directory.  Note that Hierarchical Namespace must be enabled for the account in order to use access control.  Also note that the Access Control List (ACL) includes permissions for the owner, owning group, and others, so the x-ms-permissions and x-ms-acl request headers are mutually exclusive. (required)
        :type action: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param position: This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.  It is required when uploading data to be appended to the file and when flushing previously uploaded data to the file.  The value must be the position where the data is to be appended.  Uploaded data is not immediately flushed, or written, to the file.  To flush, the previously uploaded data must be contiguous, the position parameter must be specified and equal to the length of the file after all data has been written, and there must not be a request entity body included with the request.
        :type position: int
        :param retain_uncommitted_data: Valid only for flush operations.  If \"true\", uncommitted data is retained after the flush operation completes; otherwise, the uncommitted data is deleted after the flush operation.  The default is false.  Data at offsets less than the specified position are written to the file when flush succeeds, but this optional parameter allows data after the flush position to be retained for a future flush operation.
        :type retain_uncommitted_data: bool
        :param content_length: Required for \"Append Data\" and \"Flush Data\".  Must be 0 for \"Flush Data\".  Must be the length of the request content in bytes for \"Append Data\".
        :type content_length: str
        :param x_ms_lease_action: Optional.  The lease action can be \"renew\" to renew an existing lease or \"release\" to release a lease.
        :type x_ms_lease_action: str
        :param x_ms_lease_id: The lease ID must be specified if there is an active lease.
        :type x_ms_lease_id: str
        :param x_ms_cache_control: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.
        :type x_ms_cache_control: str
        :param x_ms_content_type: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.
        :type x_ms_content_type: str
        :param x_ms_content_disposition: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.
        :type x_ms_content_disposition: str
        :param x_ms_content_encoding: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.
        :type x_ms_content_encoding: str
        :param x_ms_content_language: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.
        :type x_ms_content_language: str
        :param x_ms_properties: Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.  Valid only for the setProperties operation.  If the file or directory exists, any properties not included in the list will be removed.  All properties are removed if the header is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag, then make a conditional request with the E-Tag and include values for all properties.
        :type x_ms_properties: str
        :param x_ms_owner: Optional and valid only for the setAccessControl operation. Sets the owner of the file or directory.
        :type x_ms_owner: str
        :param x_ms_group: Optional and valid only for the setAccessControl operation. Sets the owning group of the file or directory.
        :type x_ms_group: str
        :param x_ms_permissions: Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. Invalid in conjunction with x-ms-acl.
        :type x_ms_permissions: str
        :param x_ms_acl: Optional and valid only for the setAccessControl operation. Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries that fully replaces the existing access control list (ACL).  Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format \"[scope:][type]:[id]:[permissions]\". The scope must be \"default\" to indicate the ACE belongs to the default ACL for a directory; otherwise scope is implicit and the ACE belongs to the access ACL.  There are four ACE types: \"user\" grants rights to the owner or a named user, \"group\" grants rights to the owning group or a named group, \"mask\" restricts rights granted to named users and the members of groups, and \"other\" grants rights to all users not found in any of the other entries. The user or group identifier is omitted for entries of type \"mask\" and \"other\".  The user or group identifier is also omitted for the owner and owning group.  The permission field is a 3-character sequence where the first character is 'r' to grant read access, the second character is 'w' to grant write access, and the third character is 'x' to grant execute permission.  If access is not granted, the '-' character is used to denote that the permission is denied. For example, the following ACL grants read, write, and execute rights to the file owner and john.doe@contoso, the read right to the owning group, and nothing to everyone else: \"user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx\". Invalid in conjunction with x-ms-permissions.
        :type x_ms_acl: str
        :param if_match: Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param request_body: Valid only for append operations.  The data to be uploaded and appended to the file.
        :type request_body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_update_serialize(
            filesystem=filesystem,
            path=path,
            action=action,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            position=position,
            retain_uncommitted_data=retain_uncommitted_data,
            content_length=content_length,
            x_ms_lease_action=x_ms_lease_action,
            x_ms_lease_id=x_ms_lease_id,
            x_ms_cache_control=x_ms_cache_control,
            x_ms_content_type=x_ms_content_type,
            x_ms_content_disposition=x_ms_content_disposition,
            x_ms_content_encoding=x_ms_content_encoding,
            x_ms_content_language=x_ms_content_language,
            x_ms_properties=x_ms_properties,
            x_ms_owner=x_ms_owner,
            x_ms_group=x_ms_group,
            x_ms_permissions=x_ms_permissions,
            x_ms_acl=x_ms_acl,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def path_update_without_preload_content(
        self,
        filesystem: Annotated[str, Field(min_length=3, strict=True, max_length=63, description="The filesystem identifier.")],
        path: Annotated[StrictStr, Field(description="The file or directory path.")],
        action: Annotated[StrictStr, Field(description="The action must be \"append\" to upload data to be appended to a file, \"flush\" to flush previously uploaded data to a file, \"setProperties\" to set the properties of a file or directory, or \"setAccessControl\" to set the owner, group, permissions, or access control list for a file or directory.  Note that Hierarchical Namespace must be enabled for the account in order to use access control.  Also note that the Access Control List (ACL) includes permissions for the owner, owning group, and others, so the x-ms-permissions and x-ms-acl request headers are mutually exclusive.")],
        x_ms_client_request_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="A UUID recorded in the analytics logs for troubleshooting and correlation.")] = None,
        timeout: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.")] = None,
        x_ms_date: Annotated[Optional[StrictStr], Field(description="Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.")] = None,
        x_ms_version: Annotated[Optional[StrictStr], Field(description="Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.")] = None,
        position: Annotated[Optional[StrictInt], Field(description="This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.  It is required when uploading data to be appended to the file and when flushing previously uploaded data to the file.  The value must be the position where the data is to be appended.  Uploaded data is not immediately flushed, or written, to the file.  To flush, the previously uploaded data must be contiguous, the position parameter must be specified and equal to the length of the file after all data has been written, and there must not be a request entity body included with the request.")] = None,
        retain_uncommitted_data: Annotated[Optional[StrictBool], Field(description="Valid only for flush operations.  If \"true\", uncommitted data is retained after the flush operation completes; otherwise, the uncommitted data is deleted after the flush operation.  The default is false.  Data at offsets less than the specified position are written to the file when flush succeeds, but this optional parameter allows data after the flush position to be retained for a future flush operation.")] = None,
        content_length: Annotated[Optional[StrictStr], Field(description="Required for \"Append Data\" and \"Flush Data\".  Must be 0 for \"Flush Data\".  Must be the length of the request content in bytes for \"Append Data\".")] = None,
        x_ms_lease_action: Annotated[Optional[StrictStr], Field(description="Optional.  The lease action can be \"renew\" to renew an existing lease or \"release\" to release a lease.")] = None,
        x_ms_lease_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="The lease ID must be specified if there is an active lease.")] = None,
        x_ms_cache_control: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.")] = None,
        x_ms_content_type: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.")] = None,
        x_ms_content_disposition: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.")] = None,
        x_ms_content_encoding: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.")] = None,
        x_ms_content_language: Annotated[Optional[StrictStr], Field(description="Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.")] = None,
        x_ms_properties: Annotated[Optional[StrictStr], Field(description="Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.  Valid only for the setProperties operation.  If the file or directory exists, any properties not included in the list will be removed.  All properties are removed if the header is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag, then make a conditional request with the E-Tag and include values for all properties.")] = None,
        x_ms_owner: Annotated[Optional[StrictStr], Field(description="Optional and valid only for the setAccessControl operation. Sets the owner of the file or directory.")] = None,
        x_ms_group: Annotated[Optional[StrictStr], Field(description="Optional and valid only for the setAccessControl operation. Sets the owning group of the file or directory.")] = None,
        x_ms_permissions: Annotated[Optional[StrictStr], Field(description="Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. Invalid in conjunction with x-ms-acl.")] = None,
        x_ms_acl: Annotated[Optional[StrictStr], Field(description="Optional and valid only for the setAccessControl operation. Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries that fully replaces the existing access control list (ACL).  Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format \"[scope:][type]:[id]:[permissions]\". The scope must be \"default\" to indicate the ACE belongs to the default ACL for a directory; otherwise scope is implicit and the ACE belongs to the access ACL.  There are four ACE types: \"user\" grants rights to the owner or a named user, \"group\" grants rights to the owning group or a named group, \"mask\" restricts rights granted to named users and the members of groups, and \"other\" grants rights to all users not found in any of the other entries. The user or group identifier is omitted for entries of type \"mask\" and \"other\".  The user or group identifier is also omitted for the owner and owning group.  The permission field is a 3-character sequence where the first character is 'r' to grant read access, the second character is 'w' to grant write access, and the third character is 'x' to grant execute permission.  If access is not granted, the '-' character is used to denote that the permission is denied. For example, the following ACL grants read, write, and execute rights to the file owner and john.doe@contoso, the read right to the owning group, and nothing to everyone else: \"user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx\". Invalid in conjunction with x-ms-permissions.")] = None,
        if_match: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.")] = None,
        if_none_match: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.")] = None,
        if_modified_since: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.")] = None,
        if_unmodified_since: Annotated[Optional[StrictStr], Field(description="Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.")] = None,
        request_body: Annotated[Optional[Dict[str, Any]], Field(description="Valid only for append operations.  The data to be uploaded and appended to the file.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Append Data | Flush Data | Set Properties | Set Access Control

        Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, sets properties for a file or directory, or sets access control for a file or directory. Data can only be appended to a file. This operation supports conditional HTTP requests. For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier. (required)
        :type filesystem: str
        :param path: The file or directory path. (required)
        :type path: str
        :param action: The action must be \"append\" to upload data to be appended to a file, \"flush\" to flush previously uploaded data to a file, \"setProperties\" to set the properties of a file or directory, or \"setAccessControl\" to set the owner, group, permissions, or access control list for a file or directory.  Note that Hierarchical Namespace must be enabled for the account in order to use access control.  Also note that the Access Control List (ACL) includes permissions for the owner, owning group, and others, so the x-ms-permissions and x-ms-acl request headers are mutually exclusive. (required)
        :type action: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the operation completes, the operation fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param x_ms_version: Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
        :type x_ms_version: str
        :param position: This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.  It is required when uploading data to be appended to the file and when flushing previously uploaded data to the file.  The value must be the position where the data is to be appended.  Uploaded data is not immediately flushed, or written, to the file.  To flush, the previously uploaded data must be contiguous, the position parameter must be specified and equal to the length of the file after all data has been written, and there must not be a request entity body included with the request.
        :type position: int
        :param retain_uncommitted_data: Valid only for flush operations.  If \"true\", uncommitted data is retained after the flush operation completes; otherwise, the uncommitted data is deleted after the flush operation.  The default is false.  Data at offsets less than the specified position are written to the file when flush succeeds, but this optional parameter allows data after the flush position to be retained for a future flush operation.
        :type retain_uncommitted_data: bool
        :param content_length: Required for \"Append Data\" and \"Flush Data\".  Must be 0 for \"Flush Data\".  Must be the length of the request content in bytes for \"Append Data\".
        :type content_length: str
        :param x_ms_lease_action: Optional.  The lease action can be \"renew\" to renew an existing lease or \"release\" to release a lease.
        :type x_ms_lease_action: str
        :param x_ms_lease_id: The lease ID must be specified if there is an active lease.
        :type x_ms_lease_id: str
        :param x_ms_cache_control: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Cache-Control\" response header for \"Read File\" operations.
        :type x_ms_cache_control: str
        :param x_ms_content_type: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Type\" response header for \"Read File\" operations.
        :type x_ms_content_type: str
        :param x_ms_content_disposition: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Disposition\" response header for \"Read File\" operations.
        :type x_ms_content_disposition: str
        :param x_ms_content_encoding: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Encoding\" response header for \"Read File\" operations.
        :type x_ms_content_encoding: str
        :param x_ms_content_language: Optional and only valid for flush and set properties operations.  The service stores this value and includes it in the \"Content-Language\" response header for \"Read File\" operations.
        :type x_ms_content_language: str
        :param x_ms_properties: Optional.  User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs \"n1=v1, n2=v2, ...\", where each value is base64 encoded.  Valid only for the setProperties operation.  If the file or directory exists, any properties not included in the list will be removed.  All properties are removed if the header is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag, then make a conditional request with the E-Tag and include values for all properties.
        :type x_ms_properties: str
        :param x_ms_owner: Optional and valid only for the setAccessControl operation. Sets the owner of the file or directory.
        :type x_ms_owner: str
        :param x_ms_group: Optional and valid only for the setAccessControl operation. Sets the owning group of the file or directory.
        :type x_ms_group: str
        :param x_ms_permissions: Optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. Invalid in conjunction with x-ms-acl.
        :type x_ms_permissions: str
        :param x_ms_acl: Optional and valid only for the setAccessControl operation. Sets POSIX access control rights on files and directories. The value is a comma-separated list of access control entries that fully replaces the existing access control list (ACL).  Each access control entry (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format \"[scope:][type]:[id]:[permissions]\". The scope must be \"default\" to indicate the ACE belongs to the default ACL for a directory; otherwise scope is implicit and the ACE belongs to the access ACL.  There are four ACE types: \"user\" grants rights to the owner or a named user, \"group\" grants rights to the owning group or a named group, \"mask\" restricts rights granted to named users and the members of groups, and \"other\" grants rights to all users not found in any of the other entries. The user or group identifier is omitted for entries of type \"mask\" and \"other\".  The user or group identifier is also omitted for the owner and owning group.  The permission field is a 3-character sequence where the first character is 'r' to grant read access, the second character is 'w' to grant write access, and the third character is 'x' to grant execute permission.  If access is not granted, the '-' character is used to denote that the permission is denied. For example, the following ACL grants read, write, and execute rights to the file owner and john.doe@contoso, the read right to the owning group, and nothing to everyone else: \"user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx\". Invalid in conjunction with x-ms-permissions.
        :type x_ms_acl: str
        :param if_match: Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional for Flush Data and Set Properties, but invalid for Append Data.  An ETag value or the special wildcard (\"*\") value. Specify this header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has been modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value. Specify this header to perform the operation only if the resource has not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param request_body: Valid only for append operations.  The data to be uploaded and appended to the file.
        :type request_body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._path_update_serialize(
            filesystem=filesystem,
            path=path,
            action=action,
            x_ms_client_request_id=x_ms_client_request_id,
            timeout=timeout,
            x_ms_date=x_ms_date,
            x_ms_version=x_ms_version,
            position=position,
            retain_uncommitted_data=retain_uncommitted_data,
            content_length=content_length,
            x_ms_lease_action=x_ms_lease_action,
            x_ms_lease_id=x_ms_lease_id,
            x_ms_cache_control=x_ms_cache_control,
            x_ms_content_type=x_ms_content_type,
            x_ms_content_disposition=x_ms_content_disposition,
            x_ms_content_encoding=x_ms_content_encoding,
            x_ms_content_language=x_ms_content_language,
            x_ms_properties=x_ms_properties,
            x_ms_owner=x_ms_owner,
            x_ms_group=x_ms_group,
            x_ms_permissions=x_ms_permissions,
            x_ms_acl=x_ms_acl,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _path_update_serialize(
        self,
        filesystem,
        path,
        action,
        x_ms_client_request_id,
        timeout,
        x_ms_date,
        x_ms_version,
        position,
        retain_uncommitted_data,
        content_length,
        x_ms_lease_action,
        x_ms_lease_id,
        x_ms_cache_control,
        x_ms_content_type,
        x_ms_content_disposition,
        x_ms_content_encoding,
        x_ms_content_language,
        x_ms_properties,
        x_ms_owner,
        x_ms_group,
        x_ms_permissions,
        x_ms_acl,
        if_match,
        if_none_match,
        if_modified_since,
        if_unmodified_since,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if filesystem is not None:
            _path_params['filesystem'] = filesystem
        if path is not None:
            _path_params['path'] = path
        # process the query parameters
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        if action is not None:
            
            _query_params.append(('action', action))
            
        if position is not None:
            
            _query_params.append(('position', position))
            
        if retain_uncommitted_data is not None:
            
            _query_params.append(('retainUncommittedData', retain_uncommitted_data))
            
        # process the header parameters
        if x_ms_client_request_id is not None:
            _header_params['x-ms-client-request-id'] = x_ms_client_request_id
        if x_ms_date is not None:
            _header_params['x-ms-date'] = x_ms_date
        if x_ms_version is not None:
            _header_params['x-ms-version'] = x_ms_version
        if content_length is not None:
            _header_params['Content-Length'] = content_length
        if x_ms_lease_action is not None:
            _header_params['x-ms-lease-action'] = x_ms_lease_action
        if x_ms_lease_id is not None:
            _header_params['x-ms-lease-id'] = x_ms_lease_id
        if x_ms_cache_control is not None:
            _header_params['x-ms-cache-control'] = x_ms_cache_control
        if x_ms_content_type is not None:
            _header_params['x-ms-content-type'] = x_ms_content_type
        if x_ms_content_disposition is not None:
            _header_params['x-ms-content-disposition'] = x_ms_content_disposition
        if x_ms_content_encoding is not None:
            _header_params['x-ms-content-encoding'] = x_ms_content_encoding
        if x_ms_content_language is not None:
            _header_params['x-ms-content-language'] = x_ms_content_language
        if x_ms_properties is not None:
            _header_params['x-ms-properties'] = x_ms_properties
        if x_ms_owner is not None:
            _header_params['x-ms-owner'] = x_ms_owner
        if x_ms_group is not None:
            _header_params['x-ms-group'] = x_ms_group
        if x_ms_permissions is not None:
            _header_params['x-ms-permissions'] = x_ms_permissions
        if x_ms_acl is not None:
            _header_params['x-ms-acl'] = x_ms_acl
        if if_match is not None:
            _header_params['If-Match'] = if_match
        if if_none_match is not None:
            _header_params['If-None-Match'] = if_none_match
        if if_modified_since is not None:
            _header_params['If-Modified-Since'] = if_modified_since
        if if_unmodified_since is not None:
            _header_params['If-Unmodified-Since'] = if_unmodified_since
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/octet-stream', 
                        'text/plain'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/{filesystem}/{path}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


