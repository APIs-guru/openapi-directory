# coding: utf-8

"""
    Content Moderator Client

    You use the API to scan your content as it is generated. Content Moderator then processes your content and sends the results along with relevant information either back to your systems or to the built-in review tool. You can use this information to take decisions e.g. take it down, send to human judge, etc.    When using the API, images need to have a minimum of 128 pixels and a maximum file size of 4MB.   Text can be at most 1024 characters long.   If the content passed to the text API or the image API exceeds the size limits, the API will return an error code that informs about the issue.

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.frames import Frames
from openapi_client.models.job import Job
from openapi_client.models.job_id import JobId
from openapi_client.models.review import Review
from openapi_client.models.reviews_add_video_transcript_moderation_result_request_inner import ReviewsAddVideoTranscriptModerationResultRequestInner
from openapi_client.models.reviews_create_job_request import ReviewsCreateJobRequest
from openapi_client.models.reviews_create_reviews_request_inner import ReviewsCreateReviewsRequestInner

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ReviewsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def reviews_add_video_frame(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        timescale: Annotated[Optional[StrictInt], Field(description="Timescale of the video you are adding frames to.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """reviews_add_video_frame

        The reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.    <h3>CallBack Schemas </h3>  <h4>Review Completion CallBack Sample</h4>  <p>  {<br/>    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param timescale: Timescale of the video you are adding frames to.
        :type timescale: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_add_video_frame_serialize(
            team_name=team_name,
            review_id=review_id,
            timescale=timescale,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reviews_add_video_frame_with_http_info(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        timescale: Annotated[Optional[StrictInt], Field(description="Timescale of the video you are adding frames to.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """reviews_add_video_frame

        The reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.    <h3>CallBack Schemas </h3>  <h4>Review Completion CallBack Sample</h4>  <p>  {<br/>    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param timescale: Timescale of the video you are adding frames to.
        :type timescale: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_add_video_frame_serialize(
            team_name=team_name,
            review_id=review_id,
            timescale=timescale,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reviews_add_video_frame_without_preload_content(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        timescale: Annotated[Optional[StrictInt], Field(description="Timescale of the video you are adding frames to.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reviews_add_video_frame

        The reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.    <h3>CallBack Schemas </h3>  <h4>Review Completion CallBack Sample</h4>  <p>  {<br/>    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param timescale: Timescale of the video you are adding frames to.
        :type timescale: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_add_video_frame_serialize(
            team_name=team_name,
            review_id=review_id,
            timescale=timescale,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reviews_add_video_frame_serialize(
        self,
        team_name,
        review_id,
        timescale,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if team_name is not None:
            _path_params['teamName'] = team_name
        if review_id is not None:
            _path_params['reviewId'] = review_id
        # process the query parameters
        if timescale is not None:
            
            _query_params.append(('timescale', timescale))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apim_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/frames',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reviews_add_video_transcript(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        content_type: Annotated[StrictStr, Field(description="The content type.")],
        vtt_file: Annotated[Dict[str, Any], Field(description="Transcript file of the video.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """reviews_add_video_transcript

        This API adds a transcript file (text version of all the words spoken in a video) to a video review. The file should be a valid WebVTT format.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param content_type: The content type. (required)
        :type content_type: str
        :param vtt_file: Transcript file of the video. (required)
        :type vtt_file: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_add_video_transcript_serialize(
            team_name=team_name,
            review_id=review_id,
            content_type=content_type,
            vtt_file=vtt_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reviews_add_video_transcript_with_http_info(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        content_type: Annotated[StrictStr, Field(description="The content type.")],
        vtt_file: Annotated[Dict[str, Any], Field(description="Transcript file of the video.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """reviews_add_video_transcript

        This API adds a transcript file (text version of all the words spoken in a video) to a video review. The file should be a valid WebVTT format.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param content_type: The content type. (required)
        :type content_type: str
        :param vtt_file: Transcript file of the video. (required)
        :type vtt_file: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_add_video_transcript_serialize(
            team_name=team_name,
            review_id=review_id,
            content_type=content_type,
            vtt_file=vtt_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reviews_add_video_transcript_without_preload_content(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        content_type: Annotated[StrictStr, Field(description="The content type.")],
        vtt_file: Annotated[Dict[str, Any], Field(description="Transcript file of the video.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reviews_add_video_transcript

        This API adds a transcript file (text version of all the words spoken in a video) to a video review. The file should be a valid WebVTT format.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param content_type: The content type. (required)
        :type content_type: str
        :param vtt_file: Transcript file of the video. (required)
        :type vtt_file: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_add_video_transcript_serialize(
            team_name=team_name,
            review_id=review_id,
            content_type=content_type,
            vtt_file=vtt_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reviews_add_video_transcript_serialize(
        self,
        team_name,
        review_id,
        content_type,
        vtt_file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if team_name is not None:
            _path_params['teamName'] = team_name
        if review_id is not None:
            _path_params['reviewId'] = review_id
        # process the query parameters
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        # process the form parameters
        # process the body parameter
        if vtt_file is not None:
            _body_params = vtt_file


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'text/plain'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apim_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/transcript',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reviews_add_video_transcript_moderation_result(
        self,
        content_type: Annotated[StrictStr, Field(description="The content type.")],
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        transcript_moderation_body: Annotated[List[ReviewsAddVideoTranscriptModerationResultRequestInner], Field(description="Body for add video transcript moderation result API")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """reviews_add_video_transcript_moderation_result

        This API adds a transcript screen text result file for a video review. Transcript screen text result file is a result of Screen Text API . In order to generate transcript screen text result file , a transcript file has to be screened for profanity using Screen Text API.

        :param content_type: The content type. (required)
        :type content_type: str
        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param transcript_moderation_body: Body for add video transcript moderation result API (required)
        :type transcript_moderation_body: List[ReviewsAddVideoTranscriptModerationResultRequestInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_add_video_transcript_moderation_result_serialize(
            content_type=content_type,
            team_name=team_name,
            review_id=review_id,
            transcript_moderation_body=transcript_moderation_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reviews_add_video_transcript_moderation_result_with_http_info(
        self,
        content_type: Annotated[StrictStr, Field(description="The content type.")],
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        transcript_moderation_body: Annotated[List[ReviewsAddVideoTranscriptModerationResultRequestInner], Field(description="Body for add video transcript moderation result API")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """reviews_add_video_transcript_moderation_result

        This API adds a transcript screen text result file for a video review. Transcript screen text result file is a result of Screen Text API . In order to generate transcript screen text result file , a transcript file has to be screened for profanity using Screen Text API.

        :param content_type: The content type. (required)
        :type content_type: str
        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param transcript_moderation_body: Body for add video transcript moderation result API (required)
        :type transcript_moderation_body: List[ReviewsAddVideoTranscriptModerationResultRequestInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_add_video_transcript_moderation_result_serialize(
            content_type=content_type,
            team_name=team_name,
            review_id=review_id,
            transcript_moderation_body=transcript_moderation_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reviews_add_video_transcript_moderation_result_without_preload_content(
        self,
        content_type: Annotated[StrictStr, Field(description="The content type.")],
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        transcript_moderation_body: Annotated[List[ReviewsAddVideoTranscriptModerationResultRequestInner], Field(description="Body for add video transcript moderation result API")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reviews_add_video_transcript_moderation_result

        This API adds a transcript screen text result file for a video review. Transcript screen text result file is a result of Screen Text API . In order to generate transcript screen text result file , a transcript file has to be screened for profanity using Screen Text API.

        :param content_type: The content type. (required)
        :type content_type: str
        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param transcript_moderation_body: Body for add video transcript moderation result API (required)
        :type transcript_moderation_body: List[ReviewsAddVideoTranscriptModerationResultRequestInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_add_video_transcript_moderation_result_serialize(
            content_type=content_type,
            team_name=team_name,
            review_id=review_id,
            transcript_moderation_body=transcript_moderation_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reviews_add_video_transcript_moderation_result_serialize(
        self,
        content_type,
        team_name,
        review_id,
        transcript_moderation_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'transcriptModerationBody': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if team_name is not None:
            _path_params['teamName'] = team_name
        if review_id is not None:
            _path_params['reviewId'] = review_id
        # process the query parameters
        # process the header parameters
        if content_type is not None:
            _header_params['Content-Type'] = content_type
        # process the form parameters
        # process the body parameter
        if transcript_moderation_body is not None:
            _body_params = transcript_moderation_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apim_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/transcriptmoderationresult',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reviews_create_job(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        content_type: Annotated[StrictStr, Field(description="Image, Text or Video.")],
        content_id: Annotated[StrictStr, Field(description="Id/Name to identify the content submitted.")],
        workflow_name: Annotated[StrictStr, Field(description="Workflow Name that you want to invoke.")],
        content_type2: Annotated[StrictStr, Field(description="The content type.")],
        content: Annotated[ReviewsCreateJobRequest, Field(description="Content to evaluate.")],
        call_back_endpoint: Annotated[Optional[StrictStr], Field(description="Callback endpoint for posting the create job result.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobId:
        """reviews_create_job

        A job Id will be returned for the content posted on this endpoint.     Once the content is evaluated against the Workflow provided the review will be created or ignored based on the workflow expression.    <h3>CallBack Schemas </h3>    <p>  <h4>Job Completion CallBack Sample</h4><br/>    {<br/>    \"JobId\": \"<Job Id>,<br/>    \"ReviewId\": \"<Review Id, if the Job resulted in a Review to be created>\",<br/>    \"WorkFlowId\": \"default\",<br/>    \"Status\": \"<This will be one of Complete, InProgress, Error>\",<br/>    \"ContentType\": \"Image\",<br/>    \"ContentId\": \"<This is the ContentId that was specified on input>\",<br/>    \"CallBackType\": \"Job\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>  <p>  <h4>Review Completion CallBack Sample</h4><br/>    {    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param content_type: Image, Text or Video. (required)
        :type content_type: str
        :param content_id: Id/Name to identify the content submitted. (required)
        :type content_id: str
        :param workflow_name: Workflow Name that you want to invoke. (required)
        :type workflow_name: str
        :param content_type2: The content type. (required)
        :type content_type2: str
        :param content: Content to evaluate. (required)
        :type content: ReviewsCreateJobRequest
        :param call_back_endpoint: Callback endpoint for posting the create job result.
        :type call_back_endpoint: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_create_job_serialize(
            team_name=team_name,
            content_type=content_type,
            content_id=content_id,
            workflow_name=workflow_name,
            content_type2=content_type2,
            content=content,
            call_back_endpoint=call_back_endpoint,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobId",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reviews_create_job_with_http_info(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        content_type: Annotated[StrictStr, Field(description="Image, Text or Video.")],
        content_id: Annotated[StrictStr, Field(description="Id/Name to identify the content submitted.")],
        workflow_name: Annotated[StrictStr, Field(description="Workflow Name that you want to invoke.")],
        content_type2: Annotated[StrictStr, Field(description="The content type.")],
        content: Annotated[ReviewsCreateJobRequest, Field(description="Content to evaluate.")],
        call_back_endpoint: Annotated[Optional[StrictStr], Field(description="Callback endpoint for posting the create job result.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobId]:
        """reviews_create_job

        A job Id will be returned for the content posted on this endpoint.     Once the content is evaluated against the Workflow provided the review will be created or ignored based on the workflow expression.    <h3>CallBack Schemas </h3>    <p>  <h4>Job Completion CallBack Sample</h4><br/>    {<br/>    \"JobId\": \"<Job Id>,<br/>    \"ReviewId\": \"<Review Id, if the Job resulted in a Review to be created>\",<br/>    \"WorkFlowId\": \"default\",<br/>    \"Status\": \"<This will be one of Complete, InProgress, Error>\",<br/>    \"ContentType\": \"Image\",<br/>    \"ContentId\": \"<This is the ContentId that was specified on input>\",<br/>    \"CallBackType\": \"Job\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>  <p>  <h4>Review Completion CallBack Sample</h4><br/>    {    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param content_type: Image, Text or Video. (required)
        :type content_type: str
        :param content_id: Id/Name to identify the content submitted. (required)
        :type content_id: str
        :param workflow_name: Workflow Name that you want to invoke. (required)
        :type workflow_name: str
        :param content_type2: The content type. (required)
        :type content_type2: str
        :param content: Content to evaluate. (required)
        :type content: ReviewsCreateJobRequest
        :param call_back_endpoint: Callback endpoint for posting the create job result.
        :type call_back_endpoint: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_create_job_serialize(
            team_name=team_name,
            content_type=content_type,
            content_id=content_id,
            workflow_name=workflow_name,
            content_type2=content_type2,
            content=content,
            call_back_endpoint=call_back_endpoint,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobId",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reviews_create_job_without_preload_content(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        content_type: Annotated[StrictStr, Field(description="Image, Text or Video.")],
        content_id: Annotated[StrictStr, Field(description="Id/Name to identify the content submitted.")],
        workflow_name: Annotated[StrictStr, Field(description="Workflow Name that you want to invoke.")],
        content_type2: Annotated[StrictStr, Field(description="The content type.")],
        content: Annotated[ReviewsCreateJobRequest, Field(description="Content to evaluate.")],
        call_back_endpoint: Annotated[Optional[StrictStr], Field(description="Callback endpoint for posting the create job result.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reviews_create_job

        A job Id will be returned for the content posted on this endpoint.     Once the content is evaluated against the Workflow provided the review will be created or ignored based on the workflow expression.    <h3>CallBack Schemas </h3>    <p>  <h4>Job Completion CallBack Sample</h4><br/>    {<br/>    \"JobId\": \"<Job Id>,<br/>    \"ReviewId\": \"<Review Id, if the Job resulted in a Review to be created>\",<br/>    \"WorkFlowId\": \"default\",<br/>    \"Status\": \"<This will be one of Complete, InProgress, Error>\",<br/>    \"ContentType\": \"Image\",<br/>    \"ContentId\": \"<This is the ContentId that was specified on input>\",<br/>    \"CallBackType\": \"Job\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>  <p>  <h4>Review Completion CallBack Sample</h4><br/>    {    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param content_type: Image, Text or Video. (required)
        :type content_type: str
        :param content_id: Id/Name to identify the content submitted. (required)
        :type content_id: str
        :param workflow_name: Workflow Name that you want to invoke. (required)
        :type workflow_name: str
        :param content_type2: The content type. (required)
        :type content_type2: str
        :param content: Content to evaluate. (required)
        :type content: ReviewsCreateJobRequest
        :param call_back_endpoint: Callback endpoint for posting the create job result.
        :type call_back_endpoint: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_create_job_serialize(
            team_name=team_name,
            content_type=content_type,
            content_id=content_id,
            workflow_name=workflow_name,
            content_type2=content_type2,
            content=content,
            call_back_endpoint=call_back_endpoint,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "JobId",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reviews_create_job_serialize(
        self,
        team_name,
        content_type,
        content_id,
        workflow_name,
        content_type2,
        content,
        call_back_endpoint,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if team_name is not None:
            _path_params['teamName'] = team_name
        # process the query parameters
        if content_type is not None:
            
            _query_params.append(('ContentType', content_type))
            
        if content_id is not None:
            
            _query_params.append(('ContentId', content_id))
            
        if workflow_name is not None:
            
            _query_params.append(('WorkflowName', workflow_name))
            
        if call_back_endpoint is not None:
            
            _query_params.append(('CallBackEndpoint', call_back_endpoint))
            
        # process the header parameters
        if content_type2 is not None:
            _header_params['Content-Type'] = content_type2
        # process the form parameters
        # process the body parameter
        if content is not None:
            _body_params = content


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'image/jpeg'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apim_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/contentmoderator/review/v1.0/teams/{teamName}/jobs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reviews_create_reviews(
        self,
        url_content_type: Annotated[StrictStr, Field(description="The content type.")],
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        create_review_body: Annotated[List[ReviewsCreateReviewsRequestInner], Field(description="Body for create reviews API")],
        sub_team: Annotated[Optional[StrictStr], Field(description="SubTeam of your team, you want to assign the created review to.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[str]:
        """reviews_create_reviews

        The reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.    <h3>CallBack Schemas </h3>  <h4>Review Completion CallBack Sample</h4>  <p>  {<br/>    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param url_content_type: The content type. (required)
        :type url_content_type: str
        :param team_name: Your team name. (required)
        :type team_name: str
        :param create_review_body: Body for create reviews API (required)
        :type create_review_body: List[ReviewsCreateReviewsRequestInner]
        :param sub_team: SubTeam of your team, you want to assign the created review to.
        :type sub_team: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_create_reviews_serialize(
            url_content_type=url_content_type,
            team_name=team_name,
            create_review_body=create_review_body,
            sub_team=sub_team,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reviews_create_reviews_with_http_info(
        self,
        url_content_type: Annotated[StrictStr, Field(description="The content type.")],
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        create_review_body: Annotated[List[ReviewsCreateReviewsRequestInner], Field(description="Body for create reviews API")],
        sub_team: Annotated[Optional[StrictStr], Field(description="SubTeam of your team, you want to assign the created review to.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[str]]:
        """reviews_create_reviews

        The reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.    <h3>CallBack Schemas </h3>  <h4>Review Completion CallBack Sample</h4>  <p>  {<br/>    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param url_content_type: The content type. (required)
        :type url_content_type: str
        :param team_name: Your team name. (required)
        :type team_name: str
        :param create_review_body: Body for create reviews API (required)
        :type create_review_body: List[ReviewsCreateReviewsRequestInner]
        :param sub_team: SubTeam of your team, you want to assign the created review to.
        :type sub_team: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_create_reviews_serialize(
            url_content_type=url_content_type,
            team_name=team_name,
            create_review_body=create_review_body,
            sub_team=sub_team,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reviews_create_reviews_without_preload_content(
        self,
        url_content_type: Annotated[StrictStr, Field(description="The content type.")],
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        create_review_body: Annotated[List[ReviewsCreateReviewsRequestInner], Field(description="Body for create reviews API")],
        sub_team: Annotated[Optional[StrictStr], Field(description="SubTeam of your team, you want to assign the created review to.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reviews_create_reviews

        The reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.    <h3>CallBack Schemas </h3>  <h4>Review Completion CallBack Sample</h4>  <p>  {<br/>    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param url_content_type: The content type. (required)
        :type url_content_type: str
        :param team_name: Your team name. (required)
        :type team_name: str
        :param create_review_body: Body for create reviews API (required)
        :type create_review_body: List[ReviewsCreateReviewsRequestInner]
        :param sub_team: SubTeam of your team, you want to assign the created review to.
        :type sub_team: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_create_reviews_serialize(
            url_content_type=url_content_type,
            team_name=team_name,
            create_review_body=create_review_body,
            sub_team=sub_team,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reviews_create_reviews_serialize(
        self,
        url_content_type,
        team_name,
        create_review_body,
        sub_team,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'createReviewBody': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if team_name is not None:
            _path_params['teamName'] = team_name
        # process the query parameters
        if sub_team is not None:
            
            _query_params.append(('subTeam', sub_team))
            
        # process the header parameters
        if url_content_type is not None:
            _header_params['UrlContentType'] = url_content_type
        # process the form parameters
        # process the body parameter
        if create_review_body is not None:
            _body_params = create_review_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apim_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/contentmoderator/review/v1.0/teams/{teamName}/reviews',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reviews_get_job_details(
        self,
        team_name: Annotated[StrictStr, Field(description="Your Team Name.")],
        job_id: Annotated[StrictStr, Field(description="Id of the job.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Job:
        """reviews_get_job_details

        Get the Job Details for a Job Id.

        :param team_name: Your Team Name. (required)
        :type team_name: str
        :param job_id: Id of the job. (required)
        :type job_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_get_job_details_serialize(
            team_name=team_name,
            job_id=job_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Job",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reviews_get_job_details_with_http_info(
        self,
        team_name: Annotated[StrictStr, Field(description="Your Team Name.")],
        job_id: Annotated[StrictStr, Field(description="Id of the job.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Job]:
        """reviews_get_job_details

        Get the Job Details for a Job Id.

        :param team_name: Your Team Name. (required)
        :type team_name: str
        :param job_id: Id of the job. (required)
        :type job_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_get_job_details_serialize(
            team_name=team_name,
            job_id=job_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Job",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reviews_get_job_details_without_preload_content(
        self,
        team_name: Annotated[StrictStr, Field(description="Your Team Name.")],
        job_id: Annotated[StrictStr, Field(description="Id of the job.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reviews_get_job_details

        Get the Job Details for a Job Id.

        :param team_name: Your Team Name. (required)
        :type team_name: str
        :param job_id: Id of the job. (required)
        :type job_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_get_job_details_serialize(
            team_name=team_name,
            job_id=job_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Job",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reviews_get_job_details_serialize(
        self,
        team_name,
        job_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if team_name is not None:
            _path_params['teamName'] = team_name
        if job_id is not None:
            _path_params['JobId'] = job_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apim_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contentmoderator/review/v1.0/teams/{teamName}/jobs/{JobId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reviews_get_review(
        self,
        team_name: Annotated[StrictStr, Field(description="Your Team Name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Review:
        """reviews_get_review

        Returns review details for the review Id passed.

        :param team_name: Your Team Name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_get_review_serialize(
            team_name=team_name,
            review_id=review_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Review",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reviews_get_review_with_http_info(
        self,
        team_name: Annotated[StrictStr, Field(description="Your Team Name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Review]:
        """reviews_get_review

        Returns review details for the review Id passed.

        :param team_name: Your Team Name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_get_review_serialize(
            team_name=team_name,
            review_id=review_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Review",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reviews_get_review_without_preload_content(
        self,
        team_name: Annotated[StrictStr, Field(description="Your Team Name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reviews_get_review

        Returns review details for the review Id passed.

        :param team_name: Your Team Name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_get_review_serialize(
            team_name=team_name,
            review_id=review_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Review",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reviews_get_review_serialize(
        self,
        team_name,
        review_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if team_name is not None:
            _path_params['teamName'] = team_name
        if review_id is not None:
            _path_params['reviewId'] = review_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apim_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reviews_get_video_frames(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        start_seed: Annotated[Optional[StrictInt], Field(description="Time stamp of the frame from where you want to start fetching the frames.")] = None,
        no_of_records: Annotated[Optional[StrictInt], Field(description="Number of frames to fetch.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Get frames filtered by tags.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Frames:
        """reviews_get_video_frames

        The reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.    <h3>CallBack Schemas </h3>  <h4>Review Completion CallBack Sample</h4>  <p>  {<br/>    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param start_seed: Time stamp of the frame from where you want to start fetching the frames.
        :type start_seed: int
        :param no_of_records: Number of frames to fetch.
        :type no_of_records: int
        :param filter: Get frames filtered by tags.
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_get_video_frames_serialize(
            team_name=team_name,
            review_id=review_id,
            start_seed=start_seed,
            no_of_records=no_of_records,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Frames",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reviews_get_video_frames_with_http_info(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        start_seed: Annotated[Optional[StrictInt], Field(description="Time stamp of the frame from where you want to start fetching the frames.")] = None,
        no_of_records: Annotated[Optional[StrictInt], Field(description="Number of frames to fetch.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Get frames filtered by tags.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Frames]:
        """reviews_get_video_frames

        The reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.    <h3>CallBack Schemas </h3>  <h4>Review Completion CallBack Sample</h4>  <p>  {<br/>    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param start_seed: Time stamp of the frame from where you want to start fetching the frames.
        :type start_seed: int
        :param no_of_records: Number of frames to fetch.
        :type no_of_records: int
        :param filter: Get frames filtered by tags.
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_get_video_frames_serialize(
            team_name=team_name,
            review_id=review_id,
            start_seed=start_seed,
            no_of_records=no_of_records,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Frames",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reviews_get_video_frames_without_preload_content(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        start_seed: Annotated[Optional[StrictInt], Field(description="Time stamp of the frame from where you want to start fetching the frames.")] = None,
        no_of_records: Annotated[Optional[StrictInt], Field(description="Number of frames to fetch.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Get frames filtered by tags.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reviews_get_video_frames

        The reviews created would show up for Reviewers on your team. As Reviewers complete reviewing, results of the Review would be POSTED (i.e. HTTP POST) on the specified CallBackEndpoint.    <h3>CallBack Schemas </h3>  <h4>Review Completion CallBack Sample</h4>  <p>  {<br/>    \"ReviewId\": \"<Review Id>\",<br/>    \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>    \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>    \"CallBackType\": \"Review\",<br/>    \"ContentId\": \"<The ContentId that was specified input>\",<br/>    \"Metadata\": {<br/>      \"adultscore\": \"0.xxx\",<br/>      \"a\": \"False\",<br/>      \"racyscore\": \"0.xxx\",<br/>      \"r\": \"True\"<br/>    },<br/>    \"ReviewerResultTags\": {<br/>      \"a\": \"False\",<br/>      \"r\": \"True\"<br/>    }<br/>  }<br/>    </p>.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param start_seed: Time stamp of the frame from where you want to start fetching the frames.
        :type start_seed: int
        :param no_of_records: Number of frames to fetch.
        :type no_of_records: int
        :param filter: Get frames filtered by tags.
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_get_video_frames_serialize(
            team_name=team_name,
            review_id=review_id,
            start_seed=start_seed,
            no_of_records=no_of_records,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Frames",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reviews_get_video_frames_serialize(
        self,
        team_name,
        review_id,
        start_seed,
        no_of_records,
        filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if team_name is not None:
            _path_params['teamName'] = team_name
        if review_id is not None:
            _path_params['reviewId'] = review_id
        # process the query parameters
        if start_seed is not None:
            
            _query_params.append(('startSeed', start_seed))
            
        if no_of_records is not None:
            
            _query_params.append(('noOfRecords', no_of_records))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apim_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/frames',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reviews_publish_video_review(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """reviews_publish_video_review

        Publish video review to make it available for review.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_publish_video_review_serialize(
            team_name=team_name,
            review_id=review_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reviews_publish_video_review_with_http_info(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """reviews_publish_video_review

        Publish video review to make it available for review.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_publish_video_review_serialize(
            team_name=team_name,
            review_id=review_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reviews_publish_video_review_without_preload_content(
        self,
        team_name: Annotated[StrictStr, Field(description="Your team name.")],
        review_id: Annotated[StrictStr, Field(description="Id of the review.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reviews_publish_video_review

        Publish video review to make it available for review.

        :param team_name: Your team name. (required)
        :type team_name: str
        :param review_id: Id of the review. (required)
        :type review_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reviews_publish_video_review_serialize(
            team_name=team_name,
            review_id=review_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reviews_publish_video_review_serialize(
        self,
        team_name,
        review_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if team_name is not None:
            _path_params['teamName'] = team_name
        if review_id is not None:
            _path_params['reviewId'] = review_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apim_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/contentmoderator/review/v1.0/teams/{teamName}/reviews/{reviewId}/publish',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


