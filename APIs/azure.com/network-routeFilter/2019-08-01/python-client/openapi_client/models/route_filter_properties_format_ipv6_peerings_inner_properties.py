# coding: utf-8

"""
    NetworkManagementClient

    The Microsoft Azure Network management API provides a RESTful set of web services that interact with Microsoft Azure Networks service to manage your network resources. The API has entities that capture the relationship between an end user and the Microsoft Azure Networks service.

    The version of the OpenAPI document: 2019-08-01
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.route_filter_properties_format_ipv6_peerings_inner_properties_connections_inner import RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesConnectionsInner
from openapi_client.models.route_filter_properties_format_ipv6_peerings_inner_properties_connections_inner_properties_express_route_circuit_peering import RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesConnectionsInnerPropertiesExpressRouteCircuitPeering
from openapi_client.models.route_filter_properties_format_ipv6_peerings_inner_properties_express_route_connection import RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesExpressRouteConnection
from openapi_client.models.route_filter_properties_format_ipv6_peerings_inner_properties_ipv6_peering_config import RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesIpv6PeeringConfig
from openapi_client.models.route_filter_properties_format_ipv6_peerings_inner_properties_ipv6_peering_config_microsoft_peering_config import RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesIpv6PeeringConfigMicrosoftPeeringConfig
from openapi_client.models.route_filter_properties_format_ipv6_peerings_inner_properties_peered_connections_inner import RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesPeeredConnectionsInner
from openapi_client.models.route_filter_properties_format_ipv6_peerings_inner_properties_stats import RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesStats
from typing import Optional, Set
from typing_extensions import Self

class RouteFilterPropertiesFormatIpv6PeeringsInnerProperties(BaseModel):
    """
    Properties of the express route circuit peering.
    """ # noqa: E501
    azure_asn: Optional[StrictInt] = Field(default=None, description="The Azure ASN.", alias="azureASN")
    connections: Optional[List[RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesConnectionsInner]] = Field(default=None, description="The list of circuit connections associated with Azure Private Peering for this circuit.")
    express_route_connection: Optional[RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesExpressRouteConnection] = Field(default=None, alias="expressRouteConnection")
    gateway_manager_etag: Optional[StrictStr] = Field(default=None, description="The GatewayManager Etag.", alias="gatewayManagerEtag")
    ipv6_peering_config: Optional[RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesIpv6PeeringConfig] = Field(default=None, alias="ipv6PeeringConfig")
    last_modified_by: Optional[StrictStr] = Field(default=None, description="Who was the last to modify the peering.", alias="lastModifiedBy")
    microsoft_peering_config: Optional[RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesIpv6PeeringConfigMicrosoftPeeringConfig] = Field(default=None, alias="microsoftPeeringConfig")
    peer_asn: Optional[Annotated[int, Field(le=4294967295, strict=True, ge=1)]] = Field(default=None, description="The peer ASN.", alias="peerASN")
    peered_connections: Optional[List[RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesPeeredConnectionsInner]] = Field(default=None, description="The list of peered circuit connections associated with Azure Private Peering for this circuit.", alias="peeredConnections")
    peering_type: Optional[StrictStr] = Field(default=None, description="The peering type.", alias="peeringType")
    primary_azure_port: Optional[StrictStr] = Field(default=None, description="The primary port.", alias="primaryAzurePort")
    primary_peer_address_prefix: Optional[StrictStr] = Field(default=None, description="The primary address prefix.", alias="primaryPeerAddressPrefix")
    provisioning_state: Optional[StrictStr] = Field(default=None, description="The current provisioning state.", alias="provisioningState")
    route_filter: Optional[RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesConnectionsInnerPropertiesExpressRouteCircuitPeering] = Field(default=None, alias="routeFilter")
    secondary_azure_port: Optional[StrictStr] = Field(default=None, description="The secondary port.", alias="secondaryAzurePort")
    secondary_peer_address_prefix: Optional[StrictStr] = Field(default=None, description="The secondary address prefix.", alias="secondaryPeerAddressPrefix")
    shared_key: Optional[StrictStr] = Field(default=None, description="The shared key.", alias="sharedKey")
    state: Optional[StrictStr] = Field(default=None, description="The state of peering.")
    stats: Optional[RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesStats] = None
    vlan_id: Optional[StrictInt] = Field(default=None, description="The VLAN ID.", alias="vlanId")
    __properties: ClassVar[List[str]] = ["azureASN", "connections", "expressRouteConnection", "gatewayManagerEtag", "ipv6PeeringConfig", "lastModifiedBy", "microsoftPeeringConfig", "peerASN", "peeredConnections", "peeringType", "primaryAzurePort", "primaryPeerAddressPrefix", "provisioningState", "routeFilter", "secondaryAzurePort", "secondaryPeerAddressPrefix", "sharedKey", "state", "stats", "vlanId"]

    @field_validator('peering_type')
    def peering_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AzurePublicPeering', 'AzurePrivatePeering', 'MicrosoftPeering']):
            raise ValueError("must be one of enum values ('AzurePublicPeering', 'AzurePrivatePeering', 'MicrosoftPeering')")
        return value

    @field_validator('provisioning_state')
    def provisioning_state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Succeeded', 'Updating', 'Deleting', 'Failed']):
            raise ValueError("must be one of enum values ('Succeeded', 'Updating', 'Deleting', 'Failed')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Disabled', 'Enabled']):
            raise ValueError("must be one of enum values ('Disabled', 'Enabled')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RouteFilterPropertiesFormatIpv6PeeringsInnerProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "peered_connections",
            "provisioning_state",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in connections (list)
        _items = []
        if self.connections:
            for _item_connections in self.connections:
                if _item_connections:
                    _items.append(_item_connections.to_dict())
            _dict['connections'] = _items
        # override the default output from pydantic by calling `to_dict()` of express_route_connection
        if self.express_route_connection:
            _dict['expressRouteConnection'] = self.express_route_connection.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ipv6_peering_config
        if self.ipv6_peering_config:
            _dict['ipv6PeeringConfig'] = self.ipv6_peering_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of microsoft_peering_config
        if self.microsoft_peering_config:
            _dict['microsoftPeeringConfig'] = self.microsoft_peering_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in peered_connections (list)
        _items = []
        if self.peered_connections:
            for _item_peered_connections in self.peered_connections:
                if _item_peered_connections:
                    _items.append(_item_peered_connections.to_dict())
            _dict['peeredConnections'] = _items
        # override the default output from pydantic by calling `to_dict()` of route_filter
        if self.route_filter:
            _dict['routeFilter'] = self.route_filter.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stats
        if self.stats:
            _dict['stats'] = self.stats.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RouteFilterPropertiesFormatIpv6PeeringsInnerProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "azureASN": obj.get("azureASN"),
            "connections": [RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesConnectionsInner.from_dict(_item) for _item in obj["connections"]] if obj.get("connections") is not None else None,
            "expressRouteConnection": RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesExpressRouteConnection.from_dict(obj["expressRouteConnection"]) if obj.get("expressRouteConnection") is not None else None,
            "gatewayManagerEtag": obj.get("gatewayManagerEtag"),
            "ipv6PeeringConfig": RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesIpv6PeeringConfig.from_dict(obj["ipv6PeeringConfig"]) if obj.get("ipv6PeeringConfig") is not None else None,
            "lastModifiedBy": obj.get("lastModifiedBy"),
            "microsoftPeeringConfig": RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesIpv6PeeringConfigMicrosoftPeeringConfig.from_dict(obj["microsoftPeeringConfig"]) if obj.get("microsoftPeeringConfig") is not None else None,
            "peerASN": obj.get("peerASN"),
            "peeredConnections": [RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesPeeredConnectionsInner.from_dict(_item) for _item in obj["peeredConnections"]] if obj.get("peeredConnections") is not None else None,
            "peeringType": obj.get("peeringType"),
            "primaryAzurePort": obj.get("primaryAzurePort"),
            "primaryPeerAddressPrefix": obj.get("primaryPeerAddressPrefix"),
            "provisioningState": obj.get("provisioningState"),
            "routeFilter": RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesConnectionsInnerPropertiesExpressRouteCircuitPeering.from_dict(obj["routeFilter"]) if obj.get("routeFilter") is not None else None,
            "secondaryAzurePort": obj.get("secondaryAzurePort"),
            "secondaryPeerAddressPrefix": obj.get("secondaryPeerAddressPrefix"),
            "sharedKey": obj.get("sharedKey"),
            "state": obj.get("state"),
            "stats": RouteFilterPropertiesFormatIpv6PeeringsInnerPropertiesStats.from_dict(obj["stats"]) if obj.get("stats") is not None else None,
            "vlanId": obj.get("vlanId")
        })
        return _obj


