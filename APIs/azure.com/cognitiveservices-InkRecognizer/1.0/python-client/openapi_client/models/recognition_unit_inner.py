# coding: utf-8

"""
    Ink Recognizer Client

    The service is used to perform ink layout and recognition of written words and shapes. Ink strokes passed to the service are recognized and organized into recognition results in the response

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.alternate_pattern_inner import AlternatePatternInner
from openapi_client.models.category_pattern import CategoryPattern
from openapi_client.models.class_pattern import ClassPattern
from openapi_client.models.point_details_pattern import PointDetailsPattern
from openapi_client.models.recognition_unit_inner_bounding_rectangle import RecognitionUnitInnerBoundingRectangle
from openapi_client.models.shape_pattern import ShapePattern
from typing import Optional, Set
from typing_extensions import Self

class RecognitionUnitInner(BaseModel):
    """
    This identifies the recognized entity
    """ # noqa: E501
    alternates: Optional[List[AlternatePatternInner]] = Field(default=None, description="The list of alternates for the core recognition result. In case of handwriting related recognition units, this list includes other words that are close possibilities to the results provided as 'recognizedText'.")
    bounding_rectangle: Optional[RecognitionUnitInnerBoundingRectangle] = Field(default=None, alias="boundingRectangle")
    category: CategoryPattern
    center: Optional[PointDetailsPattern] = None
    child_ids: Optional[List[StrictInt]] = Field(default=None, description="An array of integers representing the identifier of each child of the current recognition unit.", alias="childIds")
    var_class: ClassPattern = Field(alias="class")
    confidence: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="A number between 0 and 1 which indicates the confidence level in the result.")
    id: StrictInt = Field(description="The identifier of the recognition unit. This id is used to indicate parent/child relationship between different recognition units.")
    parent_id: StrictInt = Field(description="The id of the parent node in the tree structure of the recognition results. parent = 0 indicates that there is no dedicated parent node for this unit.", alias="parentId")
    points: Optional[List[PointDetailsPattern]] = Field(default=None, description="Array of point objects that represent points that are relevant to the type of recognition unit. For example, for a leaf node of inkDrawing category that represents a triangle, points would include the x, y coordinates of the vertices of the recognized triangle. The points represent the coordinates used to create the perfectly drawn shape that is closest to the original input. They may not exactly match.")
    recognized_object: Optional[ShapePattern] = Field(default=None, alias="recognizedObject")
    recognized_text: Optional[StrictStr] = Field(default=None, description="The string contains the text that was recognized. It can be an empty string if the recognizer cannot determine the text.", alias="recognizedText")
    rotated_bounding_rectangle: Optional[List[PointDetailsPattern]] = Field(default=None, description="This is the rotated bounding rectangle that covers the entire recognized object along the angle of rotation of the object. Note that this is NOT the same as rotating the boundingRectangle by the rotation angle.", alias="rotatedBoundingRectangle")
    rotation_angle: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="This is the angle at which the unit is rotated in degrees with respect to the positive X axis.", alias="rotationAngle")
    stroke_ids: List[StrictInt] = Field(description="This is an array of integers representing the list of stroke Identifiers from the input request body that belong to this recognition unit.", alias="strokeIds")
    __properties: ClassVar[List[str]] = ["alternates", "boundingRectangle", "category", "center", "childIds", "class", "confidence", "id", "parentId", "points", "recognizedObject", "recognizedText", "rotatedBoundingRectangle", "rotationAngle", "strokeIds"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RecognitionUnitInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in alternates (list)
        _items = []
        if self.alternates:
            for _item_alternates in self.alternates:
                if _item_alternates:
                    _items.append(_item_alternates.to_dict())
            _dict['alternates'] = _items
        # override the default output from pydantic by calling `to_dict()` of bounding_rectangle
        if self.bounding_rectangle:
            _dict['boundingRectangle'] = self.bounding_rectangle.to_dict()
        # override the default output from pydantic by calling `to_dict()` of center
        if self.center:
            _dict['center'] = self.center.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in points (list)
        _items = []
        if self.points:
            for _item_points in self.points:
                if _item_points:
                    _items.append(_item_points.to_dict())
            _dict['points'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in rotated_bounding_rectangle (list)
        _items = []
        if self.rotated_bounding_rectangle:
            for _item_rotated_bounding_rectangle in self.rotated_bounding_rectangle:
                if _item_rotated_bounding_rectangle:
                    _items.append(_item_rotated_bounding_rectangle.to_dict())
            _dict['rotatedBoundingRectangle'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RecognitionUnitInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "alternates": [AlternatePatternInner.from_dict(_item) for _item in obj["alternates"]] if obj.get("alternates") is not None else None,
            "boundingRectangle": RecognitionUnitInnerBoundingRectangle.from_dict(obj["boundingRectangle"]) if obj.get("boundingRectangle") is not None else None,
            "category": obj.get("category"),
            "center": PointDetailsPattern.from_dict(obj["center"]) if obj.get("center") is not None else None,
            "childIds": obj.get("childIds"),
            "class": obj.get("class"),
            "confidence": obj.get("confidence"),
            "id": obj.get("id"),
            "parentId": obj.get("parentId"),
            "points": [PointDetailsPattern.from_dict(_item) for _item in obj["points"]] if obj.get("points") is not None else None,
            "recognizedObject": obj.get("recognizedObject"),
            "recognizedText": obj.get("recognizedText"),
            "rotatedBoundingRectangle": [PointDetailsPattern.from_dict(_item) for _item in obj["rotatedBoundingRectangle"]] if obj.get("rotatedBoundingRectangle") is not None else None,
            "rotationAngle": obj.get("rotationAngle"),
            "strokeIds": obj.get("strokeIds")
        })
        return _obj


