# coding: utf-8

"""
    Service Fabric Client APIs

    Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.

    The version of the OpenAPI document: 6.4.0.36
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.service_type_health_policy import ServiceTypeHealthPolicy
from openapi_client.models.service_type_health_policy_map_item import ServiceTypeHealthPolicyMapItem
from typing import Optional, Set
from typing_extensions import Self

class ApplicationHealthPolicy(BaseModel):
    """
    Defines a health policy used to evaluate the health of an application or one of its children entities.
    """ # noqa: E501
    consider_warning_as_error: Optional[StrictBool] = Field(default=False, description="Indicates whether warnings are treated with the same severity as errors.", alias="ConsiderWarningAsError")
    default_service_type_health_policy: Optional[ServiceTypeHealthPolicy] = Field(default=None, alias="DefaultServiceTypeHealthPolicy")
    max_percent_unhealthy_deployed_applications: Optional[StrictInt] = Field(default=None, description="The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100. The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error. This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster. The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.", alias="MaxPercentUnhealthyDeployedApplications")
    service_type_health_policy_map: Optional[List[ServiceTypeHealthPolicyMapItem]] = Field(default=None, description="Defines a ServiceTypeHealthPolicy per service type name.  The entries in the map replace the default service type health policy for each specified service type. For example, in an application that contains both a stateless gateway service type and a stateful engine service type, the health policies for the stateless and stateful services can be configured differently. With policy per service type, there's more granular control of the health of the service.  If no policy is specified for a service type name, the DefaultServiceTypeHealthPolicy is used for evaluation.", alias="ServiceTypeHealthPolicyMap")
    __properties: ClassVar[List[str]] = ["ConsiderWarningAsError", "DefaultServiceTypeHealthPolicy", "MaxPercentUnhealthyDeployedApplications", "ServiceTypeHealthPolicyMap"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ApplicationHealthPolicy from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of default_service_type_health_policy
        if self.default_service_type_health_policy:
            _dict['DefaultServiceTypeHealthPolicy'] = self.default_service_type_health_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in service_type_health_policy_map (list)
        _items = []
        if self.service_type_health_policy_map:
            for _item_service_type_health_policy_map in self.service_type_health_policy_map:
                if _item_service_type_health_policy_map:
                    _items.append(_item_service_type_health_policy_map.to_dict())
            _dict['ServiceTypeHealthPolicyMap'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ApplicationHealthPolicy from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ConsiderWarningAsError": obj.get("ConsiderWarningAsError") if obj.get("ConsiderWarningAsError") is not None else False,
            "DefaultServiceTypeHealthPolicy": ServiceTypeHealthPolicy.from_dict(obj["DefaultServiceTypeHealthPolicy"]) if obj.get("DefaultServiceTypeHealthPolicy") is not None else None,
            "MaxPercentUnhealthyDeployedApplications": obj.get("MaxPercentUnhealthyDeployedApplications"),
            "ServiceTypeHealthPolicyMap": [ServiceTypeHealthPolicyMapItem.from_dict(_item) for _item in obj["ServiceTypeHealthPolicyMap"]] if obj.get("ServiceTypeHealthPolicyMap") is not None else None
        })
        return _obj


