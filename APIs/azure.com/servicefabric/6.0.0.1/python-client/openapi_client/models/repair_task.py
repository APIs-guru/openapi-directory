# coding: utf-8

"""
    Service Fabric Client APIs

    Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.

    The version of the OpenAPI document: 6.0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.repair_impact_description_base import RepairImpactDescriptionBase
from openapi_client.models.repair_target_description_base import RepairTargetDescriptionBase
from openapi_client.models.repair_task_health_check_state import RepairTaskHealthCheckState
from openapi_client.models.repair_task_history import RepairTaskHistory
from typing import Optional, Set
from typing_extensions import Self

class RepairTask(BaseModel):
    """
    Represents a repair task, which includes information about what kind of repair was requested, what its progress is, and what its final result was.  This type supports the Service Fabric platform; it is not meant to be used directly from your code. 
    """ # noqa: E501
    action: StrictStr = Field(description="The requested repair action. Must be specified when the repair task is created, and is immutable once set. ", alias="Action")
    description: Optional[StrictStr] = Field(default=None, description="A description of the purpose of the repair task, or other informational details. May be set when the repair task is created, and is immutable once set. ", alias="Description")
    executor: Optional[StrictStr] = Field(default=None, description="The name of the repair executor. Must be specified in Claimed and later states, and is immutable once set.", alias="Executor")
    executor_data: Optional[StrictStr] = Field(default=None, description="A data string that the repair executor can use to store its internal state.", alias="ExecutorData")
    flags: Optional[StrictInt] = Field(default=None, description="A bitwise-OR of the following values, which gives additional details about the status of the repair task. - 1 - Cancellation of the repair has been requested - 2 - Abort of the repair has been requested - 4 - Approval of the repair was forced via client request ", alias="Flags")
    history: Optional[RepairTaskHistory] = Field(default=None, alias="History")
    impact: Optional[RepairImpactDescriptionBase] = Field(default=None, alias="Impact")
    perform_preparing_health_check: Optional[StrictBool] = Field(default=None, description="A value to determine if health checks will be performed when the repair task enters the Preparing state.", alias="PerformPreparingHealthCheck")
    perform_restoring_health_check: Optional[StrictBool] = Field(default=None, description="A value to determine if health checks will be performed when the repair task enters the Restoring state.", alias="PerformRestoringHealthCheck")
    preparing_health_check_state: Optional[RepairTaskHealthCheckState] = Field(default=None, alias="PreparingHealthCheckState")
    restoring_health_check_state: Optional[RepairTaskHealthCheckState] = Field(default=None, alias="RestoringHealthCheckState")
    result_code: Optional[StrictInt] = Field(default=None, description="A numeric value providing additional details about the result of the repair task execution. May be specified in the Restoring and later states, and is immutable once set. ", alias="ResultCode")
    result_details: Optional[StrictStr] = Field(default=None, description="A string providing additional details about the result of the repair task execution. May be specified in the Restoring and later states, and is immutable once set. ", alias="ResultDetails")
    result_status: Optional[StrictStr] = Field(default=None, description="A value describing the overall result of the repair task execution. Must be specified in the Restoring and later states, and is immutable once set.  - Invalid - Indicates that the repair task result is invalid. All Service Fabric enumerations have the invalid value. - Succeeded - Indicates that the repair task completed execution successfully. - Cancelled - Indicates that the repair task was cancelled prior to execution. - Interrupted - Indicates that execution of the repair task was interrupted by a cancellation request after some work had already been performed. - Failed - Indicates that there was a failure during execution of the repair task. Some work may have been performed. - Pending - Indicates that the repair task result is not yet available, because the repair task has not finished executing. ", alias="ResultStatus")
    state: StrictStr = Field(description="The workflow state of the repair task. Valid initial states are Created, Claimed, and Preparing.  - Invalid - Indicates that the repair task state is invalid. All Service Fabric enumerations have the invalid value. - Created - Indicates that the repair task has been created. - Claimed - Indicates that the repair task has been claimed by a repair executor. - Preparing - Indicates that the Repair Manager is preparing the system to handle the impact of the repair task, usually by taking resources offline gracefully. - Approved - Indicates that the repair task has been approved by the Repair Manager and is safe to execute. - Executing - Indicates that execution of the repair task is in progress. - Restoring - Indicates that the Repair Manager is restoring the system to its pre-repair state, usually by bringing resources back online. - Completed - Indicates that the repair task has completed, and no further state changes will occur. ", alias="State")
    target: Optional[RepairTargetDescriptionBase] = Field(default=None, alias="Target")
    task_id: StrictStr = Field(description="The ID of the repair task.", alias="TaskId")
    version: Optional[StrictStr] = Field(default=None, description="The version of the repair task. When creating a new repair task, the version must be set to zero.  When updating a repair task,  the version is used for optimistic concurrency checks.  If the version is  set to zero, the update will not check for write conflicts.  If the version is set to a non-zero value, then the  update will only succeed if the actual current version of the repair task matches this value. ", alias="Version")
    __properties: ClassVar[List[str]] = ["Action", "Description", "Executor", "ExecutorData", "Flags", "History", "Impact", "PerformPreparingHealthCheck", "PerformRestoringHealthCheck", "PreparingHealthCheckState", "RestoringHealthCheckState", "ResultCode", "ResultDetails", "ResultStatus", "State", "Target", "TaskId", "Version"]

    @field_validator('result_status')
    def result_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Invalid', 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending']):
            raise ValueError("must be one of enum values ('Invalid', 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Invalid', 'Created', 'Claimed', 'Preparing', 'Approved', 'Executing', 'Restoring', 'Completed']):
            raise ValueError("must be one of enum values ('Invalid', 'Created', 'Claimed', 'Preparing', 'Approved', 'Executing', 'Restoring', 'Completed')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RepairTask from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of history
        if self.history:
            _dict['History'] = self.history.to_dict()
        # override the default output from pydantic by calling `to_dict()` of impact
        if self.impact:
            _dict['Impact'] = self.impact.to_dict()
        # override the default output from pydantic by calling `to_dict()` of target
        if self.target:
            _dict['Target'] = self.target.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RepairTask from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "Action": obj.get("Action"),
            "Description": obj.get("Description"),
            "Executor": obj.get("Executor"),
            "ExecutorData": obj.get("ExecutorData"),
            "Flags": obj.get("Flags"),
            "History": RepairTaskHistory.from_dict(obj["History"]) if obj.get("History") is not None else None,
            "Impact": RepairImpactDescriptionBase.from_dict(obj["Impact"]) if obj.get("Impact") is not None else None,
            "PerformPreparingHealthCheck": obj.get("PerformPreparingHealthCheck"),
            "PerformRestoringHealthCheck": obj.get("PerformRestoringHealthCheck"),
            "PreparingHealthCheckState": obj.get("PreparingHealthCheckState"),
            "RestoringHealthCheckState": obj.get("RestoringHealthCheckState"),
            "ResultCode": obj.get("ResultCode"),
            "ResultDetails": obj.get("ResultDetails"),
            "ResultStatus": obj.get("ResultStatus"),
            "State": obj.get("State"),
            "Target": RepairTargetDescriptionBase.from_dict(obj["Target"]) if obj.get("Target") is not None else None,
            "TaskId": obj.get("TaskId"),
            "Version": obj.get("Version")
        })
        return _obj


