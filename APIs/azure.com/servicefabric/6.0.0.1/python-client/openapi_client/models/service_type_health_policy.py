# coding: utf-8

"""
    Service Fabric Client APIs

    Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.

    The version of the OpenAPI document: 6.0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ServiceTypeHealthPolicy(BaseModel):
    """
    Represents the health policy used to evaluate the health of services belonging to a service type. 
    """ # noqa: E501
    max_percent_unhealthy_partitions_per_service: Optional[StrictInt] = Field(default=None, description="The maximum allowed percentage of unhealthy partitions per service. Allowed values are Byte values from zero to 100  The percentage represents the maximum tolerated percentage of partitions that can be unhealthy before the service is considered in error. If the percentage is respected but there is at least one unhealthy partition, the health is evaluated as Warning. The percentage is calculated by dividing the number of unhealthy partitions over the total number of partitions in the service. The computation rounds up to tolerate one failure on small numbers of partitions. Default percentage is zero. ", alias="MaxPercentUnhealthyPartitionsPerService")
    max_percent_unhealthy_replicas_per_partition: Optional[StrictInt] = Field(default=None, description="The maximum allowed percentage of unhealthy replicas per partition. Allowed values are Byte values from zero to 100.  The percentage represents the maximum tolerated percentage of replicas that can be unhealthy before the partition is considered in error. If the percentage is respected but there is at least one unhealthy replica, the health is evaluated as Warning. The percentage is calculated by dividing the number of unhealthy replicas over the total number of replicas in the partition. The computation rounds up to tolerate one failure on small numbers of replicas. Default percentage is zero. ", alias="MaxPercentUnhealthyReplicasPerPartition")
    max_percent_unhealthy_services: Optional[StrictInt] = Field(default=None, description="The maximum maximum allowed percentage of unhealthy services. Allowed values are Byte values from zero to 100.  The percentage represents the maximum tolerated percentage of services that can be unhealthy before the application is considered in error. If the percentage is respected but there is at least one unhealthy service, the health is evaluated as Warning. This is calculated by dividing the number of unhealthy services of the specific service type over the total number of services of the specific service type. The computation rounds up to tolerate one failure on small numbers of services. Default percentage is zero. ", alias="MaxPercentUnhealthyServices")
    __properties: ClassVar[List[str]] = ["MaxPercentUnhealthyPartitionsPerService", "MaxPercentUnhealthyReplicasPerPartition", "MaxPercentUnhealthyServices"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ServiceTypeHealthPolicy from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ServiceTypeHealthPolicy from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "MaxPercentUnhealthyPartitionsPerService": obj.get("MaxPercentUnhealthyPartitionsPerService"),
            "MaxPercentUnhealthyReplicasPerPartition": obj.get("MaxPercentUnhealthyReplicasPerPartition"),
            "MaxPercentUnhealthyServices": obj.get("MaxPercentUnhealthyServices")
        })
        return _obj


