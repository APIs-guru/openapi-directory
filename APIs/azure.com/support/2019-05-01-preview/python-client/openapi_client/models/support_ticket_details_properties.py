# coding: utf-8

"""
    Microsoft.Support

    Microsoft Azure Support Resource Provider.

    The version of the OpenAPI document: 2019-05-01-preview
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.contact_profile import ContactProfile
from openapi_client.models.quota_ticket_details import QuotaTicketDetails
from openapi_client.models.service_level_agreement import ServiceLevelAgreement
from openapi_client.models.support_engineer import SupportEngineer
from openapi_client.models.technical_ticket_details import TechnicalTicketDetails
from typing import Optional, Set
from typing_extensions import Self

class SupportTicketDetailsProperties(BaseModel):
    """
    Describes the properties of a support ticket.
    """ # noqa: E501
    contact_details: ContactProfile = Field(alias="contactDetails")
    created_date: Optional[datetime] = Field(default=None, description="Time in UTC (ISO 8601 format) when support ticket was created.", alias="createdDate")
    description: StrictStr = Field(description="Detailed description of the question or issue.")
    enrollment_id: Optional[StrictStr] = Field(default=None, description="Enrollment ID associated with the support ticket.", alias="enrollmentId")
    modified_date: Optional[datetime] = Field(default=None, description="Time in UTC (ISO 8601 format) when support ticket was last modified.", alias="modifiedDate")
    problem_classification_display_name: Optional[StrictStr] = Field(default=None, description="Localized name of problem classification.", alias="problemClassificationDisplayName")
    problem_classification_id: StrictStr = Field(description="Each Azure service has its own set of issue category called problem classification that corresponds to the type of problem you're experiencing. This parameter is the resource id of ProblemClassification resource.", alias="problemClassificationId")
    problem_start_time: Optional[datetime] = Field(default=None, description="Time in UTC (ISO 8601 format) when the problem started.", alias="problemStartTime")
    production_outage: Optional[StrictBool] = Field(default=None, description="Indicates if this issue is a production outage.", alias="productionOutage")
    quota_ticket_details: Optional[QuotaTicketDetails] = Field(default=None, alias="quotaTicketDetails")
    require24_x7_response: Optional[StrictBool] = Field(default=None, description="Indicates if this requires a 24x7 response from Azure.", alias="require24X7Response")
    service_display_name: Optional[StrictStr] = Field(default=None, description="Localized name of Azure service.", alias="serviceDisplayName")
    service_id: StrictStr = Field(description="This is the resource id of the Azure service resource associated with the support ticket.", alias="serviceId")
    service_level_agreement: Optional[ServiceLevelAgreement] = Field(default=None, alias="serviceLevelAgreement")
    severity: StrictStr = Field(description="A value that indicates the urgency of the case, which in turn determines the response time according to the service level agreement of the technical support plan you have with Azure.")
    status: Optional[StrictStr] = Field(default=None, description="Status of the support ticket.")
    support_engineer: Optional[SupportEngineer] = Field(default=None, alias="supportEngineer")
    support_plan_type: Optional[StrictStr] = Field(default=None, description="Support plan type associated with the support ticket.", alias="supportPlanType")
    support_ticket_id: Optional[StrictStr] = Field(default=None, description="System generated support ticket id that is unique.", alias="supportTicketId")
    technical_ticket_details: Optional[TechnicalTicketDetails] = Field(default=None, alias="technicalTicketDetails")
    title: StrictStr = Field(description="Title of the support ticket.")
    __properties: ClassVar[List[str]] = ["contactDetails", "createdDate", "description", "enrollmentId", "modifiedDate", "problemClassificationDisplayName", "problemClassificationId", "problemStartTime", "productionOutage", "quotaTicketDetails", "require24X7Response", "serviceDisplayName", "serviceId", "serviceLevelAgreement", "severity", "status", "supportEngineer", "supportPlanType", "supportTicketId", "technicalTicketDetails", "title"]

    @field_validator('severity')
    def severity_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['minimal', 'moderate', 'critical']):
            raise ValueError("must be one of enum values ('minimal', 'moderate', 'critical')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SupportTicketDetailsProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "created_date",
            "enrollment_id",
            "modified_date",
            "problem_classification_display_name",
            "production_outage",
            "service_display_name",
            "status",
            "support_plan_type",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of contact_details
        if self.contact_details:
            _dict['contactDetails'] = self.contact_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of quota_ticket_details
        if self.quota_ticket_details:
            _dict['quotaTicketDetails'] = self.quota_ticket_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of service_level_agreement
        if self.service_level_agreement:
            _dict['serviceLevelAgreement'] = self.service_level_agreement.to_dict()
        # override the default output from pydantic by calling `to_dict()` of support_engineer
        if self.support_engineer:
            _dict['supportEngineer'] = self.support_engineer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of technical_ticket_details
        if self.technical_ticket_details:
            _dict['technicalTicketDetails'] = self.technical_ticket_details.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SupportTicketDetailsProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "contactDetails": ContactProfile.from_dict(obj["contactDetails"]) if obj.get("contactDetails") is not None else None,
            "createdDate": obj.get("createdDate"),
            "description": obj.get("description"),
            "enrollmentId": obj.get("enrollmentId"),
            "modifiedDate": obj.get("modifiedDate"),
            "problemClassificationDisplayName": obj.get("problemClassificationDisplayName"),
            "problemClassificationId": obj.get("problemClassificationId"),
            "problemStartTime": obj.get("problemStartTime"),
            "productionOutage": obj.get("productionOutage"),
            "quotaTicketDetails": QuotaTicketDetails.from_dict(obj["quotaTicketDetails"]) if obj.get("quotaTicketDetails") is not None else None,
            "require24X7Response": obj.get("require24X7Response"),
            "serviceDisplayName": obj.get("serviceDisplayName"),
            "serviceId": obj.get("serviceId"),
            "serviceLevelAgreement": ServiceLevelAgreement.from_dict(obj["serviceLevelAgreement"]) if obj.get("serviceLevelAgreement") is not None else None,
            "severity": obj.get("severity"),
            "status": obj.get("status"),
            "supportEngineer": SupportEngineer.from_dict(obj["supportEngineer"]) if obj.get("supportEngineer") is not None else None,
            "supportPlanType": obj.get("supportPlanType"),
            "supportTicketId": obj.get("supportTicketId"),
            "technicalTicketDetails": TechnicalTicketDetails.from_dict(obj["technicalTicketDetails"]) if obj.get("technicalTicketDetails") is not None else None,
            "title": obj.get("title")
        })
        return _obj


