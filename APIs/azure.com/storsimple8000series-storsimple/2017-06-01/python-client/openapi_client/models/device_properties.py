# coding: utf-8

"""
    StorSimple8000SeriesManagementClient

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2017-06-01
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.device_details import DeviceDetails
from openapi_client.models.device_rollover_details import DeviceRolloverDetails
from typing import Optional, Set
from typing_extensions import Self

class DeviceProperties(BaseModel):
    """
    The properties of the StorSimple device.
    """ # noqa: E501
    activation_time: datetime = Field(description="The UTC time at which the device was activated", alias="activationTime")
    active_controller: StrictStr = Field(description="The identifier of the active controller of the device.", alias="activeController")
    agent_group_version: Optional[StrictInt] = Field(default=None, description="The device agent group version.", alias="agentGroupVersion")
    available_local_storage_in_bytes: Optional[StrictInt] = Field(default=None, description="The storage in bytes that is available locally on the device.", alias="availableLocalStorageInBytes")
    available_tiered_storage_in_bytes: Optional[StrictInt] = Field(default=None, description="The storage in bytes that is available on the device for tiered volumes.", alias="availableTieredStorageInBytes")
    culture: StrictStr = Field(description="The language culture setting on the device. For eg: \"en-US\"")
    details: Optional[DeviceDetails] = None
    device_configuration_status: StrictStr = Field(description="The current configuration status of the device.", alias="deviceConfigurationStatus")
    device_description: StrictStr = Field(description="The device description.", alias="deviceDescription")
    device_location: Optional[StrictStr] = Field(default=None, description="The location of the virtual appliance.", alias="deviceLocation")
    device_software_version: StrictStr = Field(description="The version number of the software running on the device.", alias="deviceSoftwareVersion")
    device_type: StrictStr = Field(description="The type of the device.", alias="deviceType")
    friendly_name: StrictStr = Field(description="The friendly name of the device.", alias="friendlyName")
    friendly_software_name: Optional[StrictStr] = Field(default=None, description="The friendly name of the software running on the device.", alias="friendlySoftwareName")
    friendly_software_version: StrictStr = Field(description="The device friendly software version.", alias="friendlySoftwareVersion")
    model_description: StrictStr = Field(description="The device model.", alias="modelDescription")
    network_interface_card_count: Optional[StrictInt] = Field(default=None, description="The number of network interface cards", alias="networkInterfaceCardCount")
    provisioned_local_storage_in_bytes: Optional[StrictInt] = Field(default=None, description="The storage in bytes used for locally pinned volumes on the device (including additional local reservation).", alias="provisionedLocalStorageInBytes")
    provisioned_tiered_storage_in_bytes: Optional[StrictInt] = Field(default=None, description="The storage in bytes that has been provisioned on the device for tiered volumes.", alias="provisionedTieredStorageInBytes")
    provisioned_volume_size_in_bytes: Optional[StrictInt] = Field(default=None, description="Total capacity in bytes of tiered and locally pinned volumes on the device", alias="provisionedVolumeSizeInBytes")
    rollover_details: Optional[DeviceRolloverDetails] = Field(default=None, alias="rolloverDetails")
    serial_number: StrictStr = Field(description="The serial number.", alias="serialNumber")
    status: StrictStr = Field(description="The current status of the device.")
    target_iqn: StrictStr = Field(description="The target IQN.", alias="targetIqn")
    total_tiered_storage_in_bytes: Optional[StrictInt] = Field(default=None, description="The total tiered storage available on the device in bytes.", alias="totalTieredStorageInBytes")
    using_storage_in_bytes: Optional[StrictInt] = Field(default=None, description="The storage in bytes that is currently being used on the device, including both local and cloud.", alias="usingStorageInBytes")
    virtual_machine_api_type: Optional[StrictStr] = Field(default=None, description="The virtual machine API type.", alias="virtualMachineApiType")
    __properties: ClassVar[List[str]] = ["activationTime", "activeController", "agentGroupVersion", "availableLocalStorageInBytes", "availableTieredStorageInBytes", "culture", "details", "deviceConfigurationStatus", "deviceDescription", "deviceLocation", "deviceSoftwareVersion", "deviceType", "friendlyName", "friendlySoftwareName", "friendlySoftwareVersion", "modelDescription", "networkInterfaceCardCount", "provisionedLocalStorageInBytes", "provisionedTieredStorageInBytes", "provisionedVolumeSizeInBytes", "rolloverDetails", "serialNumber", "status", "targetIqn", "totalTieredStorageInBytes", "usingStorageInBytes", "virtualMachineApiType"]

    @field_validator('active_controller')
    def active_controller_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Unknown', 'None', 'Controller0', 'Controller1']):
            raise ValueError("must be one of enum values ('Unknown', 'None', 'Controller0', 'Controller1')")
        return value

    @field_validator('device_configuration_status')
    def device_configuration_status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Complete', 'Pending']):
            raise ValueError("must be one of enum values ('Complete', 'Pending')")
        return value

    @field_validator('device_type')
    def device_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Invalid', 'Series8000VirtualAppliance', 'Series8000PhysicalAppliance']):
            raise ValueError("must be one of enum values ('Invalid', 'Series8000VirtualAppliance', 'Series8000PhysicalAppliance')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Unknown', 'Online', 'Offline', 'Deactivated', 'RequiresAttention', 'MaintenanceMode', 'Creating', 'Provisioning', 'Deactivating', 'Deleted', 'ReadyToSetup']):
            raise ValueError("must be one of enum values ('Unknown', 'Online', 'Offline', 'Deactivated', 'RequiresAttention', 'MaintenanceMode', 'Creating', 'Provisioning', 'Deactivating', 'Deleted', 'ReadyToSetup')")
        return value

    @field_validator('virtual_machine_api_type')
    def virtual_machine_api_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Classic', 'Arm']):
            raise ValueError("must be one of enum values ('Classic', 'Arm')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DeviceProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "virtual_machine_api_type",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of details
        if self.details:
            _dict['details'] = self.details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rollover_details
        if self.rollover_details:
            _dict['rolloverDetails'] = self.rollover_details.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DeviceProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "activationTime": obj.get("activationTime"),
            "activeController": obj.get("activeController"),
            "agentGroupVersion": obj.get("agentGroupVersion"),
            "availableLocalStorageInBytes": obj.get("availableLocalStorageInBytes"),
            "availableTieredStorageInBytes": obj.get("availableTieredStorageInBytes"),
            "culture": obj.get("culture"),
            "details": DeviceDetails.from_dict(obj["details"]) if obj.get("details") is not None else None,
            "deviceConfigurationStatus": obj.get("deviceConfigurationStatus"),
            "deviceDescription": obj.get("deviceDescription"),
            "deviceLocation": obj.get("deviceLocation"),
            "deviceSoftwareVersion": obj.get("deviceSoftwareVersion"),
            "deviceType": obj.get("deviceType"),
            "friendlyName": obj.get("friendlyName"),
            "friendlySoftwareName": obj.get("friendlySoftwareName"),
            "friendlySoftwareVersion": obj.get("friendlySoftwareVersion"),
            "modelDescription": obj.get("modelDescription"),
            "networkInterfaceCardCount": obj.get("networkInterfaceCardCount"),
            "provisionedLocalStorageInBytes": obj.get("provisionedLocalStorageInBytes"),
            "provisionedTieredStorageInBytes": obj.get("provisionedTieredStorageInBytes"),
            "provisionedVolumeSizeInBytes": obj.get("provisionedVolumeSizeInBytes"),
            "rolloverDetails": DeviceRolloverDetails.from_dict(obj["rolloverDetails"]) if obj.get("rolloverDetails") is not None else None,
            "serialNumber": obj.get("serialNumber"),
            "status": obj.get("status"),
            "targetIqn": obj.get("targetIqn"),
            "totalTieredStorageInBytes": obj.get("totalTieredStorageInBytes"),
            "usingStorageInBytes": obj.get("usingStorageInBytes"),
            "virtualMachineApiType": obj.get("virtualMachineApiType")
        })
        return _obj


