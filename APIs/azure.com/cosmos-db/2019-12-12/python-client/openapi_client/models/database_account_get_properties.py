# coding: utf-8

"""
    Cosmos DB

    Azure Cosmos DB Database Service Resource Provider REST API

    The version of the OpenAPI document: 2019-12-12
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.capability import Capability
from openapi_client.models.connector_offer import ConnectorOffer
from openapi_client.models.consistency_policy import ConsistencyPolicy
from openapi_client.models.database_account_offer_type import DatabaseAccountOfferType
from openapi_client.models.failover_policy import FailoverPolicy
from openapi_client.models.location import Location
from openapi_client.models.virtual_network_rule import VirtualNetworkRule
from typing import Optional, Set
from typing_extensions import Self

class DatabaseAccountGetProperties(BaseModel):
    """
    Properties for the database account.
    """ # noqa: E501
    capabilities: Optional[List[Capability]] = Field(default=None, description="List of Cosmos DB capabilities for the account")
    connector_offer: Optional[ConnectorOffer] = Field(default=None, alias="connectorOffer")
    consistency_policy: Optional[ConsistencyPolicy] = Field(default=None, alias="consistencyPolicy")
    database_account_offer_type: Optional[DatabaseAccountOfferType] = Field(default=None, alias="databaseAccountOfferType")
    disable_key_based_metadata_write_access: Optional[StrictBool] = Field(default=None, description="Disable write operations on metadata resources (databases, containers, throughput) via account keys", alias="disableKeyBasedMetadataWriteAccess")
    document_endpoint: Optional[StrictStr] = Field(default=None, description="The connection endpoint for the Cosmos DB database account.", alias="documentEndpoint")
    enable_automatic_failover: Optional[StrictBool] = Field(default=None, description="Enables automatic failover of the write region in the rare event that the region is unavailable due to an outage. Automatic failover will result in a new write region for the account and is chosen based on the failover priorities configured for the account.", alias="enableAutomaticFailover")
    enable_cassandra_connector: Optional[StrictBool] = Field(default=None, description="Enables the cassandra connector on the Cosmos DB C* account", alias="enableCassandraConnector")
    enable_multiple_write_locations: Optional[StrictBool] = Field(default=None, description="Enables the account to write in multiple locations", alias="enableMultipleWriteLocations")
    failover_policies: Optional[List[FailoverPolicy]] = Field(default=None, description="An array that contains the regions ordered by their failover priorities.", alias="failoverPolicies")
    ip_range_filter: Optional[StrictStr] = Field(default=None, description="Cosmos DB Firewall Support: This value specifies the set of IP addresses or IP address ranges in CIDR form to be included as the allowed list of client IPs for a given database account. IP addresses/ranges must be comma separated and must not contain any spaces.", alias="ipRangeFilter")
    is_virtual_network_filter_enabled: Optional[StrictBool] = Field(default=None, description="Flag to indicate whether to enable/disable Virtual Network ACL rules.", alias="isVirtualNetworkFilterEnabled")
    key_vault_key_uri: Optional[StrictStr] = Field(default=None, description="The URI of the key vault", alias="keyVaultKeyUri")
    locations: Optional[List[Location]] = Field(default=None, description="An array that contains all of the locations enabled for the Cosmos DB account.")
    provisioning_state: Optional[StrictStr] = Field(default=None, description="The status of the Cosmos DB account at the time the operation was called. The status can be one of following. 'Creating' – the Cosmos DB account is being created. When an account is in Creating state, only properties that are specified as input for the Create Cosmos DB account operation are returned. 'Succeeded' – the Cosmos DB account is active for use. 'Updating' – the Cosmos DB account is being updated. 'Deleting' – the Cosmos DB account is being deleted. 'Failed' – the Cosmos DB account failed creation.", alias="provisioningState")
    read_locations: Optional[List[Location]] = Field(default=None, description="An array that contains of the read locations enabled for the Cosmos DB account.", alias="readLocations")
    virtual_network_rules: Optional[List[VirtualNetworkRule]] = Field(default=None, description="List of Virtual Network ACL rules configured for the Cosmos DB account.", alias="virtualNetworkRules")
    write_locations: Optional[List[Location]] = Field(default=None, description="An array that contains the write location for the Cosmos DB account.", alias="writeLocations")
    __properties: ClassVar[List[str]] = ["capabilities", "connectorOffer", "consistencyPolicy", "databaseAccountOfferType", "disableKeyBasedMetadataWriteAccess", "documentEndpoint", "enableAutomaticFailover", "enableCassandraConnector", "enableMultipleWriteLocations", "failoverPolicies", "ipRangeFilter", "isVirtualNetworkFilterEnabled", "keyVaultKeyUri", "locations", "provisioningState", "readLocations", "virtualNetworkRules", "writeLocations"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DatabaseAccountGetProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "document_endpoint",
            "failover_policies",
            "locations",
            "read_locations",
            "write_locations",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in capabilities (list)
        _items = []
        if self.capabilities:
            for _item_capabilities in self.capabilities:
                if _item_capabilities:
                    _items.append(_item_capabilities.to_dict())
            _dict['capabilities'] = _items
        # override the default output from pydantic by calling `to_dict()` of consistency_policy
        if self.consistency_policy:
            _dict['consistencyPolicy'] = self.consistency_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in failover_policies (list)
        _items = []
        if self.failover_policies:
            for _item_failover_policies in self.failover_policies:
                if _item_failover_policies:
                    _items.append(_item_failover_policies.to_dict())
            _dict['failoverPolicies'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in locations (list)
        _items = []
        if self.locations:
            for _item_locations in self.locations:
                if _item_locations:
                    _items.append(_item_locations.to_dict())
            _dict['locations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in read_locations (list)
        _items = []
        if self.read_locations:
            for _item_read_locations in self.read_locations:
                if _item_read_locations:
                    _items.append(_item_read_locations.to_dict())
            _dict['readLocations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in virtual_network_rules (list)
        _items = []
        if self.virtual_network_rules:
            for _item_virtual_network_rules in self.virtual_network_rules:
                if _item_virtual_network_rules:
                    _items.append(_item_virtual_network_rules.to_dict())
            _dict['virtualNetworkRules'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in write_locations (list)
        _items = []
        if self.write_locations:
            for _item_write_locations in self.write_locations:
                if _item_write_locations:
                    _items.append(_item_write_locations.to_dict())
            _dict['writeLocations'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DatabaseAccountGetProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "capabilities": [Capability.from_dict(_item) for _item in obj["capabilities"]] if obj.get("capabilities") is not None else None,
            "connectorOffer": obj.get("connectorOffer"),
            "consistencyPolicy": ConsistencyPolicy.from_dict(obj["consistencyPolicy"]) if obj.get("consistencyPolicy") is not None else None,
            "databaseAccountOfferType": obj.get("databaseAccountOfferType"),
            "disableKeyBasedMetadataWriteAccess": obj.get("disableKeyBasedMetadataWriteAccess"),
            "documentEndpoint": obj.get("documentEndpoint"),
            "enableAutomaticFailover": obj.get("enableAutomaticFailover"),
            "enableCassandraConnector": obj.get("enableCassandraConnector"),
            "enableMultipleWriteLocations": obj.get("enableMultipleWriteLocations"),
            "failoverPolicies": [FailoverPolicy.from_dict(_item) for _item in obj["failoverPolicies"]] if obj.get("failoverPolicies") is not None else None,
            "ipRangeFilter": obj.get("ipRangeFilter"),
            "isVirtualNetworkFilterEnabled": obj.get("isVirtualNetworkFilterEnabled"),
            "keyVaultKeyUri": obj.get("keyVaultKeyUri"),
            "locations": [Location.from_dict(_item) for _item in obj["locations"]] if obj.get("locations") is not None else None,
            "provisioningState": obj.get("provisioningState"),
            "readLocations": [Location.from_dict(_item) for _item in obj["readLocations"]] if obj.get("readLocations") is not None else None,
            "virtualNetworkRules": [VirtualNetworkRule.from_dict(_item) for _item in obj["virtualNetworkRules"]] if obj.get("virtualNetworkRules") is not None else None,
            "writeLocations": [Location.from_dict(_item) for _item in obj["writeLocations"]] if obj.get("writeLocations") is not None else None
        })
        return _obj


