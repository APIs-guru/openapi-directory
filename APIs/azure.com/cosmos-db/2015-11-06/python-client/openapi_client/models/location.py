# coding: utf-8

"""
    Cosmos DB

    Azure Cosmos DB Database Service Resource Provider REST API

    The version of the OpenAPI document: 2015-11-06
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class Location(BaseModel):
    """
    A region in which the Azure Cosmos DB database account is deployed.
    """ # noqa: E501
    document_endpoint: Optional[StrictStr] = Field(default=None, description="The connection endpoint for the specific region. Example: https://&lt;accountName&gt;-&lt;locationName&gt;.documents.azure.com:443/", alias="documentEndpoint")
    failover_priority: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists.", alias="failoverPriority")
    id: Optional[StrictStr] = Field(default=None, description="The unique identifier of the region within the database account. Example: &lt;accountName&gt;-&lt;locationName&gt;.")
    is_zone_redundant: Optional[StrictBool] = Field(default=None, description="Flag to indicate whether or not this region is an AvailabilityZone region", alias="isZoneRedundant")
    location_name: Optional[StrictStr] = Field(default=None, description="The name of the region.", alias="locationName")
    provisioning_state: Optional[StrictStr] = Field(default=None, description="The status of the Cosmos DB account at the time the operation was called. The status can be one of following. 'Creating' – the Cosmos DB account is being created. When an account is in Creating state, only properties that are specified as input for the Create Cosmos DB account operation are returned. 'Succeeded' – the Cosmos DB account is active for use. 'Updating' – the Cosmos DB account is being updated. 'Deleting' – the Cosmos DB account is being deleted. 'Failed' – the Cosmos DB account failed creation.", alias="provisioningState")
    __properties: ClassVar[List[str]] = ["documentEndpoint", "failoverPriority", "id", "isZoneRedundant", "locationName", "provisioningState"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Location from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "document_endpoint",
            "id",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Location from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "documentEndpoint": obj.get("documentEndpoint"),
            "failoverPriority": obj.get("failoverPriority"),
            "id": obj.get("id"),
            "isZoneRedundant": obj.get("isZoneRedundant"),
            "locationName": obj.get("locationName"),
            "provisioningState": obj.get("provisioningState")
        })
        return _obj


