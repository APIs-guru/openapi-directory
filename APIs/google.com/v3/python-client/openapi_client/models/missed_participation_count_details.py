# coding: utf-8

"""
    Travel Partner API

    The Travel Partner API provides you with a RESTful interface to the Google Hotel Center platform. It enables an app to efficiently retrieve and change Hotel Center data, and is thus suitable for managing large or complex accounts.

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.no_price_count_details import NoPriceCountDetails
from openapi_client.models.price_missing_count_details import PriceMissingCountDetails
from openapi_client.models.price_problem_count_details import PriceProblemCountDetails
from openapi_client.models.price_unavailable_count_details import PriceUnavailableCountDetails
from typing import Optional, Set
from typing_extensions import Self

class MissedParticipationCountDetails(BaseModel):
    """
    Missed participation count broken down by reason.
    """ # noqa: E501
    hotel_suspended_count: Optional[StrictStr] = Field(default=None, description="The total number of missed participations due to one or more of your hotels being suspended due to price accuracy violations.", alias="hotelSuspendedCount")
    no_availability_count: Optional[StrictStr] = Field(default=None, description="The total number of missed participation due to the hotel/itinerary combination being unavailable, or the traveler was ineligible for the rates. To participate in these auctions, you may need to provide more pricing information.", alias="noAvailabilityCount")
    no_landing_page_count: Optional[StrictStr] = Field(default=None, description="No landing page matched the user.", alias="noLandingPageCount")
    no_price_count: Optional[StrictStr] = Field(default=None, description="The total number of missed participations due to a price not being offered for the requested itinerary.", alias="noPriceCount")
    no_price_count_details: Optional[NoPriceCountDetails] = Field(default=None, alias="noPriceCountDetails")
    no_tax_breakdown_count: Optional[StrictStr] = Field(default=None, description="The total number of missed participation due to one or more of your hotels not specifying taxes and fees separately.", alias="noTaxBreakdownCount")
    other_reason_count: Optional[StrictStr] = Field(default=None, description="Hotel did not participate for an unknown reason.", alias="otherReasonCount")
    price_missing_count: Optional[StrictStr] = Field(default=None, description="The total number of missed participations due to either a price not being present in Google's cache or failing to successfully respond to live pricing. Comprised of the following: * Bandwidth depleted * Cache rate missing * Itinerary blocked * Live pricing not set up * Live pricing timeout * Live pricing error", alias="priceMissingCount")
    price_missing_count_details: Optional[PriceMissingCountDetails] = Field(default=None, alias="priceMissingCountDetails")
    price_problem_count: Optional[StrictStr] = Field(default=None, description="The total number of missed participation due to an issue with the accuracy of the price provided for the itinerary. Comprised of the following: * Hotel suspended * Price unusually high * Price unusually low * Taxes and feeds missing", alias="priceProblemCount")
    price_problem_count_details: Optional[PriceProblemCountDetails] = Field(default=None, alias="priceProblemCountDetails")
    price_unavailable_count: Optional[StrictStr] = Field(default=None, description="The total number of missed participation due to price listed as unavailable (-1) for the requested itinerary. Comprised of the following: * Price unavailable * Participation not likely * Other", alias="priceUnavailableCount")
    price_unavailable_count_details: Optional[PriceUnavailableCountDetails] = Field(default=None, alias="priceUnavailableCountDetails")
    __properties: ClassVar[List[str]] = ["hotelSuspendedCount", "noAvailabilityCount", "noLandingPageCount", "noPriceCount", "noPriceCountDetails", "noTaxBreakdownCount", "otherReasonCount", "priceMissingCount", "priceMissingCountDetails", "priceProblemCount", "priceProblemCountDetails", "priceUnavailableCount", "priceUnavailableCountDetails"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MissedParticipationCountDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of no_price_count_details
        if self.no_price_count_details:
            _dict['noPriceCountDetails'] = self.no_price_count_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of price_missing_count_details
        if self.price_missing_count_details:
            _dict['priceMissingCountDetails'] = self.price_missing_count_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of price_problem_count_details
        if self.price_problem_count_details:
            _dict['priceProblemCountDetails'] = self.price_problem_count_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of price_unavailable_count_details
        if self.price_unavailable_count_details:
            _dict['priceUnavailableCountDetails'] = self.price_unavailable_count_details.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MissedParticipationCountDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "hotelSuspendedCount": obj.get("hotelSuspendedCount"),
            "noAvailabilityCount": obj.get("noAvailabilityCount"),
            "noLandingPageCount": obj.get("noLandingPageCount"),
            "noPriceCount": obj.get("noPriceCount"),
            "noPriceCountDetails": NoPriceCountDetails.from_dict(obj["noPriceCountDetails"]) if obj.get("noPriceCountDetails") is not None else None,
            "noTaxBreakdownCount": obj.get("noTaxBreakdownCount"),
            "otherReasonCount": obj.get("otherReasonCount"),
            "priceMissingCount": obj.get("priceMissingCount"),
            "priceMissingCountDetails": PriceMissingCountDetails.from_dict(obj["priceMissingCountDetails"]) if obj.get("priceMissingCountDetails") is not None else None,
            "priceProblemCount": obj.get("priceProblemCount"),
            "priceProblemCountDetails": PriceProblemCountDetails.from_dict(obj["priceProblemCountDetails"]) if obj.get("priceProblemCountDetails") is not None else None,
            "priceUnavailableCount": obj.get("priceUnavailableCount"),
            "priceUnavailableCountDetails": PriceUnavailableCountDetails.from_dict(obj["priceUnavailableCountDetails"]) if obj.get("priceUnavailableCountDetails") is not None else None
        })
        return _obj


