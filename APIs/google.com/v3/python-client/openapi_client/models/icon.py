# coding: utf-8

"""
    Travel Partner API

    The Travel Partner API provides you with a RESTful interface to the Google Hotel Center platform. It enables an app to efficiently retrieve and change Hotel Center data, and is thus suitable for managing large or complex accounts.

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBytes, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class Icon(BaseModel):
    """
    Information about a partner's icon.
    """ # noqa: E501
    disapproval_reasons: Optional[List[StrictStr]] = Field(default=None, description="Output only. The icon's disapproval reason(s). Only applies to icons with `REJECTED` state.", alias="disapprovalReasons")
    icon_uri: Optional[StrictStr] = Field(default=None, description="Output only. The approved icon's Google-hosted URI. Only applies to icons with `APPROVED` state.", alias="iconUri")
    image_data: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="Required. Input only. The icon contents, which must be in PNG format, or convertible to PNG.", alias="imageData")
    name: Optional[StrictStr] = Field(default=None, description="Required. Output only. The resource name for the icon in the format `accounts/{account_id}/icons/{icon_id}`. Google generates the `icon_id` during the `create` operation. Use the `icon_id` to associate the icon with a brand using the [accounts.brands](/hotels/hotel-prices/api-reference/rest/v3/accounts.brands#resource:-brand) API.")
    reference: Optional[StrictStr] = Field(default=None, description="Optional. Value for tracking the icon. It could be the primary key to your icon in your system, or the icon's filename. Google does not use this value.")
    state: Optional[StrictStr] = Field(default=None, description="Output only. The icon's current state.")
    __properties: ClassVar[List[str]] = ["disapprovalReasons", "iconUri", "imageData", "name", "reference", "state"]

    @field_validator('disapproval_reasons')
    def disapproval_reasons_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['IMAGE_DISAPPROVAL_REASON_UNSPECIFIED', 'NOT_LIKE_SITE', 'OFFENSIVE', 'LOW_QUALITY', 'ANIMATED', 'BAD_BACKGROUND', 'TEXT_TOO_SMALL']):
                raise ValueError("each list item must be one of ('IMAGE_DISAPPROVAL_REASON_UNSPECIFIED', 'NOT_LIKE_SITE', 'OFFENSIVE', 'LOW_QUALITY', 'ANIMATED', 'BAD_BACKGROUND', 'TEXT_TOO_SMALL')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'NEW', 'APPROVED', 'REJECTED']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'NEW', 'APPROVED', 'REJECTED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Icon from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "disapproval_reasons",
            "icon_uri",
            "name",
            "state",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Icon from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "disapprovalReasons": obj.get("disapprovalReasons"),
            "iconUri": obj.get("iconUri"),
            "imageData": obj.get("imageData"),
            "name": obj.get("name"),
            "reference": obj.get("reference"),
            "state": obj.get("state")
        })
        return _obj


