# coding: utf-8

"""
    Travel Partner API

    The Travel Partner API provides you with a RESTful interface to the Google Hotel Center platform. It enables an app to efficiently retrieve and change Hotel Center data, and is thus suitable for managing large or complex accounts.

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.data_issue_detail import DataIssueDetail
from openapi_client.models.image import Image
from openapi_client.models.lat_lng import LatLng
from openapi_client.models.localized_text import LocalizedText
from openapi_client.models.review import Review
from typing import Optional, Set
from typing_extensions import Self

class ParsedListing(BaseModel):
    """
    A parsed listing
    """ # noqa: E501
    brand: Optional[StrictStr] = Field(default=None, description="If not empty, it indicates that this listing belongs to a brand of the feed.")
    category: Optional[List[LocalizedText]] = Field(default=None, description="The partner provided category (accommodation type) of the property.")
    data_issue_detail: Optional[List[DataIssueDetail]] = Field(default=None, description="Data issues about this listing", alias="dataIssueDetail")
    description: Optional[List[LocalizedText]] = Field(default=None, description="Description of the property.")
    image: Optional[List[Image]] = Field(default=None, description="Images associated with this listing, localized.")
    imprecision_radius_meters: Optional[StrictInt] = Field(default=None, description="Represents the accuracy of the location. The listing can be anywhere within the defined circular area.", alias="imprecisionRadiusMeters")
    is_served: Optional[StrictBool] = Field(default=None, description="Whether the listing can be served based on non image data alone.", alias="isServed")
    listing_name: Optional[List[LocalizedText]] = Field(default=None, description="List of localized names.", alias="listingName")
    location: Optional[LatLng] = None
    partner_list_id: Optional[StrictStr] = Field(default=None, description="The list id on partner lec feed, provided by partner.", alias="partnerListId")
    region_code: Optional[StrictStr] = Field(default=None, description="The country code where the listing is located.", alias="regionCode")
    review: Optional[List[Review]] = Field(default=None, description="Reviews associated with this listing. Each review proto has a single language attached to it.")
    unit_attributes: Optional[Dict[str, StrictStr]] = Field(default=None, description="VR List attribute.", alias="unitAttributes")
    __properties: ClassVar[List[str]] = ["brand", "category", "dataIssueDetail", "description", "image", "imprecisionRadiusMeters", "isServed", "listingName", "location", "partnerListId", "regionCode", "review", "unitAttributes"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ParsedListing from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in category (list)
        _items = []
        if self.category:
            for _item_category in self.category:
                if _item_category:
                    _items.append(_item_category.to_dict())
            _dict['category'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in data_issue_detail (list)
        _items = []
        if self.data_issue_detail:
            for _item_data_issue_detail in self.data_issue_detail:
                if _item_data_issue_detail:
                    _items.append(_item_data_issue_detail.to_dict())
            _dict['dataIssueDetail'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in description (list)
        _items = []
        if self.description:
            for _item_description in self.description:
                if _item_description:
                    _items.append(_item_description.to_dict())
            _dict['description'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in image (list)
        _items = []
        if self.image:
            for _item_image in self.image:
                if _item_image:
                    _items.append(_item_image.to_dict())
            _dict['image'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in listing_name (list)
        _items = []
        if self.listing_name:
            for _item_listing_name in self.listing_name:
                if _item_listing_name:
                    _items.append(_item_listing_name.to_dict())
            _dict['listingName'] = _items
        # override the default output from pydantic by calling `to_dict()` of location
        if self.location:
            _dict['location'] = self.location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in review (list)
        _items = []
        if self.review:
            for _item_review in self.review:
                if _item_review:
                    _items.append(_item_review.to_dict())
            _dict['review'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ParsedListing from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "brand": obj.get("brand"),
            "category": [LocalizedText.from_dict(_item) for _item in obj["category"]] if obj.get("category") is not None else None,
            "dataIssueDetail": [DataIssueDetail.from_dict(_item) for _item in obj["dataIssueDetail"]] if obj.get("dataIssueDetail") is not None else None,
            "description": [LocalizedText.from_dict(_item) for _item in obj["description"]] if obj.get("description") is not None else None,
            "image": [Image.from_dict(_item) for _item in obj["image"]] if obj.get("image") is not None else None,
            "imprecisionRadiusMeters": obj.get("imprecisionRadiusMeters"),
            "isServed": obj.get("isServed"),
            "listingName": [LocalizedText.from_dict(_item) for _item in obj["listingName"]] if obj.get("listingName") is not None else None,
            "location": LatLng.from_dict(obj["location"]) if obj.get("location") is not None else None,
            "partnerListId": obj.get("partnerListId"),
            "regionCode": obj.get("regionCode"),
            "review": [Review.from_dict(_item) for _item in obj["review"]] if obj.get("review") is not None else None,
            "unitAttributes": obj.get("unitAttributes")
        })
        return _obj


