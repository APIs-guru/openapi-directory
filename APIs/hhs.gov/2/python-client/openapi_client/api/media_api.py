# coding: utf-8

"""
    HHS Media Services API

    <div class=\"swagger-ui-wrap extraFooter\"><h3>Common Features / Behaviors</h3> <div class=\"features\"> <ul> <li><strong>* \"sort\" param:</strong> supports multi column sorting through the use of commas as delimiters, and a hyphen to denote descending order. <br/> <strong><span>Examples:</span></strong> <ul> <li><span class=\"example\">name</span><span class=\"description\">sort results by name ascending</span></li> <li><span class=\"example\">-name</span><span class=\"description\">sort results by name descending</span></li> <li><span class=\"example\">-name,id</span><span class=\"description\">sort results by name descending and then by id ascending</span></li> <li><span class=\"example\">id,-dateContentAuthored</span><span class=\"description\">sort results by id ascending and then date descending</span></li> </ul> </li> <li><strong>Date formats:</strong> Date input format is expected to be based on <a href=\"http://www.ietf.org/rfc/rfc3339.txt\">RFC 3339</a>. <br/> <span><strong>Example:</strong></span> <ul><li>2013-11-18T18:43:01Z</li></ul> </li> </ul> </div> </div>

    The version of the OpenAPI document: 2
    Contact: syndicationadmin@hhs.gov
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date
from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.media_item import MediaItem
from openapi_client.models.media_item_wrapped import MediaItemWrapped
from openapi_client.models.resources_media_id_youtube_meta_data_json_get200_response import ResourcesMediaIdYoutubeMetaDataJsonGet200Response
from openapi_client.models.syndicate_marshaller_wrapped import SyndicateMarshallerWrapped

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class MediaApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def resources_media_featured_json_get(
        self,
        sort: Annotated[Optional[StrictStr], Field(description="The name of the property to which sorting will be applied")] = None,
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Return records starting at the offset index.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[MediaItem]:
        """Get the list of featured content in the syndication system

        Get the list of featured content in the syndication system

        :param sort: The name of the property to which sorting will be applied
        :type sort: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: Return records starting at the offset index.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_featured_json_get_serialize(
            sort=sort,
            max=max,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItem]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_featured_json_get_with_http_info(
        self,
        sort: Annotated[Optional[StrictStr], Field(description="The name of the property to which sorting will be applied")] = None,
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Return records starting at the offset index.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[MediaItem]]:
        """Get the list of featured content in the syndication system

        Get the list of featured content in the syndication system

        :param sort: The name of the property to which sorting will be applied
        :type sort: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: Return records starting at the offset index.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_featured_json_get_serialize(
            sort=sort,
            max=max,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItem]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_featured_json_get_without_preload_content(
        self,
        sort: Annotated[Optional[StrictStr], Field(description="The name of the property to which sorting will be applied")] = None,
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Return records starting at the offset index.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the list of featured content in the syndication system

        Get the list of featured content in the syndication system

        :param sort: The name of the property to which sorting will be applied
        :type sort: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: Return records starting at the offset index.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_featured_json_get_serialize(
            sort=sort,
            max=max,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItem]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_featured_json_get_serialize(
        self,
        sort,
        max,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if max is not None:
            
            _query_params.append(('max', max))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/featured.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_id_content_get(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to show content for.")],
        called_by_build: Annotated[Optional[StrictBool], Field(description="The method that called this method")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Get content for MediaItem

        The actual media content (html, image, etc...)

        :param id: The id of the media to show content for. (required)
        :type id: int
        :param called_by_build: The method that called this method
        :type called_by_build: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_content_get_serialize(
            id=id,
            called_by_build=called_by_build,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_id_content_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to show content for.")],
        called_by_build: Annotated[Optional[StrictBool], Field(description="The method that called this method")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Get content for MediaItem

        The actual media content (html, image, etc...)

        :param id: The id of the media to show content for. (required)
        :type id: int
        :param called_by_build: The method that called this method
        :type called_by_build: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_content_get_serialize(
            id=id,
            called_by_build=called_by_build,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_id_content_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to show content for.")],
        called_by_build: Annotated[Optional[StrictBool], Field(description="The method that called this method")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get content for MediaItem

        The actual media content (html, image, etc...)

        :param id: The id of the media to show content for. (required)
        :type id: int
        :param called_by_build: The method that called this method
        :type called_by_build: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_content_get_serialize(
            id=id,
            called_by_build=called_by_build,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_id_content_get_serialize(
        self,
        id,
        called_by_build,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if called_by_build is not None:
            
            _query_params.append(('calledByBuild', called_by_build))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/{id}/content',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_id_embed_json_get(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to get embed code for.")],
        flavor: Annotated[Optional[StrictStr], Field(description="Currently supports 'iframe', defaults to 'javascript'.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of the generated iframe.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of the generated iframe.")] = None,
        iframe_name: Annotated[Optional[StrictStr], Field(description="The name of the iframe element")] = None,
        exclude_jquery: Annotated[Optional[StrictBool], Field(description="Should a reference to the JQuery Library be omitted?")] = None,
        exclude_div: Annotated[Optional[StrictBool], Field(description="Should the div to insert content into be omitted?")] = None,
        div_id: Annotated[Optional[StrictStr], Field(description="Should the div to insert content into have a specific name?")] = None,
        display_method: Annotated[Optional[StrictStr], Field(description="Method used to render an html request. Accepts one: [mv, list, feed]")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Get embed code for MediaItem

        Get the javascript or iframe embed code for this item (to embed it on a web page).

        :param id: The id of the media to get embed code for. (required)
        :type id: int
        :param flavor: Currently supports 'iframe', defaults to 'javascript'.
        :type flavor: str
        :param width: The width of the generated iframe.
        :type width: int
        :param height: The height of the generated iframe.
        :type height: int
        :param iframe_name: The name of the iframe element
        :type iframe_name: str
        :param exclude_jquery: Should a reference to the JQuery Library be omitted?
        :type exclude_jquery: bool
        :param exclude_div: Should the div to insert content into be omitted?
        :type exclude_div: bool
        :param div_id: Should the div to insert content into have a specific name?
        :type div_id: str
        :param display_method: Method used to render an html request. Accepts one: [mv, list, feed]
        :type display_method: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_embed_json_get_serialize(
            id=id,
            flavor=flavor,
            width=width,
            height=height,
            iframe_name=iframe_name,
            exclude_jquery=exclude_jquery,
            exclude_div=exclude_div,
            div_id=div_id,
            display_method=display_method,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_id_embed_json_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to get embed code for.")],
        flavor: Annotated[Optional[StrictStr], Field(description="Currently supports 'iframe', defaults to 'javascript'.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of the generated iframe.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of the generated iframe.")] = None,
        iframe_name: Annotated[Optional[StrictStr], Field(description="The name of the iframe element")] = None,
        exclude_jquery: Annotated[Optional[StrictBool], Field(description="Should a reference to the JQuery Library be omitted?")] = None,
        exclude_div: Annotated[Optional[StrictBool], Field(description="Should the div to insert content into be omitted?")] = None,
        div_id: Annotated[Optional[StrictStr], Field(description="Should the div to insert content into have a specific name?")] = None,
        display_method: Annotated[Optional[StrictStr], Field(description="Method used to render an html request. Accepts one: [mv, list, feed]")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Get embed code for MediaItem

        Get the javascript or iframe embed code for this item (to embed it on a web page).

        :param id: The id of the media to get embed code for. (required)
        :type id: int
        :param flavor: Currently supports 'iframe', defaults to 'javascript'.
        :type flavor: str
        :param width: The width of the generated iframe.
        :type width: int
        :param height: The height of the generated iframe.
        :type height: int
        :param iframe_name: The name of the iframe element
        :type iframe_name: str
        :param exclude_jquery: Should a reference to the JQuery Library be omitted?
        :type exclude_jquery: bool
        :param exclude_div: Should the div to insert content into be omitted?
        :type exclude_div: bool
        :param div_id: Should the div to insert content into have a specific name?
        :type div_id: str
        :param display_method: Method used to render an html request. Accepts one: [mv, list, feed]
        :type display_method: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_embed_json_get_serialize(
            id=id,
            flavor=flavor,
            width=width,
            height=height,
            iframe_name=iframe_name,
            exclude_jquery=exclude_jquery,
            exclude_div=exclude_div,
            div_id=div_id,
            display_method=display_method,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_id_embed_json_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to get embed code for.")],
        flavor: Annotated[Optional[StrictStr], Field(description="Currently supports 'iframe', defaults to 'javascript'.")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of the generated iframe.")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of the generated iframe.")] = None,
        iframe_name: Annotated[Optional[StrictStr], Field(description="The name of the iframe element")] = None,
        exclude_jquery: Annotated[Optional[StrictBool], Field(description="Should a reference to the JQuery Library be omitted?")] = None,
        exclude_div: Annotated[Optional[StrictBool], Field(description="Should the div to insert content into be omitted?")] = None,
        div_id: Annotated[Optional[StrictStr], Field(description="Should the div to insert content into have a specific name?")] = None,
        display_method: Annotated[Optional[StrictStr], Field(description="Method used to render an html request. Accepts one: [mv, list, feed]")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get embed code for MediaItem

        Get the javascript or iframe embed code for this item (to embed it on a web page).

        :param id: The id of the media to get embed code for. (required)
        :type id: int
        :param flavor: Currently supports 'iframe', defaults to 'javascript'.
        :type flavor: str
        :param width: The width of the generated iframe.
        :type width: int
        :param height: The height of the generated iframe.
        :type height: int
        :param iframe_name: The name of the iframe element
        :type iframe_name: str
        :param exclude_jquery: Should a reference to the JQuery Library be omitted?
        :type exclude_jquery: bool
        :param exclude_div: Should the div to insert content into be omitted?
        :type exclude_div: bool
        :param div_id: Should the div to insert content into have a specific name?
        :type div_id: str
        :param display_method: Method used to render an html request. Accepts one: [mv, list, feed]
        :type display_method: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_embed_json_get_serialize(
            id=id,
            flavor=flavor,
            width=width,
            height=height,
            iframe_name=iframe_name,
            exclude_jquery=exclude_jquery,
            exclude_div=exclude_div,
            div_id=div_id,
            display_method=display_method,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_id_embed_json_get_serialize(
        self,
        id,
        flavor,
        width,
        height,
        iframe_name,
        exclude_jquery,
        exclude_div,
        div_id,
        display_method,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if flavor is not None:
            
            _query_params.append(('flavor', flavor))
            
        if width is not None:
            
            _query_params.append(('width', width))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        if iframe_name is not None:
            
            _query_params.append(('iframeName', iframe_name))
            
        if exclude_jquery is not None:
            
            _query_params.append(('excludeJquery', exclude_jquery))
            
        if exclude_div is not None:
            
            _query_params.append(('excludeDiv', exclude_div))
            
        if div_id is not None:
            
            _query_params.append(('divId', div_id))
            
        if display_method is not None:
            
            _query_params.append(('displayMethod', display_method))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/{id}/embed.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_id_json_get(
        self,
        id: Annotated[StrictInt, Field(description="The id of the record to look up")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[MediaItemWrapped]:
        """Get MediaItem by ID

        Information about a specific media item

        :param id: The id of the record to look up (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_json_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_id_json_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The id of the record to look up")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[MediaItemWrapped]]:
        """Get MediaItem by ID

        Information about a specific media item

        :param id: The id of the record to look up (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_json_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_id_json_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The id of the record to look up")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get MediaItem by ID

        Information about a specific media item

        :param id: The id of the record to look up (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_json_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_id_json_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/{id}.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_id_preview_jpg_get(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to get a preview for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Get Tag by ID

        Get the jpg preview of the content item where applicable.

        :param id: The id of the media to get a preview for. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_preview_jpg_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_id_preview_jpg_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to get a preview for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Get Tag by ID

        Get the jpg preview of the content item where applicable.

        :param id: The id of the media to get a preview for. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_preview_jpg_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_id_preview_jpg_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to get a preview for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Tag by ID

        Get the jpg preview of the content item where applicable.

        :param id: The id of the media to get a preview for. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_preview_jpg_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_id_preview_jpg_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/{id}/preview.jpg',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_id_related_media_format_get(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media item to get related media for")],
        format: Annotated[StrictStr, Field(description="Automatically added")],
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Return records starting at the offset index.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="The name of the property to which sorting will be applied")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[MediaItemWrapped]:
        """Get related MediaItems by ID

        Get the media related to the current media item.

        :param id: The id of the media item to get related media for (required)
        :type id: int
        :param format: Automatically added (required)
        :type format: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: Return records starting at the offset index.
        :type offset: int
        :param sort: The name of the property to which sorting will be applied
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_related_media_format_get_serialize(
            id=id,
            format=format,
            max=max,
            offset=offset,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_id_related_media_format_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media item to get related media for")],
        format: Annotated[StrictStr, Field(description="Automatically added")],
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Return records starting at the offset index.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="The name of the property to which sorting will be applied")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[MediaItemWrapped]]:
        """Get related MediaItems by ID

        Get the media related to the current media item.

        :param id: The id of the media item to get related media for (required)
        :type id: int
        :param format: Automatically added (required)
        :type format: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: Return records starting at the offset index.
        :type offset: int
        :param sort: The name of the property to which sorting will be applied
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_related_media_format_get_serialize(
            id=id,
            format=format,
            max=max,
            offset=offset,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_id_related_media_format_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media item to get related media for")],
        format: Annotated[StrictStr, Field(description="Automatically added")],
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Return records starting at the offset index.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="The name of the property to which sorting will be applied")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get related MediaItems by ID

        Get the media related to the current media item.

        :param id: The id of the media item to get related media for (required)
        :type id: int
        :param format: Automatically added (required)
        :type format: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: Return records starting at the offset index.
        :type offset: int
        :param sort: The name of the property to which sorting will be applied
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_related_media_format_get_serialize(
            id=id,
            format=format,
            max=max,
            offset=offset,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_id_related_media_format_get_serialize(
        self,
        id,
        format,
        max,
        offset,
        sort,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if format is not None:
            _path_params['format'] = format
        # process the query parameters
        if max is not None:
            
            _query_params.append(('max', max))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/{id}/relatedMedia.{format}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_id_syndicate_format_get(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to show embed code for.")],
        format: Annotated[StrictStr, Field(description="Automatically added")],
        css_class: Annotated[Optional[StrictStr], Field(description="The css class to target for extraction.")] = None,
        strip_styles: Annotated[Optional[StrictBool], Field(description="Remove in-line styles from content.")] = None,
        strip_scripts: Annotated[Optional[StrictBool], Field(description="Remove script tags from content.")] = None,
        strip_images: Annotated[Optional[StrictBool], Field(description="Remove image tags from content.")] = None,
        strip_breaks: Annotated[Optional[StrictBool], Field(description="Remove break tags from content.")] = None,
        strip_classes: Annotated[Optional[StrictBool], Field(description="Remove class attributes from content (except 'syndicate').")] = None,
        font_size: Annotated[Optional[StrictInt], Field(description="Set font size (in points) of p, div, and span tags.")] = None,
        image_float: Annotated[Optional[StrictStr], Field(description="Accepts valid CSS float options, such as 'left' or 'right'. Will inject a style into the content before rendering.")] = None,
        image_margin: Annotated[Optional[StrictStr], Field(description="Accepts 4 CSV values representing pixel sizes of margin similar to CSS. Default format is 'north,east,south,west' - for example '0,10,10,0' would put a 10 pixel margin on the right and bottom sides of an image. Will inject a style into the content before rendering.")] = None,
        autoplay: Annotated[Optional[StrictBool], Field(description="If content is a video, the embeded video will auto play when loaded.")] = None,
        rel: Annotated[Optional[StrictBool], Field(description="If content is a video, related items will be shown at the end of playback.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SyndicateMarshallerWrapped:
        """Get syndicated content for MediaItem

        Get syndicated content.

        :param id: The id of the media to show embed code for. (required)
        :type id: int
        :param format: Automatically added (required)
        :type format: str
        :param css_class: The css class to target for extraction.
        :type css_class: str
        :param strip_styles: Remove in-line styles from content.
        :type strip_styles: bool
        :param strip_scripts: Remove script tags from content.
        :type strip_scripts: bool
        :param strip_images: Remove image tags from content.
        :type strip_images: bool
        :param strip_breaks: Remove break tags from content.
        :type strip_breaks: bool
        :param strip_classes: Remove class attributes from content (except 'syndicate').
        :type strip_classes: bool
        :param font_size: Set font size (in points) of p, div, and span tags.
        :type font_size: int
        :param image_float: Accepts valid CSS float options, such as 'left' or 'right'. Will inject a style into the content before rendering.
        :type image_float: str
        :param image_margin: Accepts 4 CSV values representing pixel sizes of margin similar to CSS. Default format is 'north,east,south,west' - for example '0,10,10,0' would put a 10 pixel margin on the right and bottom sides of an image. Will inject a style into the content before rendering.
        :type image_margin: str
        :param autoplay: If content is a video, the embeded video will auto play when loaded.
        :type autoplay: bool
        :param rel: If content is a video, related items will be shown at the end of playback.
        :type rel: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_syndicate_format_get_serialize(
            id=id,
            format=format,
            css_class=css_class,
            strip_styles=strip_styles,
            strip_scripts=strip_scripts,
            strip_images=strip_images,
            strip_breaks=strip_breaks,
            strip_classes=strip_classes,
            font_size=font_size,
            image_float=image_float,
            image_margin=image_margin,
            autoplay=autoplay,
            rel=rel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SyndicateMarshallerWrapped",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_id_syndicate_format_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to show embed code for.")],
        format: Annotated[StrictStr, Field(description="Automatically added")],
        css_class: Annotated[Optional[StrictStr], Field(description="The css class to target for extraction.")] = None,
        strip_styles: Annotated[Optional[StrictBool], Field(description="Remove in-line styles from content.")] = None,
        strip_scripts: Annotated[Optional[StrictBool], Field(description="Remove script tags from content.")] = None,
        strip_images: Annotated[Optional[StrictBool], Field(description="Remove image tags from content.")] = None,
        strip_breaks: Annotated[Optional[StrictBool], Field(description="Remove break tags from content.")] = None,
        strip_classes: Annotated[Optional[StrictBool], Field(description="Remove class attributes from content (except 'syndicate').")] = None,
        font_size: Annotated[Optional[StrictInt], Field(description="Set font size (in points) of p, div, and span tags.")] = None,
        image_float: Annotated[Optional[StrictStr], Field(description="Accepts valid CSS float options, such as 'left' or 'right'. Will inject a style into the content before rendering.")] = None,
        image_margin: Annotated[Optional[StrictStr], Field(description="Accepts 4 CSV values representing pixel sizes of margin similar to CSS. Default format is 'north,east,south,west' - for example '0,10,10,0' would put a 10 pixel margin on the right and bottom sides of an image. Will inject a style into the content before rendering.")] = None,
        autoplay: Annotated[Optional[StrictBool], Field(description="If content is a video, the embeded video will auto play when loaded.")] = None,
        rel: Annotated[Optional[StrictBool], Field(description="If content is a video, related items will be shown at the end of playback.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SyndicateMarshallerWrapped]:
        """Get syndicated content for MediaItem

        Get syndicated content.

        :param id: The id of the media to show embed code for. (required)
        :type id: int
        :param format: Automatically added (required)
        :type format: str
        :param css_class: The css class to target for extraction.
        :type css_class: str
        :param strip_styles: Remove in-line styles from content.
        :type strip_styles: bool
        :param strip_scripts: Remove script tags from content.
        :type strip_scripts: bool
        :param strip_images: Remove image tags from content.
        :type strip_images: bool
        :param strip_breaks: Remove break tags from content.
        :type strip_breaks: bool
        :param strip_classes: Remove class attributes from content (except 'syndicate').
        :type strip_classes: bool
        :param font_size: Set font size (in points) of p, div, and span tags.
        :type font_size: int
        :param image_float: Accepts valid CSS float options, such as 'left' or 'right'. Will inject a style into the content before rendering.
        :type image_float: str
        :param image_margin: Accepts 4 CSV values representing pixel sizes of margin similar to CSS. Default format is 'north,east,south,west' - for example '0,10,10,0' would put a 10 pixel margin on the right and bottom sides of an image. Will inject a style into the content before rendering.
        :type image_margin: str
        :param autoplay: If content is a video, the embeded video will auto play when loaded.
        :type autoplay: bool
        :param rel: If content is a video, related items will be shown at the end of playback.
        :type rel: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_syndicate_format_get_serialize(
            id=id,
            format=format,
            css_class=css_class,
            strip_styles=strip_styles,
            strip_scripts=strip_scripts,
            strip_images=strip_images,
            strip_breaks=strip_breaks,
            strip_classes=strip_classes,
            font_size=font_size,
            image_float=image_float,
            image_margin=image_margin,
            autoplay=autoplay,
            rel=rel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SyndicateMarshallerWrapped",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_id_syndicate_format_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to show embed code for.")],
        format: Annotated[StrictStr, Field(description="Automatically added")],
        css_class: Annotated[Optional[StrictStr], Field(description="The css class to target for extraction.")] = None,
        strip_styles: Annotated[Optional[StrictBool], Field(description="Remove in-line styles from content.")] = None,
        strip_scripts: Annotated[Optional[StrictBool], Field(description="Remove script tags from content.")] = None,
        strip_images: Annotated[Optional[StrictBool], Field(description="Remove image tags from content.")] = None,
        strip_breaks: Annotated[Optional[StrictBool], Field(description="Remove break tags from content.")] = None,
        strip_classes: Annotated[Optional[StrictBool], Field(description="Remove class attributes from content (except 'syndicate').")] = None,
        font_size: Annotated[Optional[StrictInt], Field(description="Set font size (in points) of p, div, and span tags.")] = None,
        image_float: Annotated[Optional[StrictStr], Field(description="Accepts valid CSS float options, such as 'left' or 'right'. Will inject a style into the content before rendering.")] = None,
        image_margin: Annotated[Optional[StrictStr], Field(description="Accepts 4 CSV values representing pixel sizes of margin similar to CSS. Default format is 'north,east,south,west' - for example '0,10,10,0' would put a 10 pixel margin on the right and bottom sides of an image. Will inject a style into the content before rendering.")] = None,
        autoplay: Annotated[Optional[StrictBool], Field(description="If content is a video, the embeded video will auto play when loaded.")] = None,
        rel: Annotated[Optional[StrictBool], Field(description="If content is a video, related items will be shown at the end of playback.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get syndicated content for MediaItem

        Get syndicated content.

        :param id: The id of the media to show embed code for. (required)
        :type id: int
        :param format: Automatically added (required)
        :type format: str
        :param css_class: The css class to target for extraction.
        :type css_class: str
        :param strip_styles: Remove in-line styles from content.
        :type strip_styles: bool
        :param strip_scripts: Remove script tags from content.
        :type strip_scripts: bool
        :param strip_images: Remove image tags from content.
        :type strip_images: bool
        :param strip_breaks: Remove break tags from content.
        :type strip_breaks: bool
        :param strip_classes: Remove class attributes from content (except 'syndicate').
        :type strip_classes: bool
        :param font_size: Set font size (in points) of p, div, and span tags.
        :type font_size: int
        :param image_float: Accepts valid CSS float options, such as 'left' or 'right'. Will inject a style into the content before rendering.
        :type image_float: str
        :param image_margin: Accepts 4 CSV values representing pixel sizes of margin similar to CSS. Default format is 'north,east,south,west' - for example '0,10,10,0' would put a 10 pixel margin on the right and bottom sides of an image. Will inject a style into the content before rendering.
        :type image_margin: str
        :param autoplay: If content is a video, the embeded video will auto play when loaded.
        :type autoplay: bool
        :param rel: If content is a video, related items will be shown at the end of playback.
        :type rel: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_syndicate_format_get_serialize(
            id=id,
            format=format,
            css_class=css_class,
            strip_styles=strip_styles,
            strip_scripts=strip_scripts,
            strip_images=strip_images,
            strip_breaks=strip_breaks,
            strip_classes=strip_classes,
            font_size=font_size,
            image_float=image_float,
            image_margin=image_margin,
            autoplay=autoplay,
            rel=rel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SyndicateMarshallerWrapped",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_id_syndicate_format_get_serialize(
        self,
        id,
        format,
        css_class,
        strip_styles,
        strip_scripts,
        strip_images,
        strip_breaks,
        strip_classes,
        font_size,
        image_float,
        image_margin,
        autoplay,
        rel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if format is not None:
            _path_params['format'] = format
        # process the query parameters
        if css_class is not None:
            
            _query_params.append(('cssClass', css_class))
            
        if strip_styles is not None:
            
            _query_params.append(('stripStyles', strip_styles))
            
        if strip_scripts is not None:
            
            _query_params.append(('stripScripts', strip_scripts))
            
        if strip_images is not None:
            
            _query_params.append(('stripImages', strip_images))
            
        if strip_breaks is not None:
            
            _query_params.append(('stripBreaks', strip_breaks))
            
        if strip_classes is not None:
            
            _query_params.append(('stripClasses', strip_classes))
            
        if font_size is not None:
            
            _query_params.append(('font-size', font_size))
            
        if image_float is not None:
            
            _query_params.append(('imageFloat', image_float))
            
        if image_margin is not None:
            
            _query_params.append(('imageMargin', image_margin))
            
        if autoplay is not None:
            
            _query_params.append(('autoplay', autoplay))
            
        if rel is not None:
            
            _query_params.append(('rel', rel))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/{id}/syndicate.{format}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_id_thumbnail_jpg_get(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to get a thumbnail for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Get JPG thumbnail for MediaItem

        Get the jpg thumbnail of the content item where applicable.

        :param id: The id of the media to get a thumbnail for. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_thumbnail_jpg_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_id_thumbnail_jpg_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to get a thumbnail for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Get JPG thumbnail for MediaItem

        Get the jpg thumbnail of the content item where applicable.

        :param id: The id of the media to get a thumbnail for. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_thumbnail_jpg_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_id_thumbnail_jpg_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The id of the media to get a thumbnail for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get JPG thumbnail for MediaItem

        Get the jpg thumbnail of the content item where applicable.

        :param id: The id of the media to get a thumbnail for. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_thumbnail_jpg_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_id_thumbnail_jpg_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/{id}/thumbnail.jpg',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_id_youtube_meta_data_json_get(
        self,
        id: Annotated[StrictInt, Field(description="The id of the video to show meta data for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ResourcesMediaIdYoutubeMetaDataJsonGet200Response:
        """Get Youtube metadata for MediaItem

        Youtube meta-data for a video item.

        :param id: The id of the video to show meta data for. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_youtube_meta_data_json_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourcesMediaIdYoutubeMetaDataJsonGet200Response",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_id_youtube_meta_data_json_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The id of the video to show meta data for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ResourcesMediaIdYoutubeMetaDataJsonGet200Response]:
        """Get Youtube metadata for MediaItem

        Youtube meta-data for a video item.

        :param id: The id of the video to show meta data for. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_youtube_meta_data_json_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourcesMediaIdYoutubeMetaDataJsonGet200Response",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_id_youtube_meta_data_json_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The id of the video to show meta data for.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Youtube metadata for MediaItem

        Youtube meta-data for a video item.

        :param id: The id of the video to show meta data for. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_id_youtube_meta_data_json_get_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourcesMediaIdYoutubeMetaDataJsonGet200Response",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_id_youtube_meta_data_json_get_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/{id}/youtubeMetaData.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_json_get(
        self,
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The offset of the records set to return for pagination.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="* Set of fields to sort the records by.")] = None,
        order: Annotated[Optional[StrictStr], Field(description="* The ascending or descending order.")] = None,
        media_types: Annotated[Optional[StrictStr], Field(description="Find all media items belonging to the specified media type[s].")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Find all media items containing the provided name, case insensitive.")] = None,
        collection_id: Annotated[Optional[StrictInt], Field(description="Restrict filtering to media items in a specific collection.")] = None,
        name_contains: Annotated[Optional[StrictStr], Field(description="Find all media items containing the partial name, case insensitive.")] = None,
        description_contains: Annotated[Optional[StrictStr], Field(description="Find all media items containing the provided partial description, case insensitive.")] = None,
        source_url: Annotated[Optional[StrictStr], Field(description="Find all media items which have the provided sourceUrl, case insensitive.")] = None,
        source_url_contains: Annotated[Optional[StrictStr], Field(description="Find all media items which contain the provided partial sourceUrl, case insensitive.")] = None,
        custom_thumbnail_url: Annotated[Optional[StrictStr], Field(description="Find all media items which have the provided customThumbnailUrl, case insensitive.")] = None,
        custom_thumbnail_url_contains: Annotated[Optional[StrictStr], Field(description="Find all media items which contain the provided partial customThumbnailUrl, case insensitive.")] = None,
        date_content_authored: Annotated[Optional[date], Field(description="Find all media items authored on the provided day (RFC 3339, time ignored).")] = None,
        date_content_updated: Annotated[Optional[date], Field(description="Find all media items updated on the provided day (RFC 3339, time ignored).")] = None,
        date_content_published: Annotated[Optional[date], Field(description="Find all media items published on the provided day (RFC 3339, time ignored).")] = None,
        date_content_reviewed: Annotated[Optional[date], Field(description="Find all media items reviewed on the provided day (RFC 3339, time ignored).")] = None,
        date_syndication_captured: Annotated[Optional[date], Field(description="Find all media items syndicated on the provided day (RFC 3339, time ignored).")] = None,
        date_syndication_updated: Annotated[Optional[date], Field(description="Find all media items updated through the syndication system on the provided day, (RFC 3339, time ignored).")] = None,
        content_authored_since_date: Annotated[Optional[date], Field(description="Find all media items authored since the provided day (RFC 3339, time ignored).")] = None,
        content_authored_before_date: Annotated[Optional[date], Field(description="Find all media items authored before the provided day (RFC 3339, time ignored).")] = None,
        content_authored_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        content_updated_since_date: Annotated[Optional[date], Field(description="Find all media items updated since the provided day (RFC 3339, time ignored).")] = None,
        content_updated_before_date: Annotated[Optional[date], Field(description="Find all media items updated before the provided day (RFC 3339, time ignored).")] = None,
        content_updated_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items updated between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        content_published_since_date: Annotated[Optional[date], Field(description="Find all media items updated since the provided day (RFC 3339, time ignored).")] = None,
        content_published_before_date: Annotated[Optional[date], Field(description="Find all media items published before the provided day (RFC 3339, time ignored).")] = None,
        content_published_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items published between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        content_reviewed_since_date: Annotated[Optional[date], Field(description="Find all media items reviewed since the provided day (RFC 3339, time ignored).")] = None,
        content_reviewed_before_date: Annotated[Optional[date], Field(description="Find all media items reviewed before the provided day (RFC 3339, time ignored).")] = None,
        content_reviewed_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items reviewed between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        syndication_captured_since_date: Annotated[Optional[date], Field(description="Find all media items authored since the provided day (RFC 3339, time ignored).")] = None,
        syndication_captured_before_date: Annotated[Optional[date], Field(description="Find all media items authored before the provided day (RFC 3339, time ignored).")] = None,
        syndication_captured_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        syndication_updated_since_date: Annotated[Optional[date], Field(description="Find all media items updated since the provided day, (RFC 3339, time ignored).")] = None,
        syndication_updated_before_date: Annotated[Optional[date], Field(description="Find all media items updated before the provided day, (RFC 3339, time ignored).")] = None,
        syndication_updated_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items updated between the provided start and end days, (RFC 3339, comma separated, time ignored).")] = None,
        syndication_visible_since_date: Annotated[Optional[date], Field(description="Find all media items visible since the provided day, (RFC 3339, time ignored).")] = None,
        syndication_visible_before_date: Annotated[Optional[date], Field(description="Find all media items visible before the provided day, (RFC 3339, time ignored).")] = None,
        syndication_visible_in_range: Annotated[Optional[date], Field(description="Find all media items visible between the provided start and end days, (RFC 3339, comma separated, time ignored).")] = None,
        language_id: Annotated[Optional[StrictInt], Field(description="Find all media items written in the language specified by Id.")] = None,
        language_name: Annotated[Optional[StrictStr], Field(description="Find all media items written in the language specified by name, case insensitive.")] = None,
        language_iso_code: Annotated[Optional[StrictStr], Field(description="Find all media items written in the language specified by 639-2 isoCode , case insensitive.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Find all media items which match the provided hash, case insensitive.")] = None,
        hash_contains: Annotated[Optional[StrictStr], Field(description="Find all media items which match the provided partial hash, case insensitive.")] = None,
        source_id: Annotated[Optional[StrictInt], Field(description="Find all media items that belong to the source specified by Id.")] = None,
        source_name: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by name, case insensitive.")] = None,
        source_name_contains: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by partial name, case insensitive.")] = None,
        source_acronym: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by acronym, case insensitive.")] = None,
        source_acronym_contains: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by partial acronym, case insensitive.")] = None,
        tag_ids: Annotated[Optional[StrictStr], Field(description="Find only media items tagged with the specified tag Ids.")] = None,
        restrict_to_set: Annotated[Optional[StrictStr], Field(description="Find only media from within the supplied list of Ids.")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="Find all media items containing the createdBy value.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[MediaItemWrapped]:
        """Get MediaItems

        Media Items Listings

        :param max: The maximum number of records to return
        :type max: int
        :param offset: The offset of the records set to return for pagination.
        :type offset: int
        :param sort: * Set of fields to sort the records by.
        :type sort: str
        :param order: * The ascending or descending order.
        :type order: str
        :param media_types: Find all media items belonging to the specified media type[s].
        :type media_types: str
        :param name: Find all media items containing the provided name, case insensitive.
        :type name: str
        :param collection_id: Restrict filtering to media items in a specific collection.
        :type collection_id: int
        :param name_contains: Find all media items containing the partial name, case insensitive.
        :type name_contains: str
        :param description_contains: Find all media items containing the provided partial description, case insensitive.
        :type description_contains: str
        :param source_url: Find all media items which have the provided sourceUrl, case insensitive.
        :type source_url: str
        :param source_url_contains: Find all media items which contain the provided partial sourceUrl, case insensitive.
        :type source_url_contains: str
        :param custom_thumbnail_url: Find all media items which have the provided customThumbnailUrl, case insensitive.
        :type custom_thumbnail_url: str
        :param custom_thumbnail_url_contains: Find all media items which contain the provided partial customThumbnailUrl, case insensitive.
        :type custom_thumbnail_url_contains: str
        :param date_content_authored: Find all media items authored on the provided day (RFC 3339, time ignored).
        :type date_content_authored: date
        :param date_content_updated: Find all media items updated on the provided day (RFC 3339, time ignored).
        :type date_content_updated: date
        :param date_content_published: Find all media items published on the provided day (RFC 3339, time ignored).
        :type date_content_published: date
        :param date_content_reviewed: Find all media items reviewed on the provided day (RFC 3339, time ignored).
        :type date_content_reviewed: date
        :param date_syndication_captured: Find all media items syndicated on the provided day (RFC 3339, time ignored).
        :type date_syndication_captured: date
        :param date_syndication_updated: Find all media items updated through the syndication system on the provided day, (RFC 3339, time ignored).
        :type date_syndication_updated: date
        :param content_authored_since_date: Find all media items authored since the provided day (RFC 3339, time ignored).
        :type content_authored_since_date: date
        :param content_authored_before_date: Find all media items authored before the provided day (RFC 3339, time ignored).
        :type content_authored_before_date: date
        :param content_authored_in_range: Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_authored_in_range: str
        :param content_updated_since_date: Find all media items updated since the provided day (RFC 3339, time ignored).
        :type content_updated_since_date: date
        :param content_updated_before_date: Find all media items updated before the provided day (RFC 3339, time ignored).
        :type content_updated_before_date: date
        :param content_updated_in_range: Find all media items updated between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_updated_in_range: str
        :param content_published_since_date: Find all media items updated since the provided day (RFC 3339, time ignored).
        :type content_published_since_date: date
        :param content_published_before_date: Find all media items published before the provided day (RFC 3339, time ignored).
        :type content_published_before_date: date
        :param content_published_in_range: Find all media items published between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_published_in_range: str
        :param content_reviewed_since_date: Find all media items reviewed since the provided day (RFC 3339, time ignored).
        :type content_reviewed_since_date: date
        :param content_reviewed_before_date: Find all media items reviewed before the provided day (RFC 3339, time ignored).
        :type content_reviewed_before_date: date
        :param content_reviewed_in_range: Find all media items reviewed between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_reviewed_in_range: str
        :param syndication_captured_since_date: Find all media items authored since the provided day (RFC 3339, time ignored).
        :type syndication_captured_since_date: date
        :param syndication_captured_before_date: Find all media items authored before the provided day (RFC 3339, time ignored).
        :type syndication_captured_before_date: date
        :param syndication_captured_in_range: Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type syndication_captured_in_range: str
        :param syndication_updated_since_date: Find all media items updated since the provided day, (RFC 3339, time ignored).
        :type syndication_updated_since_date: date
        :param syndication_updated_before_date: Find all media items updated before the provided day, (RFC 3339, time ignored).
        :type syndication_updated_before_date: date
        :param syndication_updated_in_range: Find all media items updated between the provided start and end days, (RFC 3339, comma separated, time ignored).
        :type syndication_updated_in_range: str
        :param syndication_visible_since_date: Find all media items visible since the provided day, (RFC 3339, time ignored).
        :type syndication_visible_since_date: date
        :param syndication_visible_before_date: Find all media items visible before the provided day, (RFC 3339, time ignored).
        :type syndication_visible_before_date: date
        :param syndication_visible_in_range: Find all media items visible between the provided start and end days, (RFC 3339, comma separated, time ignored).
        :type syndication_visible_in_range: date
        :param language_id: Find all media items written in the language specified by Id.
        :type language_id: int
        :param language_name: Find all media items written in the language specified by name, case insensitive.
        :type language_name: str
        :param language_iso_code: Find all media items written in the language specified by 639-2 isoCode , case insensitive.
        :type language_iso_code: str
        :param hash: Find all media items which match the provided hash, case insensitive.
        :type hash: str
        :param hash_contains: Find all media items which match the provided partial hash, case insensitive.
        :type hash_contains: str
        :param source_id: Find all media items that belong to the source specified by Id.
        :type source_id: int
        :param source_name: Find all media items that belong to the source specified by name, case insensitive.
        :type source_name: str
        :param source_name_contains: Find all media items that belong to the source specified by partial name, case insensitive.
        :type source_name_contains: str
        :param source_acronym: Find all media items that belong to the source specified by acronym, case insensitive.
        :type source_acronym: str
        :param source_acronym_contains: Find all media items that belong to the source specified by partial acronym, case insensitive.
        :type source_acronym_contains: str
        :param tag_ids: Find only media items tagged with the specified tag Ids.
        :type tag_ids: str
        :param restrict_to_set: Find only media from within the supplied list of Ids.
        :type restrict_to_set: str
        :param created_by: Find all media items containing the createdBy value.
        :type created_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_json_get_serialize(
            max=max,
            offset=offset,
            sort=sort,
            order=order,
            media_types=media_types,
            name=name,
            collection_id=collection_id,
            name_contains=name_contains,
            description_contains=description_contains,
            source_url=source_url,
            source_url_contains=source_url_contains,
            custom_thumbnail_url=custom_thumbnail_url,
            custom_thumbnail_url_contains=custom_thumbnail_url_contains,
            date_content_authored=date_content_authored,
            date_content_updated=date_content_updated,
            date_content_published=date_content_published,
            date_content_reviewed=date_content_reviewed,
            date_syndication_captured=date_syndication_captured,
            date_syndication_updated=date_syndication_updated,
            content_authored_since_date=content_authored_since_date,
            content_authored_before_date=content_authored_before_date,
            content_authored_in_range=content_authored_in_range,
            content_updated_since_date=content_updated_since_date,
            content_updated_before_date=content_updated_before_date,
            content_updated_in_range=content_updated_in_range,
            content_published_since_date=content_published_since_date,
            content_published_before_date=content_published_before_date,
            content_published_in_range=content_published_in_range,
            content_reviewed_since_date=content_reviewed_since_date,
            content_reviewed_before_date=content_reviewed_before_date,
            content_reviewed_in_range=content_reviewed_in_range,
            syndication_captured_since_date=syndication_captured_since_date,
            syndication_captured_before_date=syndication_captured_before_date,
            syndication_captured_in_range=syndication_captured_in_range,
            syndication_updated_since_date=syndication_updated_since_date,
            syndication_updated_before_date=syndication_updated_before_date,
            syndication_updated_in_range=syndication_updated_in_range,
            syndication_visible_since_date=syndication_visible_since_date,
            syndication_visible_before_date=syndication_visible_before_date,
            syndication_visible_in_range=syndication_visible_in_range,
            language_id=language_id,
            language_name=language_name,
            language_iso_code=language_iso_code,
            hash=hash,
            hash_contains=hash_contains,
            source_id=source_id,
            source_name=source_name,
            source_name_contains=source_name_contains,
            source_acronym=source_acronym,
            source_acronym_contains=source_acronym_contains,
            tag_ids=tag_ids,
            restrict_to_set=restrict_to_set,
            created_by=created_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_json_get_with_http_info(
        self,
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The offset of the records set to return for pagination.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="* Set of fields to sort the records by.")] = None,
        order: Annotated[Optional[StrictStr], Field(description="* The ascending or descending order.")] = None,
        media_types: Annotated[Optional[StrictStr], Field(description="Find all media items belonging to the specified media type[s].")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Find all media items containing the provided name, case insensitive.")] = None,
        collection_id: Annotated[Optional[StrictInt], Field(description="Restrict filtering to media items in a specific collection.")] = None,
        name_contains: Annotated[Optional[StrictStr], Field(description="Find all media items containing the partial name, case insensitive.")] = None,
        description_contains: Annotated[Optional[StrictStr], Field(description="Find all media items containing the provided partial description, case insensitive.")] = None,
        source_url: Annotated[Optional[StrictStr], Field(description="Find all media items which have the provided sourceUrl, case insensitive.")] = None,
        source_url_contains: Annotated[Optional[StrictStr], Field(description="Find all media items which contain the provided partial sourceUrl, case insensitive.")] = None,
        custom_thumbnail_url: Annotated[Optional[StrictStr], Field(description="Find all media items which have the provided customThumbnailUrl, case insensitive.")] = None,
        custom_thumbnail_url_contains: Annotated[Optional[StrictStr], Field(description="Find all media items which contain the provided partial customThumbnailUrl, case insensitive.")] = None,
        date_content_authored: Annotated[Optional[date], Field(description="Find all media items authored on the provided day (RFC 3339, time ignored).")] = None,
        date_content_updated: Annotated[Optional[date], Field(description="Find all media items updated on the provided day (RFC 3339, time ignored).")] = None,
        date_content_published: Annotated[Optional[date], Field(description="Find all media items published on the provided day (RFC 3339, time ignored).")] = None,
        date_content_reviewed: Annotated[Optional[date], Field(description="Find all media items reviewed on the provided day (RFC 3339, time ignored).")] = None,
        date_syndication_captured: Annotated[Optional[date], Field(description="Find all media items syndicated on the provided day (RFC 3339, time ignored).")] = None,
        date_syndication_updated: Annotated[Optional[date], Field(description="Find all media items updated through the syndication system on the provided day, (RFC 3339, time ignored).")] = None,
        content_authored_since_date: Annotated[Optional[date], Field(description="Find all media items authored since the provided day (RFC 3339, time ignored).")] = None,
        content_authored_before_date: Annotated[Optional[date], Field(description="Find all media items authored before the provided day (RFC 3339, time ignored).")] = None,
        content_authored_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        content_updated_since_date: Annotated[Optional[date], Field(description="Find all media items updated since the provided day (RFC 3339, time ignored).")] = None,
        content_updated_before_date: Annotated[Optional[date], Field(description="Find all media items updated before the provided day (RFC 3339, time ignored).")] = None,
        content_updated_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items updated between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        content_published_since_date: Annotated[Optional[date], Field(description="Find all media items updated since the provided day (RFC 3339, time ignored).")] = None,
        content_published_before_date: Annotated[Optional[date], Field(description="Find all media items published before the provided day (RFC 3339, time ignored).")] = None,
        content_published_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items published between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        content_reviewed_since_date: Annotated[Optional[date], Field(description="Find all media items reviewed since the provided day (RFC 3339, time ignored).")] = None,
        content_reviewed_before_date: Annotated[Optional[date], Field(description="Find all media items reviewed before the provided day (RFC 3339, time ignored).")] = None,
        content_reviewed_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items reviewed between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        syndication_captured_since_date: Annotated[Optional[date], Field(description="Find all media items authored since the provided day (RFC 3339, time ignored).")] = None,
        syndication_captured_before_date: Annotated[Optional[date], Field(description="Find all media items authored before the provided day (RFC 3339, time ignored).")] = None,
        syndication_captured_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        syndication_updated_since_date: Annotated[Optional[date], Field(description="Find all media items updated since the provided day, (RFC 3339, time ignored).")] = None,
        syndication_updated_before_date: Annotated[Optional[date], Field(description="Find all media items updated before the provided day, (RFC 3339, time ignored).")] = None,
        syndication_updated_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items updated between the provided start and end days, (RFC 3339, comma separated, time ignored).")] = None,
        syndication_visible_since_date: Annotated[Optional[date], Field(description="Find all media items visible since the provided day, (RFC 3339, time ignored).")] = None,
        syndication_visible_before_date: Annotated[Optional[date], Field(description="Find all media items visible before the provided day, (RFC 3339, time ignored).")] = None,
        syndication_visible_in_range: Annotated[Optional[date], Field(description="Find all media items visible between the provided start and end days, (RFC 3339, comma separated, time ignored).")] = None,
        language_id: Annotated[Optional[StrictInt], Field(description="Find all media items written in the language specified by Id.")] = None,
        language_name: Annotated[Optional[StrictStr], Field(description="Find all media items written in the language specified by name, case insensitive.")] = None,
        language_iso_code: Annotated[Optional[StrictStr], Field(description="Find all media items written in the language specified by 639-2 isoCode , case insensitive.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Find all media items which match the provided hash, case insensitive.")] = None,
        hash_contains: Annotated[Optional[StrictStr], Field(description="Find all media items which match the provided partial hash, case insensitive.")] = None,
        source_id: Annotated[Optional[StrictInt], Field(description="Find all media items that belong to the source specified by Id.")] = None,
        source_name: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by name, case insensitive.")] = None,
        source_name_contains: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by partial name, case insensitive.")] = None,
        source_acronym: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by acronym, case insensitive.")] = None,
        source_acronym_contains: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by partial acronym, case insensitive.")] = None,
        tag_ids: Annotated[Optional[StrictStr], Field(description="Find only media items tagged with the specified tag Ids.")] = None,
        restrict_to_set: Annotated[Optional[StrictStr], Field(description="Find only media from within the supplied list of Ids.")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="Find all media items containing the createdBy value.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[MediaItemWrapped]]:
        """Get MediaItems

        Media Items Listings

        :param max: The maximum number of records to return
        :type max: int
        :param offset: The offset of the records set to return for pagination.
        :type offset: int
        :param sort: * Set of fields to sort the records by.
        :type sort: str
        :param order: * The ascending or descending order.
        :type order: str
        :param media_types: Find all media items belonging to the specified media type[s].
        :type media_types: str
        :param name: Find all media items containing the provided name, case insensitive.
        :type name: str
        :param collection_id: Restrict filtering to media items in a specific collection.
        :type collection_id: int
        :param name_contains: Find all media items containing the partial name, case insensitive.
        :type name_contains: str
        :param description_contains: Find all media items containing the provided partial description, case insensitive.
        :type description_contains: str
        :param source_url: Find all media items which have the provided sourceUrl, case insensitive.
        :type source_url: str
        :param source_url_contains: Find all media items which contain the provided partial sourceUrl, case insensitive.
        :type source_url_contains: str
        :param custom_thumbnail_url: Find all media items which have the provided customThumbnailUrl, case insensitive.
        :type custom_thumbnail_url: str
        :param custom_thumbnail_url_contains: Find all media items which contain the provided partial customThumbnailUrl, case insensitive.
        :type custom_thumbnail_url_contains: str
        :param date_content_authored: Find all media items authored on the provided day (RFC 3339, time ignored).
        :type date_content_authored: date
        :param date_content_updated: Find all media items updated on the provided day (RFC 3339, time ignored).
        :type date_content_updated: date
        :param date_content_published: Find all media items published on the provided day (RFC 3339, time ignored).
        :type date_content_published: date
        :param date_content_reviewed: Find all media items reviewed on the provided day (RFC 3339, time ignored).
        :type date_content_reviewed: date
        :param date_syndication_captured: Find all media items syndicated on the provided day (RFC 3339, time ignored).
        :type date_syndication_captured: date
        :param date_syndication_updated: Find all media items updated through the syndication system on the provided day, (RFC 3339, time ignored).
        :type date_syndication_updated: date
        :param content_authored_since_date: Find all media items authored since the provided day (RFC 3339, time ignored).
        :type content_authored_since_date: date
        :param content_authored_before_date: Find all media items authored before the provided day (RFC 3339, time ignored).
        :type content_authored_before_date: date
        :param content_authored_in_range: Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_authored_in_range: str
        :param content_updated_since_date: Find all media items updated since the provided day (RFC 3339, time ignored).
        :type content_updated_since_date: date
        :param content_updated_before_date: Find all media items updated before the provided day (RFC 3339, time ignored).
        :type content_updated_before_date: date
        :param content_updated_in_range: Find all media items updated between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_updated_in_range: str
        :param content_published_since_date: Find all media items updated since the provided day (RFC 3339, time ignored).
        :type content_published_since_date: date
        :param content_published_before_date: Find all media items published before the provided day (RFC 3339, time ignored).
        :type content_published_before_date: date
        :param content_published_in_range: Find all media items published between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_published_in_range: str
        :param content_reviewed_since_date: Find all media items reviewed since the provided day (RFC 3339, time ignored).
        :type content_reviewed_since_date: date
        :param content_reviewed_before_date: Find all media items reviewed before the provided day (RFC 3339, time ignored).
        :type content_reviewed_before_date: date
        :param content_reviewed_in_range: Find all media items reviewed between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_reviewed_in_range: str
        :param syndication_captured_since_date: Find all media items authored since the provided day (RFC 3339, time ignored).
        :type syndication_captured_since_date: date
        :param syndication_captured_before_date: Find all media items authored before the provided day (RFC 3339, time ignored).
        :type syndication_captured_before_date: date
        :param syndication_captured_in_range: Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type syndication_captured_in_range: str
        :param syndication_updated_since_date: Find all media items updated since the provided day, (RFC 3339, time ignored).
        :type syndication_updated_since_date: date
        :param syndication_updated_before_date: Find all media items updated before the provided day, (RFC 3339, time ignored).
        :type syndication_updated_before_date: date
        :param syndication_updated_in_range: Find all media items updated between the provided start and end days, (RFC 3339, comma separated, time ignored).
        :type syndication_updated_in_range: str
        :param syndication_visible_since_date: Find all media items visible since the provided day, (RFC 3339, time ignored).
        :type syndication_visible_since_date: date
        :param syndication_visible_before_date: Find all media items visible before the provided day, (RFC 3339, time ignored).
        :type syndication_visible_before_date: date
        :param syndication_visible_in_range: Find all media items visible between the provided start and end days, (RFC 3339, comma separated, time ignored).
        :type syndication_visible_in_range: date
        :param language_id: Find all media items written in the language specified by Id.
        :type language_id: int
        :param language_name: Find all media items written in the language specified by name, case insensitive.
        :type language_name: str
        :param language_iso_code: Find all media items written in the language specified by 639-2 isoCode , case insensitive.
        :type language_iso_code: str
        :param hash: Find all media items which match the provided hash, case insensitive.
        :type hash: str
        :param hash_contains: Find all media items which match the provided partial hash, case insensitive.
        :type hash_contains: str
        :param source_id: Find all media items that belong to the source specified by Id.
        :type source_id: int
        :param source_name: Find all media items that belong to the source specified by name, case insensitive.
        :type source_name: str
        :param source_name_contains: Find all media items that belong to the source specified by partial name, case insensitive.
        :type source_name_contains: str
        :param source_acronym: Find all media items that belong to the source specified by acronym, case insensitive.
        :type source_acronym: str
        :param source_acronym_contains: Find all media items that belong to the source specified by partial acronym, case insensitive.
        :type source_acronym_contains: str
        :param tag_ids: Find only media items tagged with the specified tag Ids.
        :type tag_ids: str
        :param restrict_to_set: Find only media from within the supplied list of Ids.
        :type restrict_to_set: str
        :param created_by: Find all media items containing the createdBy value.
        :type created_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_json_get_serialize(
            max=max,
            offset=offset,
            sort=sort,
            order=order,
            media_types=media_types,
            name=name,
            collection_id=collection_id,
            name_contains=name_contains,
            description_contains=description_contains,
            source_url=source_url,
            source_url_contains=source_url_contains,
            custom_thumbnail_url=custom_thumbnail_url,
            custom_thumbnail_url_contains=custom_thumbnail_url_contains,
            date_content_authored=date_content_authored,
            date_content_updated=date_content_updated,
            date_content_published=date_content_published,
            date_content_reviewed=date_content_reviewed,
            date_syndication_captured=date_syndication_captured,
            date_syndication_updated=date_syndication_updated,
            content_authored_since_date=content_authored_since_date,
            content_authored_before_date=content_authored_before_date,
            content_authored_in_range=content_authored_in_range,
            content_updated_since_date=content_updated_since_date,
            content_updated_before_date=content_updated_before_date,
            content_updated_in_range=content_updated_in_range,
            content_published_since_date=content_published_since_date,
            content_published_before_date=content_published_before_date,
            content_published_in_range=content_published_in_range,
            content_reviewed_since_date=content_reviewed_since_date,
            content_reviewed_before_date=content_reviewed_before_date,
            content_reviewed_in_range=content_reviewed_in_range,
            syndication_captured_since_date=syndication_captured_since_date,
            syndication_captured_before_date=syndication_captured_before_date,
            syndication_captured_in_range=syndication_captured_in_range,
            syndication_updated_since_date=syndication_updated_since_date,
            syndication_updated_before_date=syndication_updated_before_date,
            syndication_updated_in_range=syndication_updated_in_range,
            syndication_visible_since_date=syndication_visible_since_date,
            syndication_visible_before_date=syndication_visible_before_date,
            syndication_visible_in_range=syndication_visible_in_range,
            language_id=language_id,
            language_name=language_name,
            language_iso_code=language_iso_code,
            hash=hash,
            hash_contains=hash_contains,
            source_id=source_id,
            source_name=source_name,
            source_name_contains=source_name_contains,
            source_acronym=source_acronym,
            source_acronym_contains=source_acronym_contains,
            tag_ids=tag_ids,
            restrict_to_set=restrict_to_set,
            created_by=created_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_json_get_without_preload_content(
        self,
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The offset of the records set to return for pagination.")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="* Set of fields to sort the records by.")] = None,
        order: Annotated[Optional[StrictStr], Field(description="* The ascending or descending order.")] = None,
        media_types: Annotated[Optional[StrictStr], Field(description="Find all media items belonging to the specified media type[s].")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Find all media items containing the provided name, case insensitive.")] = None,
        collection_id: Annotated[Optional[StrictInt], Field(description="Restrict filtering to media items in a specific collection.")] = None,
        name_contains: Annotated[Optional[StrictStr], Field(description="Find all media items containing the partial name, case insensitive.")] = None,
        description_contains: Annotated[Optional[StrictStr], Field(description="Find all media items containing the provided partial description, case insensitive.")] = None,
        source_url: Annotated[Optional[StrictStr], Field(description="Find all media items which have the provided sourceUrl, case insensitive.")] = None,
        source_url_contains: Annotated[Optional[StrictStr], Field(description="Find all media items which contain the provided partial sourceUrl, case insensitive.")] = None,
        custom_thumbnail_url: Annotated[Optional[StrictStr], Field(description="Find all media items which have the provided customThumbnailUrl, case insensitive.")] = None,
        custom_thumbnail_url_contains: Annotated[Optional[StrictStr], Field(description="Find all media items which contain the provided partial customThumbnailUrl, case insensitive.")] = None,
        date_content_authored: Annotated[Optional[date], Field(description="Find all media items authored on the provided day (RFC 3339, time ignored).")] = None,
        date_content_updated: Annotated[Optional[date], Field(description="Find all media items updated on the provided day (RFC 3339, time ignored).")] = None,
        date_content_published: Annotated[Optional[date], Field(description="Find all media items published on the provided day (RFC 3339, time ignored).")] = None,
        date_content_reviewed: Annotated[Optional[date], Field(description="Find all media items reviewed on the provided day (RFC 3339, time ignored).")] = None,
        date_syndication_captured: Annotated[Optional[date], Field(description="Find all media items syndicated on the provided day (RFC 3339, time ignored).")] = None,
        date_syndication_updated: Annotated[Optional[date], Field(description="Find all media items updated through the syndication system on the provided day, (RFC 3339, time ignored).")] = None,
        content_authored_since_date: Annotated[Optional[date], Field(description="Find all media items authored since the provided day (RFC 3339, time ignored).")] = None,
        content_authored_before_date: Annotated[Optional[date], Field(description="Find all media items authored before the provided day (RFC 3339, time ignored).")] = None,
        content_authored_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        content_updated_since_date: Annotated[Optional[date], Field(description="Find all media items updated since the provided day (RFC 3339, time ignored).")] = None,
        content_updated_before_date: Annotated[Optional[date], Field(description="Find all media items updated before the provided day (RFC 3339, time ignored).")] = None,
        content_updated_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items updated between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        content_published_since_date: Annotated[Optional[date], Field(description="Find all media items updated since the provided day (RFC 3339, time ignored).")] = None,
        content_published_before_date: Annotated[Optional[date], Field(description="Find all media items published before the provided day (RFC 3339, time ignored).")] = None,
        content_published_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items published between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        content_reviewed_since_date: Annotated[Optional[date], Field(description="Find all media items reviewed since the provided day (RFC 3339, time ignored).")] = None,
        content_reviewed_before_date: Annotated[Optional[date], Field(description="Find all media items reviewed before the provided day (RFC 3339, time ignored).")] = None,
        content_reviewed_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items reviewed between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        syndication_captured_since_date: Annotated[Optional[date], Field(description="Find all media items authored since the provided day (RFC 3339, time ignored).")] = None,
        syndication_captured_before_date: Annotated[Optional[date], Field(description="Find all media items authored before the provided day (RFC 3339, time ignored).")] = None,
        syndication_captured_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).")] = None,
        syndication_updated_since_date: Annotated[Optional[date], Field(description="Find all media items updated since the provided day, (RFC 3339, time ignored).")] = None,
        syndication_updated_before_date: Annotated[Optional[date], Field(description="Find all media items updated before the provided day, (RFC 3339, time ignored).")] = None,
        syndication_updated_in_range: Annotated[Optional[StrictStr], Field(description="Find all media items updated between the provided start and end days, (RFC 3339, comma separated, time ignored).")] = None,
        syndication_visible_since_date: Annotated[Optional[date], Field(description="Find all media items visible since the provided day, (RFC 3339, time ignored).")] = None,
        syndication_visible_before_date: Annotated[Optional[date], Field(description="Find all media items visible before the provided day, (RFC 3339, time ignored).")] = None,
        syndication_visible_in_range: Annotated[Optional[date], Field(description="Find all media items visible between the provided start and end days, (RFC 3339, comma separated, time ignored).")] = None,
        language_id: Annotated[Optional[StrictInt], Field(description="Find all media items written in the language specified by Id.")] = None,
        language_name: Annotated[Optional[StrictStr], Field(description="Find all media items written in the language specified by name, case insensitive.")] = None,
        language_iso_code: Annotated[Optional[StrictStr], Field(description="Find all media items written in the language specified by 639-2 isoCode , case insensitive.")] = None,
        hash: Annotated[Optional[StrictStr], Field(description="Find all media items which match the provided hash, case insensitive.")] = None,
        hash_contains: Annotated[Optional[StrictStr], Field(description="Find all media items which match the provided partial hash, case insensitive.")] = None,
        source_id: Annotated[Optional[StrictInt], Field(description="Find all media items that belong to the source specified by Id.")] = None,
        source_name: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by name, case insensitive.")] = None,
        source_name_contains: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by partial name, case insensitive.")] = None,
        source_acronym: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by acronym, case insensitive.")] = None,
        source_acronym_contains: Annotated[Optional[StrictStr], Field(description="Find all media items that belong to the source specified by partial acronym, case insensitive.")] = None,
        tag_ids: Annotated[Optional[StrictStr], Field(description="Find only media items tagged with the specified tag Ids.")] = None,
        restrict_to_set: Annotated[Optional[StrictStr], Field(description="Find only media from within the supplied list of Ids.")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="Find all media items containing the createdBy value.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get MediaItems

        Media Items Listings

        :param max: The maximum number of records to return
        :type max: int
        :param offset: The offset of the records set to return for pagination.
        :type offset: int
        :param sort: * Set of fields to sort the records by.
        :type sort: str
        :param order: * The ascending or descending order.
        :type order: str
        :param media_types: Find all media items belonging to the specified media type[s].
        :type media_types: str
        :param name: Find all media items containing the provided name, case insensitive.
        :type name: str
        :param collection_id: Restrict filtering to media items in a specific collection.
        :type collection_id: int
        :param name_contains: Find all media items containing the partial name, case insensitive.
        :type name_contains: str
        :param description_contains: Find all media items containing the provided partial description, case insensitive.
        :type description_contains: str
        :param source_url: Find all media items which have the provided sourceUrl, case insensitive.
        :type source_url: str
        :param source_url_contains: Find all media items which contain the provided partial sourceUrl, case insensitive.
        :type source_url_contains: str
        :param custom_thumbnail_url: Find all media items which have the provided customThumbnailUrl, case insensitive.
        :type custom_thumbnail_url: str
        :param custom_thumbnail_url_contains: Find all media items which contain the provided partial customThumbnailUrl, case insensitive.
        :type custom_thumbnail_url_contains: str
        :param date_content_authored: Find all media items authored on the provided day (RFC 3339, time ignored).
        :type date_content_authored: date
        :param date_content_updated: Find all media items updated on the provided day (RFC 3339, time ignored).
        :type date_content_updated: date
        :param date_content_published: Find all media items published on the provided day (RFC 3339, time ignored).
        :type date_content_published: date
        :param date_content_reviewed: Find all media items reviewed on the provided day (RFC 3339, time ignored).
        :type date_content_reviewed: date
        :param date_syndication_captured: Find all media items syndicated on the provided day (RFC 3339, time ignored).
        :type date_syndication_captured: date
        :param date_syndication_updated: Find all media items updated through the syndication system on the provided day, (RFC 3339, time ignored).
        :type date_syndication_updated: date
        :param content_authored_since_date: Find all media items authored since the provided day (RFC 3339, time ignored).
        :type content_authored_since_date: date
        :param content_authored_before_date: Find all media items authored before the provided day (RFC 3339, time ignored).
        :type content_authored_before_date: date
        :param content_authored_in_range: Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_authored_in_range: str
        :param content_updated_since_date: Find all media items updated since the provided day (RFC 3339, time ignored).
        :type content_updated_since_date: date
        :param content_updated_before_date: Find all media items updated before the provided day (RFC 3339, time ignored).
        :type content_updated_before_date: date
        :param content_updated_in_range: Find all media items updated between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_updated_in_range: str
        :param content_published_since_date: Find all media items updated since the provided day (RFC 3339, time ignored).
        :type content_published_since_date: date
        :param content_published_before_date: Find all media items published before the provided day (RFC 3339, time ignored).
        :type content_published_before_date: date
        :param content_published_in_range: Find all media items published between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_published_in_range: str
        :param content_reviewed_since_date: Find all media items reviewed since the provided day (RFC 3339, time ignored).
        :type content_reviewed_since_date: date
        :param content_reviewed_before_date: Find all media items reviewed before the provided day (RFC 3339, time ignored).
        :type content_reviewed_before_date: date
        :param content_reviewed_in_range: Find all media items reviewed between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type content_reviewed_in_range: str
        :param syndication_captured_since_date: Find all media items authored since the provided day (RFC 3339, time ignored).
        :type syndication_captured_since_date: date
        :param syndication_captured_before_date: Find all media items authored before the provided day (RFC 3339, time ignored).
        :type syndication_captured_before_date: date
        :param syndication_captured_in_range: Find all media items authored between the provided start and end days (RFC 3339, comma separated, time ignored).
        :type syndication_captured_in_range: str
        :param syndication_updated_since_date: Find all media items updated since the provided day, (RFC 3339, time ignored).
        :type syndication_updated_since_date: date
        :param syndication_updated_before_date: Find all media items updated before the provided day, (RFC 3339, time ignored).
        :type syndication_updated_before_date: date
        :param syndication_updated_in_range: Find all media items updated between the provided start and end days, (RFC 3339, comma separated, time ignored).
        :type syndication_updated_in_range: str
        :param syndication_visible_since_date: Find all media items visible since the provided day, (RFC 3339, time ignored).
        :type syndication_visible_since_date: date
        :param syndication_visible_before_date: Find all media items visible before the provided day, (RFC 3339, time ignored).
        :type syndication_visible_before_date: date
        :param syndication_visible_in_range: Find all media items visible between the provided start and end days, (RFC 3339, comma separated, time ignored).
        :type syndication_visible_in_range: date
        :param language_id: Find all media items written in the language specified by Id.
        :type language_id: int
        :param language_name: Find all media items written in the language specified by name, case insensitive.
        :type language_name: str
        :param language_iso_code: Find all media items written in the language specified by 639-2 isoCode , case insensitive.
        :type language_iso_code: str
        :param hash: Find all media items which match the provided hash, case insensitive.
        :type hash: str
        :param hash_contains: Find all media items which match the provided partial hash, case insensitive.
        :type hash_contains: str
        :param source_id: Find all media items that belong to the source specified by Id.
        :type source_id: int
        :param source_name: Find all media items that belong to the source specified by name, case insensitive.
        :type source_name: str
        :param source_name_contains: Find all media items that belong to the source specified by partial name, case insensitive.
        :type source_name_contains: str
        :param source_acronym: Find all media items that belong to the source specified by acronym, case insensitive.
        :type source_acronym: str
        :param source_acronym_contains: Find all media items that belong to the source specified by partial acronym, case insensitive.
        :type source_acronym_contains: str
        :param tag_ids: Find only media items tagged with the specified tag Ids.
        :type tag_ids: str
        :param restrict_to_set: Find only media from within the supplied list of Ids.
        :type restrict_to_set: str
        :param created_by: Find all media items containing the createdBy value.
        :type created_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_json_get_serialize(
            max=max,
            offset=offset,
            sort=sort,
            order=order,
            media_types=media_types,
            name=name,
            collection_id=collection_id,
            name_contains=name_contains,
            description_contains=description_contains,
            source_url=source_url,
            source_url_contains=source_url_contains,
            custom_thumbnail_url=custom_thumbnail_url,
            custom_thumbnail_url_contains=custom_thumbnail_url_contains,
            date_content_authored=date_content_authored,
            date_content_updated=date_content_updated,
            date_content_published=date_content_published,
            date_content_reviewed=date_content_reviewed,
            date_syndication_captured=date_syndication_captured,
            date_syndication_updated=date_syndication_updated,
            content_authored_since_date=content_authored_since_date,
            content_authored_before_date=content_authored_before_date,
            content_authored_in_range=content_authored_in_range,
            content_updated_since_date=content_updated_since_date,
            content_updated_before_date=content_updated_before_date,
            content_updated_in_range=content_updated_in_range,
            content_published_since_date=content_published_since_date,
            content_published_before_date=content_published_before_date,
            content_published_in_range=content_published_in_range,
            content_reviewed_since_date=content_reviewed_since_date,
            content_reviewed_before_date=content_reviewed_before_date,
            content_reviewed_in_range=content_reviewed_in_range,
            syndication_captured_since_date=syndication_captured_since_date,
            syndication_captured_before_date=syndication_captured_before_date,
            syndication_captured_in_range=syndication_captured_in_range,
            syndication_updated_since_date=syndication_updated_since_date,
            syndication_updated_before_date=syndication_updated_before_date,
            syndication_updated_in_range=syndication_updated_in_range,
            syndication_visible_since_date=syndication_visible_since_date,
            syndication_visible_before_date=syndication_visible_before_date,
            syndication_visible_in_range=syndication_visible_in_range,
            language_id=language_id,
            language_name=language_name,
            language_iso_code=language_iso_code,
            hash=hash,
            hash_contains=hash_contains,
            source_id=source_id,
            source_name=source_name,
            source_name_contains=source_name_contains,
            source_acronym=source_acronym,
            source_acronym_contains=source_acronym_contains,
            tag_ids=tag_ids,
            restrict_to_set=restrict_to_set,
            created_by=created_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_json_get_serialize(
        self,
        max,
        offset,
        sort,
        order,
        media_types,
        name,
        collection_id,
        name_contains,
        description_contains,
        source_url,
        source_url_contains,
        custom_thumbnail_url,
        custom_thumbnail_url_contains,
        date_content_authored,
        date_content_updated,
        date_content_published,
        date_content_reviewed,
        date_syndication_captured,
        date_syndication_updated,
        content_authored_since_date,
        content_authored_before_date,
        content_authored_in_range,
        content_updated_since_date,
        content_updated_before_date,
        content_updated_in_range,
        content_published_since_date,
        content_published_before_date,
        content_published_in_range,
        content_reviewed_since_date,
        content_reviewed_before_date,
        content_reviewed_in_range,
        syndication_captured_since_date,
        syndication_captured_before_date,
        syndication_captured_in_range,
        syndication_updated_since_date,
        syndication_updated_before_date,
        syndication_updated_in_range,
        syndication_visible_since_date,
        syndication_visible_before_date,
        syndication_visible_in_range,
        language_id,
        language_name,
        language_iso_code,
        hash,
        hash_contains,
        source_id,
        source_name,
        source_name_contains,
        source_acronym,
        source_acronym_contains,
        tag_ids,
        restrict_to_set,
        created_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if max is not None:
            
            _query_params.append(('max', max))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if order is not None:
            
            _query_params.append(('order', order))
            
        if media_types is not None:
            
            _query_params.append(('mediaTypes', media_types))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if collection_id is not None:
            
            _query_params.append(('collectionId', collection_id))
            
        if name_contains is not None:
            
            _query_params.append(('nameContains', name_contains))
            
        if description_contains is not None:
            
            _query_params.append(('descriptionContains', description_contains))
            
        if source_url is not None:
            
            _query_params.append(('sourceUrl', source_url))
            
        if source_url_contains is not None:
            
            _query_params.append(('sourceUrlContains', source_url_contains))
            
        if custom_thumbnail_url is not None:
            
            _query_params.append(('customThumbnailUrl', custom_thumbnail_url))
            
        if custom_thumbnail_url_contains is not None:
            
            _query_params.append(('customThumbnailUrlContains', custom_thumbnail_url_contains))
            
        if date_content_authored is not None:
            if isinstance(date_content_authored, date):
                _query_params.append(
                    (
                        'dateContentAuthored',
                        date_content_authored.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('dateContentAuthored', date_content_authored))
            
        if date_content_updated is not None:
            if isinstance(date_content_updated, date):
                _query_params.append(
                    (
                        'dateContentUpdated',
                        date_content_updated.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('dateContentUpdated', date_content_updated))
            
        if date_content_published is not None:
            if isinstance(date_content_published, date):
                _query_params.append(
                    (
                        'dateContentPublished',
                        date_content_published.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('dateContentPublished', date_content_published))
            
        if date_content_reviewed is not None:
            if isinstance(date_content_reviewed, date):
                _query_params.append(
                    (
                        'dateContentReviewed',
                        date_content_reviewed.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('dateContentReviewed', date_content_reviewed))
            
        if date_syndication_captured is not None:
            if isinstance(date_syndication_captured, date):
                _query_params.append(
                    (
                        'dateSyndicationCaptured',
                        date_syndication_captured.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('dateSyndicationCaptured', date_syndication_captured))
            
        if date_syndication_updated is not None:
            if isinstance(date_syndication_updated, date):
                _query_params.append(
                    (
                        'dateSyndicationUpdated',
                        date_syndication_updated.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('dateSyndicationUpdated', date_syndication_updated))
            
        if content_authored_since_date is not None:
            if isinstance(content_authored_since_date, date):
                _query_params.append(
                    (
                        'contentAuthoredSinceDate',
                        content_authored_since_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('contentAuthoredSinceDate', content_authored_since_date))
            
        if content_authored_before_date is not None:
            if isinstance(content_authored_before_date, date):
                _query_params.append(
                    (
                        'contentAuthoredBeforeDate',
                        content_authored_before_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('contentAuthoredBeforeDate', content_authored_before_date))
            
        if content_authored_in_range is not None:
            
            _query_params.append(('contentAuthoredInRange', content_authored_in_range))
            
        if content_updated_since_date is not None:
            if isinstance(content_updated_since_date, date):
                _query_params.append(
                    (
                        'contentUpdatedSinceDate',
                        content_updated_since_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('contentUpdatedSinceDate', content_updated_since_date))
            
        if content_updated_before_date is not None:
            if isinstance(content_updated_before_date, date):
                _query_params.append(
                    (
                        'contentUpdatedBeforeDate',
                        content_updated_before_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('contentUpdatedBeforeDate', content_updated_before_date))
            
        if content_updated_in_range is not None:
            
            _query_params.append(('contentUpdatedInRange', content_updated_in_range))
            
        if content_published_since_date is not None:
            if isinstance(content_published_since_date, date):
                _query_params.append(
                    (
                        'contentPublishedSinceDate',
                        content_published_since_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('contentPublishedSinceDate', content_published_since_date))
            
        if content_published_before_date is not None:
            if isinstance(content_published_before_date, date):
                _query_params.append(
                    (
                        'contentPublishedBeforeDate',
                        content_published_before_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('contentPublishedBeforeDate', content_published_before_date))
            
        if content_published_in_range is not None:
            
            _query_params.append(('contentPublishedInRange', content_published_in_range))
            
        if content_reviewed_since_date is not None:
            if isinstance(content_reviewed_since_date, date):
                _query_params.append(
                    (
                        'contentReviewedSinceDate',
                        content_reviewed_since_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('contentReviewedSinceDate', content_reviewed_since_date))
            
        if content_reviewed_before_date is not None:
            if isinstance(content_reviewed_before_date, date):
                _query_params.append(
                    (
                        'contentReviewedBeforeDate',
                        content_reviewed_before_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('contentReviewedBeforeDate', content_reviewed_before_date))
            
        if content_reviewed_in_range is not None:
            
            _query_params.append(('contentReviewedInRange', content_reviewed_in_range))
            
        if syndication_captured_since_date is not None:
            if isinstance(syndication_captured_since_date, date):
                _query_params.append(
                    (
                        'syndicationCapturedSinceDate',
                        syndication_captured_since_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('syndicationCapturedSinceDate', syndication_captured_since_date))
            
        if syndication_captured_before_date is not None:
            if isinstance(syndication_captured_before_date, date):
                _query_params.append(
                    (
                        'syndicationCapturedBeforeDate',
                        syndication_captured_before_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('syndicationCapturedBeforeDate', syndication_captured_before_date))
            
        if syndication_captured_in_range is not None:
            
            _query_params.append(('syndicationCapturedInRange', syndication_captured_in_range))
            
        if syndication_updated_since_date is not None:
            if isinstance(syndication_updated_since_date, date):
                _query_params.append(
                    (
                        'syndicationUpdatedSinceDate',
                        syndication_updated_since_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('syndicationUpdatedSinceDate', syndication_updated_since_date))
            
        if syndication_updated_before_date is not None:
            if isinstance(syndication_updated_before_date, date):
                _query_params.append(
                    (
                        'syndicationUpdatedBeforeDate',
                        syndication_updated_before_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('syndicationUpdatedBeforeDate', syndication_updated_before_date))
            
        if syndication_updated_in_range is not None:
            
            _query_params.append(('syndicationUpdatedInRange', syndication_updated_in_range))
            
        if syndication_visible_since_date is not None:
            if isinstance(syndication_visible_since_date, date):
                _query_params.append(
                    (
                        'syndicationVisibleSinceDate',
                        syndication_visible_since_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('syndicationVisibleSinceDate', syndication_visible_since_date))
            
        if syndication_visible_before_date is not None:
            if isinstance(syndication_visible_before_date, date):
                _query_params.append(
                    (
                        'syndicationVisibleBeforeDate',
                        syndication_visible_before_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('syndicationVisibleBeforeDate', syndication_visible_before_date))
            
        if syndication_visible_in_range is not None:
            if isinstance(syndication_visible_in_range, date):
                _query_params.append(
                    (
                        'syndicationVisibleInRange',
                        syndication_visible_in_range.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('syndicationVisibleInRange', syndication_visible_in_range))
            
        if language_id is not None:
            
            _query_params.append(('languageId', language_id))
            
        if language_name is not None:
            
            _query_params.append(('languageName', language_name))
            
        if language_iso_code is not None:
            
            _query_params.append(('languageIsoCode', language_iso_code))
            
        if hash is not None:
            
            _query_params.append(('hash', hash))
            
        if hash_contains is not None:
            
            _query_params.append(('hashContains', hash_contains))
            
        if source_id is not None:
            
            _query_params.append(('sourceId', source_id))
            
        if source_name is not None:
            
            _query_params.append(('sourceName', source_name))
            
        if source_name_contains is not None:
            
            _query_params.append(('sourceNameContains', source_name_contains))
            
        if source_acronym is not None:
            
            _query_params.append(('sourceAcronym', source_acronym))
            
        if source_acronym_contains is not None:
            
            _query_params.append(('sourceAcronymContains', source_acronym_contains))
            
        if tag_ids is not None:
            
            _query_params.append(('tagIds', tag_ids))
            
        if restrict_to_set is not None:
            
            _query_params.append(('restrictToSet', restrict_to_set))
            
        if created_by is not None:
            
            _query_params.append(('createdBy', created_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_most_popular_media_format_get(
        self,
        format: Annotated[StrictStr, Field(description="Automatically added")],
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The offset of the records set to return for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[MediaItemWrapped]:
        """Get MediaItems by popularity

        Get the media with the highest ratings.

        :param format: Automatically added (required)
        :type format: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: The offset of the records set to return for pagination.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_most_popular_media_format_get_serialize(
            format=format,
            max=max,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_most_popular_media_format_get_with_http_info(
        self,
        format: Annotated[StrictStr, Field(description="Automatically added")],
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The offset of the records set to return for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[MediaItemWrapped]]:
        """Get MediaItems by popularity

        Get the media with the highest ratings.

        :param format: Automatically added (required)
        :type format: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: The offset of the records set to return for pagination.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_most_popular_media_format_get_serialize(
            format=format,
            max=max,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_most_popular_media_format_get_without_preload_content(
        self,
        format: Annotated[StrictStr, Field(description="Automatically added")],
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The offset of the records set to return for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get MediaItems by popularity

        Get the media with the highest ratings.

        :param format: Automatically added (required)
        :type format: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: The offset of the records set to return for pagination.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_most_popular_media_format_get_serialize(
            format=format,
            max=max,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_most_popular_media_format_get_serialize(
        self,
        format,
        max,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if format is not None:
            _path_params['format'] = format
        # process the query parameters
        if max is not None:
            
            _query_params.append(('max', max))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/mostPopularMedia.{format}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def resources_media_search_results_json_get(
        self,
        q: Annotated[StrictStr, Field(description="The search query supplied by the user")],
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The offset of the records set to return for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[MediaItemWrapped]:
        """Get MediaItems by search query

        Full search

        :param q: The search query supplied by the user (required)
        :type q: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: The offset of the records set to return for pagination.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_search_results_json_get_serialize(
            q=q,
            max=max,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def resources_media_search_results_json_get_with_http_info(
        self,
        q: Annotated[StrictStr, Field(description="The search query supplied by the user")],
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The offset of the records set to return for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[MediaItemWrapped]]:
        """Get MediaItems by search query

        Full search

        :param q: The search query supplied by the user (required)
        :type q: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: The offset of the records set to return for pagination.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_search_results_json_get_serialize(
            q=q,
            max=max,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def resources_media_search_results_json_get_without_preload_content(
        self,
        q: Annotated[StrictStr, Field(description="The search query supplied by the user")],
        max: Annotated[Optional[StrictInt], Field(description="The maximum number of records to return")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The offset of the records set to return for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get MediaItems by search query

        Full search

        :param q: The search query supplied by the user (required)
        :type q: str
        :param max: The maximum number of records to return
        :type max: int
        :param offset: The offset of the records set to return for pagination.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._resources_media_search_results_json_get_serialize(
            q=q,
            max=max,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaItemWrapped]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _resources_media_search_results_json_get_serialize(
        self,
        q,
        max,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if q is not None:
            
            _query_params.append(('q', q))
            
        if max is not None:
            
            _query_params.append(('max', max))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/resources/media/searchResults.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


