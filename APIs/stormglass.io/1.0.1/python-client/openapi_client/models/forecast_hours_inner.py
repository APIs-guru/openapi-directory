# coding: utf-8

"""
    Storm Glass Marine Weather

    Global marine weather data from multiple sources in one single API with hourly resolution. Get your API key by visiting the Storm Glass web site.

    The version of the OpenAPI document: 1.0.1
    Contact: support@stormglass.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.forecast_hours_inner_air_temperature_inner import ForecastHoursInnerAirTemperatureInner
from openapi_client.models.forecast_hours_inner_swell_direction_inner import ForecastHoursInnerSwellDirectionInner
from openapi_client.models.forecast_hours_inner_swell_height_inner import ForecastHoursInnerSwellHeightInner
from openapi_client.models.forecast_hours_inner_swell_period_inner import ForecastHoursInnerSwellPeriodInner
from openapi_client.models.forecast_hours_inner_water_temperature_inner import ForecastHoursInnerWaterTemperatureInner
from openapi_client.models.forecast_hours_inner_wave_direction_inner import ForecastHoursInnerWaveDirectionInner
from openapi_client.models.forecast_hours_inner_wave_height_inner import ForecastHoursInnerWaveHeightInner
from openapi_client.models.forecast_hours_inner_wave_period_inner import ForecastHoursInnerWavePeriodInner
from openapi_client.models.forecast_hours_inner_wind_direction_inner import ForecastHoursInnerWindDirectionInner
from openapi_client.models.forecast_hours_inner_wind_speed_inner import ForecastHoursInnerWindSpeedInner
from typing import Optional, Set
from typing_extensions import Self

class ForecastHoursInner(BaseModel):
    """
    Hourly forecast information
    """ # noqa: E501
    air_temperature: Optional[List[ForecastHoursInnerAirTemperatureInner]] = Field(default=None, alias="airTemperature")
    swell_direction: Optional[List[ForecastHoursInnerSwellDirectionInner]] = Field(default=None, alias="swellDirection")
    swell_height: Optional[List[ForecastHoursInnerSwellHeightInner]] = Field(default=None, alias="swellHeight")
    swell_period: Optional[List[ForecastHoursInnerSwellPeriodInner]] = Field(default=None, alias="swellPeriod")
    time: Optional[StrictStr] = Field(default=None, description="Timestamp in utc for the hour represented")
    water_temperature: Optional[List[ForecastHoursInnerWaterTemperatureInner]] = Field(default=None, alias="waterTemperature")
    wave_direction: Optional[List[ForecastHoursInnerWaveDirectionInner]] = Field(default=None, alias="waveDirection")
    wave_height: Optional[List[ForecastHoursInnerWaveHeightInner]] = Field(default=None, alias="waveHeight")
    wave_period: Optional[List[ForecastHoursInnerWavePeriodInner]] = Field(default=None, alias="wavePeriod")
    wind_direction: Optional[List[ForecastHoursInnerWindDirectionInner]] = Field(default=None, alias="windDirection")
    wind_speed: Optional[List[ForecastHoursInnerWindSpeedInner]] = Field(default=None, alias="windSpeed")
    __properties: ClassVar[List[str]] = ["airTemperature", "swellDirection", "swellHeight", "swellPeriod", "time", "waterTemperature", "waveDirection", "waveHeight", "wavePeriod", "windDirection", "windSpeed"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ForecastHoursInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in air_temperature (list)
        _items = []
        if self.air_temperature:
            for _item_air_temperature in self.air_temperature:
                if _item_air_temperature:
                    _items.append(_item_air_temperature.to_dict())
            _dict['airTemperature'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in swell_direction (list)
        _items = []
        if self.swell_direction:
            for _item_swell_direction in self.swell_direction:
                if _item_swell_direction:
                    _items.append(_item_swell_direction.to_dict())
            _dict['swellDirection'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in swell_height (list)
        _items = []
        if self.swell_height:
            for _item_swell_height in self.swell_height:
                if _item_swell_height:
                    _items.append(_item_swell_height.to_dict())
            _dict['swellHeight'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in swell_period (list)
        _items = []
        if self.swell_period:
            for _item_swell_period in self.swell_period:
                if _item_swell_period:
                    _items.append(_item_swell_period.to_dict())
            _dict['swellPeriod'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in water_temperature (list)
        _items = []
        if self.water_temperature:
            for _item_water_temperature in self.water_temperature:
                if _item_water_temperature:
                    _items.append(_item_water_temperature.to_dict())
            _dict['waterTemperature'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in wave_direction (list)
        _items = []
        if self.wave_direction:
            for _item_wave_direction in self.wave_direction:
                if _item_wave_direction:
                    _items.append(_item_wave_direction.to_dict())
            _dict['waveDirection'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in wave_height (list)
        _items = []
        if self.wave_height:
            for _item_wave_height in self.wave_height:
                if _item_wave_height:
                    _items.append(_item_wave_height.to_dict())
            _dict['waveHeight'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in wave_period (list)
        _items = []
        if self.wave_period:
            for _item_wave_period in self.wave_period:
                if _item_wave_period:
                    _items.append(_item_wave_period.to_dict())
            _dict['wavePeriod'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in wind_direction (list)
        _items = []
        if self.wind_direction:
            for _item_wind_direction in self.wind_direction:
                if _item_wind_direction:
                    _items.append(_item_wind_direction.to_dict())
            _dict['windDirection'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in wind_speed (list)
        _items = []
        if self.wind_speed:
            for _item_wind_speed in self.wind_speed:
                if _item_wind_speed:
                    _items.append(_item_wind_speed.to_dict())
            _dict['windSpeed'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ForecastHoursInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "airTemperature": [ForecastHoursInnerAirTemperatureInner.from_dict(_item) for _item in obj["airTemperature"]] if obj.get("airTemperature") is not None else None,
            "swellDirection": [ForecastHoursInnerSwellDirectionInner.from_dict(_item) for _item in obj["swellDirection"]] if obj.get("swellDirection") is not None else None,
            "swellHeight": [ForecastHoursInnerSwellHeightInner.from_dict(_item) for _item in obj["swellHeight"]] if obj.get("swellHeight") is not None else None,
            "swellPeriod": [ForecastHoursInnerSwellPeriodInner.from_dict(_item) for _item in obj["swellPeriod"]] if obj.get("swellPeriod") is not None else None,
            "time": obj.get("time"),
            "waterTemperature": [ForecastHoursInnerWaterTemperatureInner.from_dict(_item) for _item in obj["waterTemperature"]] if obj.get("waterTemperature") is not None else None,
            "waveDirection": [ForecastHoursInnerWaveDirectionInner.from_dict(_item) for _item in obj["waveDirection"]] if obj.get("waveDirection") is not None else None,
            "waveHeight": [ForecastHoursInnerWaveHeightInner.from_dict(_item) for _item in obj["waveHeight"]] if obj.get("waveHeight") is not None else None,
            "wavePeriod": [ForecastHoursInnerWavePeriodInner.from_dict(_item) for _item in obj["wavePeriod"]] if obj.get("wavePeriod") is not None else None,
            "windDirection": [ForecastHoursInnerWindDirectionInner.from_dict(_item) for _item in obj["windDirection"]] if obj.get("windDirection") is not None else None,
            "windSpeed": [ForecastHoursInnerWindSpeedInner.from_dict(_item) for _item in obj["windSpeed"]] if obj.get("windSpeed") is not None else None
        })
        return _obj


