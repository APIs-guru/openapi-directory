# coding: utf-8

"""
    Slack Web API

    One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

    The version of the OpenAPI document: 1.7.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Optional, Union
from typing_extensions import Annotated
from openapi_client.models.chat_delete_scheduled_message_schema import ChatDeleteScheduledMessageSchema
from openapi_client.models.chat_delete_success_schema import ChatDeleteSuccessSchema
from openapi_client.models.chat_get_permalink_success_schema import ChatGetPermalinkSuccessSchema
from openapi_client.models.chat_me_message_schema import ChatMeMessageSchema
from openapi_client.models.chat_post_ephemeral_success_schema import ChatPostEphemeralSuccessSchema
from openapi_client.models.chat_post_message_success_schema import ChatPostMessageSuccessSchema
from openapi_client.models.chat_schedule_message_success_schema import ChatScheduleMessageSuccessSchema
from openapi_client.models.chat_scheduled_messages_list_schema import ChatScheduledMessagesListSchema
from openapi_client.models.chat_unfurl_success_schema import ChatUnfurlSuccessSchema
from openapi_client.models.chat_update_success_schema import ChatUpdateSuccessSchema

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ChatApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def chat_delete(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `chat:write`")] = None,
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Channel containing the message to be deleted.")] = None,
        ts: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timestamp of the message to be deleted.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChatDeleteSuccessSchema:
        """chat_delete

        Deletes a message.

        :param token: Authentication token. Requires scope: `chat:write`
        :type token: str
        :param as_user: Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
        :type as_user: bool
        :param channel: Channel containing the message to be deleted.
        :type channel: str
        :param ts: Timestamp of the message to be deleted.
        :type ts: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_delete_serialize(
            token=token,
            as_user=as_user,
            channel=channel,
            ts=ts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatDeleteSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def chat_delete_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `chat:write`")] = None,
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Channel containing the message to be deleted.")] = None,
        ts: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timestamp of the message to be deleted.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChatDeleteSuccessSchema]:
        """chat_delete

        Deletes a message.

        :param token: Authentication token. Requires scope: `chat:write`
        :type token: str
        :param as_user: Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
        :type as_user: bool
        :param channel: Channel containing the message to be deleted.
        :type channel: str
        :param ts: Timestamp of the message to be deleted.
        :type ts: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_delete_serialize(
            token=token,
            as_user=as_user,
            channel=channel,
            ts=ts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatDeleteSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def chat_delete_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `chat:write`")] = None,
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Channel containing the message to be deleted.")] = None,
        ts: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Timestamp of the message to be deleted.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """chat_delete

        Deletes a message.

        :param token: Authentication token. Requires scope: `chat:write`
        :type token: str
        :param as_user: Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
        :type as_user: bool
        :param channel: Channel containing the message to be deleted.
        :type channel: str
        :param ts: Timestamp of the message to be deleted.
        :type ts: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_delete_serialize(
            token=token,
            as_user=as_user,
            channel=channel,
            ts=ts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatDeleteSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _chat_delete_serialize(
        self,
        token,
        as_user,
        channel,
        ts,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if as_user is not None:
            _form_params.append(('as_user', as_user))
        if channel is not None:
            _form_params.append(('channel', channel))
        if ts is not None:
            _form_params.append(('ts', ts))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/chat.delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def chat_delete_scheduled_message(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="The channel the scheduled_message is posting to")],
        scheduled_message_id: Annotated[StrictStr, Field(description="`scheduled_message_id` returned from call to chat.scheduleMessage")],
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChatDeleteScheduledMessageSchema:
        """chat_delete_scheduled_message

        Deletes a pending scheduled message from the queue.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: The channel the scheduled_message is posting to (required)
        :type channel: str
        :param scheduled_message_id: `scheduled_message_id` returned from call to chat.scheduleMessage (required)
        :type scheduled_message_id: str
        :param as_user: Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
        :type as_user: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_delete_scheduled_message_serialize(
            token=token,
            channel=channel,
            scheduled_message_id=scheduled_message_id,
            as_user=as_user,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatDeleteScheduledMessageSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def chat_delete_scheduled_message_with_http_info(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="The channel the scheduled_message is posting to")],
        scheduled_message_id: Annotated[StrictStr, Field(description="`scheduled_message_id` returned from call to chat.scheduleMessage")],
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChatDeleteScheduledMessageSchema]:
        """chat_delete_scheduled_message

        Deletes a pending scheduled message from the queue.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: The channel the scheduled_message is posting to (required)
        :type channel: str
        :param scheduled_message_id: `scheduled_message_id` returned from call to chat.scheduleMessage (required)
        :type scheduled_message_id: str
        :param as_user: Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
        :type as_user: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_delete_scheduled_message_serialize(
            token=token,
            channel=channel,
            scheduled_message_id=scheduled_message_id,
            as_user=as_user,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatDeleteScheduledMessageSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def chat_delete_scheduled_message_without_preload_content(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="The channel the scheduled_message is posting to")],
        scheduled_message_id: Annotated[StrictStr, Field(description="`scheduled_message_id` returned from call to chat.scheduleMessage")],
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """chat_delete_scheduled_message

        Deletes a pending scheduled message from the queue.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: The channel the scheduled_message is posting to (required)
        :type channel: str
        :param scheduled_message_id: `scheduled_message_id` returned from call to chat.scheduleMessage (required)
        :type scheduled_message_id: str
        :param as_user: Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
        :type as_user: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_delete_scheduled_message_serialize(
            token=token,
            channel=channel,
            scheduled_message_id=scheduled_message_id,
            as_user=as_user,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatDeleteScheduledMessageSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _chat_delete_scheduled_message_serialize(
        self,
        token,
        channel,
        scheduled_message_id,
        as_user,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if as_user is not None:
            _form_params.append(('as_user', as_user))
        if channel is not None:
            _form_params.append(('channel', channel))
        if scheduled_message_id is not None:
            _form_params.append(('scheduled_message_id', scheduled_message_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/chat.deleteScheduledMessage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def chat_get_permalink(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `none`")],
        channel: Annotated[StrictStr, Field(description="The ID of the conversation or channel containing the message")],
        message_ts: Annotated[StrictStr, Field(description="A message's `ts` value, uniquely identifying it within a channel")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChatGetPermalinkSuccessSchema:
        """chat_get_permalink

        Retrieve a permalink URL for a specific extant message

        :param token: Authentication token. Requires scope: `none` (required)
        :type token: str
        :param channel: The ID of the conversation or channel containing the message (required)
        :type channel: str
        :param message_ts: A message's `ts` value, uniquely identifying it within a channel (required)
        :type message_ts: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_get_permalink_serialize(
            token=token,
            channel=channel,
            message_ts=message_ts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatGetPermalinkSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def chat_get_permalink_with_http_info(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `none`")],
        channel: Annotated[StrictStr, Field(description="The ID of the conversation or channel containing the message")],
        message_ts: Annotated[StrictStr, Field(description="A message's `ts` value, uniquely identifying it within a channel")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChatGetPermalinkSuccessSchema]:
        """chat_get_permalink

        Retrieve a permalink URL for a specific extant message

        :param token: Authentication token. Requires scope: `none` (required)
        :type token: str
        :param channel: The ID of the conversation or channel containing the message (required)
        :type channel: str
        :param message_ts: A message's `ts` value, uniquely identifying it within a channel (required)
        :type message_ts: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_get_permalink_serialize(
            token=token,
            channel=channel,
            message_ts=message_ts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatGetPermalinkSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def chat_get_permalink_without_preload_content(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `none`")],
        channel: Annotated[StrictStr, Field(description="The ID of the conversation or channel containing the message")],
        message_ts: Annotated[StrictStr, Field(description="A message's `ts` value, uniquely identifying it within a channel")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """chat_get_permalink

        Retrieve a permalink URL for a specific extant message

        :param token: Authentication token. Requires scope: `none` (required)
        :type token: str
        :param channel: The ID of the conversation or channel containing the message (required)
        :type channel: str
        :param message_ts: A message's `ts` value, uniquely identifying it within a channel (required)
        :type message_ts: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_get_permalink_serialize(
            token=token,
            channel=channel,
            message_ts=message_ts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatGetPermalinkSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _chat_get_permalink_serialize(
        self,
        token,
        channel,
        message_ts,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        if channel is not None:
            
            _query_params.append(('channel', channel))
            
        if message_ts is not None:
            
            _query_params.append(('message_ts', message_ts))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/chat.getPermalink',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def chat_me_message(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `chat:write`")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="Text of the message to send.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChatMeMessageSchema:
        """chat_me_message

        Share a me message into a channel.

        :param token: Authentication token. Requires scope: `chat:write`
        :type token: str
        :param channel: Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
        :type channel: str
        :param text: Text of the message to send.
        :type text: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_me_message_serialize(
            token=token,
            channel=channel,
            text=text,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatMeMessageSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def chat_me_message_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `chat:write`")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="Text of the message to send.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChatMeMessageSchema]:
        """chat_me_message

        Share a me message into a channel.

        :param token: Authentication token. Requires scope: `chat:write`
        :type token: str
        :param channel: Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
        :type channel: str
        :param text: Text of the message to send.
        :type text: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_me_message_serialize(
            token=token,
            channel=channel,
            text=text,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatMeMessageSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def chat_me_message_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `chat:write`")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="Text of the message to send.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """chat_me_message

        Share a me message into a channel.

        :param token: Authentication token. Requires scope: `chat:write`
        :type token: str
        :param channel: Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
        :type channel: str
        :param text: Text of the message to send.
        :type text: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_me_message_serialize(
            token=token,
            channel=channel,
            text=text,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatMeMessageSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _chat_me_message_serialize(
        self,
        token,
        channel,
        text,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if channel is not None:
            _form_params.append(('channel', channel))
        if text is not None:
            _form_params.append(('text', text))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/chat.meMessage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def chat_post_ephemeral(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.")],
        user: Annotated[StrictStr, Field(description="`id` of the user who will receive the ephemeral message. The user should be in the channel specified by the `channel` argument.")],
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured blocks, presented as a URL-encoded string.")] = None,
        icon_emoji: Annotated[Optional[StrictStr], Field(description="Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.")] = None,
        icon_url: Annotated[Optional[StrictStr], Field(description="URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        link_names: Annotated[Optional[StrictBool], Field(description="Find and link channel names and usernames.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `none`. See [below](#formatting).")] = None,
        text: Annotated[Optional[StrictStr], Field(description="How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.")] = None,
        thread_ts: Annotated[Optional[StrictStr], Field(description="Provide another message's `ts` value to post this message in a thread. Avoid using a reply's `ts` value; use its parent's value instead. Ephemeral messages in threads are only shown if there is already an active thread.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChatPostEphemeralSuccessSchema:
        """chat_post_ephemeral

        Sends an ephemeral message to a user in a channel.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. (required)
        :type channel: str
        :param user: `id` of the user who will receive the ephemeral message. The user should be in the channel specified by the `channel` argument. (required)
        :type user: str
        :param as_user: Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
        :type as_user: bool
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
        :type attachments: str
        :param blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
        :type blocks: str
        :param icon_emoji: Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.
        :type icon_emoji: str
        :param icon_url: URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type icon_url: str
        :param link_names: Find and link channel names and usernames.
        :type link_names: bool
        :param parse: Change how messages are treated. Defaults to `none`. See [below](#formatting).
        :type parse: str
        :param text: How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
        :type text: str
        :param thread_ts: Provide another message's `ts` value to post this message in a thread. Avoid using a reply's `ts` value; use its parent's value instead. Ephemeral messages in threads are only shown if there is already an active thread.
        :type thread_ts: str
        :param username: Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_post_ephemeral_serialize(
            token=token,
            channel=channel,
            user=user,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            icon_emoji=icon_emoji,
            icon_url=icon_url,
            link_names=link_names,
            parse=parse,
            text=text,
            thread_ts=thread_ts,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatPostEphemeralSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def chat_post_ephemeral_with_http_info(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.")],
        user: Annotated[StrictStr, Field(description="`id` of the user who will receive the ephemeral message. The user should be in the channel specified by the `channel` argument.")],
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured blocks, presented as a URL-encoded string.")] = None,
        icon_emoji: Annotated[Optional[StrictStr], Field(description="Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.")] = None,
        icon_url: Annotated[Optional[StrictStr], Field(description="URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        link_names: Annotated[Optional[StrictBool], Field(description="Find and link channel names and usernames.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `none`. See [below](#formatting).")] = None,
        text: Annotated[Optional[StrictStr], Field(description="How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.")] = None,
        thread_ts: Annotated[Optional[StrictStr], Field(description="Provide another message's `ts` value to post this message in a thread. Avoid using a reply's `ts` value; use its parent's value instead. Ephemeral messages in threads are only shown if there is already an active thread.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChatPostEphemeralSuccessSchema]:
        """chat_post_ephemeral

        Sends an ephemeral message to a user in a channel.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. (required)
        :type channel: str
        :param user: `id` of the user who will receive the ephemeral message. The user should be in the channel specified by the `channel` argument. (required)
        :type user: str
        :param as_user: Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
        :type as_user: bool
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
        :type attachments: str
        :param blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
        :type blocks: str
        :param icon_emoji: Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.
        :type icon_emoji: str
        :param icon_url: URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type icon_url: str
        :param link_names: Find and link channel names and usernames.
        :type link_names: bool
        :param parse: Change how messages are treated. Defaults to `none`. See [below](#formatting).
        :type parse: str
        :param text: How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
        :type text: str
        :param thread_ts: Provide another message's `ts` value to post this message in a thread. Avoid using a reply's `ts` value; use its parent's value instead. Ephemeral messages in threads are only shown if there is already an active thread.
        :type thread_ts: str
        :param username: Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_post_ephemeral_serialize(
            token=token,
            channel=channel,
            user=user,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            icon_emoji=icon_emoji,
            icon_url=icon_url,
            link_names=link_names,
            parse=parse,
            text=text,
            thread_ts=thread_ts,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatPostEphemeralSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def chat_post_ephemeral_without_preload_content(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.")],
        user: Annotated[StrictStr, Field(description="`id` of the user who will receive the ephemeral message. The user should be in the channel specified by the `channel` argument.")],
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured blocks, presented as a URL-encoded string.")] = None,
        icon_emoji: Annotated[Optional[StrictStr], Field(description="Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.")] = None,
        icon_url: Annotated[Optional[StrictStr], Field(description="URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        link_names: Annotated[Optional[StrictBool], Field(description="Find and link channel names and usernames.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `none`. See [below](#formatting).")] = None,
        text: Annotated[Optional[StrictStr], Field(description="How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.")] = None,
        thread_ts: Annotated[Optional[StrictStr], Field(description="Provide another message's `ts` value to post this message in a thread. Avoid using a reply's `ts` value; use its parent's value instead. Ephemeral messages in threads are only shown if there is already an active thread.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """chat_post_ephemeral

        Sends an ephemeral message to a user in a channel.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. (required)
        :type channel: str
        :param user: `id` of the user who will receive the ephemeral message. The user should be in the channel specified by the `channel` argument. (required)
        :type user: str
        :param as_user: Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
        :type as_user: bool
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
        :type attachments: str
        :param blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
        :type blocks: str
        :param icon_emoji: Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.
        :type icon_emoji: str
        :param icon_url: URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type icon_url: str
        :param link_names: Find and link channel names and usernames.
        :type link_names: bool
        :param parse: Change how messages are treated. Defaults to `none`. See [below](#formatting).
        :type parse: str
        :param text: How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
        :type text: str
        :param thread_ts: Provide another message's `ts` value to post this message in a thread. Avoid using a reply's `ts` value; use its parent's value instead. Ephemeral messages in threads are only shown if there is already an active thread.
        :type thread_ts: str
        :param username: Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_post_ephemeral_serialize(
            token=token,
            channel=channel,
            user=user,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            icon_emoji=icon_emoji,
            icon_url=icon_url,
            link_names=link_names,
            parse=parse,
            text=text,
            thread_ts=thread_ts,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatPostEphemeralSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _chat_post_ephemeral_serialize(
        self,
        token,
        channel,
        user,
        as_user,
        attachments,
        blocks,
        icon_emoji,
        icon_url,
        link_names,
        parse,
        text,
        thread_ts,
        username,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if as_user is not None:
            _form_params.append(('as_user', as_user))
        if attachments is not None:
            _form_params.append(('attachments', attachments))
        if blocks is not None:
            _form_params.append(('blocks', blocks))
        if channel is not None:
            _form_params.append(('channel', channel))
        if icon_emoji is not None:
            _form_params.append(('icon_emoji', icon_emoji))
        if icon_url is not None:
            _form_params.append(('icon_url', icon_url))
        if link_names is not None:
            _form_params.append(('link_names', link_names))
        if parse is not None:
            _form_params.append(('parse', parse))
        if text is not None:
            _form_params.append(('text', text))
        if thread_ts is not None:
            _form_params.append(('thread_ts', thread_ts))
        if user is not None:
            _form_params.append(('user', user))
        if username is not None:
            _form_params.append(('username', username))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/chat.postEphemeral',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def chat_post_message(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.")],
        as_user: Annotated[Optional[StrictStr], Field(description="Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured blocks, presented as a URL-encoded string.")] = None,
        icon_emoji: Annotated[Optional[StrictStr], Field(description="Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.")] = None,
        icon_url: Annotated[Optional[StrictStr], Field(description="URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        link_names: Annotated[Optional[StrictBool], Field(description="Find and link channel names and usernames.")] = None,
        mrkdwn: Annotated[Optional[StrictBool], Field(description="Disable Slack markup parsing by setting to `false`. Enabled by default.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `none`. See [below](#formatting).")] = None,
        reply_broadcast: Annotated[Optional[StrictBool], Field(description="Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.")] = None,
        thread_ts: Annotated[Optional[StrictStr], Field(description="Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.")] = None,
        unfurl_links: Annotated[Optional[StrictBool], Field(description="Pass true to enable unfurling of primarily text-based content.")] = None,
        unfurl_media: Annotated[Optional[StrictBool], Field(description="Pass false to disable unfurling of media content.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChatPostMessageSuccessSchema:
        """chat_post_message

        Sends a message to a channel.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details. (required)
        :type channel: str
        :param as_user: Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.
        :type as_user: str
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
        :type attachments: str
        :param blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
        :type blocks: str
        :param icon_emoji: Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.
        :type icon_emoji: str
        :param icon_url: URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type icon_url: str
        :param link_names: Find and link channel names and usernames.
        :type link_names: bool
        :param mrkdwn: Disable Slack markup parsing by setting to `false`. Enabled by default.
        :type mrkdwn: bool
        :param parse: Change how messages are treated. Defaults to `none`. See [below](#formatting).
        :type parse: str
        :param reply_broadcast: Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
        :type reply_broadcast: bool
        :param text: How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
        :type text: str
        :param thread_ts: Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.
        :type thread_ts: str
        :param unfurl_links: Pass true to enable unfurling of primarily text-based content.
        :type unfurl_links: bool
        :param unfurl_media: Pass false to disable unfurling of media content.
        :type unfurl_media: bool
        :param username: Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_post_message_serialize(
            token=token,
            channel=channel,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            icon_emoji=icon_emoji,
            icon_url=icon_url,
            link_names=link_names,
            mrkdwn=mrkdwn,
            parse=parse,
            reply_broadcast=reply_broadcast,
            text=text,
            thread_ts=thread_ts,
            unfurl_links=unfurl_links,
            unfurl_media=unfurl_media,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatPostMessageSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def chat_post_message_with_http_info(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.")],
        as_user: Annotated[Optional[StrictStr], Field(description="Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured blocks, presented as a URL-encoded string.")] = None,
        icon_emoji: Annotated[Optional[StrictStr], Field(description="Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.")] = None,
        icon_url: Annotated[Optional[StrictStr], Field(description="URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        link_names: Annotated[Optional[StrictBool], Field(description="Find and link channel names and usernames.")] = None,
        mrkdwn: Annotated[Optional[StrictBool], Field(description="Disable Slack markup parsing by setting to `false`. Enabled by default.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `none`. See [below](#formatting).")] = None,
        reply_broadcast: Annotated[Optional[StrictBool], Field(description="Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.")] = None,
        thread_ts: Annotated[Optional[StrictStr], Field(description="Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.")] = None,
        unfurl_links: Annotated[Optional[StrictBool], Field(description="Pass true to enable unfurling of primarily text-based content.")] = None,
        unfurl_media: Annotated[Optional[StrictBool], Field(description="Pass false to disable unfurling of media content.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChatPostMessageSuccessSchema]:
        """chat_post_message

        Sends a message to a channel.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details. (required)
        :type channel: str
        :param as_user: Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.
        :type as_user: str
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
        :type attachments: str
        :param blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
        :type blocks: str
        :param icon_emoji: Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.
        :type icon_emoji: str
        :param icon_url: URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type icon_url: str
        :param link_names: Find and link channel names and usernames.
        :type link_names: bool
        :param mrkdwn: Disable Slack markup parsing by setting to `false`. Enabled by default.
        :type mrkdwn: bool
        :param parse: Change how messages are treated. Defaults to `none`. See [below](#formatting).
        :type parse: str
        :param reply_broadcast: Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
        :type reply_broadcast: bool
        :param text: How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
        :type text: str
        :param thread_ts: Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.
        :type thread_ts: str
        :param unfurl_links: Pass true to enable unfurling of primarily text-based content.
        :type unfurl_links: bool
        :param unfurl_media: Pass false to disable unfurling of media content.
        :type unfurl_media: bool
        :param username: Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_post_message_serialize(
            token=token,
            channel=channel,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            icon_emoji=icon_emoji,
            icon_url=icon_url,
            link_names=link_names,
            mrkdwn=mrkdwn,
            parse=parse,
            reply_broadcast=reply_broadcast,
            text=text,
            thread_ts=thread_ts,
            unfurl_links=unfurl_links,
            unfurl_media=unfurl_media,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatPostMessageSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def chat_post_message_without_preload_content(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.")],
        as_user: Annotated[Optional[StrictStr], Field(description="Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured blocks, presented as a URL-encoded string.")] = None,
        icon_emoji: Annotated[Optional[StrictStr], Field(description="Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.")] = None,
        icon_url: Annotated[Optional[StrictStr], Field(description="URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        link_names: Annotated[Optional[StrictBool], Field(description="Find and link channel names and usernames.")] = None,
        mrkdwn: Annotated[Optional[StrictBool], Field(description="Disable Slack markup parsing by setting to `false`. Enabled by default.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `none`. See [below](#formatting).")] = None,
        reply_broadcast: Annotated[Optional[StrictBool], Field(description="Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.")] = None,
        thread_ts: Annotated[Optional[StrictStr], Field(description="Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.")] = None,
        unfurl_links: Annotated[Optional[StrictBool], Field(description="Pass true to enable unfurling of primarily text-based content.")] = None,
        unfurl_media: Annotated[Optional[StrictBool], Field(description="Pass false to disable unfurling of media content.")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """chat_post_message

        Sends a message to a channel.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details. (required)
        :type channel: str
        :param as_user: Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.
        :type as_user: str
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
        :type attachments: str
        :param blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
        :type blocks: str
        :param icon_emoji: Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](#authorship) below.
        :type icon_emoji: str
        :param icon_url: URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type icon_url: str
        :param link_names: Find and link channel names and usernames.
        :type link_names: bool
        :param mrkdwn: Disable Slack markup parsing by setting to `false`. Enabled by default.
        :type mrkdwn: bool
        :param parse: Change how messages are treated. Defaults to `none`. See [below](#formatting).
        :type parse: str
        :param reply_broadcast: Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
        :type reply_broadcast: bool
        :param text: How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
        :type text: str
        :param thread_ts: Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.
        :type thread_ts: str
        :param unfurl_links: Pass true to enable unfurling of primarily text-based content.
        :type unfurl_links: bool
        :param unfurl_media: Pass false to disable unfurling of media content.
        :type unfurl_media: bool
        :param username: Set your bot's user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_post_message_serialize(
            token=token,
            channel=channel,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            icon_emoji=icon_emoji,
            icon_url=icon_url,
            link_names=link_names,
            mrkdwn=mrkdwn,
            parse=parse,
            reply_broadcast=reply_broadcast,
            text=text,
            thread_ts=thread_ts,
            unfurl_links=unfurl_links,
            unfurl_media=unfurl_media,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatPostMessageSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _chat_post_message_serialize(
        self,
        token,
        channel,
        as_user,
        attachments,
        blocks,
        icon_emoji,
        icon_url,
        link_names,
        mrkdwn,
        parse,
        reply_broadcast,
        text,
        thread_ts,
        unfurl_links,
        unfurl_media,
        username,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if as_user is not None:
            _form_params.append(('as_user', as_user))
        if attachments is not None:
            _form_params.append(('attachments', attachments))
        if blocks is not None:
            _form_params.append(('blocks', blocks))
        if channel is not None:
            _form_params.append(('channel', channel))
        if icon_emoji is not None:
            _form_params.append(('icon_emoji', icon_emoji))
        if icon_url is not None:
            _form_params.append(('icon_url', icon_url))
        if link_names is not None:
            _form_params.append(('link_names', link_names))
        if mrkdwn is not None:
            _form_params.append(('mrkdwn', mrkdwn))
        if parse is not None:
            _form_params.append(('parse', parse))
        if reply_broadcast is not None:
            _form_params.append(('reply_broadcast', reply_broadcast))
        if text is not None:
            _form_params.append(('text', text))
        if thread_ts is not None:
            _form_params.append(('thread_ts', thread_ts))
        if unfurl_links is not None:
            _form_params.append(('unfurl_links', unfurl_links))
        if unfurl_media is not None:
            _form_params.append(('unfurl_media', unfurl_media))
        if username is not None:
            _form_params.append(('username', username))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/chat.postMessage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def chat_schedule_message(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `chat:write`")] = None,
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured blocks, presented as a URL-encoded string.")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.")] = None,
        link_names: Annotated[Optional[StrictBool], Field(description="Find and link channel names and usernames.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `none`. See [chat.postMessage](chat.postMessage#formatting).")] = None,
        post_at: Annotated[Optional[StrictStr], Field(description="Unix EPOCH timestamp of time in future to send the message.")] = None,
        reply_broadcast: Annotated[Optional[StrictBool], Field(description="Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.")] = None,
        thread_ts: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.")] = None,
        unfurl_links: Annotated[Optional[StrictBool], Field(description="Pass true to enable unfurling of primarily text-based content.")] = None,
        unfurl_media: Annotated[Optional[StrictBool], Field(description="Pass false to disable unfurling of media content.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChatScheduleMessageSuccessSchema:
        """chat_schedule_message

        Schedules a message to be sent to a channel.

        :param token: Authentication token. Requires scope: `chat:write`
        :type token: str
        :param as_user: Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
        :type as_user: bool
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
        :type attachments: str
        :param blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
        :type blocks: str
        :param channel: Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
        :type channel: str
        :param link_names: Find and link channel names and usernames.
        :type link_names: bool
        :param parse: Change how messages are treated. Defaults to `none`. See [chat.postMessage](chat.postMessage#formatting).
        :type parse: str
        :param post_at: Unix EPOCH timestamp of time in future to send the message.
        :type post_at: str
        :param reply_broadcast: Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
        :type reply_broadcast: bool
        :param text: How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
        :type text: str
        :param thread_ts: Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.
        :type thread_ts: float
        :param unfurl_links: Pass true to enable unfurling of primarily text-based content.
        :type unfurl_links: bool
        :param unfurl_media: Pass false to disable unfurling of media content.
        :type unfurl_media: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_schedule_message_serialize(
            token=token,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            channel=channel,
            link_names=link_names,
            parse=parse,
            post_at=post_at,
            reply_broadcast=reply_broadcast,
            text=text,
            thread_ts=thread_ts,
            unfurl_links=unfurl_links,
            unfurl_media=unfurl_media,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatScheduleMessageSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def chat_schedule_message_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `chat:write`")] = None,
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured blocks, presented as a URL-encoded string.")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.")] = None,
        link_names: Annotated[Optional[StrictBool], Field(description="Find and link channel names and usernames.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `none`. See [chat.postMessage](chat.postMessage#formatting).")] = None,
        post_at: Annotated[Optional[StrictStr], Field(description="Unix EPOCH timestamp of time in future to send the message.")] = None,
        reply_broadcast: Annotated[Optional[StrictBool], Field(description="Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.")] = None,
        thread_ts: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.")] = None,
        unfurl_links: Annotated[Optional[StrictBool], Field(description="Pass true to enable unfurling of primarily text-based content.")] = None,
        unfurl_media: Annotated[Optional[StrictBool], Field(description="Pass false to disable unfurling of media content.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChatScheduleMessageSuccessSchema]:
        """chat_schedule_message

        Schedules a message to be sent to a channel.

        :param token: Authentication token. Requires scope: `chat:write`
        :type token: str
        :param as_user: Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
        :type as_user: bool
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
        :type attachments: str
        :param blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
        :type blocks: str
        :param channel: Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
        :type channel: str
        :param link_names: Find and link channel names and usernames.
        :type link_names: bool
        :param parse: Change how messages are treated. Defaults to `none`. See [chat.postMessage](chat.postMessage#formatting).
        :type parse: str
        :param post_at: Unix EPOCH timestamp of time in future to send the message.
        :type post_at: str
        :param reply_broadcast: Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
        :type reply_broadcast: bool
        :param text: How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
        :type text: str
        :param thread_ts: Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.
        :type thread_ts: float
        :param unfurl_links: Pass true to enable unfurling of primarily text-based content.
        :type unfurl_links: bool
        :param unfurl_media: Pass false to disable unfurling of media content.
        :type unfurl_media: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_schedule_message_serialize(
            token=token,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            channel=channel,
            link_names=link_names,
            parse=parse,
            post_at=post_at,
            reply_broadcast=reply_broadcast,
            text=text,
            thread_ts=thread_ts,
            unfurl_links=unfurl_links,
            unfurl_media=unfurl_media,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatScheduleMessageSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def chat_schedule_message_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `chat:write`")] = None,
        as_user: Annotated[Optional[StrictBool], Field(description="Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured blocks, presented as a URL-encoded string.")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.")] = None,
        link_names: Annotated[Optional[StrictBool], Field(description="Find and link channel names and usernames.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `none`. See [chat.postMessage](chat.postMessage#formatting).")] = None,
        post_at: Annotated[Optional[StrictStr], Field(description="Unix EPOCH timestamp of time in future to send the message.")] = None,
        reply_broadcast: Annotated[Optional[StrictBool], Field(description="Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.")] = None,
        thread_ts: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.")] = None,
        unfurl_links: Annotated[Optional[StrictBool], Field(description="Pass true to enable unfurling of primarily text-based content.")] = None,
        unfurl_media: Annotated[Optional[StrictBool], Field(description="Pass false to disable unfurling of media content.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """chat_schedule_message

        Schedules a message to be sent to a channel.

        :param token: Authentication token. Requires scope: `chat:write`
        :type token: str
        :param as_user: Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
        :type as_user: bool
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string.
        :type attachments: str
        :param blocks: A JSON-based array of structured blocks, presented as a URL-encoded string.
        :type blocks: str
        :param channel: Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
        :type channel: str
        :param link_names: Find and link channel names and usernames.
        :type link_names: bool
        :param parse: Change how messages are treated. Defaults to `none`. See [chat.postMessage](chat.postMessage#formatting).
        :type parse: str
        :param post_at: Unix EPOCH timestamp of time in future to send the message.
        :type post_at: str
        :param reply_broadcast: Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
        :type reply_broadcast: bool
        :param text: How this field works and whether it is required depends on other fields you use in your API call. [See below](#text_usage) for more detail.
        :type text: str
        :param thread_ts: Provide another message's `ts` value to make this message a reply. Avoid using a reply's `ts` value; use its parent instead.
        :type thread_ts: float
        :param unfurl_links: Pass true to enable unfurling of primarily text-based content.
        :type unfurl_links: bool
        :param unfurl_media: Pass false to disable unfurling of media content.
        :type unfurl_media: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_schedule_message_serialize(
            token=token,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            channel=channel,
            link_names=link_names,
            parse=parse,
            post_at=post_at,
            reply_broadcast=reply_broadcast,
            text=text,
            thread_ts=thread_ts,
            unfurl_links=unfurl_links,
            unfurl_media=unfurl_media,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatScheduleMessageSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _chat_schedule_message_serialize(
        self,
        token,
        as_user,
        attachments,
        blocks,
        channel,
        link_names,
        parse,
        post_at,
        reply_broadcast,
        text,
        thread_ts,
        unfurl_links,
        unfurl_media,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if as_user is not None:
            _form_params.append(('as_user', as_user))
        if attachments is not None:
            _form_params.append(('attachments', attachments))
        if blocks is not None:
            _form_params.append(('blocks', blocks))
        if channel is not None:
            _form_params.append(('channel', channel))
        if link_names is not None:
            _form_params.append(('link_names', link_names))
        if parse is not None:
            _form_params.append(('parse', parse))
        if post_at is not None:
            _form_params.append(('post_at', post_at))
        if reply_broadcast is not None:
            _form_params.append(('reply_broadcast', reply_broadcast))
        if text is not None:
            _form_params.append(('text', text))
        if thread_ts is not None:
            _form_params.append(('thread_ts', thread_ts))
        if unfurl_links is not None:
            _form_params.append(('unfurl_links', unfurl_links))
        if unfurl_media is not None:
            _form_params.append(('unfurl_media', unfurl_media))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/chat.scheduleMessage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def chat_scheduled_messages_list_0(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `none`")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="The channel of the scheduled messages")] = None,
        latest: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="A UNIX timestamp of the latest value in the time range")] = None,
        oldest: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="A UNIX timestamp of the oldest value in the time range")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Maximum number of original entries to return.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="For pagination purposes, this is the `cursor` value returned from a previous call to `chat.scheduledmessages.list` indicating where you want to start this call from.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChatScheduledMessagesListSchema:
        """chat_scheduled_messages_list_0

        Returns a list of scheduled messages.

        :param token: Authentication token. Requires scope: `none`
        :type token: str
        :param channel: The channel of the scheduled messages
        :type channel: str
        :param latest: A UNIX timestamp of the latest value in the time range
        :type latest: float
        :param oldest: A UNIX timestamp of the oldest value in the time range
        :type oldest: float
        :param limit: Maximum number of original entries to return.
        :type limit: int
        :param cursor: For pagination purposes, this is the `cursor` value returned from a previous call to `chat.scheduledmessages.list` indicating where you want to start this call from.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_scheduled_messages_list_0_serialize(
            token=token,
            channel=channel,
            latest=latest,
            oldest=oldest,
            limit=limit,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatScheduledMessagesListSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def chat_scheduled_messages_list_0_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `none`")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="The channel of the scheduled messages")] = None,
        latest: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="A UNIX timestamp of the latest value in the time range")] = None,
        oldest: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="A UNIX timestamp of the oldest value in the time range")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Maximum number of original entries to return.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="For pagination purposes, this is the `cursor` value returned from a previous call to `chat.scheduledmessages.list` indicating where you want to start this call from.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChatScheduledMessagesListSchema]:
        """chat_scheduled_messages_list_0

        Returns a list of scheduled messages.

        :param token: Authentication token. Requires scope: `none`
        :type token: str
        :param channel: The channel of the scheduled messages
        :type channel: str
        :param latest: A UNIX timestamp of the latest value in the time range
        :type latest: float
        :param oldest: A UNIX timestamp of the oldest value in the time range
        :type oldest: float
        :param limit: Maximum number of original entries to return.
        :type limit: int
        :param cursor: For pagination purposes, this is the `cursor` value returned from a previous call to `chat.scheduledmessages.list` indicating where you want to start this call from.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_scheduled_messages_list_0_serialize(
            token=token,
            channel=channel,
            latest=latest,
            oldest=oldest,
            limit=limit,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatScheduledMessagesListSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def chat_scheduled_messages_list_0_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token. Requires scope: `none`")] = None,
        channel: Annotated[Optional[StrictStr], Field(description="The channel of the scheduled messages")] = None,
        latest: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="A UNIX timestamp of the latest value in the time range")] = None,
        oldest: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="A UNIX timestamp of the oldest value in the time range")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Maximum number of original entries to return.")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="For pagination purposes, this is the `cursor` value returned from a previous call to `chat.scheduledmessages.list` indicating where you want to start this call from.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """chat_scheduled_messages_list_0

        Returns a list of scheduled messages.

        :param token: Authentication token. Requires scope: `none`
        :type token: str
        :param channel: The channel of the scheduled messages
        :type channel: str
        :param latest: A UNIX timestamp of the latest value in the time range
        :type latest: float
        :param oldest: A UNIX timestamp of the oldest value in the time range
        :type oldest: float
        :param limit: Maximum number of original entries to return.
        :type limit: int
        :param cursor: For pagination purposes, this is the `cursor` value returned from a previous call to `chat.scheduledmessages.list` indicating where you want to start this call from.
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_scheduled_messages_list_0_serialize(
            token=token,
            channel=channel,
            latest=latest,
            oldest=oldest,
            limit=limit,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatScheduledMessagesListSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _chat_scheduled_messages_list_0_serialize(
        self,
        token,
        channel,
        latest,
        oldest,
        limit,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if channel is not None:
            
            _query_params.append(('channel', channel))
            
        if latest is not None:
            
            _query_params.append(('latest', latest))
            
        if oldest is not None:
            
            _query_params.append(('oldest', oldest))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/chat.scheduledMessages.list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def chat_unfurl(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `links:write`")],
        channel: Annotated[StrictStr, Field(description="Channel ID of the message")],
        ts: Annotated[StrictStr, Field(description="Timestamp of the message to add unfurl behavior to.")],
        unfurls: Annotated[Optional[StrictStr], Field(description="URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.")] = None,
        user_auth_message: Annotated[Optional[StrictStr], Field(description="Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior")] = None,
        user_auth_required: Annotated[Optional[StrictBool], Field(description="Set to `true` or `1` to indicate the user must install your Slack app to trigger unfurls for this domain")] = None,
        user_auth_url: Annotated[Optional[StrictStr], Field(description="Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChatUnfurlSuccessSchema:
        """chat_unfurl

        Provide custom unfurl behavior for user-posted URLs

        :param token: Authentication token. Requires scope: `links:write` (required)
        :type token: str
        :param channel: Channel ID of the message (required)
        :type channel: str
        :param ts: Timestamp of the message to add unfurl behavior to. (required)
        :type ts: str
        :param unfurls: URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.
        :type unfurls: str
        :param user_auth_message: Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior
        :type user_auth_message: str
        :param user_auth_required: Set to `true` or `1` to indicate the user must install your Slack app to trigger unfurls for this domain
        :type user_auth_required: bool
        :param user_auth_url: Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
        :type user_auth_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_unfurl_serialize(
            token=token,
            channel=channel,
            ts=ts,
            unfurls=unfurls,
            user_auth_message=user_auth_message,
            user_auth_required=user_auth_required,
            user_auth_url=user_auth_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatUnfurlSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def chat_unfurl_with_http_info(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `links:write`")],
        channel: Annotated[StrictStr, Field(description="Channel ID of the message")],
        ts: Annotated[StrictStr, Field(description="Timestamp of the message to add unfurl behavior to.")],
        unfurls: Annotated[Optional[StrictStr], Field(description="URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.")] = None,
        user_auth_message: Annotated[Optional[StrictStr], Field(description="Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior")] = None,
        user_auth_required: Annotated[Optional[StrictBool], Field(description="Set to `true` or `1` to indicate the user must install your Slack app to trigger unfurls for this domain")] = None,
        user_auth_url: Annotated[Optional[StrictStr], Field(description="Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChatUnfurlSuccessSchema]:
        """chat_unfurl

        Provide custom unfurl behavior for user-posted URLs

        :param token: Authentication token. Requires scope: `links:write` (required)
        :type token: str
        :param channel: Channel ID of the message (required)
        :type channel: str
        :param ts: Timestamp of the message to add unfurl behavior to. (required)
        :type ts: str
        :param unfurls: URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.
        :type unfurls: str
        :param user_auth_message: Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior
        :type user_auth_message: str
        :param user_auth_required: Set to `true` or `1` to indicate the user must install your Slack app to trigger unfurls for this domain
        :type user_auth_required: bool
        :param user_auth_url: Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
        :type user_auth_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_unfurl_serialize(
            token=token,
            channel=channel,
            ts=ts,
            unfurls=unfurls,
            user_auth_message=user_auth_message,
            user_auth_required=user_auth_required,
            user_auth_url=user_auth_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatUnfurlSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def chat_unfurl_without_preload_content(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `links:write`")],
        channel: Annotated[StrictStr, Field(description="Channel ID of the message")],
        ts: Annotated[StrictStr, Field(description="Timestamp of the message to add unfurl behavior to.")],
        unfurls: Annotated[Optional[StrictStr], Field(description="URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.")] = None,
        user_auth_message: Annotated[Optional[StrictStr], Field(description="Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior")] = None,
        user_auth_required: Annotated[Optional[StrictBool], Field(description="Set to `true` or `1` to indicate the user must install your Slack app to trigger unfurls for this domain")] = None,
        user_auth_url: Annotated[Optional[StrictStr], Field(description="Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """chat_unfurl

        Provide custom unfurl behavior for user-posted URLs

        :param token: Authentication token. Requires scope: `links:write` (required)
        :type token: str
        :param channel: Channel ID of the message (required)
        :type channel: str
        :param ts: Timestamp of the message to add unfurl behavior to. (required)
        :type ts: str
        :param unfurls: URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.
        :type unfurls: str
        :param user_auth_message: Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior
        :type user_auth_message: str
        :param user_auth_required: Set to `true` or `1` to indicate the user must install your Slack app to trigger unfurls for this domain
        :type user_auth_required: bool
        :param user_auth_url: Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
        :type user_auth_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_unfurl_serialize(
            token=token,
            channel=channel,
            ts=ts,
            unfurls=unfurls,
            user_auth_message=user_auth_message,
            user_auth_required=user_auth_required,
            user_auth_url=user_auth_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatUnfurlSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _chat_unfurl_serialize(
        self,
        token,
        channel,
        ts,
        unfurls,
        user_auth_message,
        user_auth_required,
        user_auth_url,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if channel is not None:
            _form_params.append(('channel', channel))
        if ts is not None:
            _form_params.append(('ts', ts))
        if unfurls is not None:
            _form_params.append(('unfurls', unfurls))
        if user_auth_message is not None:
            _form_params.append(('user_auth_message', user_auth_message))
        if user_auth_required is not None:
            _form_params.append(('user_auth_required', user_auth_required))
        if user_auth_url is not None:
            _form_params.append(('user_auth_url', user_auth_url))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/chat.unfurl',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def chat_update(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="Channel containing the message to be updated.")],
        ts: Annotated[StrictStr, Field(description="Timestamp of the message to be updated.")],
        as_user: Annotated[Optional[StrictStr], Field(description="Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting `text`. If you don't include this field, the message's previous `attachments` will be retained. To remove previous `attachments`, include an empty array for this field.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of [structured blocks](/block-kit/building), presented as a URL-encoded string. If you don't include this field, the message's previous `blocks` will be retained. To remove previous `blocks`, include an empty array for this field.")] = None,
        link_names: Annotated[Optional[StrictStr], Field(description="Find and link channel names and usernames. Defaults to `none`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `none`.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `client`, unlike `chat.postMessage`. Accepts either `none` or `full`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `client`.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="New text for the message, using the [default formatting rules](/reference/surfaces/formatting). It's not required when presenting `blocks` or `attachments`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChatUpdateSuccessSchema:
        """chat_update

        Updates a message.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: Channel containing the message to be updated. (required)
        :type channel: str
        :param ts: Timestamp of the message to be updated. (required)
        :type ts: str
        :param as_user: Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.
        :type as_user: str
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting `text`. If you don't include this field, the message's previous `attachments` will be retained. To remove previous `attachments`, include an empty array for this field.
        :type attachments: str
        :param blocks: A JSON-based array of [structured blocks](/block-kit/building), presented as a URL-encoded string. If you don't include this field, the message's previous `blocks` will be retained. To remove previous `blocks`, include an empty array for this field.
        :type blocks: str
        :param link_names: Find and link channel names and usernames. Defaults to `none`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `none`.
        :type link_names: str
        :param parse: Change how messages are treated. Defaults to `client`, unlike `chat.postMessage`. Accepts either `none` or `full`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `client`.
        :type parse: str
        :param text: New text for the message, using the [default formatting rules](/reference/surfaces/formatting). It's not required when presenting `blocks` or `attachments`.
        :type text: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_update_serialize(
            token=token,
            channel=channel,
            ts=ts,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            link_names=link_names,
            parse=parse,
            text=text,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatUpdateSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def chat_update_with_http_info(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="Channel containing the message to be updated.")],
        ts: Annotated[StrictStr, Field(description="Timestamp of the message to be updated.")],
        as_user: Annotated[Optional[StrictStr], Field(description="Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting `text`. If you don't include this field, the message's previous `attachments` will be retained. To remove previous `attachments`, include an empty array for this field.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of [structured blocks](/block-kit/building), presented as a URL-encoded string. If you don't include this field, the message's previous `blocks` will be retained. To remove previous `blocks`, include an empty array for this field.")] = None,
        link_names: Annotated[Optional[StrictStr], Field(description="Find and link channel names and usernames. Defaults to `none`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `none`.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `client`, unlike `chat.postMessage`. Accepts either `none` or `full`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `client`.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="New text for the message, using the [default formatting rules](/reference/surfaces/formatting). It's not required when presenting `blocks` or `attachments`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChatUpdateSuccessSchema]:
        """chat_update

        Updates a message.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: Channel containing the message to be updated. (required)
        :type channel: str
        :param ts: Timestamp of the message to be updated. (required)
        :type ts: str
        :param as_user: Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.
        :type as_user: str
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting `text`. If you don't include this field, the message's previous `attachments` will be retained. To remove previous `attachments`, include an empty array for this field.
        :type attachments: str
        :param blocks: A JSON-based array of [structured blocks](/block-kit/building), presented as a URL-encoded string. If you don't include this field, the message's previous `blocks` will be retained. To remove previous `blocks`, include an empty array for this field.
        :type blocks: str
        :param link_names: Find and link channel names and usernames. Defaults to `none`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `none`.
        :type link_names: str
        :param parse: Change how messages are treated. Defaults to `client`, unlike `chat.postMessage`. Accepts either `none` or `full`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `client`.
        :type parse: str
        :param text: New text for the message, using the [default formatting rules](/reference/surfaces/formatting). It's not required when presenting `blocks` or `attachments`.
        :type text: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_update_serialize(
            token=token,
            channel=channel,
            ts=ts,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            link_names=link_names,
            parse=parse,
            text=text,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatUpdateSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def chat_update_without_preload_content(
        self,
        token: Annotated[StrictStr, Field(description="Authentication token. Requires scope: `chat:write`")],
        channel: Annotated[StrictStr, Field(description="Channel containing the message to be updated.")],
        ts: Annotated[StrictStr, Field(description="Timestamp of the message to be updated.")],
        as_user: Annotated[Optional[StrictStr], Field(description="Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.")] = None,
        attachments: Annotated[Optional[StrictStr], Field(description="A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting `text`. If you don't include this field, the message's previous `attachments` will be retained. To remove previous `attachments`, include an empty array for this field.")] = None,
        blocks: Annotated[Optional[StrictStr], Field(description="A JSON-based array of [structured blocks](/block-kit/building), presented as a URL-encoded string. If you don't include this field, the message's previous `blocks` will be retained. To remove previous `blocks`, include an empty array for this field.")] = None,
        link_names: Annotated[Optional[StrictStr], Field(description="Find and link channel names and usernames. Defaults to `none`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `none`.")] = None,
        parse: Annotated[Optional[StrictStr], Field(description="Change how messages are treated. Defaults to `client`, unlike `chat.postMessage`. Accepts either `none` or `full`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `client`.")] = None,
        text: Annotated[Optional[StrictStr], Field(description="New text for the message, using the [default formatting rules](/reference/surfaces/formatting). It's not required when presenting `blocks` or `attachments`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """chat_update

        Updates a message.

        :param token: Authentication token. Requires scope: `chat:write` (required)
        :type token: str
        :param channel: Channel containing the message to be updated. (required)
        :type channel: str
        :param ts: Timestamp of the message to be updated. (required)
        :type ts: str
        :param as_user: Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.
        :type as_user: str
        :param attachments: A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting `text`. If you don't include this field, the message's previous `attachments` will be retained. To remove previous `attachments`, include an empty array for this field.
        :type attachments: str
        :param blocks: A JSON-based array of [structured blocks](/block-kit/building), presented as a URL-encoded string. If you don't include this field, the message's previous `blocks` will be retained. To remove previous `blocks`, include an empty array for this field.
        :type blocks: str
        :param link_names: Find and link channel names and usernames. Defaults to `none`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `none`.
        :type link_names: str
        :param parse: Change how messages are treated. Defaults to `client`, unlike `chat.postMessage`. Accepts either `none` or `full`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `client`.
        :type parse: str
        :param text: New text for the message, using the [default formatting rules](/reference/surfaces/formatting). It's not required when presenting `blocks` or `attachments`.
        :type text: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._chat_update_serialize(
            token=token,
            channel=channel,
            ts=ts,
            as_user=as_user,
            attachments=attachments,
            blocks=blocks,
            link_names=link_names,
            parse=parse,
            text=text,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChatUpdateSuccessSchema",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _chat_update_serialize(
        self,
        token,
        channel,
        ts,
        as_user,
        attachments,
        blocks,
        link_names,
        parse,
        text,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if token is not None:
            _header_params['token'] = token
        # process the form parameters
        if as_user is not None:
            _form_params.append(('as_user', as_user))
        if attachments is not None:
            _form_params.append(('attachments', attachments))
        if blocks is not None:
            _form_params.append(('blocks', blocks))
        if channel is not None:
            _form_params.append(('channel', channel))
        if link_names is not None:
            _form_params.append(('link_names', link_names))
        if parse is not None:
            _form_params.append(('parse', parse))
        if text is not None:
            _form_params.append(('text', text))
        if ts is not None:
            _form_params.append(('ts', ts))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'slackAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/chat.update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


