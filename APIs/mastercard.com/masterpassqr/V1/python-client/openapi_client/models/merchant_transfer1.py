# coding: utf-8

"""
    Send Person to Merchant

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: V1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.participant13 import Participant13
from openapi_client.models.recipient7 import Recipient7
from openapi_client.models.reconciliation_data11 import ReconciliationData11
from openapi_client.models.sender3 import Sender3
from openapi_client.models.transfer_amount2 import TransferAmount2
from typing import Optional, Set
from typing_extensions import Self

class MerchantTransfer1(BaseModel):
    """
    Contains the details of the request message.
    """ # noqa: E501
    additional_message: Optional[StrictStr] = Field(default=None, description="Message a financial institution will associate to the transfer and may display. \\n\\nType: Alphanumeric Special [a-zA-Z0-9!\\\"#$%&'()*+,-./\\\\:;<=>?@[]_`{|}~], Length: 1-65")
    convenience_amount: Optional[StrictStr] = Field(default=None, description="Amount of the convenience fee. The decimal point is implied based on the transaction_amount.currency. \"[0-9]*\". Max Length: 12. Value must be less than payment_transfer.amount.")
    convenience_indicator: Optional[StrictStr] = Field(default=None, description="Convenience fee type code. Min length: 2. Max Length: 2. Valid values  (01: Indicates Consumer should be prompted to enter tip 02: Indicates that merchant would mandatorily charge a flat convenience fee 03: Indicates that merchant would charge a percentage convenience fee)")
    digital_account_reference_number: Optional[StrictStr] = Field(default=None, description="URI to identify the digital account reference number. URI scheme must be pan. Valid Values- Refer 'Account URIs'. ")
    interchange_rate_designator: Optional[StrictStr] = Field(default=None, description="Indicates the interchange rate and editing rules applied to the transaction. Field is applicable for Europe OIs only.  Type:Alphanumeric [a-zA-Z 0-9], Length: 2")
    mastercard_assigned_id: Optional[StrictStr] = Field(default=None, description="Mastercard Assigned ID for tiered interchange calculations.   Type: Numeric [0-9], Length: 6")
    participant: Participant13
    participation_id: Optional[StrictStr] = Field(default=None, description="Participation identifier of the sender. The receiving financial institution will associate the value to the transfer. \\n\\nType: Alphanumeric Special [a-zA-Z0-9!\\\"#$%&'()*+,-./\\\\:;<=>?@[]_`{|}~], Length: 1-30")
    payment_origination_country: Optional[StrictStr] = Field(default=None, description="Country where the payment originated from as an ISO 3166-1 alpha-3 country code.   Type: Alpha [A-Z], Length: 3")
    payment_type: StrictStr = Field(description="Payment type used for transfer. Value - P2M: Person to Merchant.   Type: Alphanumeric [A-Z0-9], Length: 3")
    processor_id: Optional[StrictStr] = Field(default=None, description="The processor ID is a ten-digit number of the form: 9000xxxxxx, where the Single Message System-assigned processor ID will be up to the last six digits xxxxxx. Partner must provide this value only if the program they are enabling requires it. For all other implementations this value must not be provided.   Type: Numeric [0-9], Length: 10")
    qr_data: Optional[StrictStr] = Field(default=None, description="Encoded QR (Quick Response) code data. Type: Alphanumeric and special characters [a-zA-Z0-9!\"#$%&'()*+,-./\\:;<=>?@[]_`{|}~], Maximum Length: 237")
    recipient: Recipient7
    recipient_account_uri: StrictStr = Field(description="URI to identify the account of the recipient/merchant. Pan, Manual Entry Alias and Alias are valid schemas. Refer 'Account URIs'")
    reconciliation_data: Optional[ReconciliationData11] = None
    routing_transit_number: Optional[StrictStr] = Field(default=None, description="The nine-digit Federal Reserve Routing and Transit (R & T) number of the acquiring institution or the nine-digit pseudo-number assigned to the acquiring institution by Mastercard. Partner must provide this value only if the program they are enabling requires it. For all other implementations this value must not be provided.    Type: Numeric [0-9], Length: 9")
    sender: Sender3
    sender_account_uri: StrictStr = Field(description="URI to identify the account information of the sender. Only PAN is the valid scheme. Refer 'Account URIs'")
    transaction_local_date_time: StrictStr = Field(description="Local date and time when the transaction is submitted as an ISO 8601 format.   Type: Alphanumerical Special [A-Z 0-9-:], Length: 25")
    transfer_amount: TransferAmount2
    transfer_reference: StrictStr = Field(description="Provide a unique transaction reference number. It must be a unique value for each request initiated by the partner.   Type: Alphanumeric Special [a-zA-Z0-9 * , - . _ ~], Length: 6-40")
    unique_reference_number: Optional[StrictStr] = Field(default=None, description="Unique reference number for the transaction.    Type: Alphanumeric [a-zA-Z 0-9], Maximum Length: 19")
    __properties: ClassVar[List[str]] = ["additional_message", "convenience_amount", "convenience_indicator", "digital_account_reference_number", "interchange_rate_designator", "mastercard_assigned_id", "participant", "participation_id", "payment_origination_country", "payment_type", "processor_id", "qr_data", "recipient", "recipient_account_uri", "reconciliation_data", "routing_transit_number", "sender", "sender_account_uri", "transaction_local_date_time", "transfer_amount", "transfer_reference", "unique_reference_number"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MerchantTransfer1 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of participant
        if self.participant:
            _dict['participant'] = self.participant.to_dict()
        # override the default output from pydantic by calling `to_dict()` of recipient
        if self.recipient:
            _dict['recipient'] = self.recipient.to_dict()
        # override the default output from pydantic by calling `to_dict()` of reconciliation_data
        if self.reconciliation_data:
            _dict['reconciliation_data'] = self.reconciliation_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sender
        if self.sender:
            _dict['sender'] = self.sender.to_dict()
        # override the default output from pydantic by calling `to_dict()` of transfer_amount
        if self.transfer_amount:
            _dict['transfer_amount'] = self.transfer_amount.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MerchantTransfer1 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "additional_message": obj.get("additional_message"),
            "convenience_amount": obj.get("convenience_amount"),
            "convenience_indicator": obj.get("convenience_indicator"),
            "digital_account_reference_number": obj.get("digital_account_reference_number"),
            "interchange_rate_designator": obj.get("interchange_rate_designator"),
            "mastercard_assigned_id": obj.get("mastercard_assigned_id"),
            "participant": Participant13.from_dict(obj["participant"]) if obj.get("participant") is not None else None,
            "participation_id": obj.get("participation_id"),
            "payment_origination_country": obj.get("payment_origination_country"),
            "payment_type": obj.get("payment_type"),
            "processor_id": obj.get("processor_id"),
            "qr_data": obj.get("qr_data"),
            "recipient": Recipient7.from_dict(obj["recipient"]) if obj.get("recipient") is not None else None,
            "recipient_account_uri": obj.get("recipient_account_uri"),
            "reconciliation_data": ReconciliationData11.from_dict(obj["reconciliation_data"]) if obj.get("reconciliation_data") is not None else None,
            "routing_transit_number": obj.get("routing_transit_number"),
            "sender": Sender3.from_dict(obj["sender"]) if obj.get("sender") is not None else None,
            "sender_account_uri": obj.get("sender_account_uri"),
            "transaction_local_date_time": obj.get("transaction_local_date_time"),
            "transfer_amount": TransferAmount2.from_dict(obj["transfer_amount"]) if obj.get("transfer_amount") is not None else None,
            "transfer_reference": obj.get("transfer_reference"),
            "unique_reference_number": obj.get("unique_reference_number")
        })
        return _obj


