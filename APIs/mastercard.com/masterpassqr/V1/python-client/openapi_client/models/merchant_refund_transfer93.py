# coding: utf-8

"""
    Send Person to Merchant

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: V1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.participant101 import Participant101
from openapi_client.models.payment_transaction_reference102 import PaymentTransactionReference102
from openapi_client.models.recipient96 import Recipient96
from openapi_client.models.reconciliation_data99 import ReconciliationData99
from openapi_client.models.sender94 import Sender94
from openapi_client.models.token_cryptogram103 import TokenCryptogram103
from typing import Optional, Set
from typing_extensions import Self

class MerchantRefundTransfer93(BaseModel):
    """
    Contains the details of the request message.
    """ # noqa: E501
    additional_message: Optional[StrictStr] = Field(default=None, description="Message a financial institution will associate to the transfer and may display. \\n\\nType: Alphanumeric Special [a-zA-Z0-9!\\\"#$%&'()*+,-./\\\\:;<=>?@[]_`{|}~], Length: 1-65")
    amount: StrictStr = Field(description="Amount of the transfer. The decimal point is implied based on the payment transfer currency. Details- 1-999999999999")
    authentication_value: Optional[StrictStr] = Field(default=None, description="List of name/value pairs containing authentication  values. Refer 'Authentication Value URIs'")
    channel: Optional[StrictStr] = Field(default=None, description="Initiation channel of the transfer request. This value can be defined in the onboarding process instead of passing in every call. Values: WEB, MOBILE, BANK, KIOSK. Details- Conditional")
    currency: StrictStr = Field(description="Currency of the transfer amount as an ISO alpha currency code. Details- Alpha, Length: 3")
    device_id: Optional[StrictStr] = Field(default=None, description="The serial number of a device initiating the transfer. Details- 1-40")
    digital_account_reference_number: Optional[StrictStr] = Field(default=None, description="URI to identify the digital account reference number. URI scheme must be pan. If merchant_refund_transfer.sender_account_uri does not start with PAN, the Digital Account Reference Number is required. Valid Values- Refer 'Account URIs'.")
    funding_source: StrictStr = Field(description="Funding source must contain one of the following: CREDIT, DEBIT, PREPAID, DEPOSIT_ACCOUNT, MOBILE_MONEY_ACCOUNT, CASH. In the Asia/Pacific region, funding sources are limited to Mastercard cards. In Subfield 1 values 04, 05, 06, and 07 are not applicable.")
    interchange_rate_designator: Optional[StrictStr] = Field(default=None, description="Indicates the interchange rate and editing rules applied to the transaction.  Type:Alphanumeric [a-zA-Z 0-9], Length: 2")
    location: Optional[StrictStr] = Field(default=None, description="Location where the transaction is initiated. Valid Values- Refer 'Location URIs'.")
    mastercard_assigned_id: Optional[StrictStr] = Field(default=None, description="Mastercard Assigned ID for tiered interchange calculations. This field can be provided when available if transfer.payment_type is P2M. Type: Numeric [0-9], Maximum Length: 6")
    participant: Optional[Participant101] = None
    participation_id: Optional[StrictStr] = Field(default=None, description="Participation identifier of the sender. The receiving financial institution will associate the value to the transfer. Details- 1-30")
    payment_origination_country: Optional[StrictStr] = Field(default=None, description="The country where the payment originates from as an ISO 3166-1 alpha-3 country code, in uppercase. Details - Conditional. If provided, this should match a valid country configured for the partner during onboarding. If the partner is configured for multiple origination countries this field is required and must be provided. Alpha, length: 3")
    payment_transaction_reference: Optional[PaymentTransactionReference102] = None
    payment_type: StrictStr = Field(description="MRF: Merchant Refund")
    processor_id: Optional[StrictStr] = Field(default=None, description="The processor ID is a ten-digit number of the form: 9000xxxxxx, where the Single Message System-assigned processor ID will be up to the last six digits xxxxxx. If the partner is enrolled in multiple processorId numbers, the processorId number must be specified. If the partner is only enrolled in a single processorId number then system takes the onboarded value. Please contact your MasterCard Representative to enable the usage of fields in this section. Details- Numeric, 10")
    recipient: Optional[Recipient96] = None
    reconciliation_data: Optional[ReconciliationData99] = None
    routing_transit_number: Optional[StrictStr] = Field(default=None, description="The nine-digit Federal Reserve Routing and Transit (R & T) number of the acquiring institution or the nine-digit pseudo-number assigned to the acquiring institution by Mastercard. If the partner is enrolled in multiple routing transit numbers, the routing transit number must be specified. If the partner is only enrolled in a single routing transit number then system takes the onboarded value. Please contact your MasterCard Representative to enable the usage of fields in this section. Details- Numeric, 9")
    sender: Optional[Sender94] = None
    sender_account_uri: StrictStr = Field(description="URI to identify the account information of the sender. When PAN is the URI then sender information is required. If scheme chosen is raw, then funding_source must be other than CREDIT, DEBIT or PREPAID. Valid Values- Refer 'Account URIs'")
    token_cryptogram: Optional[TokenCryptogram103] = None
    transaction_local_date_time: StrictStr = Field(description="Local date and time when the transaction is submitted. Details-YYYY-MM-DDTHH:MM:SSÂ±hh[:mm] ")
    transfer_reference: StrictStr = Field(description="Provide a unique transaction reference number. It must be a unique value for the partner. Details- 6-40, Allowable characters are alphanumeric and * , - . _ ~")
    __properties: ClassVar[List[str]] = ["additional_message", "amount", "authentication_value", "channel", "currency", "device_id", "digital_account_reference_number", "funding_source", "interchange_rate_designator", "location", "mastercard_assigned_id", "participant", "participation_id", "payment_origination_country", "payment_transaction_reference", "payment_type", "processor_id", "recipient", "reconciliation_data", "routing_transit_number", "sender", "sender_account_uri", "token_cryptogram", "transaction_local_date_time", "transfer_reference"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MerchantRefundTransfer93 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of participant
        if self.participant:
            _dict['participant'] = self.participant.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payment_transaction_reference
        if self.payment_transaction_reference:
            _dict['payment_transaction_reference'] = self.payment_transaction_reference.to_dict()
        # override the default output from pydantic by calling `to_dict()` of recipient
        if self.recipient:
            _dict['recipient'] = self.recipient.to_dict()
        # override the default output from pydantic by calling `to_dict()` of reconciliation_data
        if self.reconciliation_data:
            _dict['reconciliation_data'] = self.reconciliation_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sender
        if self.sender:
            _dict['sender'] = self.sender.to_dict()
        # override the default output from pydantic by calling `to_dict()` of token_cryptogram
        if self.token_cryptogram:
            _dict['token_cryptogram'] = self.token_cryptogram.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MerchantRefundTransfer93 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "additional_message": obj.get("additional_message"),
            "amount": obj.get("amount"),
            "authentication_value": obj.get("authentication_value"),
            "channel": obj.get("channel"),
            "currency": obj.get("currency"),
            "device_id": obj.get("device_id"),
            "digital_account_reference_number": obj.get("digital_account_reference_number"),
            "funding_source": obj.get("funding_source"),
            "interchange_rate_designator": obj.get("interchange_rate_designator"),
            "location": obj.get("location"),
            "mastercard_assigned_id": obj.get("mastercard_assigned_id"),
            "participant": Participant101.from_dict(obj["participant"]) if obj.get("participant") is not None else None,
            "participation_id": obj.get("participation_id"),
            "payment_origination_country": obj.get("payment_origination_country"),
            "payment_transaction_reference": PaymentTransactionReference102.from_dict(obj["payment_transaction_reference"]) if obj.get("payment_transaction_reference") is not None else None,
            "payment_type": obj.get("payment_type"),
            "processor_id": obj.get("processor_id"),
            "recipient": Recipient96.from_dict(obj["recipient"]) if obj.get("recipient") is not None else None,
            "reconciliation_data": ReconciliationData99.from_dict(obj["reconciliation_data"]) if obj.get("reconciliation_data") is not None else None,
            "routing_transit_number": obj.get("routing_transit_number"),
            "sender": Sender94.from_dict(obj["sender"]) if obj.get("sender") is not None else None,
            "sender_account_uri": obj.get("sender_account_uri"),
            "token_cryptogram": TokenCryptogram103.from_dict(obj["token_cryptogram"]) if obj.get("token_cryptogram") is not None else None,
            "transaction_local_date_time": obj.get("transaction_local_date_time"),
            "transfer_reference": obj.get("transfer_reference")
        })
        return _obj


