# coding: utf-8

"""
    LH Partner API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import Optional
from typing_extensions import Annotated

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class OffersApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def all_fares(
        self,
        catalogues: Annotated[StrictStr, Field(description="Specifies in which catalogue the fares need to be searched (e.g.'4U;OS').")],
        origin: Annotated[StrictStr, Field(description="Enter journey origin (e.g 'FRA').")],
        destination: Annotated[StrictStr, Field(description="Enter journey destination (e.g 'MAD').")],
        travel_date: Annotated[StrictStr, Field(description="Enter journey travel-date (e.g 2016-10-20)")],
        return_date: Annotated[Optional[StrictStr], Field(description="Enter journey return-date (e.g 2016-10-31)'.")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Enter the required cabin class (e.g econonmy, business etc.). (Acceptable values are: \"\", \"economy\", \"premium economy\", \"business\", \"first\")")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Specifies the type and number of travelers (e.g. '(adult=2;child=2;infant=1)') For LH only (adult=1) possible.")] = None,
        fare_family: Annotated[Optional[StrictStr], Field(description="Mandatory for 4U. Specifies, which fares to be returned, such as basic, smart, best, smartflex, bestflex . (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        trackingid: Annotated[Optional[StrictStr], Field(description="Austrian Airlines only - specify the web tracking id to be used in OS Deep link.")] = None,
        accept: Annotated[Optional[StrictStr], Field(description="Mandatory http header:  application/xml or application/json")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """All Fares

        Retrieves all available fares for a specific Origin & Destination pair on a given date. Available fares are: One-way and Return for 4U. Return only for OS

        :param catalogues: Specifies in which catalogue the fares need to be searched (e.g.'4U;OS'). (required)
        :type catalogues: str
        :param origin: Enter journey origin (e.g 'FRA'). (required)
        :type origin: str
        :param destination: Enter journey destination (e.g 'MAD'). (required)
        :type destination: str
        :param travel_date: Enter journey travel-date (e.g 2016-10-20) (required)
        :type travel_date: str
        :param return_date: Enter journey return-date (e.g 2016-10-31)'.
        :type return_date: str
        :param cabin_class: Enter the required cabin class (e.g econonmy, business etc.). (Acceptable values are: \"\", \"economy\", \"premium economy\", \"business\", \"first\")
        :type cabin_class: str
        :param travelers: Specifies the type and number of travelers (e.g. '(adult=2;child=2;infant=1)') For LH only (adult=1) possible.
        :type travelers: str
        :param fare_family: Mandatory for 4U. Specifies, which fares to be returned, such as basic, smart, best, smartflex, bestflex . (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_family: str
        :param trackingid: Austrian Airlines only - specify the web tracking id to be used in OS Deep link.
        :type trackingid: str
        :param accept: Mandatory http header:  application/xml or application/json
        :type accept: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._all_fares_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            return_date=return_date,
            cabin_class=cabin_class,
            travelers=travelers,
            fare_family=fare_family,
            trackingid=trackingid,
            accept=accept,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def all_fares_with_http_info(
        self,
        catalogues: Annotated[StrictStr, Field(description="Specifies in which catalogue the fares need to be searched (e.g.'4U;OS').")],
        origin: Annotated[StrictStr, Field(description="Enter journey origin (e.g 'FRA').")],
        destination: Annotated[StrictStr, Field(description="Enter journey destination (e.g 'MAD').")],
        travel_date: Annotated[StrictStr, Field(description="Enter journey travel-date (e.g 2016-10-20)")],
        return_date: Annotated[Optional[StrictStr], Field(description="Enter journey return-date (e.g 2016-10-31)'.")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Enter the required cabin class (e.g econonmy, business etc.). (Acceptable values are: \"\", \"economy\", \"premium economy\", \"business\", \"first\")")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Specifies the type and number of travelers (e.g. '(adult=2;child=2;infant=1)') For LH only (adult=1) possible.")] = None,
        fare_family: Annotated[Optional[StrictStr], Field(description="Mandatory for 4U. Specifies, which fares to be returned, such as basic, smart, best, smartflex, bestflex . (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        trackingid: Annotated[Optional[StrictStr], Field(description="Austrian Airlines only - specify the web tracking id to be used in OS Deep link.")] = None,
        accept: Annotated[Optional[StrictStr], Field(description="Mandatory http header:  application/xml or application/json")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """All Fares

        Retrieves all available fares for a specific Origin & Destination pair on a given date. Available fares are: One-way and Return for 4U. Return only for OS

        :param catalogues: Specifies in which catalogue the fares need to be searched (e.g.'4U;OS'). (required)
        :type catalogues: str
        :param origin: Enter journey origin (e.g 'FRA'). (required)
        :type origin: str
        :param destination: Enter journey destination (e.g 'MAD'). (required)
        :type destination: str
        :param travel_date: Enter journey travel-date (e.g 2016-10-20) (required)
        :type travel_date: str
        :param return_date: Enter journey return-date (e.g 2016-10-31)'.
        :type return_date: str
        :param cabin_class: Enter the required cabin class (e.g econonmy, business etc.). (Acceptable values are: \"\", \"economy\", \"premium economy\", \"business\", \"first\")
        :type cabin_class: str
        :param travelers: Specifies the type and number of travelers (e.g. '(adult=2;child=2;infant=1)') For LH only (adult=1) possible.
        :type travelers: str
        :param fare_family: Mandatory for 4U. Specifies, which fares to be returned, such as basic, smart, best, smartflex, bestflex . (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_family: str
        :param trackingid: Austrian Airlines only - specify the web tracking id to be used in OS Deep link.
        :type trackingid: str
        :param accept: Mandatory http header:  application/xml or application/json
        :type accept: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._all_fares_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            return_date=return_date,
            cabin_class=cabin_class,
            travelers=travelers,
            fare_family=fare_family,
            trackingid=trackingid,
            accept=accept,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def all_fares_without_preload_content(
        self,
        catalogues: Annotated[StrictStr, Field(description="Specifies in which catalogue the fares need to be searched (e.g.'4U;OS').")],
        origin: Annotated[StrictStr, Field(description="Enter journey origin (e.g 'FRA').")],
        destination: Annotated[StrictStr, Field(description="Enter journey destination (e.g 'MAD').")],
        travel_date: Annotated[StrictStr, Field(description="Enter journey travel-date (e.g 2016-10-20)")],
        return_date: Annotated[Optional[StrictStr], Field(description="Enter journey return-date (e.g 2016-10-31)'.")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Enter the required cabin class (e.g econonmy, business etc.). (Acceptable values are: \"\", \"economy\", \"premium economy\", \"business\", \"first\")")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Specifies the type and number of travelers (e.g. '(adult=2;child=2;infant=1)') For LH only (adult=1) possible.")] = None,
        fare_family: Annotated[Optional[StrictStr], Field(description="Mandatory for 4U. Specifies, which fares to be returned, such as basic, smart, best, smartflex, bestflex . (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        trackingid: Annotated[Optional[StrictStr], Field(description="Austrian Airlines only - specify the web tracking id to be used in OS Deep link.")] = None,
        accept: Annotated[Optional[StrictStr], Field(description="Mandatory http header:  application/xml or application/json")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """All Fares

        Retrieves all available fares for a specific Origin & Destination pair on a given date. Available fares are: One-way and Return for 4U. Return only for OS

        :param catalogues: Specifies in which catalogue the fares need to be searched (e.g.'4U;OS'). (required)
        :type catalogues: str
        :param origin: Enter journey origin (e.g 'FRA'). (required)
        :type origin: str
        :param destination: Enter journey destination (e.g 'MAD'). (required)
        :type destination: str
        :param travel_date: Enter journey travel-date (e.g 2016-10-20) (required)
        :type travel_date: str
        :param return_date: Enter journey return-date (e.g 2016-10-31)'.
        :type return_date: str
        :param cabin_class: Enter the required cabin class (e.g econonmy, business etc.). (Acceptable values are: \"\", \"economy\", \"premium economy\", \"business\", \"first\")
        :type cabin_class: str
        :param travelers: Specifies the type and number of travelers (e.g. '(adult=2;child=2;infant=1)') For LH only (adult=1) possible.
        :type travelers: str
        :param fare_family: Mandatory for 4U. Specifies, which fares to be returned, such as basic, smart, best, smartflex, bestflex . (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_family: str
        :param trackingid: Austrian Airlines only - specify the web tracking id to be used in OS Deep link.
        :type trackingid: str
        :param accept: Mandatory http header:  application/xml or application/json
        :type accept: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._all_fares_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            return_date=return_date,
            cabin_class=cabin_class,
            travelers=travelers,
            fare_family=fare_family,
            trackingid=trackingid,
            accept=accept,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _all_fares_serialize(
        self,
        catalogues,
        origin,
        destination,
        travel_date,
        return_date,
        cabin_class,
        travelers,
        fare_family,
        trackingid,
        accept,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if catalogues is not None:
            
            _query_params.append(('catalogues', catalogues))
            
        if origin is not None:
            
            _query_params.append(('origin', origin))
            
        if destination is not None:
            
            _query_params.append(('destination', destination))
            
        if travel_date is not None:
            
            _query_params.append(('travel-date', travel_date))
            
        if return_date is not None:
            
            _query_params.append(('return-date', return_date))
            
        if cabin_class is not None:
            
            _query_params.append(('cabin-class', cabin_class))
            
        if travelers is not None:
            
            _query_params.append(('travelers', travelers))
            
        if fare_family is not None:
            
            _query_params.append(('fare-family', fare_family))
            
        if trackingid is not None:
            
            _query_params.append(('trackingid', trackingid))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/fares/allfares',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def best_fares(
        self,
        catalogues: Annotated[StrictStr, Field(description="Search fares from these carriers' catalogues (e.g. '4U;OS;LH')")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA airport code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport code (e.g. 'MAD')")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date (YYYY-MM-DD)")],
        trip_duration: Annotated[StrictStr, Field(description="Trip duration in days (e.g. '7')")],
        range: Annotated[StrictStr, Field(description="Fare range: 'byday' or 'bymonth' (Acceptable values are: \"byday\", \"bymonth\")")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')")] = None,
        trackingid: Annotated[Optional[StrictStr], Field(description="Austrian Airlines only - specify the web tracking id to be used in OS Deep link.")] = None,
        fare_family: Annotated[Optional[StrictStr], Field(description="Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Best Fares

        Retrieve best fares for the requested journey across multiple days or multiple months.

        :param catalogues: Search fares from these carriers' catalogues (e.g. '4U;OS;LH') (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA airport code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport code (e.g. 'MAD') (required)
        :type destination: str
        :param travel_date: Journey travel-date (YYYY-MM-DD) (required)
        :type travel_date: str
        :param trip_duration: Trip duration in days (e.g. '7') (required)
        :type trip_duration: str
        :param range: Fare range: 'byday' or 'bymonth' (Acceptable values are: \"byday\", \"bymonth\") (required)
        :type range: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param country: Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')
        :type country: str
        :param trackingid: Austrian Airlines only - specify the web tracking id to be used in OS Deep link.
        :type trackingid: str
        :param fare_family: Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_family: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._best_fares_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            trip_duration=trip_duration,
            range=range,
            accept=accept,
            cabin_class=cabin_class,
            country=country,
            trackingid=trackingid,
            fare_family=fare_family,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def best_fares_with_http_info(
        self,
        catalogues: Annotated[StrictStr, Field(description="Search fares from these carriers' catalogues (e.g. '4U;OS;LH')")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA airport code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport code (e.g. 'MAD')")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date (YYYY-MM-DD)")],
        trip_duration: Annotated[StrictStr, Field(description="Trip duration in days (e.g. '7')")],
        range: Annotated[StrictStr, Field(description="Fare range: 'byday' or 'bymonth' (Acceptable values are: \"byday\", \"bymonth\")")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')")] = None,
        trackingid: Annotated[Optional[StrictStr], Field(description="Austrian Airlines only - specify the web tracking id to be used in OS Deep link.")] = None,
        fare_family: Annotated[Optional[StrictStr], Field(description="Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Best Fares

        Retrieve best fares for the requested journey across multiple days or multiple months.

        :param catalogues: Search fares from these carriers' catalogues (e.g. '4U;OS;LH') (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA airport code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport code (e.g. 'MAD') (required)
        :type destination: str
        :param travel_date: Journey travel-date (YYYY-MM-DD) (required)
        :type travel_date: str
        :param trip_duration: Trip duration in days (e.g. '7') (required)
        :type trip_duration: str
        :param range: Fare range: 'byday' or 'bymonth' (Acceptable values are: \"byday\", \"bymonth\") (required)
        :type range: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param country: Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')
        :type country: str
        :param trackingid: Austrian Airlines only - specify the web tracking id to be used in OS Deep link.
        :type trackingid: str
        :param fare_family: Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_family: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._best_fares_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            trip_duration=trip_duration,
            range=range,
            accept=accept,
            cabin_class=cabin_class,
            country=country,
            trackingid=trackingid,
            fare_family=fare_family,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def best_fares_without_preload_content(
        self,
        catalogues: Annotated[StrictStr, Field(description="Search fares from these carriers' catalogues (e.g. '4U;OS;LH')")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA airport code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport code (e.g. 'MAD')")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date (YYYY-MM-DD)")],
        trip_duration: Annotated[StrictStr, Field(description="Trip duration in days (e.g. '7')")],
        range: Annotated[StrictStr, Field(description="Fare range: 'byday' or 'bymonth' (Acceptable values are: \"byday\", \"bymonth\")")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')")] = None,
        trackingid: Annotated[Optional[StrictStr], Field(description="Austrian Airlines only - specify the web tracking id to be used in OS Deep link.")] = None,
        fare_family: Annotated[Optional[StrictStr], Field(description="Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Best Fares

        Retrieve best fares for the requested journey across multiple days or multiple months.

        :param catalogues: Search fares from these carriers' catalogues (e.g. '4U;OS;LH') (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA airport code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport code (e.g. 'MAD') (required)
        :type destination: str
        :param travel_date: Journey travel-date (YYYY-MM-DD) (required)
        :type travel_date: str
        :param trip_duration: Trip duration in days (e.g. '7') (required)
        :type trip_duration: str
        :param range: Fare range: 'byday' or 'bymonth' (Acceptable values are: \"byday\", \"bymonth\") (required)
        :type range: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param country: Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')
        :type country: str
        :param trackingid: Austrian Airlines only - specify the web tracking id to be used in OS Deep link.
        :type trackingid: str
        :param fare_family: Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_family: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._best_fares_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            trip_duration=trip_duration,
            range=range,
            accept=accept,
            cabin_class=cabin_class,
            country=country,
            trackingid=trackingid,
            fare_family=fare_family,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _best_fares_serialize(
        self,
        catalogues,
        origin,
        destination,
        travel_date,
        trip_duration,
        range,
        accept,
        cabin_class,
        country,
        trackingid,
        fare_family,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if catalogues is not None:
            
            _query_params.append(('catalogues', catalogues))
            
        if origin is not None:
            
            _query_params.append(('origin', origin))
            
        if destination is not None:
            
            _query_params.append(('destination', destination))
            
        if travel_date is not None:
            
            _query_params.append(('travel-date', travel_date))
            
        if trip_duration is not None:
            
            _query_params.append(('trip-duration', trip_duration))
            
        if range is not None:
            
            _query_params.append(('range', range))
            
        if cabin_class is not None:
            
            _query_params.append(('cabin-class', cabin_class))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if trackingid is not None:
            
            _query_params.append(('trackingid', trackingid))
            
        if fare_family is not None:
            
            _query_params.append(('fare-family', fare_family))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/fares/bestfares',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def deep_links(
        self,
        catalogues: Annotated[StrictStr, Field(description="Carrier for which the deep link will be created (e.g. 'LH')")],
        trackingid: Annotated[StrictStr, Field(description="Deep link tracking ID")],
        country: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 country code")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        origin: Annotated[Optional[StrictStr], Field(description="Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')")] = None,
        origin_name: Annotated[Optional[StrictStr], Field(description="Journey origin airport or city name (e.g. 'frankfurt')")] = None,
        destination: Annotated[Optional[StrictStr], Field(description="Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')")] = None,
        destination_name: Annotated[Optional[StrictStr], Field(description="Journey destination airport or city name (e.g. 'madrid')")] = None,
        travel_date: Annotated[Optional[StrictStr], Field(description="Journey travel-date (YYYY-MM-DD)")] = None,
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date (YYYY-MM-DD)")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        outbound_segments: Annotated[Optional[StrictStr], Field(description="Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480')")] = None,
        return_segments: Annotated[Optional[StrictStr], Field(description="Flight segments in the sequence of travel (e.g. 'LH7465;LH431')")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')")] = None,
        fare: Annotated[Optional[StrictStr], Field(description="Travel fare (e.g. '1341.45')")] = None,
        net_fare: Annotated[Optional[StrictStr], Field(description="Travel net fare. Total fare less taxes and charges (e.g. '1140')")] = None,
        fare_currency: Annotated[Optional[StrictStr], Field(description="Fare currency (e.g. 'EUR')")] = None,
        partnerid: Annotated[Optional[StrictStr], Field(description="Deep link partner id (e.g. '1247')")] = None,
        encryption_key: Annotated[Optional[StrictStr], Field(description="Deep link encryption-key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Deep Links

        Returns valid deep links for the provided input parameters

        :param catalogues: Carrier for which the deep link will be created (e.g. 'LH') (required)
        :type catalogues: str
        :param trackingid: Deep link tracking ID (required)
        :type trackingid: str
        :param country: 2-letter ISO 3166-1 country code (required)
        :type country: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param origin: Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')
        :type origin: str
        :param origin_name: Journey origin airport or city name (e.g. 'frankfurt')
        :type origin_name: str
        :param destination: Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')
        :type destination: str
        :param destination_name: Journey destination airport or city name (e.g. 'madrid')
        :type destination_name: str
        :param travel_date: Journey travel-date (YYYY-MM-DD)
        :type travel_date: str
        :param return_date: Journey return-date (YYYY-MM-DD)
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param outbound_segments: Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480')
        :type outbound_segments: str
        :param return_segments: Flight segments in the sequence of travel (e.g. 'LH7465;LH431')
        :type return_segments: str
        :param travelers: Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')
        :type travelers: str
        :param fare: Travel fare (e.g. '1341.45')
        :type fare: str
        :param net_fare: Travel net fare. Total fare less taxes and charges (e.g. '1140')
        :type net_fare: str
        :param fare_currency: Fare currency (e.g. 'EUR')
        :type fare_currency: str
        :param partnerid: Deep link partner id (e.g. '1247')
        :type partnerid: str
        :param encryption_key: Deep link encryption-key
        :type encryption_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._deep_links_serialize(
            catalogues=catalogues,
            trackingid=trackingid,
            country=country,
            lang=lang,
            accept=accept,
            origin=origin,
            origin_name=origin_name,
            destination=destination,
            destination_name=destination_name,
            travel_date=travel_date,
            return_date=return_date,
            cabin_class=cabin_class,
            outbound_segments=outbound_segments,
            return_segments=return_segments,
            travelers=travelers,
            fare=fare,
            net_fare=net_fare,
            fare_currency=fare_currency,
            partnerid=partnerid,
            encryption_key=encryption_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def deep_links_with_http_info(
        self,
        catalogues: Annotated[StrictStr, Field(description="Carrier for which the deep link will be created (e.g. 'LH')")],
        trackingid: Annotated[StrictStr, Field(description="Deep link tracking ID")],
        country: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 country code")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        origin: Annotated[Optional[StrictStr], Field(description="Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')")] = None,
        origin_name: Annotated[Optional[StrictStr], Field(description="Journey origin airport or city name (e.g. 'frankfurt')")] = None,
        destination: Annotated[Optional[StrictStr], Field(description="Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')")] = None,
        destination_name: Annotated[Optional[StrictStr], Field(description="Journey destination airport or city name (e.g. 'madrid')")] = None,
        travel_date: Annotated[Optional[StrictStr], Field(description="Journey travel-date (YYYY-MM-DD)")] = None,
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date (YYYY-MM-DD)")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        outbound_segments: Annotated[Optional[StrictStr], Field(description="Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480')")] = None,
        return_segments: Annotated[Optional[StrictStr], Field(description="Flight segments in the sequence of travel (e.g. 'LH7465;LH431')")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')")] = None,
        fare: Annotated[Optional[StrictStr], Field(description="Travel fare (e.g. '1341.45')")] = None,
        net_fare: Annotated[Optional[StrictStr], Field(description="Travel net fare. Total fare less taxes and charges (e.g. '1140')")] = None,
        fare_currency: Annotated[Optional[StrictStr], Field(description="Fare currency (e.g. 'EUR')")] = None,
        partnerid: Annotated[Optional[StrictStr], Field(description="Deep link partner id (e.g. '1247')")] = None,
        encryption_key: Annotated[Optional[StrictStr], Field(description="Deep link encryption-key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Deep Links

        Returns valid deep links for the provided input parameters

        :param catalogues: Carrier for which the deep link will be created (e.g. 'LH') (required)
        :type catalogues: str
        :param trackingid: Deep link tracking ID (required)
        :type trackingid: str
        :param country: 2-letter ISO 3166-1 country code (required)
        :type country: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param origin: Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')
        :type origin: str
        :param origin_name: Journey origin airport or city name (e.g. 'frankfurt')
        :type origin_name: str
        :param destination: Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')
        :type destination: str
        :param destination_name: Journey destination airport or city name (e.g. 'madrid')
        :type destination_name: str
        :param travel_date: Journey travel-date (YYYY-MM-DD)
        :type travel_date: str
        :param return_date: Journey return-date (YYYY-MM-DD)
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param outbound_segments: Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480')
        :type outbound_segments: str
        :param return_segments: Flight segments in the sequence of travel (e.g. 'LH7465;LH431')
        :type return_segments: str
        :param travelers: Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')
        :type travelers: str
        :param fare: Travel fare (e.g. '1341.45')
        :type fare: str
        :param net_fare: Travel net fare. Total fare less taxes and charges (e.g. '1140')
        :type net_fare: str
        :param fare_currency: Fare currency (e.g. 'EUR')
        :type fare_currency: str
        :param partnerid: Deep link partner id (e.g. '1247')
        :type partnerid: str
        :param encryption_key: Deep link encryption-key
        :type encryption_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._deep_links_serialize(
            catalogues=catalogues,
            trackingid=trackingid,
            country=country,
            lang=lang,
            accept=accept,
            origin=origin,
            origin_name=origin_name,
            destination=destination,
            destination_name=destination_name,
            travel_date=travel_date,
            return_date=return_date,
            cabin_class=cabin_class,
            outbound_segments=outbound_segments,
            return_segments=return_segments,
            travelers=travelers,
            fare=fare,
            net_fare=net_fare,
            fare_currency=fare_currency,
            partnerid=partnerid,
            encryption_key=encryption_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def deep_links_without_preload_content(
        self,
        catalogues: Annotated[StrictStr, Field(description="Carrier for which the deep link will be created (e.g. 'LH')")],
        trackingid: Annotated[StrictStr, Field(description="Deep link tracking ID")],
        country: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 country code")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        origin: Annotated[Optional[StrictStr], Field(description="Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')")] = None,
        origin_name: Annotated[Optional[StrictStr], Field(description="Journey origin airport or city name (e.g. 'frankfurt')")] = None,
        destination: Annotated[Optional[StrictStr], Field(description="Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')")] = None,
        destination_name: Annotated[Optional[StrictStr], Field(description="Journey destination airport or city name (e.g. 'madrid')")] = None,
        travel_date: Annotated[Optional[StrictStr], Field(description="Journey travel-date (YYYY-MM-DD)")] = None,
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date (YYYY-MM-DD)")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        outbound_segments: Annotated[Optional[StrictStr], Field(description="Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480')")] = None,
        return_segments: Annotated[Optional[StrictStr], Field(description="Flight segments in the sequence of travel (e.g. 'LH7465;LH431')")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')")] = None,
        fare: Annotated[Optional[StrictStr], Field(description="Travel fare (e.g. '1341.45')")] = None,
        net_fare: Annotated[Optional[StrictStr], Field(description="Travel net fare. Total fare less taxes and charges (e.g. '1140')")] = None,
        fare_currency: Annotated[Optional[StrictStr], Field(description="Fare currency (e.g. 'EUR')")] = None,
        partnerid: Annotated[Optional[StrictStr], Field(description="Deep link partner id (e.g. '1247')")] = None,
        encryption_key: Annotated[Optional[StrictStr], Field(description="Deep link encryption-key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deep Links

        Returns valid deep links for the provided input parameters

        :param catalogues: Carrier for which the deep link will be created (e.g. 'LH') (required)
        :type catalogues: str
        :param trackingid: Deep link tracking ID (required)
        :type trackingid: str
        :param country: 2-letter ISO 3166-1 country code (required)
        :type country: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param origin: Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')
        :type origin: str
        :param origin_name: Journey origin airport or city name (e.g. 'frankfurt')
        :type origin_name: str
        :param destination: Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')
        :type destination: str
        :param destination_name: Journey destination airport or city name (e.g. 'madrid')
        :type destination_name: str
        :param travel_date: Journey travel-date (YYYY-MM-DD)
        :type travel_date: str
        :param return_date: Journey return-date (YYYY-MM-DD)
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param outbound_segments: Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480')
        :type outbound_segments: str
        :param return_segments: Flight segments in the sequence of travel (e.g. 'LH7465;LH431')
        :type return_segments: str
        :param travelers: Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')
        :type travelers: str
        :param fare: Travel fare (e.g. '1341.45')
        :type fare: str
        :param net_fare: Travel net fare. Total fare less taxes and charges (e.g. '1140')
        :type net_fare: str
        :param fare_currency: Fare currency (e.g. 'EUR')
        :type fare_currency: str
        :param partnerid: Deep link partner id (e.g. '1247')
        :type partnerid: str
        :param encryption_key: Deep link encryption-key
        :type encryption_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._deep_links_serialize(
            catalogues=catalogues,
            trackingid=trackingid,
            country=country,
            lang=lang,
            accept=accept,
            origin=origin,
            origin_name=origin_name,
            destination=destination,
            destination_name=destination_name,
            travel_date=travel_date,
            return_date=return_date,
            cabin_class=cabin_class,
            outbound_segments=outbound_segments,
            return_segments=return_segments,
            travelers=travelers,
            fare=fare,
            net_fare=net_fare,
            fare_currency=fare_currency,
            partnerid=partnerid,
            encryption_key=encryption_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _deep_links_serialize(
        self,
        catalogues,
        trackingid,
        country,
        lang,
        accept,
        origin,
        origin_name,
        destination,
        destination_name,
        travel_date,
        return_date,
        cabin_class,
        outbound_segments,
        return_segments,
        travelers,
        fare,
        net_fare,
        fare_currency,
        partnerid,
        encryption_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if catalogues is not None:
            
            _query_params.append(('catalogues', catalogues))
            
        if trackingid is not None:
            
            _query_params.append(('trackingid', trackingid))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        if origin is not None:
            
            _query_params.append(('origin', origin))
            
        if origin_name is not None:
            
            _query_params.append(('origin-name', origin_name))
            
        if destination is not None:
            
            _query_params.append(('destination', destination))
            
        if destination_name is not None:
            
            _query_params.append(('destination-name', destination_name))
            
        if travel_date is not None:
            
            _query_params.append(('travel-date', travel_date))
            
        if return_date is not None:
            
            _query_params.append(('return-date', return_date))
            
        if cabin_class is not None:
            
            _query_params.append(('cabin-class', cabin_class))
            
        if outbound_segments is not None:
            
            _query_params.append(('outbound-segments', outbound_segments))
            
        if return_segments is not None:
            
            _query_params.append(('return-segments', return_segments))
            
        if travelers is not None:
            
            _query_params.append(('travelers', travelers))
            
        if fare is not None:
            
            _query_params.append(('fare', fare))
            
        if net_fare is not None:
            
            _query_params.append(('net-fare', net_fare))
            
        if fare_currency is not None:
            
            _query_params.append(('fare-currency', fare_currency))
            
        if partnerid is not None:
            
            _query_params.append(('partnerid', partnerid))
            
        if encryption_key is not None:
            
            _query_params.append(('encryption-key', encryption_key))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/fares/deeplink',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fares(
        self,
        catalogues: Annotated[StrictStr, Field(description="Search fares from these carriers' catalogues - currently active for Germanwings only  (4U)")],
        segments: Annotated[StrictStr, Field(description="Journey details  e.g. (origin=TXL;destination=CGN;travel-date=2016-12-15;return-date=2016-12-20;cabin=Economy)")],
        carriers: Annotated[StrictStr, Field(description="Include fares for these carriers e.g. ('4U;LH')")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers e.g. (adult=1;child=1;infant=1)")] = None,
        fare_types: Annotated[Optional[StrictStr], Field(description="Fares family: basic,smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Fares

        Retrieve all available fares per fare family for a specific Origin & Destination on a given date

        :param catalogues: Search fares from these carriers' catalogues - currently active for Germanwings only  (4U) (required)
        :type catalogues: str
        :param segments: Journey details  e.g. (origin=TXL;destination=CGN;travel-date=2016-12-15;return-date=2016-12-20;cabin=Economy) (required)
        :type segments: str
        :param carriers: Include fares for these carriers e.g. ('4U;LH') (required)
        :type carriers: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param travelers: Type and number of travelers e.g. (adult=1;child=1;infant=1)
        :type travelers: str
        :param fare_types: Fares family: basic,smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_types: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fares_serialize(
            catalogues=catalogues,
            segments=segments,
            carriers=carriers,
            accept=accept,
            travelers=travelers,
            fare_types=fare_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fares_with_http_info(
        self,
        catalogues: Annotated[StrictStr, Field(description="Search fares from these carriers' catalogues - currently active for Germanwings only  (4U)")],
        segments: Annotated[StrictStr, Field(description="Journey details  e.g. (origin=TXL;destination=CGN;travel-date=2016-12-15;return-date=2016-12-20;cabin=Economy)")],
        carriers: Annotated[StrictStr, Field(description="Include fares for these carriers e.g. ('4U;LH')")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers e.g. (adult=1;child=1;infant=1)")] = None,
        fare_types: Annotated[Optional[StrictStr], Field(description="Fares family: basic,smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Fares

        Retrieve all available fares per fare family for a specific Origin & Destination on a given date

        :param catalogues: Search fares from these carriers' catalogues - currently active for Germanwings only  (4U) (required)
        :type catalogues: str
        :param segments: Journey details  e.g. (origin=TXL;destination=CGN;travel-date=2016-12-15;return-date=2016-12-20;cabin=Economy) (required)
        :type segments: str
        :param carriers: Include fares for these carriers e.g. ('4U;LH') (required)
        :type carriers: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param travelers: Type and number of travelers e.g. (adult=1;child=1;infant=1)
        :type travelers: str
        :param fare_types: Fares family: basic,smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_types: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fares_serialize(
            catalogues=catalogues,
            segments=segments,
            carriers=carriers,
            accept=accept,
            travelers=travelers,
            fare_types=fare_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fares_without_preload_content(
        self,
        catalogues: Annotated[StrictStr, Field(description="Search fares from these carriers' catalogues - currently active for Germanwings only  (4U)")],
        segments: Annotated[StrictStr, Field(description="Journey details  e.g. (origin=TXL;destination=CGN;travel-date=2016-12-15;return-date=2016-12-20;cabin=Economy)")],
        carriers: Annotated[StrictStr, Field(description="Include fares for these carriers e.g. ('4U;LH')")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers e.g. (adult=1;child=1;infant=1)")] = None,
        fare_types: Annotated[Optional[StrictStr], Field(description="Fares family: basic,smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fares

        Retrieve all available fares per fare family for a specific Origin & Destination on a given date

        :param catalogues: Search fares from these carriers' catalogues - currently active for Germanwings only  (4U) (required)
        :type catalogues: str
        :param segments: Journey details  e.g. (origin=TXL;destination=CGN;travel-date=2016-12-15;return-date=2016-12-20;cabin=Economy) (required)
        :type segments: str
        :param carriers: Include fares for these carriers e.g. ('4U;LH') (required)
        :type carriers: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param travelers: Type and number of travelers e.g. (adult=1;child=1;infant=1)
        :type travelers: str
        :param fare_types: Fares family: basic,smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_types: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fares_serialize(
            catalogues=catalogues,
            segments=segments,
            carriers=carriers,
            accept=accept,
            travelers=travelers,
            fare_types=fare_types,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fares_serialize(
        self,
        catalogues,
        segments,
        carriers,
        accept,
        travelers,
        fare_types,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if catalogues is not None:
            
            _query_params.append(('catalogues', catalogues))
            
        if segments is not None:
            
            _query_params.append(('segments', segments))
            
        if carriers is not None:
            
            _query_params.append(('carriers', carriers))
            
        if travelers is not None:
            
            _query_params.append(('travelers', travelers))
            
        if fare_types is not None:
            
            _query_params.append(('fare-types', fare_types))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/fares/fares',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fares_subscriptions(
        self,
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-leter IATA airport code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport code (e.g. 'MAD')")],
        cabin_class: Annotated[StrictStr, Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")],
        trip_duration: Annotated[StrictStr, Field(description="Trip duration in days (e.g. '7')")],
        email: Annotated[StrictStr, Field(description="Email Address')")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        country: Annotated[Optional[StrictStr], Field(description="2-letter ISO 3166-1 country code")] = None,
        trackingid: Annotated[Optional[StrictStr], Field(description="Tracking parameter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Fares Subscriptions

        Create a subscription for best price O&D. Receive regular updates on lowest fares

        :param origin: Journey origin. 3-leter IATA airport code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport code (e.g. 'MAD') (required)
        :type destination: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\") (required)
        :type cabin_class: str
        :param trip_duration: Trip duration in days (e.g. '7') (required)
        :type trip_duration: str
        :param email: Email Address') (required)
        :type email: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param country: 2-letter ISO 3166-1 country code
        :type country: str
        :param trackingid: Tracking parameter
        :type trackingid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fares_subscriptions_serialize(
            origin=origin,
            destination=destination,
            cabin_class=cabin_class,
            trip_duration=trip_duration,
            email=email,
            lang=lang,
            accept=accept,
            country=country,
            trackingid=trackingid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fares_subscriptions_with_http_info(
        self,
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-leter IATA airport code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport code (e.g. 'MAD')")],
        cabin_class: Annotated[StrictStr, Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")],
        trip_duration: Annotated[StrictStr, Field(description="Trip duration in days (e.g. '7')")],
        email: Annotated[StrictStr, Field(description="Email Address')")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        country: Annotated[Optional[StrictStr], Field(description="2-letter ISO 3166-1 country code")] = None,
        trackingid: Annotated[Optional[StrictStr], Field(description="Tracking parameter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Fares Subscriptions

        Create a subscription for best price O&D. Receive regular updates on lowest fares

        :param origin: Journey origin. 3-leter IATA airport code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport code (e.g. 'MAD') (required)
        :type destination: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\") (required)
        :type cabin_class: str
        :param trip_duration: Trip duration in days (e.g. '7') (required)
        :type trip_duration: str
        :param email: Email Address') (required)
        :type email: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param country: 2-letter ISO 3166-1 country code
        :type country: str
        :param trackingid: Tracking parameter
        :type trackingid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fares_subscriptions_serialize(
            origin=origin,
            destination=destination,
            cabin_class=cabin_class,
            trip_duration=trip_duration,
            email=email,
            lang=lang,
            accept=accept,
            country=country,
            trackingid=trackingid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fares_subscriptions_without_preload_content(
        self,
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-leter IATA airport code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport code (e.g. 'MAD')")],
        cabin_class: Annotated[StrictStr, Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")],
        trip_duration: Annotated[StrictStr, Field(description="Trip duration in days (e.g. '7')")],
        email: Annotated[StrictStr, Field(description="Email Address')")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        country: Annotated[Optional[StrictStr], Field(description="2-letter ISO 3166-1 country code")] = None,
        trackingid: Annotated[Optional[StrictStr], Field(description="Tracking parameter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fares Subscriptions

        Create a subscription for best price O&D. Receive regular updates on lowest fares

        :param origin: Journey origin. 3-leter IATA airport code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport code (e.g. 'MAD') (required)
        :type destination: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\") (required)
        :type cabin_class: str
        :param trip_duration: Trip duration in days (e.g. '7') (required)
        :type trip_duration: str
        :param email: Email Address') (required)
        :type email: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param country: 2-letter ISO 3166-1 country code
        :type country: str
        :param trackingid: Tracking parameter
        :type trackingid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fares_subscriptions_serialize(
            origin=origin,
            destination=destination,
            cabin_class=cabin_class,
            trip_duration=trip_duration,
            email=email,
            lang=lang,
            accept=accept,
            country=country,
            trackingid=trackingid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fares_subscriptions_serialize(
        self,
        origin,
        destination,
        cabin_class,
        trip_duration,
        email,
        lang,
        accept,
        country,
        trackingid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if origin is not None:
            
            _query_params.append(('origin', origin))
            
        if destination is not None:
            
            _query_params.append(('destination', destination))
            
        if cabin_class is not None:
            
            _query_params.append(('cabin-class', cabin_class))
            
        if trip_duration is not None:
            
            _query_params.append(('trip-duration', trip_duration))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if trackingid is not None:
            
            _query_params.append(('trackingid', trackingid))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/fares/subscriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def l_h_deep_links__ffp(
        self,
        catalogues: Annotated[StrictStr, Field(description="Carrier for which the deep link will be created (e.g. 'LH')")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date (YYYY-MM-DD)")],
        trackingid: Annotated[StrictStr, Field(description="Deep link tracking ID")],
        country: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 country code")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date (YYYY-MM-DD)")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')")] = None,
        partnerid: Annotated[Optional[StrictStr], Field(description="Deep link partner id (e.g. '1247')")] = None,
        encryption_key: Annotated[Optional[StrictStr], Field(description="Deep link encryption-key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """LH Deep Links - FFP

        Returns valid LH deep links (FFP - links to flight selection screen on LH.COM)

        :param catalogues: Carrier for which the deep link will be created (e.g. 'LH') (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA airport or city code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport or city code (e.g. 'MAD') (required)
        :type destination: str
        :param travel_date: Journey travel-date (YYYY-MM-DD) (required)
        :type travel_date: str
        :param trackingid: Deep link tracking ID (required)
        :type trackingid: str
        :param country: 2-letter ISO 3166-1 country code (required)
        :type country: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param return_date: Journey return-date (YYYY-MM-DD)
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param travelers: Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')
        :type travelers: str
        :param partnerid: Deep link partner id (e.g. '1247')
        :type partnerid: str
        :param encryption_key: Deep link encryption-key
        :type encryption_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._l_h_deep_links__ffp_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            trackingid=trackingid,
            country=country,
            lang=lang,
            accept=accept,
            return_date=return_date,
            cabin_class=cabin_class,
            travelers=travelers,
            partnerid=partnerid,
            encryption_key=encryption_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def l_h_deep_links__ffp_with_http_info(
        self,
        catalogues: Annotated[StrictStr, Field(description="Carrier for which the deep link will be created (e.g. 'LH')")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date (YYYY-MM-DD)")],
        trackingid: Annotated[StrictStr, Field(description="Deep link tracking ID")],
        country: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 country code")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date (YYYY-MM-DD)")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')")] = None,
        partnerid: Annotated[Optional[StrictStr], Field(description="Deep link partner id (e.g. '1247')")] = None,
        encryption_key: Annotated[Optional[StrictStr], Field(description="Deep link encryption-key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """LH Deep Links - FFP

        Returns valid LH deep links (FFP - links to flight selection screen on LH.COM)

        :param catalogues: Carrier for which the deep link will be created (e.g. 'LH') (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA airport or city code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport or city code (e.g. 'MAD') (required)
        :type destination: str
        :param travel_date: Journey travel-date (YYYY-MM-DD) (required)
        :type travel_date: str
        :param trackingid: Deep link tracking ID (required)
        :type trackingid: str
        :param country: 2-letter ISO 3166-1 country code (required)
        :type country: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param return_date: Journey return-date (YYYY-MM-DD)
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param travelers: Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')
        :type travelers: str
        :param partnerid: Deep link partner id (e.g. '1247')
        :type partnerid: str
        :param encryption_key: Deep link encryption-key
        :type encryption_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._l_h_deep_links__ffp_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            trackingid=trackingid,
            country=country,
            lang=lang,
            accept=accept,
            return_date=return_date,
            cabin_class=cabin_class,
            travelers=travelers,
            partnerid=partnerid,
            encryption_key=encryption_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def l_h_deep_links__ffp_without_preload_content(
        self,
        catalogues: Annotated[StrictStr, Field(description="Carrier for which the deep link will be created (e.g. 'LH')")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date (YYYY-MM-DD)")],
        trackingid: Annotated[StrictStr, Field(description="Deep link tracking ID")],
        country: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 country code")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date (YYYY-MM-DD)")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')")] = None,
        partnerid: Annotated[Optional[StrictStr], Field(description="Deep link partner id (e.g. '1247')")] = None,
        encryption_key: Annotated[Optional[StrictStr], Field(description="Deep link encryption-key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """LH Deep Links - FFP

        Returns valid LH deep links (FFP - links to flight selection screen on LH.COM)

        :param catalogues: Carrier for which the deep link will be created (e.g. 'LH') (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA airport or city code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport or city code (e.g. 'MAD') (required)
        :type destination: str
        :param travel_date: Journey travel-date (YYYY-MM-DD) (required)
        :type travel_date: str
        :param trackingid: Deep link tracking ID (required)
        :type trackingid: str
        :param country: 2-letter ISO 3166-1 country code (required)
        :type country: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param return_date: Journey return-date (YYYY-MM-DD)
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param travelers: Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')
        :type travelers: str
        :param partnerid: Deep link partner id (e.g. '1247')
        :type partnerid: str
        :param encryption_key: Deep link encryption-key
        :type encryption_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._l_h_deep_links__ffp_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            trackingid=trackingid,
            country=country,
            lang=lang,
            accept=accept,
            return_date=return_date,
            cabin_class=cabin_class,
            travelers=travelers,
            partnerid=partnerid,
            encryption_key=encryption_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _l_h_deep_links__ffp_serialize(
        self,
        catalogues,
        origin,
        destination,
        travel_date,
        trackingid,
        country,
        lang,
        accept,
        return_date,
        cabin_class,
        travelers,
        partnerid,
        encryption_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if catalogues is not None:
            
            _query_params.append(('catalogues', catalogues))
            
        if origin is not None:
            
            _query_params.append(('origin', origin))
            
        if destination is not None:
            
            _query_params.append(('destination', destination))
            
        if travel_date is not None:
            
            _query_params.append(('travel-date', travel_date))
            
        if trackingid is not None:
            
            _query_params.append(('trackingid', trackingid))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        if return_date is not None:
            
            _query_params.append(('return-date', return_date))
            
        if cabin_class is not None:
            
            _query_params.append(('cabin-class', cabin_class))
            
        if travelers is not None:
            
            _query_params.append(('travelers', travelers))
            
        if partnerid is not None:
            
            _query_params.append(('partnerid', partnerid))
            
        if encryption_key is not None:
            
            _query_params.append(('encryption-key', encryption_key))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/fares/deeplink/ffp',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def l_h_deep_links__itco(
        self,
        catalogues: Annotated[StrictStr, Field(description="Carrier for which the deep link will be created (e.g. 'LH')")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date (YYYY-MM-DD)")],
        outbound_segments: Annotated[StrictStr, Field(description="Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480')")],
        fare: Annotated[StrictStr, Field(description="Travel fare (e.g. '1341.45')")],
        fare_currency: Annotated[StrictStr, Field(description="Fare currency (e.g. 'EUR')")],
        trackingid: Annotated[StrictStr, Field(description="Deep link tracking ID")],
        country: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 country code")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date (YYYY-MM-DD)")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        return_segments: Annotated[Optional[StrictStr], Field(description="Flight segments in the sequence of travel (e.g. 'LH7465;LH431')")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')")] = None,
        net_fare: Annotated[Optional[StrictStr], Field(description="Travel net fare. Total fare less taxes and charges (e.g. '1140')")] = None,
        partnerid: Annotated[Optional[StrictStr], Field(description="Deep link partner id (e.g. '1247')")] = None,
        encryption_key: Annotated[Optional[StrictStr], Field(description="Deep link encryption-key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """LH Deep Links - ITCO

        Returns valid LH deep links (ITCO - links to shopping cart on LH.COM)

        :param catalogues: Carrier for which the deep link will be created (e.g. 'LH') (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA airport or city code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport or city code (e.g. 'MAD') (required)
        :type destination: str
        :param travel_date: Journey travel-date (YYYY-MM-DD) (required)
        :type travel_date: str
        :param outbound_segments: Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480') (required)
        :type outbound_segments: str
        :param fare: Travel fare (e.g. '1341.45') (required)
        :type fare: str
        :param fare_currency: Fare currency (e.g. 'EUR') (required)
        :type fare_currency: str
        :param trackingid: Deep link tracking ID (required)
        :type trackingid: str
        :param country: 2-letter ISO 3166-1 country code (required)
        :type country: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param return_date: Journey return-date (YYYY-MM-DD)
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param return_segments: Flight segments in the sequence of travel (e.g. 'LH7465;LH431')
        :type return_segments: str
        :param travelers: Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')
        :type travelers: str
        :param net_fare: Travel net fare. Total fare less taxes and charges (e.g. '1140')
        :type net_fare: str
        :param partnerid: Deep link partner id (e.g. '1247')
        :type partnerid: str
        :param encryption_key: Deep link encryption-key
        :type encryption_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._l_h_deep_links__itco_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            outbound_segments=outbound_segments,
            fare=fare,
            fare_currency=fare_currency,
            trackingid=trackingid,
            country=country,
            lang=lang,
            accept=accept,
            return_date=return_date,
            cabin_class=cabin_class,
            return_segments=return_segments,
            travelers=travelers,
            net_fare=net_fare,
            partnerid=partnerid,
            encryption_key=encryption_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def l_h_deep_links__itco_with_http_info(
        self,
        catalogues: Annotated[StrictStr, Field(description="Carrier for which the deep link will be created (e.g. 'LH')")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date (YYYY-MM-DD)")],
        outbound_segments: Annotated[StrictStr, Field(description="Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480')")],
        fare: Annotated[StrictStr, Field(description="Travel fare (e.g. '1341.45')")],
        fare_currency: Annotated[StrictStr, Field(description="Fare currency (e.g. 'EUR')")],
        trackingid: Annotated[StrictStr, Field(description="Deep link tracking ID")],
        country: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 country code")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date (YYYY-MM-DD)")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        return_segments: Annotated[Optional[StrictStr], Field(description="Flight segments in the sequence of travel (e.g. 'LH7465;LH431')")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')")] = None,
        net_fare: Annotated[Optional[StrictStr], Field(description="Travel net fare. Total fare less taxes and charges (e.g. '1140')")] = None,
        partnerid: Annotated[Optional[StrictStr], Field(description="Deep link partner id (e.g. '1247')")] = None,
        encryption_key: Annotated[Optional[StrictStr], Field(description="Deep link encryption-key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """LH Deep Links - ITCO

        Returns valid LH deep links (ITCO - links to shopping cart on LH.COM)

        :param catalogues: Carrier for which the deep link will be created (e.g. 'LH') (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA airport or city code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport or city code (e.g. 'MAD') (required)
        :type destination: str
        :param travel_date: Journey travel-date (YYYY-MM-DD) (required)
        :type travel_date: str
        :param outbound_segments: Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480') (required)
        :type outbound_segments: str
        :param fare: Travel fare (e.g. '1341.45') (required)
        :type fare: str
        :param fare_currency: Fare currency (e.g. 'EUR') (required)
        :type fare_currency: str
        :param trackingid: Deep link tracking ID (required)
        :type trackingid: str
        :param country: 2-letter ISO 3166-1 country code (required)
        :type country: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param return_date: Journey return-date (YYYY-MM-DD)
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param return_segments: Flight segments in the sequence of travel (e.g. 'LH7465;LH431')
        :type return_segments: str
        :param travelers: Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')
        :type travelers: str
        :param net_fare: Travel net fare. Total fare less taxes and charges (e.g. '1140')
        :type net_fare: str
        :param partnerid: Deep link partner id (e.g. '1247')
        :type partnerid: str
        :param encryption_key: Deep link encryption-key
        :type encryption_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._l_h_deep_links__itco_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            outbound_segments=outbound_segments,
            fare=fare,
            fare_currency=fare_currency,
            trackingid=trackingid,
            country=country,
            lang=lang,
            accept=accept,
            return_date=return_date,
            cabin_class=cabin_class,
            return_segments=return_segments,
            travelers=travelers,
            net_fare=net_fare,
            partnerid=partnerid,
            encryption_key=encryption_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def l_h_deep_links__itco_without_preload_content(
        self,
        catalogues: Annotated[StrictStr, Field(description="Carrier for which the deep link will be created (e.g. 'LH')")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA airport or city code (e.g. 'FRA')")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport or city code (e.g. 'MAD')")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date (YYYY-MM-DD)")],
        outbound_segments: Annotated[StrictStr, Field(description="Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480')")],
        fare: Annotated[StrictStr, Field(description="Travel fare (e.g. '1341.45')")],
        fare_currency: Annotated[StrictStr, Field(description="Fare currency (e.g. 'EUR')")],
        trackingid: Annotated[StrictStr, Field(description="Deep link tracking ID")],
        country: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 country code")],
        lang: Annotated[StrictStr, Field(description="2-letter ISO 3166-1 language code")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date (YYYY-MM-DD)")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        return_segments: Annotated[Optional[StrictStr], Field(description="Flight segments in the sequence of travel (e.g. 'LH7465;LH431')")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')")] = None,
        net_fare: Annotated[Optional[StrictStr], Field(description="Travel net fare. Total fare less taxes and charges (e.g. '1140')")] = None,
        partnerid: Annotated[Optional[StrictStr], Field(description="Deep link partner id (e.g. '1247')")] = None,
        encryption_key: Annotated[Optional[StrictStr], Field(description="Deep link encryption-key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """LH Deep Links - ITCO

        Returns valid LH deep links (ITCO - links to shopping cart on LH.COM)

        :param catalogues: Carrier for which the deep link will be created (e.g. 'LH') (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA airport or city code (e.g. 'FRA') (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport or city code (e.g. 'MAD') (required)
        :type destination: str
        :param travel_date: Journey travel-date (YYYY-MM-DD) (required)
        :type travel_date: str
        :param outbound_segments: Outbound flight segments in the sequence of travel (e.g. 'LH096;LH480') (required)
        :type outbound_segments: str
        :param fare: Travel fare (e.g. '1341.45') (required)
        :type fare: str
        :param fare_currency: Fare currency (e.g. 'EUR') (required)
        :type fare_currency: str
        :param trackingid: Deep link tracking ID (required)
        :type trackingid: str
        :param country: 2-letter ISO 3166-1 country code (required)
        :type country: str
        :param lang: 2-letter ISO 3166-1 language code (required)
        :type lang: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param return_date: Journey return-date (YYYY-MM-DD)
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param return_segments: Flight segments in the sequence of travel (e.g. 'LH7465;LH431')
        :type return_segments: str
        :param travelers: Type and number of travelers (e.g. '(adult=2;child=2;infant=1)')
        :type travelers: str
        :param net_fare: Travel net fare. Total fare less taxes and charges (e.g. '1140')
        :type net_fare: str
        :param partnerid: Deep link partner id (e.g. '1247')
        :type partnerid: str
        :param encryption_key: Deep link encryption-key
        :type encryption_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._l_h_deep_links__itco_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            outbound_segments=outbound_segments,
            fare=fare,
            fare_currency=fare_currency,
            trackingid=trackingid,
            country=country,
            lang=lang,
            accept=accept,
            return_date=return_date,
            cabin_class=cabin_class,
            return_segments=return_segments,
            travelers=travelers,
            net_fare=net_fare,
            partnerid=partnerid,
            encryption_key=encryption_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _l_h_deep_links__itco_serialize(
        self,
        catalogues,
        origin,
        destination,
        travel_date,
        outbound_segments,
        fare,
        fare_currency,
        trackingid,
        country,
        lang,
        accept,
        return_date,
        cabin_class,
        return_segments,
        travelers,
        net_fare,
        partnerid,
        encryption_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if catalogues is not None:
            
            _query_params.append(('catalogues', catalogues))
            
        if origin is not None:
            
            _query_params.append(('origin', origin))
            
        if destination is not None:
            
            _query_params.append(('destination', destination))
            
        if travel_date is not None:
            
            _query_params.append(('travel-date', travel_date))
            
        if outbound_segments is not None:
            
            _query_params.append(('outbound-segments', outbound_segments))
            
        if fare is not None:
            
            _query_params.append(('fare', fare))
            
        if fare_currency is not None:
            
            _query_params.append(('fare-currency', fare_currency))
            
        if trackingid is not None:
            
            _query_params.append(('trackingid', trackingid))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        if return_date is not None:
            
            _query_params.append(('return-date', return_date))
            
        if cabin_class is not None:
            
            _query_params.append(('cabin-class', cabin_class))
            
        if return_segments is not None:
            
            _query_params.append(('return-segments', return_segments))
            
        if travelers is not None:
            
            _query_params.append(('travelers', travelers))
            
        if net_fare is not None:
            
            _query_params.append(('net-fare', net_fare))
            
        if partnerid is not None:
            
            _query_params.append(('partnerid', partnerid))
            
        if encryption_key is not None:
            
            _query_params.append(('encryption-key', encryption_key))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/fares/deeplink/itco',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def lowest_fares(
        self,
        catalogues: Annotated[StrictStr, Field(description="Search fares from these carriers' catalogues e.g. '4U;OS;LH'")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA aiport code e.g. 'FRA'")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport code e.g. 'MAD'")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date YYYY-MM-DD")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date - mandatory for OS and LH searches YYYY-MM-DD")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers e.g. '(adult=2;child=2;infant=1)'. For LH only (adult=1) possible")] = None,
        fare_family: Annotated[Optional[StrictStr], Field(description="Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Lowest Fares

        Retrieve lowest fare for a specific Origin & Destination pair on a given date. Available fares are: One-way and Return for 4U. Return only for OS & LH

        :param catalogues: Search fares from these carriers' catalogues e.g. '4U;OS;LH' (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA aiport code e.g. 'FRA' (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport code e.g. 'MAD' (required)
        :type destination: str
        :param travel_date: Journey travel-date YYYY-MM-DD (required)
        :type travel_date: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param return_date: Journey return-date - mandatory for OS and LH searches YYYY-MM-DD
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param travelers: Type and number of travelers e.g. '(adult=2;child=2;infant=1)'. For LH only (adult=1) possible
        :type travelers: str
        :param fare_family: Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_family: str
        :param country: Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._lowest_fares_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            accept=accept,
            return_date=return_date,
            cabin_class=cabin_class,
            travelers=travelers,
            fare_family=fare_family,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def lowest_fares_with_http_info(
        self,
        catalogues: Annotated[StrictStr, Field(description="Search fares from these carriers' catalogues e.g. '4U;OS;LH'")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA aiport code e.g. 'FRA'")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport code e.g. 'MAD'")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date YYYY-MM-DD")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date - mandatory for OS and LH searches YYYY-MM-DD")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers e.g. '(adult=2;child=2;infant=1)'. For LH only (adult=1) possible")] = None,
        fare_family: Annotated[Optional[StrictStr], Field(description="Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Lowest Fares

        Retrieve lowest fare for a specific Origin & Destination pair on a given date. Available fares are: One-way and Return for 4U. Return only for OS & LH

        :param catalogues: Search fares from these carriers' catalogues e.g. '4U;OS;LH' (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA aiport code e.g. 'FRA' (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport code e.g. 'MAD' (required)
        :type destination: str
        :param travel_date: Journey travel-date YYYY-MM-DD (required)
        :type travel_date: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param return_date: Journey return-date - mandatory for OS and LH searches YYYY-MM-DD
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param travelers: Type and number of travelers e.g. '(adult=2;child=2;infant=1)'. For LH only (adult=1) possible
        :type travelers: str
        :param fare_family: Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_family: str
        :param country: Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._lowest_fares_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            accept=accept,
            return_date=return_date,
            cabin_class=cabin_class,
            travelers=travelers,
            fare_family=fare_family,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def lowest_fares_without_preload_content(
        self,
        catalogues: Annotated[StrictStr, Field(description="Search fares from these carriers' catalogues e.g. '4U;OS;LH'")],
        origin: Annotated[StrictStr, Field(description="Journey origin. 3-letter IATA aiport code e.g. 'FRA'")],
        destination: Annotated[StrictStr, Field(description="Journey destination. 3-letter IATA airport code e.g. 'MAD'")],
        travel_date: Annotated[StrictStr, Field(description="Journey travel-date YYYY-MM-DD")],
        accept: Annotated[StrictStr, Field(description="http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\")")],
        return_date: Annotated[Optional[StrictStr], Field(description="Journey return-date - mandatory for OS and LH searches YYYY-MM-DD")] = None,
        cabin_class: Annotated[Optional[StrictStr], Field(description="Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")")] = None,
        travelers: Annotated[Optional[StrictStr], Field(description="Type and number of travelers e.g. '(adult=2;child=2;infant=1)'. For LH only (adult=1) possible")] = None,
        fare_family: Annotated[Optional[StrictStr], Field(description="Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lowest Fares

        Retrieve lowest fare for a specific Origin & Destination pair on a given date. Available fares are: One-way and Return for 4U. Return only for OS & LH

        :param catalogues: Search fares from these carriers' catalogues e.g. '4U;OS;LH' (required)
        :type catalogues: str
        :param origin: Journey origin. 3-letter IATA aiport code e.g. 'FRA' (required)
        :type origin: str
        :param destination: Journey destination. 3-letter IATA airport code e.g. 'MAD' (required)
        :type destination: str
        :param travel_date: Journey travel-date YYYY-MM-DD (required)
        :type travel_date: str
        :param accept: http header: application/json or application/xml (Acceptable values are: \"application/json\", \"application/xml\") (required)
        :type accept: str
        :param return_date: Journey return-date - mandatory for OS and LH searches YYYY-MM-DD
        :type return_date: str
        :param cabin_class: Cabin class: 'economy', 'premium_economy', 'business', 'first' (Acceptable values are: \"\", \"economy\", \"premium_economy\", \"business\", \"first\")
        :type cabin_class: str
        :param travelers: Type and number of travelers e.g. '(adult=2;child=2;infant=1)'. For LH only (adult=1) possible
        :type travelers: str
        :param fare_family: Fare family: basic, smart, best, smartflex, bestflex - Germanwings only (Acceptable values are: \"\", \"basic\", \"smart\", \"best\", \"smartflex\", \"bestflex\")
        :type fare_family: str
        :param country: Country code of requestor. 2-letter ISO 3166-1 country code (e.g. 'de')
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._lowest_fares_serialize(
            catalogues=catalogues,
            origin=origin,
            destination=destination,
            travel_date=travel_date,
            accept=accept,
            return_date=return_date,
            cabin_class=cabin_class,
            travelers=travelers,
            fare_family=fare_family,
            country=country,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _lowest_fares_serialize(
        self,
        catalogues,
        origin,
        destination,
        travel_date,
        accept,
        return_date,
        cabin_class,
        travelers,
        fare_family,
        country,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if catalogues is not None:
            
            _query_params.append(('catalogues', catalogues))
            
        if origin is not None:
            
            _query_params.append(('origin', origin))
            
        if destination is not None:
            
            _query_params.append(('destination', destination))
            
        if travel_date is not None:
            
            _query_params.append(('travel-date', travel_date))
            
        if return_date is not None:
            
            _query_params.append(('return-date', return_date))
            
        if cabin_class is not None:
            
            _query_params.append(('cabin-class', cabin_class))
            
        if travelers is not None:
            
            _query_params.append(('travelers', travelers))
            
        if fare_family is not None:
            
            _query_params.append(('fare-family', fare_family))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/fares/lowestfares',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def o_nd_route(
        self,
        origin: Annotated[StrictStr, Field(description="Enter either the orgin city or orgin country code (e.g 'FRA' or 'DE'). Enter '*' for all")],
        destination: Annotated[StrictStr, Field(description="Enter either the destination city or country code (e.g 'MAD' or 'ES'). Enter '*' for all")],
        accept: Annotated[StrictStr, Field(description="Mandatory http header:  application/xml or application/json")],
        catalogues: Annotated[Optional[StrictStr], Field(description="Carrier for which the OND will be retrieved (e.g. 'LH')")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="Number of records returned per request. Defaults to 20, maximum is 100 (if a value bigger than 100 is given, 100 will be taken)")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Number of records skipped. Defaults to 0")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """OND Route

        Returns LH route origin & destination information

        :param origin: Enter either the orgin city or orgin country code (e.g 'FRA' or 'DE'). Enter '*' for all (required)
        :type origin: str
        :param destination: Enter either the destination city or country code (e.g 'MAD' or 'ES'). Enter '*' for all (required)
        :type destination: str
        :param accept: Mandatory http header:  application/xml or application/json (required)
        :type accept: str
        :param catalogues: Carrier for which the OND will be retrieved (e.g. 'LH')
        :type catalogues: str
        :param limit: Number of records returned per request. Defaults to 20, maximum is 100 (if a value bigger than 100 is given, 100 will be taken)
        :type limit: str
        :param offset: Number of records skipped. Defaults to 0
        :type offset: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._o_nd_route_serialize(
            origin=origin,
            destination=destination,
            accept=accept,
            catalogues=catalogues,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def o_nd_route_with_http_info(
        self,
        origin: Annotated[StrictStr, Field(description="Enter either the orgin city or orgin country code (e.g 'FRA' or 'DE'). Enter '*' for all")],
        destination: Annotated[StrictStr, Field(description="Enter either the destination city or country code (e.g 'MAD' or 'ES'). Enter '*' for all")],
        accept: Annotated[StrictStr, Field(description="Mandatory http header:  application/xml or application/json")],
        catalogues: Annotated[Optional[StrictStr], Field(description="Carrier for which the OND will be retrieved (e.g. 'LH')")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="Number of records returned per request. Defaults to 20, maximum is 100 (if a value bigger than 100 is given, 100 will be taken)")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Number of records skipped. Defaults to 0")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """OND Route

        Returns LH route origin & destination information

        :param origin: Enter either the orgin city or orgin country code (e.g 'FRA' or 'DE'). Enter '*' for all (required)
        :type origin: str
        :param destination: Enter either the destination city or country code (e.g 'MAD' or 'ES'). Enter '*' for all (required)
        :type destination: str
        :param accept: Mandatory http header:  application/xml or application/json (required)
        :type accept: str
        :param catalogues: Carrier for which the OND will be retrieved (e.g. 'LH')
        :type catalogues: str
        :param limit: Number of records returned per request. Defaults to 20, maximum is 100 (if a value bigger than 100 is given, 100 will be taken)
        :type limit: str
        :param offset: Number of records skipped. Defaults to 0
        :type offset: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._o_nd_route_serialize(
            origin=origin,
            destination=destination,
            accept=accept,
            catalogues=catalogues,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def o_nd_route_without_preload_content(
        self,
        origin: Annotated[StrictStr, Field(description="Enter either the orgin city or orgin country code (e.g 'FRA' or 'DE'). Enter '*' for all")],
        destination: Annotated[StrictStr, Field(description="Enter either the destination city or country code (e.g 'MAD' or 'ES'). Enter '*' for all")],
        accept: Annotated[StrictStr, Field(description="Mandatory http header:  application/xml or application/json")],
        catalogues: Annotated[Optional[StrictStr], Field(description="Carrier for which the OND will be retrieved (e.g. 'LH')")] = None,
        limit: Annotated[Optional[StrictStr], Field(description="Number of records returned per request. Defaults to 20, maximum is 100 (if a value bigger than 100 is given, 100 will be taken)")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="Number of records skipped. Defaults to 0")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """OND Route

        Returns LH route origin & destination information

        :param origin: Enter either the orgin city or orgin country code (e.g 'FRA' or 'DE'). Enter '*' for all (required)
        :type origin: str
        :param destination: Enter either the destination city or country code (e.g 'MAD' or 'ES'). Enter '*' for all (required)
        :type destination: str
        :param accept: Mandatory http header:  application/xml or application/json (required)
        :type accept: str
        :param catalogues: Carrier for which the OND will be retrieved (e.g. 'LH')
        :type catalogues: str
        :param limit: Number of records returned per request. Defaults to 20, maximum is 100 (if a value bigger than 100 is given, 100 will be taken)
        :type limit: str
        :param offset: Number of records skipped. Defaults to 0
        :type offset: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._o_nd_route_serialize(
            origin=origin,
            destination=destination,
            accept=accept,
            catalogues=catalogues,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _o_nd_route_serialize(
        self,
        origin,
        destination,
        accept,
        catalogues,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if origin is not None:
            _path_params['origin'] = origin
        if destination is not None:
            _path_params['destination'] = destination
        # process the query parameters
        if catalogues is not None:
            
            _query_params.append(('catalogues', catalogues))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/ond/route/{origin}/{destination}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def o_nd_status(
        self,
        accept: Annotated[StrictStr, Field(description="Mandatory http header:  application/xml or application/json")],
        catalogues: Annotated[Optional[StrictStr], Field(description="Carrier for which the OND will be retrieved (e.g. 'LH')")] = None,
        new_routes: Annotated[Optional[StrictStr], Field(description="Enter if newly added routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")")] = None,
        old_routes: Annotated[Optional[StrictStr], Field(description="Enter if old (deleted) routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """OND Status

        Returns LH network route status information. Search for recently added or retired routes

        :param accept: Mandatory http header:  application/xml or application/json (required)
        :type accept: str
        :param catalogues: Carrier for which the OND will be retrieved (e.g. 'LH')
        :type catalogues: str
        :param new_routes: Enter if newly added routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")
        :type new_routes: str
        :param old_routes: Enter if old (deleted) routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")
        :type old_routes: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._o_nd_status_serialize(
            accept=accept,
            catalogues=catalogues,
            new_routes=new_routes,
            old_routes=old_routes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def o_nd_status_with_http_info(
        self,
        accept: Annotated[StrictStr, Field(description="Mandatory http header:  application/xml or application/json")],
        catalogues: Annotated[Optional[StrictStr], Field(description="Carrier for which the OND will be retrieved (e.g. 'LH')")] = None,
        new_routes: Annotated[Optional[StrictStr], Field(description="Enter if newly added routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")")] = None,
        old_routes: Annotated[Optional[StrictStr], Field(description="Enter if old (deleted) routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """OND Status

        Returns LH network route status information. Search for recently added or retired routes

        :param accept: Mandatory http header:  application/xml or application/json (required)
        :type accept: str
        :param catalogues: Carrier for which the OND will be retrieved (e.g. 'LH')
        :type catalogues: str
        :param new_routes: Enter if newly added routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")
        :type new_routes: str
        :param old_routes: Enter if old (deleted) routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")
        :type old_routes: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._o_nd_status_serialize(
            accept=accept,
            catalogues=catalogues,
            new_routes=new_routes,
            old_routes=old_routes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def o_nd_status_without_preload_content(
        self,
        accept: Annotated[StrictStr, Field(description="Mandatory http header:  application/xml or application/json")],
        catalogues: Annotated[Optional[StrictStr], Field(description="Carrier for which the OND will be retrieved (e.g. 'LH')")] = None,
        new_routes: Annotated[Optional[StrictStr], Field(description="Enter if newly added routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")")] = None,
        old_routes: Annotated[Optional[StrictStr], Field(description="Enter if old (deleted) routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """OND Status

        Returns LH network route status information. Search for recently added or retired routes

        :param accept: Mandatory http header:  application/xml or application/json (required)
        :type accept: str
        :param catalogues: Carrier for which the OND will be retrieved (e.g. 'LH')
        :type catalogues: str
        :param new_routes: Enter if newly added routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")
        :type new_routes: str
        :param old_routes: Enter if old (deleted) routes should be returned in the response. (Acceptable values are: \"\", \"true\", \"false\")
        :type old_routes: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._o_nd_status_serialize(
            accept=accept,
            catalogues=catalogues,
            new_routes=new_routes,
            old_routes=old_routes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _o_nd_status_serialize(
        self,
        accept,
        catalogues,
        new_routes,
        old_routes,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if catalogues is not None:
            
            _query_params.append(('catalogues', catalogues))
            
        if new_routes is not None:
            
            _query_params.append(('new-routes', new_routes))
            
        if old_routes is not None:
            
            _query_params.append(('old-routes', old_routes))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/ond/status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def top_ond(
        self,
        accept: Annotated[StrictStr, Field(description="Mandatory http header:  application/xml or application/json")],
        catalogues: Annotated[Optional[StrictStr], Field(description="Carrier for which the OND will be retrieved (e.g. 'LH')")] = None,
        origin: Annotated[Optional[StrictStr], Field(description="Enter the origin country code (e.g. 'DE'). Leave empty to search Top OND across all countries")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Top OND

        Returns LH Top routes per country or across all countries

        :param accept: Mandatory http header:  application/xml or application/json (required)
        :type accept: str
        :param catalogues: Carrier for which the OND will be retrieved (e.g. 'LH')
        :type catalogues: str
        :param origin: Enter the origin country code (e.g. 'DE'). Leave empty to search Top OND across all countries
        :type origin: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_ond_serialize(
            accept=accept,
            catalogues=catalogues,
            origin=origin,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def top_ond_with_http_info(
        self,
        accept: Annotated[StrictStr, Field(description="Mandatory http header:  application/xml or application/json")],
        catalogues: Annotated[Optional[StrictStr], Field(description="Carrier for which the OND will be retrieved (e.g. 'LH')")] = None,
        origin: Annotated[Optional[StrictStr], Field(description="Enter the origin country code (e.g. 'DE'). Leave empty to search Top OND across all countries")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Top OND

        Returns LH Top routes per country or across all countries

        :param accept: Mandatory http header:  application/xml or application/json (required)
        :type accept: str
        :param catalogues: Carrier for which the OND will be retrieved (e.g. 'LH')
        :type catalogues: str
        :param origin: Enter the origin country code (e.g. 'DE'). Leave empty to search Top OND across all countries
        :type origin: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_ond_serialize(
            accept=accept,
            catalogues=catalogues,
            origin=origin,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def top_ond_without_preload_content(
        self,
        accept: Annotated[StrictStr, Field(description="Mandatory http header:  application/xml or application/json")],
        catalogues: Annotated[Optional[StrictStr], Field(description="Carrier for which the OND will be retrieved (e.g. 'LH')")] = None,
        origin: Annotated[Optional[StrictStr], Field(description="Enter the origin country code (e.g. 'DE'). Leave empty to search Top OND across all countries")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Top OND

        Returns LH Top routes per country or across all countries

        :param accept: Mandatory http header:  application/xml or application/json (required)
        :type accept: str
        :param catalogues: Carrier for which the OND will be retrieved (e.g. 'LH')
        :type catalogues: str
        :param origin: Enter the origin country code (e.g. 'DE'). Leave empty to search Top OND across all countries
        :type origin: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_ond_serialize(
            accept=accept,
            catalogues=catalogues,
            origin=origin,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _top_ond_serialize(
        self,
        accept,
        catalogues,
        origin,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if catalogues is not None:
            
            _query_params.append(('catalogues', catalogues))
            
        if origin is not None:
            
            _query_params.append(('origin', origin))
            
        # process the header parameters
        if accept is not None:
            _header_params['Accept'] = accept
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'auth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offers/ond/top',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


