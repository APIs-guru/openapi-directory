# coding: utf-8

"""
    Branch Locator API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.contact_info_inner import ContactInfoInner
from openapi_client.models.other_accessibility_inner import OtherAccessibilityInner
from openapi_client.models.other_customer_segment_inner import OtherCustomerSegmentInner
from openapi_client.models.other_service_and_facility_inner import OtherServiceAndFacilityInner
from typing import Optional, Set
from typing_extensions import Self

class BranchInner(BaseModel):
    """
    Information that locates and identifies a specific branch of a financial institution.
    """ # noqa: E501
    accessibility: Optional[List[StrictStr]] = Field(default=None, description="Accessibility is the ability and ease a customer can access a service, good, associate, or facility. Features which make the Bank accessible to disabled people", alias="Accessibility")
    availability: Optional[Dict[str, Any]] = Field(default=None, description="Days and times defining when the branch is available for use by a customer", alias="Availability")
    contact_info: Optional[List[ContactInfoInner]] = Field(default=None, description="Communication device number or electronic address used for communication.", alias="ContactInfo")
    customer_segment: Annotated[List[StrictStr], Field(min_length=1)] = Field(description="The marketing segment which the branch is able to address in terms of customer type. Market segmentation is a marketing term referring to the aggregating of prospective buyers into groups, or segments, that have common needs and respond similarly to a marketing action. Market segmentation enables companies to target different categories of consumers who perceive the full value of certain products and services differently from one another", alias="CustomerSegment")
    identification: Annotated[str, Field(min_length=1, strict=True, max_length=35)] = Field(description="Unique and unambiguous identification of a branch of a financial institution.", alias="Identification")
    name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=140)]] = Field(default=None, description="Name by which a branch is known and which is usually used to identify that branch.", alias="Name")
    note: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=2000)]] = Field(default=None, description="Summary description of services, facility and availability.", alias="Note")
    other_accessibility: Optional[List[OtherAccessibilityInner]] = Field(default=None, description="Enter any new code , name and description for any other Accessibility", alias="OtherAccessibility")
    other_customer_segment: Optional[List[OtherCustomerSegmentInner]] = Field(default=None, description="Enter a new code , name and description for any other Customer Segment", alias="OtherCustomerSegment")
    other_service_and_facility: Optional[List[OtherServiceAndFacilityInner]] = Field(default=None, description="Enter any new code , name and description for any Other Facility", alias="OtherServiceAndFacility")
    photo: Optional[StrictStr] = Field(default=None, description="Image related to the branch", alias="Photo")
    postal_address: Dict[str, Any] = Field(description="Information that locates and identifies a specific address, as defined by postal services.", alias="PostalAddress")
    sequence_number: Annotated[str, Field(min_length=1, strict=True, max_length=35)] = Field(description="Sequence Number that is used in conjunction with Identification to uniquely identify a branch. Physical branches should have 0 assigned, mobile and sub branches should have 1,2,3....etc. assigned.", alias="SequenceNumber")
    service_and_facility: Optional[List[StrictStr]] = Field(default=None, description="Service/Facilities offered at a branch.", alias="ServiceAndFacility")
    sort_code: Optional[List[Annotated[str, Field(min_length=1, strict=True, max_length=8)]]] = Field(default=None, description="United Kingdom (UK) Sort Code - identifies British financial institutions on the British national clearing systems. The sort code, which is a six-digit number, is usually formatted as three pairs of numbers, for example 12-34-56. It identifies both the bank and the branch(s) where the account is held.", alias="SortCode")
    type: StrictStr = Field(description="Codeset to indicate if a branch is physically in 1 location or is mobile", alias="Type")
    __properties: ClassVar[List[str]] = ["Accessibility", "Availability", "ContactInfo", "CustomerSegment", "Identification", "Name", "Note", "OtherAccessibility", "OtherCustomerSegment", "OtherServiceAndFacility", "Photo", "PostalAddress", "SequenceNumber", "ServiceAndFacility", "SortCode", "Type"]

    @field_validator('accessibility')
    def accessibility_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['AutomaticDoors', 'AudioCashMachine', 'ExternalRamp', 'HelpingHandUnit', 'InductionLoop', 'InternalRamp', 'LevelAccess', 'LowerLevelCounter', 'Other', 'WheelchairAccess']):
                raise ValueError("each list item must be one of ('AutomaticDoors', 'AudioCashMachine', 'ExternalRamp', 'HelpingHandUnit', 'InductionLoop', 'InternalRamp', 'LevelAccess', 'LowerLevelCounter', 'Other', 'WheelchairAccess')")
        return value

    @field_validator('customer_segment')
    def customer_segment_validate_enum(cls, value):
        """Validates the enum"""
        for i in value:
            if i not in set(['Business', 'Corporate', 'Other', 'Personal', 'Private', 'Premier', 'Select', 'SME', 'Wealth']):
                raise ValueError("each list item must be one of ('Business', 'Corporate', 'Other', 'Personal', 'Private', 'Premier', 'Select', 'SME', 'Wealth')")
        return value

    @field_validator('service_and_facility')
    def service_and_facility_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['AssistedServiceCounter', 'ExternalATM', 'AccountVerificationService', 'BusinessCounter', 'BureauDeChange', 'BusinessDepositTerminal', 'BusinessITSupport', 'CardIssuanceFacility', 'CollectionLockers', 'CounterServices', 'ExternalQuickServicePoint', 'InternalQuickServicePoint', 'InternalATM', 'LodgementDevice', 'MortgageAdvisor', 'MeetingRooms', 'NightSafe', 'OnlineBankingPoint', 'OnDemandCurrency', 'Other', 'Parking', 'PremierCounter', 'QuickDeposit', 'SaturdayCounterService', 'StatementPrinter', 'SelfServiceAccountOpening', 'VideoBanking', 'WiFi']):
                raise ValueError("each list item must be one of ('AssistedServiceCounter', 'ExternalATM', 'AccountVerificationService', 'BusinessCounter', 'BureauDeChange', 'BusinessDepositTerminal', 'BusinessITSupport', 'CardIssuanceFacility', 'CollectionLockers', 'CounterServices', 'ExternalQuickServicePoint', 'InternalQuickServicePoint', 'InternalATM', 'LodgementDevice', 'MortgageAdvisor', 'MeetingRooms', 'NightSafe', 'OnlineBankingPoint', 'OnDemandCurrency', 'Other', 'Parking', 'PremierCounter', 'QuickDeposit', 'SaturdayCounterService', 'StatementPrinter', 'SelfServiceAccountOpening', 'VideoBanking', 'WiFi')")
        return value

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Mobile', 'Physical']):
            raise ValueError("must be one of enum values ('Mobile', 'Physical')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of BranchInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in contact_info (list)
        _items = []
        if self.contact_info:
            for _item_contact_info in self.contact_info:
                if _item_contact_info:
                    _items.append(_item_contact_info.to_dict())
            _dict['ContactInfo'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in other_accessibility (list)
        _items = []
        if self.other_accessibility:
            for _item_other_accessibility in self.other_accessibility:
                if _item_other_accessibility:
                    _items.append(_item_other_accessibility.to_dict())
            _dict['OtherAccessibility'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in other_customer_segment (list)
        _items = []
        if self.other_customer_segment:
            for _item_other_customer_segment in self.other_customer_segment:
                if _item_other_customer_segment:
                    _items.append(_item_other_customer_segment.to_dict())
            _dict['OtherCustomerSegment'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in other_service_and_facility (list)
        _items = []
        if self.other_service_and_facility:
            for _item_other_service_and_facility in self.other_service_and_facility:
                if _item_other_service_and_facility:
                    _items.append(_item_other_service_and_facility.to_dict())
            _dict['OtherServiceAndFacility'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of BranchInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "Accessibility": obj.get("Accessibility"),
            "Availability": obj.get("Availability"),
            "ContactInfo": [ContactInfoInner.from_dict(_item) for _item in obj["ContactInfo"]] if obj.get("ContactInfo") is not None else None,
            "CustomerSegment": obj.get("CustomerSegment"),
            "Identification": obj.get("Identification"),
            "Name": obj.get("Name"),
            "Note": obj.get("Note"),
            "OtherAccessibility": [OtherAccessibilityInner.from_dict(_item) for _item in obj["OtherAccessibility"]] if obj.get("OtherAccessibility") is not None else None,
            "OtherCustomerSegment": [OtherCustomerSegmentInner.from_dict(_item) for _item in obj["OtherCustomerSegment"]] if obj.get("OtherCustomerSegment") is not None else None,
            "OtherServiceAndFacility": [OtherServiceAndFacilityInner.from_dict(_item) for _item in obj["OtherServiceAndFacility"]] if obj.get("OtherServiceAndFacility") is not None else None,
            "Photo": obj.get("Photo"),
            "PostalAddress": obj.get("PostalAddress"),
            "SequenceNumber": obj.get("SequenceNumber"),
            "ServiceAndFacility": obj.get("ServiceAndFacility"),
            "SortCode": obj.get("SortCode"),
            "Type": obj.get("Type")
        })
        return _obj


