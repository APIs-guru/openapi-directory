# coding: utf-8

"""
    Swagger API2Cart

    API2Cart

    The version of the OpenAPI document: 1.1
    Contact: contact@api2cart.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.account_config_update200_response import AccountConfigUpdate200Response
from openapi_client.models.attribute_delete200_response import AttributeDelete200Response
from openapi_client.models.bridge_delete200_response import BridgeDelete200Response
from openapi_client.models.cart_config_update200_response import CartConfigUpdate200Response
from openapi_client.models.category_add200_response import CategoryAdd200Response
from openapi_client.models.category_count200_response import CategoryCount200Response
from openapi_client.models.category_find200_response import CategoryFind200Response
from openapi_client.models.category_image_add200_response import CategoryImageAdd200Response
from openapi_client.models.category_info200_response import CategoryInfo200Response
from openapi_client.models.model_response_category_list import ModelResponseCategoryList

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class CategoryApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def category_add(
        self,
        name: Annotated[StrictStr, Field(description="Defines category's name that has to be added")],
        parent_id: Annotated[Optional[StrictStr], Field(description="Adds categories specified by parent id")] = None,
        stores_ids: Annotated[Optional[StrictStr], Field(description="Create category in the stores that is specified by comma-separated stores' id")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        sort_order: Annotated[Optional[StrictInt], Field(description="Sort number in the list")] = None,
        created_time: Annotated[Optional[StrictStr], Field(description="Entity's date creation")] = None,
        modified_time: Annotated[Optional[StrictStr], Field(description="Entity's date modification")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Defines category's description")] = None,
        meta_title: Annotated[Optional[StrictStr], Field(description="Defines unique meta title for each entity")] = None,
        meta_description: Annotated[Optional[StrictStr], Field(description="Defines unique meta description of a entity")] = None,
        meta_keywords: Annotated[Optional[StrictStr], Field(description="Defines unique meta keywords for each entity")] = None,
        seo_url: Annotated[Optional[StrictStr], Field(description="Defines unique category's URL for SEO")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CategoryAdd200Response:
        """category_add

        Add new category in store

        :param name: Defines category's name that has to be added (required)
        :type name: str
        :param parent_id: Adds categories specified by parent id
        :type parent_id: str
        :param stores_ids: Create category in the stores that is specified by comma-separated stores' id
        :type stores_ids: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param sort_order: Sort number in the list
        :type sort_order: int
        :param created_time: Entity's date creation
        :type created_time: str
        :param modified_time: Entity's date modification
        :type modified_time: str
        :param description: Defines category's description
        :type description: str
        :param meta_title: Defines unique meta title for each entity
        :type meta_title: str
        :param meta_description: Defines unique meta description of a entity
        :type meta_description: str
        :param meta_keywords: Defines unique meta keywords for each entity
        :type meta_keywords: str
        :param seo_url: Defines unique category's URL for SEO
        :type seo_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_add_serialize(
            name=name,
            parent_id=parent_id,
            stores_ids=stores_ids,
            store_id=store_id,
            lang_id=lang_id,
            avail=avail,
            sort_order=sort_order,
            created_time=created_time,
            modified_time=modified_time,
            description=description,
            meta_title=meta_title,
            meta_description=meta_description,
            meta_keywords=meta_keywords,
            seo_url=seo_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_add_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Defines category's name that has to be added")],
        parent_id: Annotated[Optional[StrictStr], Field(description="Adds categories specified by parent id")] = None,
        stores_ids: Annotated[Optional[StrictStr], Field(description="Create category in the stores that is specified by comma-separated stores' id")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        sort_order: Annotated[Optional[StrictInt], Field(description="Sort number in the list")] = None,
        created_time: Annotated[Optional[StrictStr], Field(description="Entity's date creation")] = None,
        modified_time: Annotated[Optional[StrictStr], Field(description="Entity's date modification")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Defines category's description")] = None,
        meta_title: Annotated[Optional[StrictStr], Field(description="Defines unique meta title for each entity")] = None,
        meta_description: Annotated[Optional[StrictStr], Field(description="Defines unique meta description of a entity")] = None,
        meta_keywords: Annotated[Optional[StrictStr], Field(description="Defines unique meta keywords for each entity")] = None,
        seo_url: Annotated[Optional[StrictStr], Field(description="Defines unique category's URL for SEO")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CategoryAdd200Response]:
        """category_add

        Add new category in store

        :param name: Defines category's name that has to be added (required)
        :type name: str
        :param parent_id: Adds categories specified by parent id
        :type parent_id: str
        :param stores_ids: Create category in the stores that is specified by comma-separated stores' id
        :type stores_ids: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param sort_order: Sort number in the list
        :type sort_order: int
        :param created_time: Entity's date creation
        :type created_time: str
        :param modified_time: Entity's date modification
        :type modified_time: str
        :param description: Defines category's description
        :type description: str
        :param meta_title: Defines unique meta title for each entity
        :type meta_title: str
        :param meta_description: Defines unique meta description of a entity
        :type meta_description: str
        :param meta_keywords: Defines unique meta keywords for each entity
        :type meta_keywords: str
        :param seo_url: Defines unique category's URL for SEO
        :type seo_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_add_serialize(
            name=name,
            parent_id=parent_id,
            stores_ids=stores_ids,
            store_id=store_id,
            lang_id=lang_id,
            avail=avail,
            sort_order=sort_order,
            created_time=created_time,
            modified_time=modified_time,
            description=description,
            meta_title=meta_title,
            meta_description=meta_description,
            meta_keywords=meta_keywords,
            seo_url=seo_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_add_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Defines category's name that has to be added")],
        parent_id: Annotated[Optional[StrictStr], Field(description="Adds categories specified by parent id")] = None,
        stores_ids: Annotated[Optional[StrictStr], Field(description="Create category in the stores that is specified by comma-separated stores' id")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        sort_order: Annotated[Optional[StrictInt], Field(description="Sort number in the list")] = None,
        created_time: Annotated[Optional[StrictStr], Field(description="Entity's date creation")] = None,
        modified_time: Annotated[Optional[StrictStr], Field(description="Entity's date modification")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Defines category's description")] = None,
        meta_title: Annotated[Optional[StrictStr], Field(description="Defines unique meta title for each entity")] = None,
        meta_description: Annotated[Optional[StrictStr], Field(description="Defines unique meta description of a entity")] = None,
        meta_keywords: Annotated[Optional[StrictStr], Field(description="Defines unique meta keywords for each entity")] = None,
        seo_url: Annotated[Optional[StrictStr], Field(description="Defines unique category's URL for SEO")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_add

        Add new category in store

        :param name: Defines category's name that has to be added (required)
        :type name: str
        :param parent_id: Adds categories specified by parent id
        :type parent_id: str
        :param stores_ids: Create category in the stores that is specified by comma-separated stores' id
        :type stores_ids: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param sort_order: Sort number in the list
        :type sort_order: int
        :param created_time: Entity's date creation
        :type created_time: str
        :param modified_time: Entity's date modification
        :type modified_time: str
        :param description: Defines category's description
        :type description: str
        :param meta_title: Defines unique meta title for each entity
        :type meta_title: str
        :param meta_description: Defines unique meta description of a entity
        :type meta_description: str
        :param meta_keywords: Defines unique meta keywords for each entity
        :type meta_keywords: str
        :param seo_url: Defines unique category's URL for SEO
        :type seo_url: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_add_serialize(
            name=name,
            parent_id=parent_id,
            stores_ids=stores_ids,
            store_id=store_id,
            lang_id=lang_id,
            avail=avail,
            sort_order=sort_order,
            created_time=created_time,
            modified_time=modified_time,
            description=description,
            meta_title=meta_title,
            meta_description=meta_description,
            meta_keywords=meta_keywords,
            seo_url=seo_url,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_add_serialize(
        self,
        name,
        parent_id,
        stores_ids,
        store_id,
        lang_id,
        avail,
        sort_order,
        created_time,
        modified_time,
        description,
        meta_title,
        meta_description,
        meta_keywords,
        seo_url,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if stores_ids is not None:
            
            _query_params.append(('stores_ids', stores_ids))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if avail is not None:
            
            _query_params.append(('avail', avail))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if created_time is not None:
            
            _query_params.append(('created_time', created_time))
            
        if modified_time is not None:
            
            _query_params.append(('modified_time', modified_time))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if meta_title is not None:
            
            _query_params.append(('meta_title', meta_title))
            
        if meta_description is not None:
            
            _query_params.append(('meta_description', meta_description))
            
        if meta_keywords is not None:
            
            _query_params.append(('meta_keywords', meta_keywords))
            
        if seo_url is not None:
            
            _query_params.append(('seo_url', seo_url))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/category.add.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def category_assign(
        self,
        product_id: Annotated[StrictStr, Field(description="Defines category assign to the product, specified by product id")],
        category_id: Annotated[StrictStr, Field(description="Defines category assign, specified by category id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartConfigUpdate200Response:
        """category_assign

        Assign category to product

        :param product_id: Defines category assign to the product, specified by product id (required)
        :type product_id: str
        :param category_id: Defines category assign, specified by category id (required)
        :type category_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_assign_serialize(
            product_id=product_id,
            category_id=category_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_assign_with_http_info(
        self,
        product_id: Annotated[StrictStr, Field(description="Defines category assign to the product, specified by product id")],
        category_id: Annotated[StrictStr, Field(description="Defines category assign, specified by category id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartConfigUpdate200Response]:
        """category_assign

        Assign category to product

        :param product_id: Defines category assign to the product, specified by product id (required)
        :type product_id: str
        :param category_id: Defines category assign, specified by category id (required)
        :type category_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_assign_serialize(
            product_id=product_id,
            category_id=category_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_assign_without_preload_content(
        self,
        product_id: Annotated[StrictStr, Field(description="Defines category assign to the product, specified by product id")],
        category_id: Annotated[StrictStr, Field(description="Defines category assign, specified by category id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_assign

        Assign category to product

        :param product_id: Defines category assign to the product, specified by product id (required)
        :type product_id: str
        :param category_id: Defines category assign, specified by category id (required)
        :type category_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_assign_serialize(
            product_id=product_id,
            category_id=category_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_assign_serialize(
        self,
        product_id,
        category_id,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if product_id is not None:
            
            _query_params.append(('product_id', product_id))
            
        if category_id is not None:
            
            _query_params.append(('category_id', category_id))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/category.assign.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def category_count(
        self,
        parent_id: Annotated[Optional[StrictStr], Field(description="Counts categories specified by parent id")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Counts category specified by store id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Counts category specified by language id")] = None,
        created_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their creation date")] = None,
        created_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their creation date")] = None,
        modified_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their modification date")] = None,
        modified_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their modification date")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CategoryCount200Response:
        """category_count

        Count categories in store.

        :param parent_id: Counts categories specified by parent id
        :type parent_id: str
        :param store_id: Counts category specified by store id
        :type store_id: str
        :param lang_id: Counts category specified by language id
        :type lang_id: str
        :param created_from: Retrieve entities from their creation date
        :type created_from: str
        :param created_to: Retrieve entities to their creation date
        :type created_to: str
        :param modified_from: Retrieve entities from their modification date
        :type modified_from: str
        :param modified_to: Retrieve entities to their modification date
        :type modified_to: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_count_serialize(
            parent_id=parent_id,
            store_id=store_id,
            lang_id=lang_id,
            created_from=created_from,
            created_to=created_to,
            modified_from=modified_from,
            modified_to=modified_to,
            avail=avail,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_count_with_http_info(
        self,
        parent_id: Annotated[Optional[StrictStr], Field(description="Counts categories specified by parent id")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Counts category specified by store id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Counts category specified by language id")] = None,
        created_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their creation date")] = None,
        created_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their creation date")] = None,
        modified_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their modification date")] = None,
        modified_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their modification date")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CategoryCount200Response]:
        """category_count

        Count categories in store.

        :param parent_id: Counts categories specified by parent id
        :type parent_id: str
        :param store_id: Counts category specified by store id
        :type store_id: str
        :param lang_id: Counts category specified by language id
        :type lang_id: str
        :param created_from: Retrieve entities from their creation date
        :type created_from: str
        :param created_to: Retrieve entities to their creation date
        :type created_to: str
        :param modified_from: Retrieve entities from their modification date
        :type modified_from: str
        :param modified_to: Retrieve entities to their modification date
        :type modified_to: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_count_serialize(
            parent_id=parent_id,
            store_id=store_id,
            lang_id=lang_id,
            created_from=created_from,
            created_to=created_to,
            modified_from=modified_from,
            modified_to=modified_to,
            avail=avail,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_count_without_preload_content(
        self,
        parent_id: Annotated[Optional[StrictStr], Field(description="Counts categories specified by parent id")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Counts category specified by store id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Counts category specified by language id")] = None,
        created_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their creation date")] = None,
        created_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their creation date")] = None,
        modified_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their modification date")] = None,
        modified_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their modification date")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_count

        Count categories in store.

        :param parent_id: Counts categories specified by parent id
        :type parent_id: str
        :param store_id: Counts category specified by store id
        :type store_id: str
        :param lang_id: Counts category specified by language id
        :type lang_id: str
        :param created_from: Retrieve entities from their creation date
        :type created_from: str
        :param created_to: Retrieve entities to their creation date
        :type created_to: str
        :param modified_from: Retrieve entities from their modification date
        :type modified_from: str
        :param modified_to: Retrieve entities to their modification date
        :type modified_to: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_count_serialize(
            parent_id=parent_id,
            store_id=store_id,
            lang_id=lang_id,
            created_from=created_from,
            created_to=created_to,
            modified_from=modified_from,
            modified_to=modified_to,
            avail=avail,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_count_serialize(
        self,
        parent_id,
        store_id,
        lang_id,
        created_from,
        created_to,
        modified_from,
        modified_to,
        avail,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if created_from is not None:
            
            _query_params.append(('created_from', created_from))
            
        if created_to is not None:
            
            _query_params.append(('created_to', created_to))
            
        if modified_from is not None:
            
            _query_params.append(('modified_from', modified_from))
            
        if modified_to is not None:
            
            _query_params.append(('modified_to', modified_to))
            
        if avail is not None:
            
            _query_params.append(('avail', avail))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/category.count.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def category_delete(
        self,
        id: Annotated[StrictStr, Field(description="Defines category removal, specified by category id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BridgeDelete200Response:
        """category_delete

        Delete category in store

        :param id: Defines category removal, specified by category id (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BridgeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_delete_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Defines category removal, specified by category id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BridgeDelete200Response]:
        """category_delete

        Delete category in store

        :param id: Defines category removal, specified by category id (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BridgeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_delete_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Defines category removal, specified by category id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_delete

        Delete category in store

        :param id: Defines category removal, specified by category id (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BridgeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/category.delete.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def category_find(
        self,
        find_value: Annotated[StrictStr, Field(description="Entity search that is specified by some value")],
        find_where: Annotated[Optional[StrictStr], Field(description="Entity search that is specified by the comma-separated unique fields")] = None,
        find_params: Annotated[Optional[StrictStr], Field(description="Entity search that is specified by comma-separated parameters")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CategoryFind200Response:
        """category_find

        Search category in store. \"Laptop\" is specified here by default.

        :param find_value: Entity search that is specified by some value (required)
        :type find_value: str
        :param find_where: Entity search that is specified by the comma-separated unique fields
        :type find_where: str
        :param find_params: Entity search that is specified by comma-separated parameters
        :type find_params: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_find_serialize(
            find_value=find_value,
            find_where=find_where,
            find_params=find_params,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryFind200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_find_with_http_info(
        self,
        find_value: Annotated[StrictStr, Field(description="Entity search that is specified by some value")],
        find_where: Annotated[Optional[StrictStr], Field(description="Entity search that is specified by the comma-separated unique fields")] = None,
        find_params: Annotated[Optional[StrictStr], Field(description="Entity search that is specified by comma-separated parameters")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CategoryFind200Response]:
        """category_find

        Search category in store. \"Laptop\" is specified here by default.

        :param find_value: Entity search that is specified by some value (required)
        :type find_value: str
        :param find_where: Entity search that is specified by the comma-separated unique fields
        :type find_where: str
        :param find_params: Entity search that is specified by comma-separated parameters
        :type find_params: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_find_serialize(
            find_value=find_value,
            find_where=find_where,
            find_params=find_params,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryFind200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_find_without_preload_content(
        self,
        find_value: Annotated[StrictStr, Field(description="Entity search that is specified by some value")],
        find_where: Annotated[Optional[StrictStr], Field(description="Entity search that is specified by the comma-separated unique fields")] = None,
        find_params: Annotated[Optional[StrictStr], Field(description="Entity search that is specified by comma-separated parameters")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_find

        Search category in store. \"Laptop\" is specified here by default.

        :param find_value: Entity search that is specified by some value (required)
        :type find_value: str
        :param find_where: Entity search that is specified by the comma-separated unique fields
        :type find_where: str
        :param find_params: Entity search that is specified by comma-separated parameters
        :type find_params: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_find_serialize(
            find_value=find_value,
            find_where=find_where,
            find_params=find_params,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryFind200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_find_serialize(
        self,
        find_value,
        find_where,
        find_params,
        store_id,
        lang_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if find_value is not None:
            
            _query_params.append(('find_value', find_value))
            
        if find_where is not None:
            
            _query_params.append(('find_where', find_where))
            
        if find_params is not None:
            
            _query_params.append(('find_params', find_params))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/category.find.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def category_image_add(
        self,
        category_id: Annotated[StrictStr, Field(description="Defines category id where the image should be added")],
        image_name: Annotated[StrictStr, Field(description="Defines image's name")],
        url: Annotated[StrictStr, Field(description="Defines URL of the image that has to be added")],
        type: Annotated[StrictStr, Field(description="Defines image's types that are specified by comma-separated list")],
        label: Annotated[Optional[StrictStr], Field(description="Defines alternative text that has to be attached to the picture")] = None,
        mime: Annotated[Optional[StrictStr], Field(description="Mime type of image http://en.wikipedia.org/wiki/Internet_media_type.")] = None,
        position: Annotated[Optional[StrictInt], Field(description="Defines image’s position in the list")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CategoryImageAdd200Response:
        """category_image_add

        Add image to category

        :param category_id: Defines category id where the image should be added (required)
        :type category_id: str
        :param image_name: Defines image's name (required)
        :type image_name: str
        :param url: Defines URL of the image that has to be added (required)
        :type url: str
        :param type: Defines image's types that are specified by comma-separated list (required)
        :type type: str
        :param label: Defines alternative text that has to be attached to the picture
        :type label: str
        :param mime: Mime type of image http://en.wikipedia.org/wiki/Internet_media_type.
        :type mime: str
        :param position: Defines image’s position in the list
        :type position: int
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_image_add_serialize(
            category_id=category_id,
            image_name=image_name,
            url=url,
            type=type,
            label=label,
            mime=mime,
            position=position,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryImageAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_image_add_with_http_info(
        self,
        category_id: Annotated[StrictStr, Field(description="Defines category id where the image should be added")],
        image_name: Annotated[StrictStr, Field(description="Defines image's name")],
        url: Annotated[StrictStr, Field(description="Defines URL of the image that has to be added")],
        type: Annotated[StrictStr, Field(description="Defines image's types that are specified by comma-separated list")],
        label: Annotated[Optional[StrictStr], Field(description="Defines alternative text that has to be attached to the picture")] = None,
        mime: Annotated[Optional[StrictStr], Field(description="Mime type of image http://en.wikipedia.org/wiki/Internet_media_type.")] = None,
        position: Annotated[Optional[StrictInt], Field(description="Defines image’s position in the list")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CategoryImageAdd200Response]:
        """category_image_add

        Add image to category

        :param category_id: Defines category id where the image should be added (required)
        :type category_id: str
        :param image_name: Defines image's name (required)
        :type image_name: str
        :param url: Defines URL of the image that has to be added (required)
        :type url: str
        :param type: Defines image's types that are specified by comma-separated list (required)
        :type type: str
        :param label: Defines alternative text that has to be attached to the picture
        :type label: str
        :param mime: Mime type of image http://en.wikipedia.org/wiki/Internet_media_type.
        :type mime: str
        :param position: Defines image’s position in the list
        :type position: int
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_image_add_serialize(
            category_id=category_id,
            image_name=image_name,
            url=url,
            type=type,
            label=label,
            mime=mime,
            position=position,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryImageAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_image_add_without_preload_content(
        self,
        category_id: Annotated[StrictStr, Field(description="Defines category id where the image should be added")],
        image_name: Annotated[StrictStr, Field(description="Defines image's name")],
        url: Annotated[StrictStr, Field(description="Defines URL of the image that has to be added")],
        type: Annotated[StrictStr, Field(description="Defines image's types that are specified by comma-separated list")],
        label: Annotated[Optional[StrictStr], Field(description="Defines alternative text that has to be attached to the picture")] = None,
        mime: Annotated[Optional[StrictStr], Field(description="Mime type of image http://en.wikipedia.org/wiki/Internet_media_type.")] = None,
        position: Annotated[Optional[StrictInt], Field(description="Defines image’s position in the list")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_image_add

        Add image to category

        :param category_id: Defines category id where the image should be added (required)
        :type category_id: str
        :param image_name: Defines image's name (required)
        :type image_name: str
        :param url: Defines URL of the image that has to be added (required)
        :type url: str
        :param type: Defines image's types that are specified by comma-separated list (required)
        :type type: str
        :param label: Defines alternative text that has to be attached to the picture
        :type label: str
        :param mime: Mime type of image http://en.wikipedia.org/wiki/Internet_media_type.
        :type mime: str
        :param position: Defines image’s position in the list
        :type position: int
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_image_add_serialize(
            category_id=category_id,
            image_name=image_name,
            url=url,
            type=type,
            label=label,
            mime=mime,
            position=position,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryImageAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_image_add_serialize(
        self,
        category_id,
        image_name,
        url,
        type,
        label,
        mime,
        position,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if category_id is not None:
            
            _query_params.append(('category_id', category_id))
            
        if image_name is not None:
            
            _query_params.append(('image_name', image_name))
            
        if url is not None:
            
            _query_params.append(('url', url))
            
        if label is not None:
            
            _query_params.append(('label', label))
            
        if mime is not None:
            
            _query_params.append(('mime', mime))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if position is not None:
            
            _query_params.append(('position', position))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/category.image.add.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def category_image_delete(
        self,
        category_id: Annotated[StrictStr, Field(description="Defines category id where the image should be deleted")],
        image_id: Annotated[StrictStr, Field(description="Define image id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeDelete200Response:
        """category_image_delete

        Delete image

        :param category_id: Defines category id where the image should be deleted (required)
        :type category_id: str
        :param image_id: Define image id (required)
        :type image_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_image_delete_serialize(
            category_id=category_id,
            image_id=image_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_image_delete_with_http_info(
        self,
        category_id: Annotated[StrictStr, Field(description="Defines category id where the image should be deleted")],
        image_id: Annotated[StrictStr, Field(description="Define image id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeDelete200Response]:
        """category_image_delete

        Delete image

        :param category_id: Defines category id where the image should be deleted (required)
        :type category_id: str
        :param image_id: Define image id (required)
        :type image_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_image_delete_serialize(
            category_id=category_id,
            image_id=image_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_image_delete_without_preload_content(
        self,
        category_id: Annotated[StrictStr, Field(description="Defines category id where the image should be deleted")],
        image_id: Annotated[StrictStr, Field(description="Define image id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_image_delete

        Delete image

        :param category_id: Defines category id where the image should be deleted (required)
        :type category_id: str
        :param image_id: Define image id (required)
        :type image_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_image_delete_serialize(
            category_id=category_id,
            image_id=image_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_image_delete_serialize(
        self,
        category_id,
        image_id,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if category_id is not None:
            
            _query_params.append(('category_id', category_id))
            
        if image_id is not None:
            
            _query_params.append(('image_id', image_id))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/category.image.delete.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def category_info(
        self,
        id: Annotated[StrictStr, Field(description="Retrieves category's info specified by category id")],
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Retrieves category info  specified by store id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Retrieves category info  specified by language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CategoryInfo200Response:
        """category_info

        Get category info about category ID*** or specify other category ID.

        :param id: Retrieves category's info specified by category id (required)
        :type id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param store_id: Retrieves category info  specified by store id
        :type store_id: str
        :param lang_id: Retrieves category info  specified by language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_info_serialize(
            id=id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryInfo200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_info_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Retrieves category's info specified by category id")],
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Retrieves category info  specified by store id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Retrieves category info  specified by language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CategoryInfo200Response]:
        """category_info

        Get category info about category ID*** or specify other category ID.

        :param id: Retrieves category's info specified by category id (required)
        :type id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param store_id: Retrieves category info  specified by store id
        :type store_id: str
        :param lang_id: Retrieves category info  specified by language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_info_serialize(
            id=id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryInfo200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_info_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Retrieves category's info specified by category id")],
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Retrieves category info  specified by store id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Retrieves category info  specified by language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_info

        Get category info about category ID*** or specify other category ID.

        :param id: Retrieves category's info specified by category id (required)
        :type id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param store_id: Retrieves category info  specified by store id
        :type store_id: str
        :param lang_id: Retrieves category info  specified by language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_info_serialize(
            id=id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CategoryInfo200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_info_serialize(
        self,
        id,
        params,
        response_fields,
        exclude,
        store_id,
        lang_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/category.info.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def category_list(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        parent_id: Annotated[Optional[StrictStr], Field(description="Retrieves categories specified by parent id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Retrieves categories specified by store id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Retrieves categorys specified by language id")] = None,
        created_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their creation date")] = None,
        created_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their creation date")] = None,
        modified_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their modification date")] = None,
        modified_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their modification date")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelResponseCategoryList:
        """category_list

        Get list of categories from store.

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param parent_id: Retrieves categories specified by parent id
        :type parent_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param store_id: Retrieves categories specified by store id
        :type store_id: str
        :param lang_id: Retrieves categorys specified by language id
        :type lang_id: str
        :param created_from: Retrieve entities from their creation date
        :type created_from: str
        :param created_to: Retrieve entities to their creation date
        :type created_to: str
        :param modified_from: Retrieve entities from their modification date
        :type modified_from: str
        :param modified_to: Retrieve entities to their modification date
        :type modified_to: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_list_serialize(
            start=start,
            count=count,
            page_cursor=page_cursor,
            parent_id=parent_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            store_id=store_id,
            lang_id=lang_id,
            created_from=created_from,
            created_to=created_to,
            modified_from=modified_from,
            modified_to=modified_to,
            avail=avail,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCategoryList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_list_with_http_info(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        parent_id: Annotated[Optional[StrictStr], Field(description="Retrieves categories specified by parent id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Retrieves categories specified by store id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Retrieves categorys specified by language id")] = None,
        created_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their creation date")] = None,
        created_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their creation date")] = None,
        modified_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their modification date")] = None,
        modified_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their modification date")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelResponseCategoryList]:
        """category_list

        Get list of categories from store.

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param parent_id: Retrieves categories specified by parent id
        :type parent_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param store_id: Retrieves categories specified by store id
        :type store_id: str
        :param lang_id: Retrieves categorys specified by language id
        :type lang_id: str
        :param created_from: Retrieve entities from their creation date
        :type created_from: str
        :param created_to: Retrieve entities to their creation date
        :type created_to: str
        :param modified_from: Retrieve entities from their modification date
        :type modified_from: str
        :param modified_to: Retrieve entities to their modification date
        :type modified_to: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_list_serialize(
            start=start,
            count=count,
            page_cursor=page_cursor,
            parent_id=parent_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            store_id=store_id,
            lang_id=lang_id,
            created_from=created_from,
            created_to=created_to,
            modified_from=modified_from,
            modified_to=modified_to,
            avail=avail,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCategoryList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_list_without_preload_content(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        parent_id: Annotated[Optional[StrictStr], Field(description="Retrieves categories specified by parent id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Retrieves categories specified by store id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Retrieves categorys specified by language id")] = None,
        created_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their creation date")] = None,
        created_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their creation date")] = None,
        modified_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their modification date")] = None,
        modified_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their modification date")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_list

        Get list of categories from store.

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param parent_id: Retrieves categories specified by parent id
        :type parent_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param store_id: Retrieves categories specified by store id
        :type store_id: str
        :param lang_id: Retrieves categorys specified by language id
        :type lang_id: str
        :param created_from: Retrieve entities from their creation date
        :type created_from: str
        :param created_to: Retrieve entities to their creation date
        :type created_to: str
        :param modified_from: Retrieve entities from their modification date
        :type modified_from: str
        :param modified_to: Retrieve entities to their modification date
        :type modified_to: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_list_serialize(
            start=start,
            count=count,
            page_cursor=page_cursor,
            parent_id=parent_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            store_id=store_id,
            lang_id=lang_id,
            created_from=created_from,
            created_to=created_to,
            modified_from=modified_from,
            modified_to=modified_to,
            avail=avail,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCategoryList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_list_serialize(
        self,
        start,
        count,
        page_cursor,
        parent_id,
        params,
        response_fields,
        exclude,
        store_id,
        lang_id,
        created_from,
        created_to,
        modified_from,
        modified_to,
        avail,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start is not None:
            
            _query_params.append(('start', start))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if page_cursor is not None:
            
            _query_params.append(('page_cursor', page_cursor))
            
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if created_from is not None:
            
            _query_params.append(('created_from', created_from))
            
        if created_to is not None:
            
            _query_params.append(('created_to', created_to))
            
        if modified_from is not None:
            
            _query_params.append(('modified_from', modified_from))
            
        if modified_to is not None:
            
            _query_params.append(('modified_to', modified_to))
            
        if avail is not None:
            
            _query_params.append(('avail', avail))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/category.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def category_unassign(
        self,
        category_id: Annotated[StrictStr, Field(description="Defines category unassign, specified by category id")],
        product_id: Annotated[StrictStr, Field(description="Defines category unassign to the product, specified by product id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartConfigUpdate200Response:
        """category_unassign

        Unassign category to product

        :param category_id: Defines category unassign, specified by category id (required)
        :type category_id: str
        :param product_id: Defines category unassign to the product, specified by product id (required)
        :type product_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_unassign_serialize(
            category_id=category_id,
            product_id=product_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_unassign_with_http_info(
        self,
        category_id: Annotated[StrictStr, Field(description="Defines category unassign, specified by category id")],
        product_id: Annotated[StrictStr, Field(description="Defines category unassign to the product, specified by product id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartConfigUpdate200Response]:
        """category_unassign

        Unassign category to product

        :param category_id: Defines category unassign, specified by category id (required)
        :type category_id: str
        :param product_id: Defines category unassign to the product, specified by product id (required)
        :type product_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_unassign_serialize(
            category_id=category_id,
            product_id=product_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_unassign_without_preload_content(
        self,
        category_id: Annotated[StrictStr, Field(description="Defines category unassign, specified by category id")],
        product_id: Annotated[StrictStr, Field(description="Defines category unassign to the product, specified by product id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_unassign

        Unassign category to product

        :param category_id: Defines category unassign, specified by category id (required)
        :type category_id: str
        :param product_id: Defines category unassign to the product, specified by product id (required)
        :type product_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_unassign_serialize(
            category_id=category_id,
            product_id=product_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_unassign_serialize(
        self,
        category_id,
        product_id,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if category_id is not None:
            
            _query_params.append(('category_id', category_id))
            
        if product_id is not None:
            
            _query_params.append(('product_id', product_id))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/category.unassign.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def category_update(
        self,
        id: Annotated[StrictStr, Field(description="Defines category update specified by category id")],
        name: Annotated[Optional[StrictStr], Field(description="Defines new category’s name")] = None,
        parent_id: Annotated[Optional[StrictStr], Field(description="Defines new parent category id")] = None,
        stores_ids: Annotated[Optional[StrictStr], Field(description="Update category in the stores that is specified by comma-separated stores' id")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        sort_order: Annotated[Optional[StrictInt], Field(description="Sort number in the list")] = None,
        modified_time: Annotated[Optional[StrictStr], Field(description="Entity's date modification")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Defines new category's description")] = None,
        meta_title: Annotated[Optional[StrictStr], Field(description="Defines unique meta title for each entity")] = None,
        meta_description: Annotated[Optional[StrictStr], Field(description="Defines unique meta description of a entity")] = None,
        meta_keywords: Annotated[Optional[StrictStr], Field(description="Defines unique meta keywords for each entity")] = None,
        seo_url: Annotated[Optional[StrictStr], Field(description="Defines unique category's URL for SEO")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountConfigUpdate200Response:
        """category_update

        Update category in store

        :param id: Defines category update specified by category id (required)
        :type id: str
        :param name: Defines new category’s name
        :type name: str
        :param parent_id: Defines new parent category id
        :type parent_id: str
        :param stores_ids: Update category in the stores that is specified by comma-separated stores' id
        :type stores_ids: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param sort_order: Sort number in the list
        :type sort_order: int
        :param modified_time: Entity's date modification
        :type modified_time: str
        :param description: Defines new category's description
        :type description: str
        :param meta_title: Defines unique meta title for each entity
        :type meta_title: str
        :param meta_description: Defines unique meta description of a entity
        :type meta_description: str
        :param meta_keywords: Defines unique meta keywords for each entity
        :type meta_keywords: str
        :param seo_url: Defines unique category's URL for SEO
        :type seo_url: str
        :param lang_id: Language id
        :type lang_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_update_serialize(
            id=id,
            name=name,
            parent_id=parent_id,
            stores_ids=stores_ids,
            avail=avail,
            sort_order=sort_order,
            modified_time=modified_time,
            description=description,
            meta_title=meta_title,
            meta_description=meta_description,
            meta_keywords=meta_keywords,
            seo_url=seo_url,
            lang_id=lang_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def category_update_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Defines category update specified by category id")],
        name: Annotated[Optional[StrictStr], Field(description="Defines new category’s name")] = None,
        parent_id: Annotated[Optional[StrictStr], Field(description="Defines new parent category id")] = None,
        stores_ids: Annotated[Optional[StrictStr], Field(description="Update category in the stores that is specified by comma-separated stores' id")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        sort_order: Annotated[Optional[StrictInt], Field(description="Sort number in the list")] = None,
        modified_time: Annotated[Optional[StrictStr], Field(description="Entity's date modification")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Defines new category's description")] = None,
        meta_title: Annotated[Optional[StrictStr], Field(description="Defines unique meta title for each entity")] = None,
        meta_description: Annotated[Optional[StrictStr], Field(description="Defines unique meta description of a entity")] = None,
        meta_keywords: Annotated[Optional[StrictStr], Field(description="Defines unique meta keywords for each entity")] = None,
        seo_url: Annotated[Optional[StrictStr], Field(description="Defines unique category's URL for SEO")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountConfigUpdate200Response]:
        """category_update

        Update category in store

        :param id: Defines category update specified by category id (required)
        :type id: str
        :param name: Defines new category’s name
        :type name: str
        :param parent_id: Defines new parent category id
        :type parent_id: str
        :param stores_ids: Update category in the stores that is specified by comma-separated stores' id
        :type stores_ids: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param sort_order: Sort number in the list
        :type sort_order: int
        :param modified_time: Entity's date modification
        :type modified_time: str
        :param description: Defines new category's description
        :type description: str
        :param meta_title: Defines unique meta title for each entity
        :type meta_title: str
        :param meta_description: Defines unique meta description of a entity
        :type meta_description: str
        :param meta_keywords: Defines unique meta keywords for each entity
        :type meta_keywords: str
        :param seo_url: Defines unique category's URL for SEO
        :type seo_url: str
        :param lang_id: Language id
        :type lang_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_update_serialize(
            id=id,
            name=name,
            parent_id=parent_id,
            stores_ids=stores_ids,
            avail=avail,
            sort_order=sort_order,
            modified_time=modified_time,
            description=description,
            meta_title=meta_title,
            meta_description=meta_description,
            meta_keywords=meta_keywords,
            seo_url=seo_url,
            lang_id=lang_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def category_update_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Defines category update specified by category id")],
        name: Annotated[Optional[StrictStr], Field(description="Defines new category’s name")] = None,
        parent_id: Annotated[Optional[StrictStr], Field(description="Defines new parent category id")] = None,
        stores_ids: Annotated[Optional[StrictStr], Field(description="Update category in the stores that is specified by comma-separated stores' id")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        sort_order: Annotated[Optional[StrictInt], Field(description="Sort number in the list")] = None,
        modified_time: Annotated[Optional[StrictStr], Field(description="Entity's date modification")] = None,
        description: Annotated[Optional[StrictStr], Field(description="Defines new category's description")] = None,
        meta_title: Annotated[Optional[StrictStr], Field(description="Defines unique meta title for each entity")] = None,
        meta_description: Annotated[Optional[StrictStr], Field(description="Defines unique meta description of a entity")] = None,
        meta_keywords: Annotated[Optional[StrictStr], Field(description="Defines unique meta keywords for each entity")] = None,
        seo_url: Annotated[Optional[StrictStr], Field(description="Defines unique category's URL for SEO")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """category_update

        Update category in store

        :param id: Defines category update specified by category id (required)
        :type id: str
        :param name: Defines new category’s name
        :type name: str
        :param parent_id: Defines new parent category id
        :type parent_id: str
        :param stores_ids: Update category in the stores that is specified by comma-separated stores' id
        :type stores_ids: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param sort_order: Sort number in the list
        :type sort_order: int
        :param modified_time: Entity's date modification
        :type modified_time: str
        :param description: Defines new category's description
        :type description: str
        :param meta_title: Defines unique meta title for each entity
        :type meta_title: str
        :param meta_description: Defines unique meta description of a entity
        :type meta_description: str
        :param meta_keywords: Defines unique meta keywords for each entity
        :type meta_keywords: str
        :param seo_url: Defines unique category's URL for SEO
        :type seo_url: str
        :param lang_id: Language id
        :type lang_id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._category_update_serialize(
            id=id,
            name=name,
            parent_id=parent_id,
            stores_ids=stores_ids,
            avail=avail,
            sort_order=sort_order,
            modified_time=modified_time,
            description=description,
            meta_title=meta_title,
            meta_description=meta_description,
            meta_keywords=meta_keywords,
            seo_url=seo_url,
            lang_id=lang_id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _category_update_serialize(
        self,
        id,
        name,
        parent_id,
        stores_ids,
        avail,
        sort_order,
        modified_time,
        description,
        meta_title,
        meta_description,
        meta_keywords,
        seo_url,
        lang_id,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if stores_ids is not None:
            
            _query_params.append(('stores_ids', stores_ids))
            
        if avail is not None:
            
            _query_params.append(('avail', avail))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if modified_time is not None:
            
            _query_params.append(('modified_time', modified_time))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if meta_title is not None:
            
            _query_params.append(('meta_title', meta_title))
            
        if meta_description is not None:
            
            _query_params.append(('meta_description', meta_description))
            
        if meta_keywords is not None:
            
            _query_params.append(('meta_keywords', meta_keywords))
            
        if seo_url is not None:
            
            _query_params.append(('seo_url', seo_url))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/category.update.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


