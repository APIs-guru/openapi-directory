# coding: utf-8

"""
    Swagger API2Cart

    API2Cart

    The version of the OpenAPI document: 1.1
    Contact: contact@api2cart.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.attribute_add200_response import AttributeAdd200Response
from openapi_client.models.attribute_assign_group200_response import AttributeAssignGroup200Response
from openapi_client.models.attribute_attributeset_list200_response import AttributeAttributesetList200Response
from openapi_client.models.attribute_count200_response import AttributeCount200Response
from openapi_client.models.attribute_delete200_response import AttributeDelete200Response
from openapi_client.models.attribute_info200_response import AttributeInfo200Response
from openapi_client.models.attribute_type_list200_response import AttributeTypeList200Response
from openapi_client.models.attribute_unassign_group200_response import AttributeUnassignGroup200Response
from openapi_client.models.attribute_update200_response import AttributeUpdate200Response
from openapi_client.models.model_response_attribute_list import ModelResponseAttributeList

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class AttributeApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def attribute_add(
        self,
        type: Annotated[StrictStr, Field(description="Defines attribute's type")],
        name: Annotated[StrictStr, Field(description="Defines attributes's name")],
        code: Annotated[Optional[StrictStr], Field(description="Entity code")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        visible: Annotated[Optional[StrictBool], Field(description="Set visibility status")] = None,
        required: Annotated[Optional[StrictBool], Field(description="Defines if the option is required")] = None,
        position: Annotated[Optional[StrictInt], Field(description="Attribute`s position")] = None,
        attribute_group_id: Annotated[Optional[StrictStr], Field(description="Filter by attribute_group_id")] = None,
        is_global: Annotated[Optional[StrictStr], Field(description="Attribute saving scope")] = None,
        is_searchable: Annotated[Optional[StrictBool], Field(description="Use attribute in Quick Search")] = None,
        is_filterable: Annotated[Optional[StrictStr], Field(description="Use In Layered Navigation")] = None,
        is_comparable: Annotated[Optional[StrictBool], Field(description="Comparable on Front-end")] = None,
        is_html_allowed_on_front: Annotated[Optional[StrictBool], Field(description="Allow HTML Tags on Frontend")] = None,
        is_filterable_in_search: Annotated[Optional[StrictBool], Field(description="Use In Search Results Layered Navigation")] = None,
        is_configurable: Annotated[Optional[StrictBool], Field(description="Use To Create Configurable Product")] = None,
        is_visible_in_advanced_search: Annotated[Optional[StrictBool], Field(description="Use in Advanced Search")] = None,
        is_used_for_promo_rules: Annotated[Optional[StrictBool], Field(description="Use for Promo Rule Conditions")] = None,
        used_in_product_listing: Annotated[Optional[StrictBool], Field(description="Used in Product Listing")] = None,
        used_for_sort_by: Annotated[Optional[StrictBool], Field(description="Used for Sorting in Product Listing")] = None,
        apply_to: Annotated[Optional[StrictStr], Field(description="Types of products which can have this attribute")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeAdd200Response:
        """attribute_add

        Add new attribute

        :param type: Defines attribute's type (required)
        :type type: str
        :param name: Defines attributes's name (required)
        :type name: str
        :param code: Entity code
        :type code: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param visible: Set visibility status
        :type visible: bool
        :param required: Defines if the option is required
        :type required: bool
        :param position: Attribute`s position
        :type position: int
        :param attribute_group_id: Filter by attribute_group_id
        :type attribute_group_id: str
        :param is_global: Attribute saving scope
        :type is_global: str
        :param is_searchable: Use attribute in Quick Search
        :type is_searchable: bool
        :param is_filterable: Use In Layered Navigation
        :type is_filterable: str
        :param is_comparable: Comparable on Front-end
        :type is_comparable: bool
        :param is_html_allowed_on_front: Allow HTML Tags on Frontend
        :type is_html_allowed_on_front: bool
        :param is_filterable_in_search: Use In Search Results Layered Navigation
        :type is_filterable_in_search: bool
        :param is_configurable: Use To Create Configurable Product
        :type is_configurable: bool
        :param is_visible_in_advanced_search: Use in Advanced Search
        :type is_visible_in_advanced_search: bool
        :param is_used_for_promo_rules: Use for Promo Rule Conditions
        :type is_used_for_promo_rules: bool
        :param used_in_product_listing: Used in Product Listing
        :type used_in_product_listing: bool
        :param used_for_sort_by: Used for Sorting in Product Listing
        :type used_for_sort_by: bool
        :param apply_to: Types of products which can have this attribute
        :type apply_to: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_add_serialize(
            type=type,
            name=name,
            code=code,
            store_id=store_id,
            lang_id=lang_id,
            visible=visible,
            required=required,
            position=position,
            attribute_group_id=attribute_group_id,
            is_global=is_global,
            is_searchable=is_searchable,
            is_filterable=is_filterable,
            is_comparable=is_comparable,
            is_html_allowed_on_front=is_html_allowed_on_front,
            is_filterable_in_search=is_filterable_in_search,
            is_configurable=is_configurable,
            is_visible_in_advanced_search=is_visible_in_advanced_search,
            is_used_for_promo_rules=is_used_for_promo_rules,
            used_in_product_listing=used_in_product_listing,
            used_for_sort_by=used_for_sort_by,
            apply_to=apply_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_add_with_http_info(
        self,
        type: Annotated[StrictStr, Field(description="Defines attribute's type")],
        name: Annotated[StrictStr, Field(description="Defines attributes's name")],
        code: Annotated[Optional[StrictStr], Field(description="Entity code")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        visible: Annotated[Optional[StrictBool], Field(description="Set visibility status")] = None,
        required: Annotated[Optional[StrictBool], Field(description="Defines if the option is required")] = None,
        position: Annotated[Optional[StrictInt], Field(description="Attribute`s position")] = None,
        attribute_group_id: Annotated[Optional[StrictStr], Field(description="Filter by attribute_group_id")] = None,
        is_global: Annotated[Optional[StrictStr], Field(description="Attribute saving scope")] = None,
        is_searchable: Annotated[Optional[StrictBool], Field(description="Use attribute in Quick Search")] = None,
        is_filterable: Annotated[Optional[StrictStr], Field(description="Use In Layered Navigation")] = None,
        is_comparable: Annotated[Optional[StrictBool], Field(description="Comparable on Front-end")] = None,
        is_html_allowed_on_front: Annotated[Optional[StrictBool], Field(description="Allow HTML Tags on Frontend")] = None,
        is_filterable_in_search: Annotated[Optional[StrictBool], Field(description="Use In Search Results Layered Navigation")] = None,
        is_configurable: Annotated[Optional[StrictBool], Field(description="Use To Create Configurable Product")] = None,
        is_visible_in_advanced_search: Annotated[Optional[StrictBool], Field(description="Use in Advanced Search")] = None,
        is_used_for_promo_rules: Annotated[Optional[StrictBool], Field(description="Use for Promo Rule Conditions")] = None,
        used_in_product_listing: Annotated[Optional[StrictBool], Field(description="Used in Product Listing")] = None,
        used_for_sort_by: Annotated[Optional[StrictBool], Field(description="Used for Sorting in Product Listing")] = None,
        apply_to: Annotated[Optional[StrictStr], Field(description="Types of products which can have this attribute")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeAdd200Response]:
        """attribute_add

        Add new attribute

        :param type: Defines attribute's type (required)
        :type type: str
        :param name: Defines attributes's name (required)
        :type name: str
        :param code: Entity code
        :type code: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param visible: Set visibility status
        :type visible: bool
        :param required: Defines if the option is required
        :type required: bool
        :param position: Attribute`s position
        :type position: int
        :param attribute_group_id: Filter by attribute_group_id
        :type attribute_group_id: str
        :param is_global: Attribute saving scope
        :type is_global: str
        :param is_searchable: Use attribute in Quick Search
        :type is_searchable: bool
        :param is_filterable: Use In Layered Navigation
        :type is_filterable: str
        :param is_comparable: Comparable on Front-end
        :type is_comparable: bool
        :param is_html_allowed_on_front: Allow HTML Tags on Frontend
        :type is_html_allowed_on_front: bool
        :param is_filterable_in_search: Use In Search Results Layered Navigation
        :type is_filterable_in_search: bool
        :param is_configurable: Use To Create Configurable Product
        :type is_configurable: bool
        :param is_visible_in_advanced_search: Use in Advanced Search
        :type is_visible_in_advanced_search: bool
        :param is_used_for_promo_rules: Use for Promo Rule Conditions
        :type is_used_for_promo_rules: bool
        :param used_in_product_listing: Used in Product Listing
        :type used_in_product_listing: bool
        :param used_for_sort_by: Used for Sorting in Product Listing
        :type used_for_sort_by: bool
        :param apply_to: Types of products which can have this attribute
        :type apply_to: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_add_serialize(
            type=type,
            name=name,
            code=code,
            store_id=store_id,
            lang_id=lang_id,
            visible=visible,
            required=required,
            position=position,
            attribute_group_id=attribute_group_id,
            is_global=is_global,
            is_searchable=is_searchable,
            is_filterable=is_filterable,
            is_comparable=is_comparable,
            is_html_allowed_on_front=is_html_allowed_on_front,
            is_filterable_in_search=is_filterable_in_search,
            is_configurable=is_configurable,
            is_visible_in_advanced_search=is_visible_in_advanced_search,
            is_used_for_promo_rules=is_used_for_promo_rules,
            used_in_product_listing=used_in_product_listing,
            used_for_sort_by=used_for_sort_by,
            apply_to=apply_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_add_without_preload_content(
        self,
        type: Annotated[StrictStr, Field(description="Defines attribute's type")],
        name: Annotated[StrictStr, Field(description="Defines attributes's name")],
        code: Annotated[Optional[StrictStr], Field(description="Entity code")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        visible: Annotated[Optional[StrictBool], Field(description="Set visibility status")] = None,
        required: Annotated[Optional[StrictBool], Field(description="Defines if the option is required")] = None,
        position: Annotated[Optional[StrictInt], Field(description="Attribute`s position")] = None,
        attribute_group_id: Annotated[Optional[StrictStr], Field(description="Filter by attribute_group_id")] = None,
        is_global: Annotated[Optional[StrictStr], Field(description="Attribute saving scope")] = None,
        is_searchable: Annotated[Optional[StrictBool], Field(description="Use attribute in Quick Search")] = None,
        is_filterable: Annotated[Optional[StrictStr], Field(description="Use In Layered Navigation")] = None,
        is_comparable: Annotated[Optional[StrictBool], Field(description="Comparable on Front-end")] = None,
        is_html_allowed_on_front: Annotated[Optional[StrictBool], Field(description="Allow HTML Tags on Frontend")] = None,
        is_filterable_in_search: Annotated[Optional[StrictBool], Field(description="Use In Search Results Layered Navigation")] = None,
        is_configurable: Annotated[Optional[StrictBool], Field(description="Use To Create Configurable Product")] = None,
        is_visible_in_advanced_search: Annotated[Optional[StrictBool], Field(description="Use in Advanced Search")] = None,
        is_used_for_promo_rules: Annotated[Optional[StrictBool], Field(description="Use for Promo Rule Conditions")] = None,
        used_in_product_listing: Annotated[Optional[StrictBool], Field(description="Used in Product Listing")] = None,
        used_for_sort_by: Annotated[Optional[StrictBool], Field(description="Used for Sorting in Product Listing")] = None,
        apply_to: Annotated[Optional[StrictStr], Field(description="Types of products which can have this attribute")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_add

        Add new attribute

        :param type: Defines attribute's type (required)
        :type type: str
        :param name: Defines attributes's name (required)
        :type name: str
        :param code: Entity code
        :type code: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param visible: Set visibility status
        :type visible: bool
        :param required: Defines if the option is required
        :type required: bool
        :param position: Attribute`s position
        :type position: int
        :param attribute_group_id: Filter by attribute_group_id
        :type attribute_group_id: str
        :param is_global: Attribute saving scope
        :type is_global: str
        :param is_searchable: Use attribute in Quick Search
        :type is_searchable: bool
        :param is_filterable: Use In Layered Navigation
        :type is_filterable: str
        :param is_comparable: Comparable on Front-end
        :type is_comparable: bool
        :param is_html_allowed_on_front: Allow HTML Tags on Frontend
        :type is_html_allowed_on_front: bool
        :param is_filterable_in_search: Use In Search Results Layered Navigation
        :type is_filterable_in_search: bool
        :param is_configurable: Use To Create Configurable Product
        :type is_configurable: bool
        :param is_visible_in_advanced_search: Use in Advanced Search
        :type is_visible_in_advanced_search: bool
        :param is_used_for_promo_rules: Use for Promo Rule Conditions
        :type is_used_for_promo_rules: bool
        :param used_in_product_listing: Used in Product Listing
        :type used_in_product_listing: bool
        :param used_for_sort_by: Used for Sorting in Product Listing
        :type used_for_sort_by: bool
        :param apply_to: Types of products which can have this attribute
        :type apply_to: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_add_serialize(
            type=type,
            name=name,
            code=code,
            store_id=store_id,
            lang_id=lang_id,
            visible=visible,
            required=required,
            position=position,
            attribute_group_id=attribute_group_id,
            is_global=is_global,
            is_searchable=is_searchable,
            is_filterable=is_filterable,
            is_comparable=is_comparable,
            is_html_allowed_on_front=is_html_allowed_on_front,
            is_filterable_in_search=is_filterable_in_search,
            is_configurable=is_configurable,
            is_visible_in_advanced_search=is_visible_in_advanced_search,
            is_used_for_promo_rules=is_used_for_promo_rules,
            used_in_product_listing=used_in_product_listing,
            used_for_sort_by=used_for_sort_by,
            apply_to=apply_to,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_add_serialize(
        self,
        type,
        name,
        code,
        store_id,
        lang_id,
        visible,
        required,
        position,
        attribute_group_id,
        is_global,
        is_searchable,
        is_filterable,
        is_comparable,
        is_html_allowed_on_front,
        is_filterable_in_search,
        is_configurable,
        is_visible_in_advanced_search,
        is_used_for_promo_rules,
        used_in_product_listing,
        used_for_sort_by,
        apply_to,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if type is not None:
            
            _query_params.append(('type', type))
            
        if code is not None:
            
            _query_params.append(('code', code))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if visible is not None:
            
            _query_params.append(('visible', visible))
            
        if required is not None:
            
            _query_params.append(('required', required))
            
        if position is not None:
            
            _query_params.append(('position', position))
            
        if attribute_group_id is not None:
            
            _query_params.append(('attribute_group_id', attribute_group_id))
            
        if is_global is not None:
            
            _query_params.append(('is_global', is_global))
            
        if is_searchable is not None:
            
            _query_params.append(('is_searchable', is_searchable))
            
        if is_filterable is not None:
            
            _query_params.append(('is_filterable', is_filterable))
            
        if is_comparable is not None:
            
            _query_params.append(('is_comparable', is_comparable))
            
        if is_html_allowed_on_front is not None:
            
            _query_params.append(('is_html_allowed_on_front', is_html_allowed_on_front))
            
        if is_filterable_in_search is not None:
            
            _query_params.append(('is_filterable_in_search', is_filterable_in_search))
            
        if is_configurable is not None:
            
            _query_params.append(('is_configurable', is_configurable))
            
        if is_visible_in_advanced_search is not None:
            
            _query_params.append(('is_visible_in_advanced_search', is_visible_in_advanced_search))
            
        if is_used_for_promo_rules is not None:
            
            _query_params.append(('is_used_for_promo_rules', is_used_for_promo_rules))
            
        if used_in_product_listing is not None:
            
            _query_params.append(('used_in_product_listing', used_in_product_listing))
            
        if used_for_sort_by is not None:
            
            _query_params.append(('used_for_sort_by', used_for_sort_by))
            
        if apply_to is not None:
            
            _query_params.append(('apply_to', apply_to))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/attribute.add.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_assign_group(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        group_id: Annotated[StrictStr, Field(description="Attribute group_id")],
        attribute_set_id: Annotated[Optional[StrictStr], Field(description="Attribute set id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeAssignGroup200Response:
        """attribute_assign_group

        Assign attribute to the group

        :param id: Entity id (required)
        :type id: str
        :param group_id: Attribute group_id (required)
        :type group_id: str
        :param attribute_set_id: Attribute set id
        :type attribute_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_assign_group_serialize(
            id=id,
            group_id=group_id,
            attribute_set_id=attribute_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAssignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_assign_group_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        group_id: Annotated[StrictStr, Field(description="Attribute group_id")],
        attribute_set_id: Annotated[Optional[StrictStr], Field(description="Attribute set id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeAssignGroup200Response]:
        """attribute_assign_group

        Assign attribute to the group

        :param id: Entity id (required)
        :type id: str
        :param group_id: Attribute group_id (required)
        :type group_id: str
        :param attribute_set_id: Attribute set id
        :type attribute_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_assign_group_serialize(
            id=id,
            group_id=group_id,
            attribute_set_id=attribute_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAssignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_assign_group_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        group_id: Annotated[StrictStr, Field(description="Attribute group_id")],
        attribute_set_id: Annotated[Optional[StrictStr], Field(description="Attribute set id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_assign_group

        Assign attribute to the group

        :param id: Entity id (required)
        :type id: str
        :param group_id: Attribute group_id (required)
        :type group_id: str
        :param attribute_set_id: Attribute set id
        :type attribute_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_assign_group_serialize(
            id=id,
            group_id=group_id,
            attribute_set_id=attribute_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAssignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_assign_group_serialize(
        self,
        id,
        group_id,
        attribute_set_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if group_id is not None:
            
            _query_params.append(('group_id', group_id))
            
        if attribute_set_id is not None:
            
            _query_params.append(('attribute_set_id', attribute_set_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/attribute.assign.group.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_assign_set(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        attribute_set_id: Annotated[StrictStr, Field(description="Attribute set id")],
        group_id: Annotated[Optional[StrictStr], Field(description="Attribute group_id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeAssignGroup200Response:
        """attribute_assign_set

        Assign attribute to the attribute set

        :param id: Entity id (required)
        :type id: str
        :param attribute_set_id: Attribute set id (required)
        :type attribute_set_id: str
        :param group_id: Attribute group_id
        :type group_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_assign_set_serialize(
            id=id,
            attribute_set_id=attribute_set_id,
            group_id=group_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAssignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_assign_set_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        attribute_set_id: Annotated[StrictStr, Field(description="Attribute set id")],
        group_id: Annotated[Optional[StrictStr], Field(description="Attribute group_id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeAssignGroup200Response]:
        """attribute_assign_set

        Assign attribute to the attribute set

        :param id: Entity id (required)
        :type id: str
        :param attribute_set_id: Attribute set id (required)
        :type attribute_set_id: str
        :param group_id: Attribute group_id
        :type group_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_assign_set_serialize(
            id=id,
            attribute_set_id=attribute_set_id,
            group_id=group_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAssignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_assign_set_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        attribute_set_id: Annotated[StrictStr, Field(description="Attribute set id")],
        group_id: Annotated[Optional[StrictStr], Field(description="Attribute group_id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_assign_set

        Assign attribute to the attribute set

        :param id: Entity id (required)
        :type id: str
        :param attribute_set_id: Attribute set id (required)
        :type attribute_set_id: str
        :param group_id: Attribute group_id
        :type group_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_assign_set_serialize(
            id=id,
            attribute_set_id=attribute_set_id,
            group_id=group_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAssignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_assign_set_serialize(
        self,
        id,
        attribute_set_id,
        group_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if group_id is not None:
            
            _query_params.append(('group_id', group_id))
            
        if attribute_set_id is not None:
            
            _query_params.append(('attribute_set_id', attribute_set_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/attribute.assign.set.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_attributeset_list(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeAttributesetList200Response:
        """attribute_attributeset_list

        Get attribute_set list

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_attributeset_list_serialize(
            start=start,
            count=count,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAttributesetList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_attributeset_list_with_http_info(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeAttributesetList200Response]:
        """attribute_attributeset_list

        Get attribute_set list

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_attributeset_list_serialize(
            start=start,
            count=count,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAttributesetList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_attributeset_list_without_preload_content(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_attributeset_list

        Get attribute_set list

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_attributeset_list_serialize(
            start=start,
            count=count,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAttributesetList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_attributeset_list_serialize(
        self,
        start,
        count,
        params,
        exclude,
        response_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start is not None:
            
            _query_params.append(('start', start))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/attribute.attributeset.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_count(
        self,
        type: Annotated[Optional[StrictStr], Field(description="Defines attribute's type")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        visible: Annotated[Optional[StrictBool], Field(description="Filter items by visibility status")] = None,
        required: Annotated[Optional[StrictBool], Field(description="Defines if the option is required")] = None,
        system: Annotated[Optional[StrictBool], Field(description="True if attribute is system")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeCount200Response:
        """attribute_count

        Get attributes count

        :param type: Defines attribute's type
        :type type: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param visible: Filter items by visibility status
        :type visible: bool
        :param required: Defines if the option is required
        :type required: bool
        :param system: True if attribute is system
        :type system: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_count_serialize(
            type=type,
            store_id=store_id,
            lang_id=lang_id,
            visible=visible,
            required=required,
            system=system,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_count_with_http_info(
        self,
        type: Annotated[Optional[StrictStr], Field(description="Defines attribute's type")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        visible: Annotated[Optional[StrictBool], Field(description="Filter items by visibility status")] = None,
        required: Annotated[Optional[StrictBool], Field(description="Defines if the option is required")] = None,
        system: Annotated[Optional[StrictBool], Field(description="True if attribute is system")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeCount200Response]:
        """attribute_count

        Get attributes count

        :param type: Defines attribute's type
        :type type: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param visible: Filter items by visibility status
        :type visible: bool
        :param required: Defines if the option is required
        :type required: bool
        :param system: True if attribute is system
        :type system: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_count_serialize(
            type=type,
            store_id=store_id,
            lang_id=lang_id,
            visible=visible,
            required=required,
            system=system,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_count_without_preload_content(
        self,
        type: Annotated[Optional[StrictStr], Field(description="Defines attribute's type")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        visible: Annotated[Optional[StrictBool], Field(description="Filter items by visibility status")] = None,
        required: Annotated[Optional[StrictBool], Field(description="Defines if the option is required")] = None,
        system: Annotated[Optional[StrictBool], Field(description="True if attribute is system")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_count

        Get attributes count

        :param type: Defines attribute's type
        :type type: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param visible: Filter items by visibility status
        :type visible: bool
        :param required: Defines if the option is required
        :type required: bool
        :param system: True if attribute is system
        :type system: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_count_serialize(
            type=type,
            store_id=store_id,
            lang_id=lang_id,
            visible=visible,
            required=required,
            system=system,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_count_serialize(
        self,
        type,
        store_id,
        lang_id,
        visible,
        required,
        system,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if type is not None:
            
            _query_params.append(('type', type))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if visible is not None:
            
            _query_params.append(('visible', visible))
            
        if required is not None:
            
            _query_params.append(('required', required))
            
        if system is not None:
            
            _query_params.append(('system', system))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/attribute.count.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_delete(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeDelete200Response:
        """attribute_delete

        Delete attribute from store

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_delete_serialize(
            id=id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_delete_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeDelete200Response]:
        """attribute_delete

        Delete attribute from store

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_delete_serialize(
            id=id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_delete_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_delete

        Delete attribute from store

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_delete_serialize(
            id=id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_delete_serialize(
        self,
        id,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/attribute.delete.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_group_list(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        attribute_set_id: Annotated[Optional[StrictStr], Field(description="Attribute set id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeAttributesetList200Response:
        """attribute_group_list

        Get attribute group list

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param lang_id: Language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param attribute_set_id: Attribute set id
        :type attribute_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_group_list_serialize(
            start=start,
            count=count,
            lang_id=lang_id,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            attribute_set_id=attribute_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAttributesetList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_group_list_with_http_info(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        attribute_set_id: Annotated[Optional[StrictStr], Field(description="Attribute set id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeAttributesetList200Response]:
        """attribute_group_list

        Get attribute group list

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param lang_id: Language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param attribute_set_id: Attribute set id
        :type attribute_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_group_list_serialize(
            start=start,
            count=count,
            lang_id=lang_id,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            attribute_set_id=attribute_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAttributesetList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_group_list_without_preload_content(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        attribute_set_id: Annotated[Optional[StrictStr], Field(description="Attribute set id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_group_list

        Get attribute group list

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param lang_id: Language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param attribute_set_id: Attribute set id
        :type attribute_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_group_list_serialize(
            start=start,
            count=count,
            lang_id=lang_id,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            attribute_set_id=attribute_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAttributesetList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_group_list_serialize(
        self,
        start,
        count,
        lang_id,
        params,
        exclude,
        response_fields,
        attribute_set_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start is not None:
            
            _query_params.append(('start', start))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if attribute_set_id is not None:
            
            _query_params.append(('attribute_set_id', attribute_set_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/attribute.group.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_info(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeInfo200Response:
        """attribute_info

        Get attribute info

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_info_serialize(
            id=id,
            store_id=store_id,
            lang_id=lang_id,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeInfo200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_info_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeInfo200Response]:
        """attribute_info

        Get attribute info

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_info_serialize(
            id=id,
            store_id=store_id,
            lang_id=lang_id,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeInfo200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_info_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_info

        Get attribute info

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_info_serialize(
            id=id,
            store_id=store_id,
            lang_id=lang_id,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeInfo200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_info_serialize(
        self,
        id,
        store_id,
        lang_id,
        params,
        exclude,
        response_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/attribute.info.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_list(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Defines attribute's type")] = None,
        attribute_ids: Annotated[Optional[StrictStr], Field(description="Filter attributes by ids")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Retrieves attributes on specified language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        visible: Annotated[Optional[StrictBool], Field(description="Filter items by visibility status")] = None,
        required: Annotated[Optional[StrictBool], Field(description="Defines if the option is required")] = None,
        system: Annotated[Optional[StrictBool], Field(description="True if attribute is system")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelResponseAttributeList:
        """attribute_list

        Get attributes list

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param type: Defines attribute's type
        :type type: str
        :param attribute_ids: Filter attributes by ids
        :type attribute_ids: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Retrieves attributes on specified language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param visible: Filter items by visibility status
        :type visible: bool
        :param required: Defines if the option is required
        :type required: bool
        :param system: True if attribute is system
        :type system: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_list_serialize(
            start=start,
            count=count,
            type=type,
            attribute_ids=attribute_ids,
            store_id=store_id,
            lang_id=lang_id,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            visible=visible,
            required=required,
            system=system,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseAttributeList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_list_with_http_info(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Defines attribute's type")] = None,
        attribute_ids: Annotated[Optional[StrictStr], Field(description="Filter attributes by ids")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Retrieves attributes on specified language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        visible: Annotated[Optional[StrictBool], Field(description="Filter items by visibility status")] = None,
        required: Annotated[Optional[StrictBool], Field(description="Defines if the option is required")] = None,
        system: Annotated[Optional[StrictBool], Field(description="True if attribute is system")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelResponseAttributeList]:
        """attribute_list

        Get attributes list

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param type: Defines attribute's type
        :type type: str
        :param attribute_ids: Filter attributes by ids
        :type attribute_ids: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Retrieves attributes on specified language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param visible: Filter items by visibility status
        :type visible: bool
        :param required: Defines if the option is required
        :type required: bool
        :param system: True if attribute is system
        :type system: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_list_serialize(
            start=start,
            count=count,
            type=type,
            attribute_ids=attribute_ids,
            store_id=store_id,
            lang_id=lang_id,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            visible=visible,
            required=required,
            system=system,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseAttributeList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_list_without_preload_content(
        self,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Defines attribute's type")] = None,
        attribute_ids: Annotated[Optional[StrictStr], Field(description="Filter attributes by ids")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Retrieves attributes on specified language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        visible: Annotated[Optional[StrictBool], Field(description="Filter items by visibility status")] = None,
        required: Annotated[Optional[StrictBool], Field(description="Defines if the option is required")] = None,
        system: Annotated[Optional[StrictBool], Field(description="True if attribute is system")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_list

        Get attributes list

        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param type: Defines attribute's type
        :type type: str
        :param attribute_ids: Filter attributes by ids
        :type attribute_ids: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Retrieves attributes on specified language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param visible: Filter items by visibility status
        :type visible: bool
        :param required: Defines if the option is required
        :type required: bool
        :param system: True if attribute is system
        :type system: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_list_serialize(
            start=start,
            count=count,
            type=type,
            attribute_ids=attribute_ids,
            store_id=store_id,
            lang_id=lang_id,
            params=params,
            exclude=exclude,
            response_fields=response_fields,
            visible=visible,
            required=required,
            system=system,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseAttributeList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_list_serialize(
        self,
        start,
        count,
        type,
        attribute_ids,
        store_id,
        lang_id,
        params,
        exclude,
        response_fields,
        visible,
        required,
        system,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start is not None:
            
            _query_params.append(('start', start))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if attribute_ids is not None:
            
            _query_params.append(('attribute_ids', attribute_ids))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if visible is not None:
            
            _query_params.append(('visible', visible))
            
        if required is not None:
            
            _query_params.append(('required', required))
            
        if system is not None:
            
            _query_params.append(('system', system))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/attribute.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_type_list(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeTypeList200Response:
        """attribute_type_list

        Get list of supported attributes types

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_type_list_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeTypeList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_type_list_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeTypeList200Response]:
        """attribute_type_list

        Get list of supported attributes types

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_type_list_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeTypeList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_type_list_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_type_list

        Get list of supported attributes types

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_type_list_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeTypeList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_type_list_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/attribute.type.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_unassign_group(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        group_id: Annotated[StrictStr, Field(description="Customer group_id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeUnassignGroup200Response:
        """attribute_unassign_group

        Unassign attribute from group

        :param id: Entity id (required)
        :type id: str
        :param group_id: Customer group_id (required)
        :type group_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_unassign_group_serialize(
            id=id,
            group_id=group_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeUnassignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_unassign_group_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        group_id: Annotated[StrictStr, Field(description="Customer group_id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeUnassignGroup200Response]:
        """attribute_unassign_group

        Unassign attribute from group

        :param id: Entity id (required)
        :type id: str
        :param group_id: Customer group_id (required)
        :type group_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_unassign_group_serialize(
            id=id,
            group_id=group_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeUnassignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_unassign_group_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        group_id: Annotated[StrictStr, Field(description="Customer group_id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_unassign_group

        Unassign attribute from group

        :param id: Entity id (required)
        :type id: str
        :param group_id: Customer group_id (required)
        :type group_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_unassign_group_serialize(
            id=id,
            group_id=group_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeUnassignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_unassign_group_serialize(
        self,
        id,
        group_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if group_id is not None:
            
            _query_params.append(('group_id', group_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/attribute.unassign.group.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_unassign_set(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        attribute_set_id: Annotated[StrictStr, Field(description="Attribute set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeUnassignGroup200Response:
        """attribute_unassign_set

        Unassign attribute from attribute set

        :param id: Entity id (required)
        :type id: str
        :param attribute_set_id: Attribute set id (required)
        :type attribute_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_unassign_set_serialize(
            id=id,
            attribute_set_id=attribute_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeUnassignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_unassign_set_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        attribute_set_id: Annotated[StrictStr, Field(description="Attribute set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeUnassignGroup200Response]:
        """attribute_unassign_set

        Unassign attribute from attribute set

        :param id: Entity id (required)
        :type id: str
        :param attribute_set_id: Attribute set id (required)
        :type attribute_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_unassign_set_serialize(
            id=id,
            attribute_set_id=attribute_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeUnassignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_unassign_set_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        attribute_set_id: Annotated[StrictStr, Field(description="Attribute set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_unassign_set

        Unassign attribute from attribute set

        :param id: Entity id (required)
        :type id: str
        :param attribute_set_id: Attribute set id (required)
        :type attribute_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_unassign_set_serialize(
            id=id,
            attribute_set_id=attribute_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeUnassignGroup200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_unassign_set_serialize(
        self,
        id,
        attribute_set_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if attribute_set_id is not None:
            
            _query_params.append(('attribute_set_id', attribute_set_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/attribute.unassign.set.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def attribute_update(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        name: Annotated[StrictStr, Field(description="Defines new attributes's name")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeUpdate200Response:
        """attribute_update

        Update attribute data

        :param id: Entity id (required)
        :type id: str
        :param name: Defines new attributes's name (required)
        :type name: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_update_serialize(
            id=id,
            name=name,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def attribute_update_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        name: Annotated[StrictStr, Field(description="Defines new attributes's name")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeUpdate200Response]:
        """attribute_update

        Update attribute data

        :param id: Entity id (required)
        :type id: str
        :param name: Defines new attributes's name (required)
        :type name: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_update_serialize(
            id=id,
            name=name,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def attribute_update_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        name: Annotated[StrictStr, Field(description="Defines new attributes's name")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """attribute_update

        Update attribute data

        :param id: Entity id (required)
        :type id: str
        :param name: Defines new attributes's name (required)
        :type name: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._attribute_update_serialize(
            id=id,
            name=name,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _attribute_update_serialize(
        self,
        id,
        name,
        store_id,
        lang_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/attribute.update.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


