# coding: utf-8

"""
    Swagger API2Cart

    API2Cart

    The version of the OpenAPI document: 1.1
    Contact: contact@api2cart.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.account_cart_add200_response import AccountCartAdd200Response
from openapi_client.models.attribute_add200_response import AttributeAdd200Response
from openapi_client.models.attribute_delete200_response import AttributeDelete200Response
from openapi_client.models.basket_live_shipping_service_delete200_response import BasketLiveShippingServiceDelete200Response
from openapi_client.models.bridge_delete200_response import BridgeDelete200Response
from openapi_client.models.cart_bridge200_response import CartBridge200Response
from openapi_client.models.cart_catalog_price_rules_count200_response import CartCatalogPriceRulesCount200Response
from openapi_client.models.cart_clear_cache200_response import CartClearCache200Response
from openapi_client.models.cart_config200_response import CartConfig200Response
from openapi_client.models.cart_config_update import CartConfigUpdate
from openapi_client.models.cart_config_update200_response import CartConfigUpdate200Response
from openapi_client.models.cart_coupon_add import CartCouponAdd
from openapi_client.models.cart_coupon_add200_response import CartCouponAdd200Response
from openapi_client.models.cart_coupon_count200_response import CartCouponCount200Response
from openapi_client.models.cart_delete200_response import CartDelete200Response
from openapi_client.models.cart_disconnect200_response import CartDisconnect200Response
from openapi_client.models.cart_giftcard_add200_response import CartGiftcardAdd200Response
from openapi_client.models.cart_giftcard_count200_response import CartGiftcardCount200Response
from openapi_client.models.cart_info200_response import CartInfo200Response
from openapi_client.models.cart_list200_response import CartList200Response
from openapi_client.models.cart_methods200_response import CartMethods200Response
from openapi_client.models.cart_plugin_list200_response import CartPluginList200Response
from openapi_client.models.cart_script_add200_response import CartScriptAdd200Response
from openapi_client.models.cart_shipping_zones_list200_response import CartShippingZonesList200Response
from openapi_client.models.cart_validate200_response import CartValidate200Response
from openapi_client.models.model_response_cart_catalog_price_rules_list import ModelResponseCartCatalogPriceRulesList
from openapi_client.models.model_response_cart_coupon_list import ModelResponseCartCouponList
from openapi_client.models.model_response_cart_gift_card_list import ModelResponseCartGiftCardList
from openapi_client.models.model_response_cart_meta_data_list import ModelResponseCartMetaDataList
from openapi_client.models.model_response_cart_script_list import ModelResponseCartScriptList

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class CartApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def bridge_download(
        self,
        whitelabel: Annotated[Optional[StrictBool], Field(description="Identifies if there is a necessity to download whitelabel bridge.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """bridge_download

        Download bridge for store

        :param whitelabel: Identifies if there is a necessity to download whitelabel bridge.
        :type whitelabel: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bridge_download_serialize(
            whitelabel=whitelabel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def bridge_download_with_http_info(
        self,
        whitelabel: Annotated[Optional[StrictBool], Field(description="Identifies if there is a necessity to download whitelabel bridge.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """bridge_download

        Download bridge for store

        :param whitelabel: Identifies if there is a necessity to download whitelabel bridge.
        :type whitelabel: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bridge_download_serialize(
            whitelabel=whitelabel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def bridge_download_without_preload_content(
        self,
        whitelabel: Annotated[Optional[StrictBool], Field(description="Identifies if there is a necessity to download whitelabel bridge.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """bridge_download

        Download bridge for store

        :param whitelabel: Identifies if there is a necessity to download whitelabel bridge.
        :type whitelabel: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._bridge_download_serialize(
            whitelabel=whitelabel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _bridge_download_serialize(
        self,
        whitelabel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if whitelabel is not None:
            
            _query_params.append(('whitelabel', whitelabel))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/zip'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/bridge.download.file',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_bridge(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartBridge200Response:
        """cart_bridge

        Get bridge key and store key

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_bridge_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartBridge200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_bridge_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartBridge200Response]:
        """cart_bridge

        Get bridge key and store key

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_bridge_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartBridge200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_bridge_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_bridge

        Get bridge key and store key

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_bridge_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartBridge200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_bridge_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.bridge.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_catalog_price_rules_count(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartCatalogPriceRulesCount200Response:
        """cart_catalog_price_rules_count

        Get count of cart catalog price rules discounts.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_catalog_price_rules_count_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartCatalogPriceRulesCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_catalog_price_rules_count_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartCatalogPriceRulesCount200Response]:
        """cart_catalog_price_rules_count

        Get count of cart catalog price rules discounts.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_catalog_price_rules_count_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartCatalogPriceRulesCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_catalog_price_rules_count_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_catalog_price_rules_count

        Get count of cart catalog price rules discounts.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_catalog_price_rules_count_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartCatalogPriceRulesCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_catalog_price_rules_count_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.catalog_price_rules.count.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_catalog_price_rules_list(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        ids: Annotated[Optional[StrictStr], Field(description="Retrieves  catalog_price_rules by ids")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelResponseCartCatalogPriceRulesList:
        """cart_catalog_price_rules_list

        Get cart catalog price rules discounts.

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param ids: Retrieves  catalog_price_rules by ids
        :type ids: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_catalog_price_rules_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            ids=ids,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartCatalogPriceRulesList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_catalog_price_rules_list_with_http_info(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        ids: Annotated[Optional[StrictStr], Field(description="Retrieves  catalog_price_rules by ids")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelResponseCartCatalogPriceRulesList]:
        """cart_catalog_price_rules_list

        Get cart catalog price rules discounts.

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param ids: Retrieves  catalog_price_rules by ids
        :type ids: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_catalog_price_rules_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            ids=ids,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartCatalogPriceRulesList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_catalog_price_rules_list_without_preload_content(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        ids: Annotated[Optional[StrictStr], Field(description="Retrieves  catalog_price_rules by ids")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_catalog_price_rules_list

        Get cart catalog price rules discounts.

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param ids: Retrieves  catalog_price_rules by ids
        :type ids: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_catalog_price_rules_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            ids=ids,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartCatalogPriceRulesList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_catalog_price_rules_list_serialize(
        self,
        page_cursor,
        start,
        count,
        ids,
        params,
        response_fields,
        exclude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page_cursor is not None:
            
            _query_params.append(('page_cursor', page_cursor))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.catalog_price_rules.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_clear_cache(
        self,
        cache_type: Annotated[StrictStr, Field(description="Defines which cache should be cleared.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartClearCache200Response:
        """cart_clear_cache

        Clear cache on store.

        :param cache_type: Defines which cache should be cleared. (required)
        :type cache_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_clear_cache_serialize(
            cache_type=cache_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartClearCache200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_clear_cache_with_http_info(
        self,
        cache_type: Annotated[StrictStr, Field(description="Defines which cache should be cleared.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartClearCache200Response]:
        """cart_clear_cache

        Clear cache on store.

        :param cache_type: Defines which cache should be cleared. (required)
        :type cache_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_clear_cache_serialize(
            cache_type=cache_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartClearCache200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_clear_cache_without_preload_content(
        self,
        cache_type: Annotated[StrictStr, Field(description="Defines which cache should be cleared.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_clear_cache

        Clear cache on store.

        :param cache_type: Defines which cache should be cleared. (required)
        :type cache_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_clear_cache_serialize(
            cache_type=cache_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartClearCache200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_clear_cache_serialize(
        self,
        cache_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache_type is not None:
            
            _query_params.append(('cache_type', cache_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/cart.clear_cache.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_config(
        self,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartConfig200Response:
        """cart_config

        Get list of cart configs

        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_config_serialize(
            params=params,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfig200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_config_with_http_info(
        self,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartConfig200Response]:
        """cart_config

        Get list of cart configs

        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_config_serialize(
            params=params,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfig200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_config_without_preload_content(
        self,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_config

        Get list of cart configs

        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_config_serialize(
            params=params,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfig200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_config_serialize(
        self,
        params,
        exclude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if params is not None:
            
            _query_params.append(('params', params))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.config.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_config_update(
        self,
        cart_config_update: CartConfigUpdate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartConfigUpdate200Response:
        """(Deprecated) cart_config_update

        Use this API method to update custom data in client database.

        :param cart_config_update: (required)
        :type cart_config_update: CartConfigUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("PUT /cart.config.update.json is deprecated.", DeprecationWarning)

        _param = self._cart_config_update_serialize(
            cart_config_update=cart_config_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_config_update_with_http_info(
        self,
        cart_config_update: CartConfigUpdate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartConfigUpdate200Response]:
        """(Deprecated) cart_config_update

        Use this API method to update custom data in client database.

        :param cart_config_update: (required)
        :type cart_config_update: CartConfigUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("PUT /cart.config.update.json is deprecated.", DeprecationWarning)

        _param = self._cart_config_update_serialize(
            cart_config_update=cart_config_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_config_update_without_preload_content(
        self,
        cart_config_update: CartConfigUpdate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) cart_config_update

        Use this API method to update custom data in client database.

        :param cart_config_update: (required)
        :type cart_config_update: CartConfigUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("PUT /cart.config.update.json is deprecated.", DeprecationWarning)

        _param = self._cart_config_update_serialize(
            cart_config_update=cart_config_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartConfigUpdate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_config_update_serialize(
        self,
        cart_config_update,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if cart_config_update is not None:
            _body_params = cart_config_update


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/cart.config.update.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_coupon_add(
        self,
        cart_coupon_add: CartCouponAdd,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartCouponAdd200Response:
        """cart_coupon_add

        Create new coupon

        :param cart_coupon_add: (required)
        :type cart_coupon_add: CartCouponAdd
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_add_serialize(
            cart_coupon_add=cart_coupon_add,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartCouponAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_coupon_add_with_http_info(
        self,
        cart_coupon_add: CartCouponAdd,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartCouponAdd200Response]:
        """cart_coupon_add

        Create new coupon

        :param cart_coupon_add: (required)
        :type cart_coupon_add: CartCouponAdd
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_add_serialize(
            cart_coupon_add=cart_coupon_add,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartCouponAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_coupon_add_without_preload_content(
        self,
        cart_coupon_add: CartCouponAdd,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_coupon_add

        Create new coupon

        :param cart_coupon_add: (required)
        :type cart_coupon_add: CartCouponAdd
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_add_serialize(
            cart_coupon_add=cart_coupon_add,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartCouponAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_coupon_add_serialize(
        self,
        cart_coupon_add,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if cart_coupon_add is not None:
            _body_params = cart_coupon_add


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/cart.coupon.add.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_coupon_condition_add(
        self,
        coupon_id: Annotated[StrictStr, Field(description="Coupon Id")],
        entity: Annotated[StrictStr, Field(description="Defines condition entity type")],
        key: Annotated[StrictStr, Field(description="Defines condition entity attribute key")],
        operator: Annotated[StrictStr, Field(description="Defines condition operator")],
        value: Annotated[StrictStr, Field(description="Defines condition value, can be comma separated according to the operator.")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        target: Annotated[Optional[StrictStr], Field(description="Defines condition operator")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BasketLiveShippingServiceDelete200Response:
        """cart_coupon_condition_add

        Create new coupon condition

        :param coupon_id: Coupon Id (required)
        :type coupon_id: str
        :param entity: Defines condition entity type (required)
        :type entity: str
        :param key: Defines condition entity attribute key (required)
        :type key: str
        :param operator: Defines condition operator (required)
        :type operator: str
        :param value: Defines condition value, can be comma separated according to the operator. (required)
        :type value: str
        :param store_id: Store Id
        :type store_id: str
        :param target: Defines condition operator
        :type target: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_condition_add_serialize(
            coupon_id=coupon_id,
            entity=entity,
            key=key,
            operator=operator,
            value=value,
            store_id=store_id,
            target=target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BasketLiveShippingServiceDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_coupon_condition_add_with_http_info(
        self,
        coupon_id: Annotated[StrictStr, Field(description="Coupon Id")],
        entity: Annotated[StrictStr, Field(description="Defines condition entity type")],
        key: Annotated[StrictStr, Field(description="Defines condition entity attribute key")],
        operator: Annotated[StrictStr, Field(description="Defines condition operator")],
        value: Annotated[StrictStr, Field(description="Defines condition value, can be comma separated according to the operator.")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        target: Annotated[Optional[StrictStr], Field(description="Defines condition operator")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BasketLiveShippingServiceDelete200Response]:
        """cart_coupon_condition_add

        Create new coupon condition

        :param coupon_id: Coupon Id (required)
        :type coupon_id: str
        :param entity: Defines condition entity type (required)
        :type entity: str
        :param key: Defines condition entity attribute key (required)
        :type key: str
        :param operator: Defines condition operator (required)
        :type operator: str
        :param value: Defines condition value, can be comma separated according to the operator. (required)
        :type value: str
        :param store_id: Store Id
        :type store_id: str
        :param target: Defines condition operator
        :type target: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_condition_add_serialize(
            coupon_id=coupon_id,
            entity=entity,
            key=key,
            operator=operator,
            value=value,
            store_id=store_id,
            target=target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BasketLiveShippingServiceDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_coupon_condition_add_without_preload_content(
        self,
        coupon_id: Annotated[StrictStr, Field(description="Coupon Id")],
        entity: Annotated[StrictStr, Field(description="Defines condition entity type")],
        key: Annotated[StrictStr, Field(description="Defines condition entity attribute key")],
        operator: Annotated[StrictStr, Field(description="Defines condition operator")],
        value: Annotated[StrictStr, Field(description="Defines condition value, can be comma separated according to the operator.")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        target: Annotated[Optional[StrictStr], Field(description="Defines condition operator")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_coupon_condition_add

        Create new coupon condition

        :param coupon_id: Coupon Id (required)
        :type coupon_id: str
        :param entity: Defines condition entity type (required)
        :type entity: str
        :param key: Defines condition entity attribute key (required)
        :type key: str
        :param operator: Defines condition operator (required)
        :type operator: str
        :param value: Defines condition value, can be comma separated according to the operator. (required)
        :type value: str
        :param store_id: Store Id
        :type store_id: str
        :param target: Defines condition operator
        :type target: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_condition_add_serialize(
            coupon_id=coupon_id,
            entity=entity,
            key=key,
            operator=operator,
            value=value,
            store_id=store_id,
            target=target,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BasketLiveShippingServiceDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_coupon_condition_add_serialize(
        self,
        coupon_id,
        entity,
        key,
        operator,
        value,
        store_id,
        target,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if coupon_id is not None:
            
            _query_params.append(('coupon_id', coupon_id))
            
        if target is not None:
            
            _query_params.append(('target', target))
            
        if entity is not None:
            
            _query_params.append(('entity', entity))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if operator is not None:
            
            _query_params.append(('operator', operator))
            
        if value is not None:
            
            _query_params.append(('value', value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/cart.coupon.condition.add.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_coupon_count(
        self,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        date_start_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (greater or equal)")] = None,
        date_start_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (less or equal)")] = None,
        date_end_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (greater or equal)")] = None,
        date_end_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (less or equal)")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartCouponCount200Response:
        """cart_coupon_count

        Get cart coupons count.

        :param store_id: Store Id
        :type store_id: str
        :param date_start_from: Filter entity by date_start (greater or equal)
        :type date_start_from: str
        :param date_start_to: Filter entity by date_start (less or equal)
        :type date_start_to: str
        :param date_end_from: Filter entity by date_end (greater or equal)
        :type date_end_from: str
        :param date_end_to: Filter entity by date_end (less or equal)
        :type date_end_to: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_count_serialize(
            store_id=store_id,
            date_start_from=date_start_from,
            date_start_to=date_start_to,
            date_end_from=date_end_from,
            date_end_to=date_end_to,
            avail=avail,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartCouponCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_coupon_count_with_http_info(
        self,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        date_start_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (greater or equal)")] = None,
        date_start_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (less or equal)")] = None,
        date_end_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (greater or equal)")] = None,
        date_end_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (less or equal)")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartCouponCount200Response]:
        """cart_coupon_count

        Get cart coupons count.

        :param store_id: Store Id
        :type store_id: str
        :param date_start_from: Filter entity by date_start (greater or equal)
        :type date_start_from: str
        :param date_start_to: Filter entity by date_start (less or equal)
        :type date_start_to: str
        :param date_end_from: Filter entity by date_end (greater or equal)
        :type date_end_from: str
        :param date_end_to: Filter entity by date_end (less or equal)
        :type date_end_to: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_count_serialize(
            store_id=store_id,
            date_start_from=date_start_from,
            date_start_to=date_start_to,
            date_end_from=date_end_from,
            date_end_to=date_end_to,
            avail=avail,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartCouponCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_coupon_count_without_preload_content(
        self,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        date_start_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (greater or equal)")] = None,
        date_start_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (less or equal)")] = None,
        date_end_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (greater or equal)")] = None,
        date_end_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (less or equal)")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Defines category's visibility status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_coupon_count

        Get cart coupons count.

        :param store_id: Store Id
        :type store_id: str
        :param date_start_from: Filter entity by date_start (greater or equal)
        :type date_start_from: str
        :param date_start_to: Filter entity by date_start (less or equal)
        :type date_start_to: str
        :param date_end_from: Filter entity by date_end (greater or equal)
        :type date_end_from: str
        :param date_end_to: Filter entity by date_end (less or equal)
        :type date_end_to: str
        :param avail: Defines category's visibility status
        :type avail: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_count_serialize(
            store_id=store_id,
            date_start_from=date_start_from,
            date_start_to=date_start_to,
            date_end_from=date_end_from,
            date_end_to=date_end_to,
            avail=avail,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartCouponCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_coupon_count_serialize(
        self,
        store_id,
        date_start_from,
        date_start_to,
        date_end_from,
        date_end_to,
        avail,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if date_start_from is not None:
            
            _query_params.append(('date_start_from', date_start_from))
            
        if date_start_to is not None:
            
            _query_params.append(('date_start_to', date_start_to))
            
        if date_end_from is not None:
            
            _query_params.append(('date_end_from', date_end_from))
            
        if date_end_to is not None:
            
            _query_params.append(('date_end_to', date_end_to))
            
        if avail is not None:
            
            _query_params.append(('avail', avail))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.coupon.count.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_coupon_delete(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeDelete200Response:
        """cart_coupon_delete

        Delete coupon

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_delete_serialize(
            id=id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_coupon_delete_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeDelete200Response]:
        """cart_coupon_delete

        Delete coupon

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_delete_serialize(
            id=id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_coupon_delete_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_coupon_delete

        Delete coupon

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_delete_serialize(
            id=id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_coupon_delete_serialize(
        self,
        id,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/cart.coupon.delete.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_coupon_list(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        coupons_ids: Annotated[Optional[StrictStr], Field(description="Filter coupons by ids")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Filter coupons by store id")] = None,
        date_start_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (greater or equal)")] = None,
        date_start_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (less or equal)")] = None,
        date_end_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (greater or equal)")] = None,
        date_end_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (less or equal)")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Filter coupons by avail status")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelResponseCartCouponList:
        """cart_coupon_list

        Get cart coupon discounts.

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param coupons_ids: Filter coupons by ids
        :type coupons_ids: str
        :param store_id: Filter coupons by store id
        :type store_id: str
        :param date_start_from: Filter entity by date_start (greater or equal)
        :type date_start_from: str
        :param date_start_to: Filter entity by date_start (less or equal)
        :type date_start_to: str
        :param date_end_from: Filter entity by date_end (greater or equal)
        :type date_end_from: str
        :param date_end_to: Filter entity by date_end (less or equal)
        :type date_end_to: str
        :param avail: Filter coupons by avail status
        :type avail: bool
        :param lang_id: Language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            coupons_ids=coupons_ids,
            store_id=store_id,
            date_start_from=date_start_from,
            date_start_to=date_start_to,
            date_end_from=date_end_from,
            date_end_to=date_end_to,
            avail=avail,
            lang_id=lang_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartCouponList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_coupon_list_with_http_info(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        coupons_ids: Annotated[Optional[StrictStr], Field(description="Filter coupons by ids")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Filter coupons by store id")] = None,
        date_start_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (greater or equal)")] = None,
        date_start_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (less or equal)")] = None,
        date_end_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (greater or equal)")] = None,
        date_end_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (less or equal)")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Filter coupons by avail status")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelResponseCartCouponList]:
        """cart_coupon_list

        Get cart coupon discounts.

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param coupons_ids: Filter coupons by ids
        :type coupons_ids: str
        :param store_id: Filter coupons by store id
        :type store_id: str
        :param date_start_from: Filter entity by date_start (greater or equal)
        :type date_start_from: str
        :param date_start_to: Filter entity by date_start (less or equal)
        :type date_start_to: str
        :param date_end_from: Filter entity by date_end (greater or equal)
        :type date_end_from: str
        :param date_end_to: Filter entity by date_end (less or equal)
        :type date_end_to: str
        :param avail: Filter coupons by avail status
        :type avail: bool
        :param lang_id: Language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            coupons_ids=coupons_ids,
            store_id=store_id,
            date_start_from=date_start_from,
            date_start_to=date_start_to,
            date_end_from=date_end_from,
            date_end_to=date_end_to,
            avail=avail,
            lang_id=lang_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartCouponList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_coupon_list_without_preload_content(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        coupons_ids: Annotated[Optional[StrictStr], Field(description="Filter coupons by ids")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Filter coupons by store id")] = None,
        date_start_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (greater or equal)")] = None,
        date_start_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_start (less or equal)")] = None,
        date_end_from: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (greater or equal)")] = None,
        date_end_to: Annotated[Optional[StrictStr], Field(description="Filter entity by date_end (less or equal)")] = None,
        avail: Annotated[Optional[StrictBool], Field(description="Filter coupons by avail status")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_coupon_list

        Get cart coupon discounts.

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param coupons_ids: Filter coupons by ids
        :type coupons_ids: str
        :param store_id: Filter coupons by store id
        :type store_id: str
        :param date_start_from: Filter entity by date_start (greater or equal)
        :type date_start_from: str
        :param date_start_to: Filter entity by date_start (less or equal)
        :type date_start_to: str
        :param date_end_from: Filter entity by date_end (greater or equal)
        :type date_end_from: str
        :param date_end_to: Filter entity by date_end (less or equal)
        :type date_end_to: str
        :param avail: Filter coupons by avail status
        :type avail: bool
        :param lang_id: Language id
        :type lang_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_coupon_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            coupons_ids=coupons_ids,
            store_id=store_id,
            date_start_from=date_start_from,
            date_start_to=date_start_to,
            date_end_from=date_end_from,
            date_end_to=date_end_to,
            avail=avail,
            lang_id=lang_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartCouponList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_coupon_list_serialize(
        self,
        page_cursor,
        start,
        count,
        coupons_ids,
        store_id,
        date_start_from,
        date_start_to,
        date_end_from,
        date_end_to,
        avail,
        lang_id,
        params,
        response_fields,
        exclude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page_cursor is not None:
            
            _query_params.append(('page_cursor', page_cursor))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if coupons_ids is not None:
            
            _query_params.append(('coupons_ids', coupons_ids))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if date_start_from is not None:
            
            _query_params.append(('date_start_from', date_start_from))
            
        if date_start_to is not None:
            
            _query_params.append(('date_start_to', date_start_to))
            
        if date_end_from is not None:
            
            _query_params.append(('date_end_from', date_end_from))
            
        if date_end_to is not None:
            
            _query_params.append(('date_end_to', date_end_to))
            
        if avail is not None:
            
            _query_params.append(('avail', avail))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.coupon.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_create(
        self,
        cart_id: Annotated[StrictStr, Field(description="Store’s identifier which you can get from cart_list method")],
        store_url: Annotated[StrictStr, Field(description="A web address of a store that you would like to connect to API2Cart")],
        etsy_client_id: Annotated[StrictStr, Field(description="Etsy Client Id")],
        etsy_refresh_token: Annotated[StrictStr, Field(description="Etsy Refresh token")],
        store_id: Annotated[StrictStr, Field(description="Store Id")],
        bridge_url: Annotated[Optional[StrictStr], Field(description="This parameter allows to set up store with custom bridge url (also you must use store_root parameter if a bridge folder is not in the root folder of the store)")] = None,
        store_root: Annotated[Optional[StrictStr], Field(description="Absolute path to the store root directory (used with \"bridge_url\" parameter)")] = None,
        store_key: Annotated[Optional[StrictStr], Field(description="Set this parameter if bridge is already uploaded to store")] = None,
        shared_secret: Annotated[Optional[StrictStr], Field(description="Shared secret")] = None,
        validate_version: Annotated[Optional[StrictBool], Field(description="Specify if api2cart should validate cart version")] = None,
        verify: Annotated[Optional[StrictBool], Field(description="Enables or disables cart's verification")] = None,
        db_tables_prefix: Annotated[Optional[StrictStr], Field(description="DB tables prefix")] = None,
        ftp_host: Annotated[Optional[StrictStr], Field(description="FTP connection host")] = None,
        ftp_user: Annotated[Optional[StrictStr], Field(description="FTP User")] = None,
        ftp_password: Annotated[Optional[StrictStr], Field(description="FTP Password")] = None,
        ftp_port: Annotated[Optional[StrictInt], Field(description="FTP Port")] = None,
        ftp_store_dir: Annotated[Optional[StrictStr], Field(description="FTP Store dir")] = None,
        api_key_3dcart: Annotated[Optional[StrictStr], Field(description="3DCart API Key")] = None,
        admin_account: Annotated[Optional[StrictStr], Field(description="It's a BigCommerce account for which API is enabled")] = None,
        api_path: Annotated[Optional[StrictStr], Field(description="BigCommerce API URL")] = None,
        api_key: Annotated[Optional[StrictStr], Field(description="Bigcommerce API Key")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Client ID of the requesting app")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="Access token authorizing the app to access resources on behalf of a user")] = None,
        context: Annotated[Optional[StrictStr], Field(description="API Path section unique to the store")] = None,
        access_token2: Annotated[Optional[StrictStr], Field(description="Access token authorizing the app to access resources on behalf of a user")] = None,
        api_key_shopify: Annotated[Optional[StrictStr], Field(description="Shopify API Key")] = None,
        api_password: Annotated[Optional[StrictStr], Field(description="Shopify API Password")] = None,
        access_token_shopify: Annotated[Optional[StrictStr], Field(description="Access token authorizing the app to access resources on behalf of a user")] = None,
        api_key2: Annotated[Optional[StrictStr], Field(description="Neto API Key")] = None,
        api_username: Annotated[Optional[StrictStr], Field(description="Neto User Name")] = None,
        encrypted_password: Annotated[Optional[StrictStr], Field(description="Volusion API Password")] = None,
        login: Annotated[Optional[StrictStr], Field(description="It's a Volusion account for which API is enabled")] = None,
        api_user_adnsf: Annotated[Optional[StrictStr], Field(description="It's a AspDotNetStorefront account for which API is available")] = None,
        api_pass: Annotated[Optional[StrictStr], Field(description="AspDotNetStorefront API Password")] = None,
        private_key: Annotated[Optional[StrictStr], Field(description="3DCart Application Private Key")] = None,
        app_token: Annotated[Optional[StrictStr], Field(description="3DCart Token from Application")] = None,
        etsy_keystring: Annotated[Optional[StrictStr], Field(description="Etsy keystring")] = None,
        etsy_shared_secret: Annotated[Optional[StrictStr], Field(description="Etsy shared secret")] = None,
        token_secret: Annotated[Optional[StrictStr], Field(description="Secret token authorizing the app to access resources on behalf of a user")] = None,
        ebay_client_id: Annotated[Optional[StrictStr], Field(description="Application ID (AppID).")] = None,
        ebay_client_secret: Annotated[Optional[StrictStr], Field(description="Shared Secret from eBay application")] = None,
        ebay_runame: Annotated[Optional[StrictStr], Field(description="The RuName value that eBay assigns to your application.")] = None,
        ebay_access_token: Annotated[Optional[StrictStr], Field(description="Used to authenticate API requests.")] = None,
        ebay_refresh_token: Annotated[Optional[StrictStr], Field(description="Used to renew the access token.")] = None,
        ebay_environment: Annotated[Optional[StrictStr], Field(description="eBay environment")] = None,
        ebay_site_id: Annotated[Optional[StrictInt], Field(description="eBay global ID")] = None,
        dw_client_id: Annotated[Optional[StrictStr], Field(description="Demandware client id")] = None,
        dw_api_pass: Annotated[Optional[StrictStr], Field(description="Demandware api password")] = None,
        demandware_user_name: Annotated[Optional[StrictStr], Field(description="Demandware user name")] = None,
        demandware_user_password: Annotated[Optional[StrictStr], Field(description="Demandware user password")] = None,
        seller_id: Annotated[Optional[StrictStr], Field(description="Seller Id")] = None,
        amazon_secret_key: Annotated[Optional[StrictStr], Field(description="Amazon Secret Key")] = None,
        amazon_access_key_id: Annotated[Optional[StrictStr], Field(description="Amazon Secret Key Id")] = None,
        marketplaces_ids: Annotated[Optional[StrictStr], Field(description="Comma separated marketplaces ids")] = None,
        environment: Optional[StrictStr] = None,
        hybris_client_id: Annotated[Optional[StrictStr], Field(description="Omni Commerce Connector Client ID")] = None,
        hybris_client_secret: Annotated[Optional[StrictStr], Field(description="Omni Commerce Connector Client Secret")] = None,
        hybris_username: Annotated[Optional[StrictStr], Field(description="User Name")] = None,
        hybris_password: Annotated[Optional[StrictStr], Field(description="User password")] = None,
        hybris_websites: Annotated[Optional[List[StrictStr]], Field(description="Websites to stores mapping data")] = None,
        walmart_client_id: Annotated[Optional[StrictStr], Field(description="Walmart client ID")] = None,
        walmart_client_secret: Annotated[Optional[StrictStr], Field(description="Walmart client secret")] = None,
        walmart_environment: Annotated[Optional[StrictStr], Field(description="Walmart environment")] = None,
        walmart_channel_type: Annotated[Optional[StrictStr], Field(description="Walmart WM_CONSUMER.CHANNEL.TYPE header")] = None,
        lightspeed_api_key: Annotated[Optional[StrictStr], Field(description="LightSpeed api key")] = None,
        lightspeed_api_secret: Annotated[Optional[StrictStr], Field(description="LightSpeed api secret")] = None,
        shopware_access_key: Annotated[Optional[StrictStr], Field(description="Shopware access key")] = None,
        shopware_api_key: Annotated[Optional[StrictStr], Field(description="Shopware api key")] = None,
        shopware_api_secret: Annotated[Optional[StrictStr], Field(description="Shopware client secret access key")] = None,
        commercehq_api_key: Annotated[Optional[StrictStr], Field(description="CommerceHQ api key")] = None,
        commercehq_api_password: Annotated[Optional[StrictStr], Field(description="CommerceHQ api password")] = None,
        var_3dcart_private_key: Annotated[Optional[StrictStr], Field(description="3DCart Private Key")] = None,
        var_3dcart_access_token: Annotated[Optional[StrictStr], Field(description="3DCart Token")] = None,
        wc_consumer_key: Annotated[Optional[StrictStr], Field(description="Woocommerce consumer key")] = None,
        wc_consumer_secret: Annotated[Optional[StrictStr], Field(description="Woocommerce consumer secret")] = None,
        magento_consumer_key: Annotated[Optional[StrictStr], Field(description="Magento Consumer Key")] = None,
        magento_consumer_secret: Annotated[Optional[StrictStr], Field(description="Magento Consumer Secret")] = None,
        magento_access_token: Annotated[Optional[StrictStr], Field(description="Magento Access Token")] = None,
        magento_token_secret: Annotated[Optional[StrictStr], Field(description="Magento Token Secret")] = None,
        prestashop_webservice_key: Annotated[Optional[StrictStr], Field(description="Prestashop webservice key")] = None,
        wix_app_id: Annotated[Optional[StrictStr], Field(description="Wix App ID")] = None,
        wix_app_secret_key: Annotated[Optional[StrictStr], Field(description="Wix App Secret Key")] = None,
        wix_refresh_token: Annotated[Optional[StrictStr], Field(description="Wix refresh token")] = None,
        mercado_libre_app_id: Annotated[Optional[StrictStr], Field(description="Mercado Libre App ID")] = None,
        mercado_libre_app_secret_key: Annotated[Optional[StrictStr], Field(description="Mercado Libre App Secret Key")] = None,
        mercado_libre_refresh_token: Annotated[Optional[StrictStr], Field(description="Mercado Libre Refresh Token")] = None,
        zid_client_id: Annotated[Optional[StrictInt], Field(description="Zid Client ID")] = None,
        zid_client_secret: Annotated[Optional[StrictStr], Field(description="Zid Client Secret")] = None,
        zid_access_token: Annotated[Optional[StrictStr], Field(description="Zid Access Token")] = None,
        zid_authorization: Annotated[Optional[StrictStr], Field(description="Zid Authorization")] = None,
        zid_refresh_token: Annotated[Optional[StrictStr], Field(description="Zid refresh token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountCartAdd200Response:
        """(Deprecated) cart_create

        Add store to the account

        :param cart_id: Store’s identifier which you can get from cart_list method (required)
        :type cart_id: str
        :param store_url: A web address of a store that you would like to connect to API2Cart (required)
        :type store_url: str
        :param etsy_client_id: Etsy Client Id (required)
        :type etsy_client_id: str
        :param etsy_refresh_token: Etsy Refresh token (required)
        :type etsy_refresh_token: str
        :param store_id: Store Id (required)
        :type store_id: str
        :param bridge_url: This parameter allows to set up store with custom bridge url (also you must use store_root parameter if a bridge folder is not in the root folder of the store)
        :type bridge_url: str
        :param store_root: Absolute path to the store root directory (used with \"bridge_url\" parameter)
        :type store_root: str
        :param store_key: Set this parameter if bridge is already uploaded to store
        :type store_key: str
        :param shared_secret: Shared secret
        :type shared_secret: str
        :param validate_version: Specify if api2cart should validate cart version
        :type validate_version: bool
        :param verify: Enables or disables cart's verification
        :type verify: bool
        :param db_tables_prefix: DB tables prefix
        :type db_tables_prefix: str
        :param ftp_host: FTP connection host
        :type ftp_host: str
        :param ftp_user: FTP User
        :type ftp_user: str
        :param ftp_password: FTP Password
        :type ftp_password: str
        :param ftp_port: FTP Port
        :type ftp_port: int
        :param ftp_store_dir: FTP Store dir
        :type ftp_store_dir: str
        :param api_key_3dcart: 3DCart API Key
        :type api_key_3dcart: str
        :param admin_account: It's a BigCommerce account for which API is enabled
        :type admin_account: str
        :param api_path: BigCommerce API URL
        :type api_path: str
        :param api_key: Bigcommerce API Key
        :type api_key: str
        :param client_id: Client ID of the requesting app
        :type client_id: str
        :param access_token: Access token authorizing the app to access resources on behalf of a user
        :type access_token: str
        :param context: API Path section unique to the store
        :type context: str
        :param access_token2: Access token authorizing the app to access resources on behalf of a user
        :type access_token2: str
        :param api_key_shopify: Shopify API Key
        :type api_key_shopify: str
        :param api_password: Shopify API Password
        :type api_password: str
        :param access_token_shopify: Access token authorizing the app to access resources on behalf of a user
        :type access_token_shopify: str
        :param api_key2: Neto API Key
        :type api_key2: str
        :param api_username: Neto User Name
        :type api_username: str
        :param encrypted_password: Volusion API Password
        :type encrypted_password: str
        :param login: It's a Volusion account for which API is enabled
        :type login: str
        :param api_user_adnsf: It's a AspDotNetStorefront account for which API is available
        :type api_user_adnsf: str
        :param api_pass: AspDotNetStorefront API Password
        :type api_pass: str
        :param private_key: 3DCart Application Private Key
        :type private_key: str
        :param app_token: 3DCart Token from Application
        :type app_token: str
        :param etsy_keystring: Etsy keystring
        :type etsy_keystring: str
        :param etsy_shared_secret: Etsy shared secret
        :type etsy_shared_secret: str
        :param token_secret: Secret token authorizing the app to access resources on behalf of a user
        :type token_secret: str
        :param ebay_client_id: Application ID (AppID).
        :type ebay_client_id: str
        :param ebay_client_secret: Shared Secret from eBay application
        :type ebay_client_secret: str
        :param ebay_runame: The RuName value that eBay assigns to your application.
        :type ebay_runame: str
        :param ebay_access_token: Used to authenticate API requests.
        :type ebay_access_token: str
        :param ebay_refresh_token: Used to renew the access token.
        :type ebay_refresh_token: str
        :param ebay_environment: eBay environment
        :type ebay_environment: str
        :param ebay_site_id: eBay global ID
        :type ebay_site_id: int
        :param dw_client_id: Demandware client id
        :type dw_client_id: str
        :param dw_api_pass: Demandware api password
        :type dw_api_pass: str
        :param demandware_user_name: Demandware user name
        :type demandware_user_name: str
        :param demandware_user_password: Demandware user password
        :type demandware_user_password: str
        :param seller_id: Seller Id
        :type seller_id: str
        :param amazon_secret_key: Amazon Secret Key
        :type amazon_secret_key: str
        :param amazon_access_key_id: Amazon Secret Key Id
        :type amazon_access_key_id: str
        :param marketplaces_ids: Comma separated marketplaces ids
        :type marketplaces_ids: str
        :param environment: 
        :type environment: str
        :param hybris_client_id: Omni Commerce Connector Client ID
        :type hybris_client_id: str
        :param hybris_client_secret: Omni Commerce Connector Client Secret
        :type hybris_client_secret: str
        :param hybris_username: User Name
        :type hybris_username: str
        :param hybris_password: User password
        :type hybris_password: str
        :param hybris_websites: Websites to stores mapping data
        :type hybris_websites: List[str]
        :param walmart_client_id: Walmart client ID
        :type walmart_client_id: str
        :param walmart_client_secret: Walmart client secret
        :type walmart_client_secret: str
        :param walmart_environment: Walmart environment
        :type walmart_environment: str
        :param walmart_channel_type: Walmart WM_CONSUMER.CHANNEL.TYPE header
        :type walmart_channel_type: str
        :param lightspeed_api_key: LightSpeed api key
        :type lightspeed_api_key: str
        :param lightspeed_api_secret: LightSpeed api secret
        :type lightspeed_api_secret: str
        :param shopware_access_key: Shopware access key
        :type shopware_access_key: str
        :param shopware_api_key: Shopware api key
        :type shopware_api_key: str
        :param shopware_api_secret: Shopware client secret access key
        :type shopware_api_secret: str
        :param commercehq_api_key: CommerceHQ api key
        :type commercehq_api_key: str
        :param commercehq_api_password: CommerceHQ api password
        :type commercehq_api_password: str
        :param var_3dcart_private_key: 3DCart Private Key
        :type var_3dcart_private_key: str
        :param var_3dcart_access_token: 3DCart Token
        :type var_3dcart_access_token: str
        :param wc_consumer_key: Woocommerce consumer key
        :type wc_consumer_key: str
        :param wc_consumer_secret: Woocommerce consumer secret
        :type wc_consumer_secret: str
        :param magento_consumer_key: Magento Consumer Key
        :type magento_consumer_key: str
        :param magento_consumer_secret: Magento Consumer Secret
        :type magento_consumer_secret: str
        :param magento_access_token: Magento Access Token
        :type magento_access_token: str
        :param magento_token_secret: Magento Token Secret
        :type magento_token_secret: str
        :param prestashop_webservice_key: Prestashop webservice key
        :type prestashop_webservice_key: str
        :param wix_app_id: Wix App ID
        :type wix_app_id: str
        :param wix_app_secret_key: Wix App Secret Key
        :type wix_app_secret_key: str
        :param wix_refresh_token: Wix refresh token
        :type wix_refresh_token: str
        :param mercado_libre_app_id: Mercado Libre App ID
        :type mercado_libre_app_id: str
        :param mercado_libre_app_secret_key: Mercado Libre App Secret Key
        :type mercado_libre_app_secret_key: str
        :param mercado_libre_refresh_token: Mercado Libre Refresh Token
        :type mercado_libre_refresh_token: str
        :param zid_client_id: Zid Client ID
        :type zid_client_id: int
        :param zid_client_secret: Zid Client Secret
        :type zid_client_secret: str
        :param zid_access_token: Zid Access Token
        :type zid_access_token: str
        :param zid_authorization: Zid Authorization
        :type zid_authorization: str
        :param zid_refresh_token: Zid refresh token
        :type zid_refresh_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /cart.create.json is deprecated.", DeprecationWarning)

        _param = self._cart_create_serialize(
            cart_id=cart_id,
            store_url=store_url,
            etsy_client_id=etsy_client_id,
            etsy_refresh_token=etsy_refresh_token,
            store_id=store_id,
            bridge_url=bridge_url,
            store_root=store_root,
            store_key=store_key,
            shared_secret=shared_secret,
            validate_version=validate_version,
            verify=verify,
            db_tables_prefix=db_tables_prefix,
            ftp_host=ftp_host,
            ftp_user=ftp_user,
            ftp_password=ftp_password,
            ftp_port=ftp_port,
            ftp_store_dir=ftp_store_dir,
            api_key_3dcart=api_key_3dcart,
            admin_account=admin_account,
            api_path=api_path,
            api_key=api_key,
            client_id=client_id,
            access_token=access_token,
            context=context,
            access_token2=access_token2,
            api_key_shopify=api_key_shopify,
            api_password=api_password,
            access_token_shopify=access_token_shopify,
            api_key2=api_key2,
            api_username=api_username,
            encrypted_password=encrypted_password,
            login=login,
            api_user_adnsf=api_user_adnsf,
            api_pass=api_pass,
            private_key=private_key,
            app_token=app_token,
            etsy_keystring=etsy_keystring,
            etsy_shared_secret=etsy_shared_secret,
            token_secret=token_secret,
            ebay_client_id=ebay_client_id,
            ebay_client_secret=ebay_client_secret,
            ebay_runame=ebay_runame,
            ebay_access_token=ebay_access_token,
            ebay_refresh_token=ebay_refresh_token,
            ebay_environment=ebay_environment,
            ebay_site_id=ebay_site_id,
            dw_client_id=dw_client_id,
            dw_api_pass=dw_api_pass,
            demandware_user_name=demandware_user_name,
            demandware_user_password=demandware_user_password,
            seller_id=seller_id,
            amazon_secret_key=amazon_secret_key,
            amazon_access_key_id=amazon_access_key_id,
            marketplaces_ids=marketplaces_ids,
            environment=environment,
            hybris_client_id=hybris_client_id,
            hybris_client_secret=hybris_client_secret,
            hybris_username=hybris_username,
            hybris_password=hybris_password,
            hybris_websites=hybris_websites,
            walmart_client_id=walmart_client_id,
            walmart_client_secret=walmart_client_secret,
            walmart_environment=walmart_environment,
            walmart_channel_type=walmart_channel_type,
            lightspeed_api_key=lightspeed_api_key,
            lightspeed_api_secret=lightspeed_api_secret,
            shopware_access_key=shopware_access_key,
            shopware_api_key=shopware_api_key,
            shopware_api_secret=shopware_api_secret,
            commercehq_api_key=commercehq_api_key,
            commercehq_api_password=commercehq_api_password,
            var_3dcart_private_key=var_3dcart_private_key,
            var_3dcart_access_token=var_3dcart_access_token,
            wc_consumer_key=wc_consumer_key,
            wc_consumer_secret=wc_consumer_secret,
            magento_consumer_key=magento_consumer_key,
            magento_consumer_secret=magento_consumer_secret,
            magento_access_token=magento_access_token,
            magento_token_secret=magento_token_secret,
            prestashop_webservice_key=prestashop_webservice_key,
            wix_app_id=wix_app_id,
            wix_app_secret_key=wix_app_secret_key,
            wix_refresh_token=wix_refresh_token,
            mercado_libre_app_id=mercado_libre_app_id,
            mercado_libre_app_secret_key=mercado_libre_app_secret_key,
            mercado_libre_refresh_token=mercado_libre_refresh_token,
            zid_client_id=zid_client_id,
            zid_client_secret=zid_client_secret,
            zid_access_token=zid_access_token,
            zid_authorization=zid_authorization,
            zid_refresh_token=zid_refresh_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountCartAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_create_with_http_info(
        self,
        cart_id: Annotated[StrictStr, Field(description="Store’s identifier which you can get from cart_list method")],
        store_url: Annotated[StrictStr, Field(description="A web address of a store that you would like to connect to API2Cart")],
        etsy_client_id: Annotated[StrictStr, Field(description="Etsy Client Id")],
        etsy_refresh_token: Annotated[StrictStr, Field(description="Etsy Refresh token")],
        store_id: Annotated[StrictStr, Field(description="Store Id")],
        bridge_url: Annotated[Optional[StrictStr], Field(description="This parameter allows to set up store with custom bridge url (also you must use store_root parameter if a bridge folder is not in the root folder of the store)")] = None,
        store_root: Annotated[Optional[StrictStr], Field(description="Absolute path to the store root directory (used with \"bridge_url\" parameter)")] = None,
        store_key: Annotated[Optional[StrictStr], Field(description="Set this parameter if bridge is already uploaded to store")] = None,
        shared_secret: Annotated[Optional[StrictStr], Field(description="Shared secret")] = None,
        validate_version: Annotated[Optional[StrictBool], Field(description="Specify if api2cart should validate cart version")] = None,
        verify: Annotated[Optional[StrictBool], Field(description="Enables or disables cart's verification")] = None,
        db_tables_prefix: Annotated[Optional[StrictStr], Field(description="DB tables prefix")] = None,
        ftp_host: Annotated[Optional[StrictStr], Field(description="FTP connection host")] = None,
        ftp_user: Annotated[Optional[StrictStr], Field(description="FTP User")] = None,
        ftp_password: Annotated[Optional[StrictStr], Field(description="FTP Password")] = None,
        ftp_port: Annotated[Optional[StrictInt], Field(description="FTP Port")] = None,
        ftp_store_dir: Annotated[Optional[StrictStr], Field(description="FTP Store dir")] = None,
        api_key_3dcart: Annotated[Optional[StrictStr], Field(description="3DCart API Key")] = None,
        admin_account: Annotated[Optional[StrictStr], Field(description="It's a BigCommerce account for which API is enabled")] = None,
        api_path: Annotated[Optional[StrictStr], Field(description="BigCommerce API URL")] = None,
        api_key: Annotated[Optional[StrictStr], Field(description="Bigcommerce API Key")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Client ID of the requesting app")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="Access token authorizing the app to access resources on behalf of a user")] = None,
        context: Annotated[Optional[StrictStr], Field(description="API Path section unique to the store")] = None,
        access_token2: Annotated[Optional[StrictStr], Field(description="Access token authorizing the app to access resources on behalf of a user")] = None,
        api_key_shopify: Annotated[Optional[StrictStr], Field(description="Shopify API Key")] = None,
        api_password: Annotated[Optional[StrictStr], Field(description="Shopify API Password")] = None,
        access_token_shopify: Annotated[Optional[StrictStr], Field(description="Access token authorizing the app to access resources on behalf of a user")] = None,
        api_key2: Annotated[Optional[StrictStr], Field(description="Neto API Key")] = None,
        api_username: Annotated[Optional[StrictStr], Field(description="Neto User Name")] = None,
        encrypted_password: Annotated[Optional[StrictStr], Field(description="Volusion API Password")] = None,
        login: Annotated[Optional[StrictStr], Field(description="It's a Volusion account for which API is enabled")] = None,
        api_user_adnsf: Annotated[Optional[StrictStr], Field(description="It's a AspDotNetStorefront account for which API is available")] = None,
        api_pass: Annotated[Optional[StrictStr], Field(description="AspDotNetStorefront API Password")] = None,
        private_key: Annotated[Optional[StrictStr], Field(description="3DCart Application Private Key")] = None,
        app_token: Annotated[Optional[StrictStr], Field(description="3DCart Token from Application")] = None,
        etsy_keystring: Annotated[Optional[StrictStr], Field(description="Etsy keystring")] = None,
        etsy_shared_secret: Annotated[Optional[StrictStr], Field(description="Etsy shared secret")] = None,
        token_secret: Annotated[Optional[StrictStr], Field(description="Secret token authorizing the app to access resources on behalf of a user")] = None,
        ebay_client_id: Annotated[Optional[StrictStr], Field(description="Application ID (AppID).")] = None,
        ebay_client_secret: Annotated[Optional[StrictStr], Field(description="Shared Secret from eBay application")] = None,
        ebay_runame: Annotated[Optional[StrictStr], Field(description="The RuName value that eBay assigns to your application.")] = None,
        ebay_access_token: Annotated[Optional[StrictStr], Field(description="Used to authenticate API requests.")] = None,
        ebay_refresh_token: Annotated[Optional[StrictStr], Field(description="Used to renew the access token.")] = None,
        ebay_environment: Annotated[Optional[StrictStr], Field(description="eBay environment")] = None,
        ebay_site_id: Annotated[Optional[StrictInt], Field(description="eBay global ID")] = None,
        dw_client_id: Annotated[Optional[StrictStr], Field(description="Demandware client id")] = None,
        dw_api_pass: Annotated[Optional[StrictStr], Field(description="Demandware api password")] = None,
        demandware_user_name: Annotated[Optional[StrictStr], Field(description="Demandware user name")] = None,
        demandware_user_password: Annotated[Optional[StrictStr], Field(description="Demandware user password")] = None,
        seller_id: Annotated[Optional[StrictStr], Field(description="Seller Id")] = None,
        amazon_secret_key: Annotated[Optional[StrictStr], Field(description="Amazon Secret Key")] = None,
        amazon_access_key_id: Annotated[Optional[StrictStr], Field(description="Amazon Secret Key Id")] = None,
        marketplaces_ids: Annotated[Optional[StrictStr], Field(description="Comma separated marketplaces ids")] = None,
        environment: Optional[StrictStr] = None,
        hybris_client_id: Annotated[Optional[StrictStr], Field(description="Omni Commerce Connector Client ID")] = None,
        hybris_client_secret: Annotated[Optional[StrictStr], Field(description="Omni Commerce Connector Client Secret")] = None,
        hybris_username: Annotated[Optional[StrictStr], Field(description="User Name")] = None,
        hybris_password: Annotated[Optional[StrictStr], Field(description="User password")] = None,
        hybris_websites: Annotated[Optional[List[StrictStr]], Field(description="Websites to stores mapping data")] = None,
        walmart_client_id: Annotated[Optional[StrictStr], Field(description="Walmart client ID")] = None,
        walmart_client_secret: Annotated[Optional[StrictStr], Field(description="Walmart client secret")] = None,
        walmart_environment: Annotated[Optional[StrictStr], Field(description="Walmart environment")] = None,
        walmart_channel_type: Annotated[Optional[StrictStr], Field(description="Walmart WM_CONSUMER.CHANNEL.TYPE header")] = None,
        lightspeed_api_key: Annotated[Optional[StrictStr], Field(description="LightSpeed api key")] = None,
        lightspeed_api_secret: Annotated[Optional[StrictStr], Field(description="LightSpeed api secret")] = None,
        shopware_access_key: Annotated[Optional[StrictStr], Field(description="Shopware access key")] = None,
        shopware_api_key: Annotated[Optional[StrictStr], Field(description="Shopware api key")] = None,
        shopware_api_secret: Annotated[Optional[StrictStr], Field(description="Shopware client secret access key")] = None,
        commercehq_api_key: Annotated[Optional[StrictStr], Field(description="CommerceHQ api key")] = None,
        commercehq_api_password: Annotated[Optional[StrictStr], Field(description="CommerceHQ api password")] = None,
        var_3dcart_private_key: Annotated[Optional[StrictStr], Field(description="3DCart Private Key")] = None,
        var_3dcart_access_token: Annotated[Optional[StrictStr], Field(description="3DCart Token")] = None,
        wc_consumer_key: Annotated[Optional[StrictStr], Field(description="Woocommerce consumer key")] = None,
        wc_consumer_secret: Annotated[Optional[StrictStr], Field(description="Woocommerce consumer secret")] = None,
        magento_consumer_key: Annotated[Optional[StrictStr], Field(description="Magento Consumer Key")] = None,
        magento_consumer_secret: Annotated[Optional[StrictStr], Field(description="Magento Consumer Secret")] = None,
        magento_access_token: Annotated[Optional[StrictStr], Field(description="Magento Access Token")] = None,
        magento_token_secret: Annotated[Optional[StrictStr], Field(description="Magento Token Secret")] = None,
        prestashop_webservice_key: Annotated[Optional[StrictStr], Field(description="Prestashop webservice key")] = None,
        wix_app_id: Annotated[Optional[StrictStr], Field(description="Wix App ID")] = None,
        wix_app_secret_key: Annotated[Optional[StrictStr], Field(description="Wix App Secret Key")] = None,
        wix_refresh_token: Annotated[Optional[StrictStr], Field(description="Wix refresh token")] = None,
        mercado_libre_app_id: Annotated[Optional[StrictStr], Field(description="Mercado Libre App ID")] = None,
        mercado_libre_app_secret_key: Annotated[Optional[StrictStr], Field(description="Mercado Libre App Secret Key")] = None,
        mercado_libre_refresh_token: Annotated[Optional[StrictStr], Field(description="Mercado Libre Refresh Token")] = None,
        zid_client_id: Annotated[Optional[StrictInt], Field(description="Zid Client ID")] = None,
        zid_client_secret: Annotated[Optional[StrictStr], Field(description="Zid Client Secret")] = None,
        zid_access_token: Annotated[Optional[StrictStr], Field(description="Zid Access Token")] = None,
        zid_authorization: Annotated[Optional[StrictStr], Field(description="Zid Authorization")] = None,
        zid_refresh_token: Annotated[Optional[StrictStr], Field(description="Zid refresh token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountCartAdd200Response]:
        """(Deprecated) cart_create

        Add store to the account

        :param cart_id: Store’s identifier which you can get from cart_list method (required)
        :type cart_id: str
        :param store_url: A web address of a store that you would like to connect to API2Cart (required)
        :type store_url: str
        :param etsy_client_id: Etsy Client Id (required)
        :type etsy_client_id: str
        :param etsy_refresh_token: Etsy Refresh token (required)
        :type etsy_refresh_token: str
        :param store_id: Store Id (required)
        :type store_id: str
        :param bridge_url: This parameter allows to set up store with custom bridge url (also you must use store_root parameter if a bridge folder is not in the root folder of the store)
        :type bridge_url: str
        :param store_root: Absolute path to the store root directory (used with \"bridge_url\" parameter)
        :type store_root: str
        :param store_key: Set this parameter if bridge is already uploaded to store
        :type store_key: str
        :param shared_secret: Shared secret
        :type shared_secret: str
        :param validate_version: Specify if api2cart should validate cart version
        :type validate_version: bool
        :param verify: Enables or disables cart's verification
        :type verify: bool
        :param db_tables_prefix: DB tables prefix
        :type db_tables_prefix: str
        :param ftp_host: FTP connection host
        :type ftp_host: str
        :param ftp_user: FTP User
        :type ftp_user: str
        :param ftp_password: FTP Password
        :type ftp_password: str
        :param ftp_port: FTP Port
        :type ftp_port: int
        :param ftp_store_dir: FTP Store dir
        :type ftp_store_dir: str
        :param api_key_3dcart: 3DCart API Key
        :type api_key_3dcart: str
        :param admin_account: It's a BigCommerce account for which API is enabled
        :type admin_account: str
        :param api_path: BigCommerce API URL
        :type api_path: str
        :param api_key: Bigcommerce API Key
        :type api_key: str
        :param client_id: Client ID of the requesting app
        :type client_id: str
        :param access_token: Access token authorizing the app to access resources on behalf of a user
        :type access_token: str
        :param context: API Path section unique to the store
        :type context: str
        :param access_token2: Access token authorizing the app to access resources on behalf of a user
        :type access_token2: str
        :param api_key_shopify: Shopify API Key
        :type api_key_shopify: str
        :param api_password: Shopify API Password
        :type api_password: str
        :param access_token_shopify: Access token authorizing the app to access resources on behalf of a user
        :type access_token_shopify: str
        :param api_key2: Neto API Key
        :type api_key2: str
        :param api_username: Neto User Name
        :type api_username: str
        :param encrypted_password: Volusion API Password
        :type encrypted_password: str
        :param login: It's a Volusion account for which API is enabled
        :type login: str
        :param api_user_adnsf: It's a AspDotNetStorefront account for which API is available
        :type api_user_adnsf: str
        :param api_pass: AspDotNetStorefront API Password
        :type api_pass: str
        :param private_key: 3DCart Application Private Key
        :type private_key: str
        :param app_token: 3DCart Token from Application
        :type app_token: str
        :param etsy_keystring: Etsy keystring
        :type etsy_keystring: str
        :param etsy_shared_secret: Etsy shared secret
        :type etsy_shared_secret: str
        :param token_secret: Secret token authorizing the app to access resources on behalf of a user
        :type token_secret: str
        :param ebay_client_id: Application ID (AppID).
        :type ebay_client_id: str
        :param ebay_client_secret: Shared Secret from eBay application
        :type ebay_client_secret: str
        :param ebay_runame: The RuName value that eBay assigns to your application.
        :type ebay_runame: str
        :param ebay_access_token: Used to authenticate API requests.
        :type ebay_access_token: str
        :param ebay_refresh_token: Used to renew the access token.
        :type ebay_refresh_token: str
        :param ebay_environment: eBay environment
        :type ebay_environment: str
        :param ebay_site_id: eBay global ID
        :type ebay_site_id: int
        :param dw_client_id: Demandware client id
        :type dw_client_id: str
        :param dw_api_pass: Demandware api password
        :type dw_api_pass: str
        :param demandware_user_name: Demandware user name
        :type demandware_user_name: str
        :param demandware_user_password: Demandware user password
        :type demandware_user_password: str
        :param seller_id: Seller Id
        :type seller_id: str
        :param amazon_secret_key: Amazon Secret Key
        :type amazon_secret_key: str
        :param amazon_access_key_id: Amazon Secret Key Id
        :type amazon_access_key_id: str
        :param marketplaces_ids: Comma separated marketplaces ids
        :type marketplaces_ids: str
        :param environment: 
        :type environment: str
        :param hybris_client_id: Omni Commerce Connector Client ID
        :type hybris_client_id: str
        :param hybris_client_secret: Omni Commerce Connector Client Secret
        :type hybris_client_secret: str
        :param hybris_username: User Name
        :type hybris_username: str
        :param hybris_password: User password
        :type hybris_password: str
        :param hybris_websites: Websites to stores mapping data
        :type hybris_websites: List[str]
        :param walmart_client_id: Walmart client ID
        :type walmart_client_id: str
        :param walmart_client_secret: Walmart client secret
        :type walmart_client_secret: str
        :param walmart_environment: Walmart environment
        :type walmart_environment: str
        :param walmart_channel_type: Walmart WM_CONSUMER.CHANNEL.TYPE header
        :type walmart_channel_type: str
        :param lightspeed_api_key: LightSpeed api key
        :type lightspeed_api_key: str
        :param lightspeed_api_secret: LightSpeed api secret
        :type lightspeed_api_secret: str
        :param shopware_access_key: Shopware access key
        :type shopware_access_key: str
        :param shopware_api_key: Shopware api key
        :type shopware_api_key: str
        :param shopware_api_secret: Shopware client secret access key
        :type shopware_api_secret: str
        :param commercehq_api_key: CommerceHQ api key
        :type commercehq_api_key: str
        :param commercehq_api_password: CommerceHQ api password
        :type commercehq_api_password: str
        :param var_3dcart_private_key: 3DCart Private Key
        :type var_3dcart_private_key: str
        :param var_3dcart_access_token: 3DCart Token
        :type var_3dcart_access_token: str
        :param wc_consumer_key: Woocommerce consumer key
        :type wc_consumer_key: str
        :param wc_consumer_secret: Woocommerce consumer secret
        :type wc_consumer_secret: str
        :param magento_consumer_key: Magento Consumer Key
        :type magento_consumer_key: str
        :param magento_consumer_secret: Magento Consumer Secret
        :type magento_consumer_secret: str
        :param magento_access_token: Magento Access Token
        :type magento_access_token: str
        :param magento_token_secret: Magento Token Secret
        :type magento_token_secret: str
        :param prestashop_webservice_key: Prestashop webservice key
        :type prestashop_webservice_key: str
        :param wix_app_id: Wix App ID
        :type wix_app_id: str
        :param wix_app_secret_key: Wix App Secret Key
        :type wix_app_secret_key: str
        :param wix_refresh_token: Wix refresh token
        :type wix_refresh_token: str
        :param mercado_libre_app_id: Mercado Libre App ID
        :type mercado_libre_app_id: str
        :param mercado_libre_app_secret_key: Mercado Libre App Secret Key
        :type mercado_libre_app_secret_key: str
        :param mercado_libre_refresh_token: Mercado Libre Refresh Token
        :type mercado_libre_refresh_token: str
        :param zid_client_id: Zid Client ID
        :type zid_client_id: int
        :param zid_client_secret: Zid Client Secret
        :type zid_client_secret: str
        :param zid_access_token: Zid Access Token
        :type zid_access_token: str
        :param zid_authorization: Zid Authorization
        :type zid_authorization: str
        :param zid_refresh_token: Zid refresh token
        :type zid_refresh_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /cart.create.json is deprecated.", DeprecationWarning)

        _param = self._cart_create_serialize(
            cart_id=cart_id,
            store_url=store_url,
            etsy_client_id=etsy_client_id,
            etsy_refresh_token=etsy_refresh_token,
            store_id=store_id,
            bridge_url=bridge_url,
            store_root=store_root,
            store_key=store_key,
            shared_secret=shared_secret,
            validate_version=validate_version,
            verify=verify,
            db_tables_prefix=db_tables_prefix,
            ftp_host=ftp_host,
            ftp_user=ftp_user,
            ftp_password=ftp_password,
            ftp_port=ftp_port,
            ftp_store_dir=ftp_store_dir,
            api_key_3dcart=api_key_3dcart,
            admin_account=admin_account,
            api_path=api_path,
            api_key=api_key,
            client_id=client_id,
            access_token=access_token,
            context=context,
            access_token2=access_token2,
            api_key_shopify=api_key_shopify,
            api_password=api_password,
            access_token_shopify=access_token_shopify,
            api_key2=api_key2,
            api_username=api_username,
            encrypted_password=encrypted_password,
            login=login,
            api_user_adnsf=api_user_adnsf,
            api_pass=api_pass,
            private_key=private_key,
            app_token=app_token,
            etsy_keystring=etsy_keystring,
            etsy_shared_secret=etsy_shared_secret,
            token_secret=token_secret,
            ebay_client_id=ebay_client_id,
            ebay_client_secret=ebay_client_secret,
            ebay_runame=ebay_runame,
            ebay_access_token=ebay_access_token,
            ebay_refresh_token=ebay_refresh_token,
            ebay_environment=ebay_environment,
            ebay_site_id=ebay_site_id,
            dw_client_id=dw_client_id,
            dw_api_pass=dw_api_pass,
            demandware_user_name=demandware_user_name,
            demandware_user_password=demandware_user_password,
            seller_id=seller_id,
            amazon_secret_key=amazon_secret_key,
            amazon_access_key_id=amazon_access_key_id,
            marketplaces_ids=marketplaces_ids,
            environment=environment,
            hybris_client_id=hybris_client_id,
            hybris_client_secret=hybris_client_secret,
            hybris_username=hybris_username,
            hybris_password=hybris_password,
            hybris_websites=hybris_websites,
            walmart_client_id=walmart_client_id,
            walmart_client_secret=walmart_client_secret,
            walmart_environment=walmart_environment,
            walmart_channel_type=walmart_channel_type,
            lightspeed_api_key=lightspeed_api_key,
            lightspeed_api_secret=lightspeed_api_secret,
            shopware_access_key=shopware_access_key,
            shopware_api_key=shopware_api_key,
            shopware_api_secret=shopware_api_secret,
            commercehq_api_key=commercehq_api_key,
            commercehq_api_password=commercehq_api_password,
            var_3dcart_private_key=var_3dcart_private_key,
            var_3dcart_access_token=var_3dcart_access_token,
            wc_consumer_key=wc_consumer_key,
            wc_consumer_secret=wc_consumer_secret,
            magento_consumer_key=magento_consumer_key,
            magento_consumer_secret=magento_consumer_secret,
            magento_access_token=magento_access_token,
            magento_token_secret=magento_token_secret,
            prestashop_webservice_key=prestashop_webservice_key,
            wix_app_id=wix_app_id,
            wix_app_secret_key=wix_app_secret_key,
            wix_refresh_token=wix_refresh_token,
            mercado_libre_app_id=mercado_libre_app_id,
            mercado_libre_app_secret_key=mercado_libre_app_secret_key,
            mercado_libre_refresh_token=mercado_libre_refresh_token,
            zid_client_id=zid_client_id,
            zid_client_secret=zid_client_secret,
            zid_access_token=zid_access_token,
            zid_authorization=zid_authorization,
            zid_refresh_token=zid_refresh_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountCartAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_create_without_preload_content(
        self,
        cart_id: Annotated[StrictStr, Field(description="Store’s identifier which you can get from cart_list method")],
        store_url: Annotated[StrictStr, Field(description="A web address of a store that you would like to connect to API2Cart")],
        etsy_client_id: Annotated[StrictStr, Field(description="Etsy Client Id")],
        etsy_refresh_token: Annotated[StrictStr, Field(description="Etsy Refresh token")],
        store_id: Annotated[StrictStr, Field(description="Store Id")],
        bridge_url: Annotated[Optional[StrictStr], Field(description="This parameter allows to set up store with custom bridge url (also you must use store_root parameter if a bridge folder is not in the root folder of the store)")] = None,
        store_root: Annotated[Optional[StrictStr], Field(description="Absolute path to the store root directory (used with \"bridge_url\" parameter)")] = None,
        store_key: Annotated[Optional[StrictStr], Field(description="Set this parameter if bridge is already uploaded to store")] = None,
        shared_secret: Annotated[Optional[StrictStr], Field(description="Shared secret")] = None,
        validate_version: Annotated[Optional[StrictBool], Field(description="Specify if api2cart should validate cart version")] = None,
        verify: Annotated[Optional[StrictBool], Field(description="Enables or disables cart's verification")] = None,
        db_tables_prefix: Annotated[Optional[StrictStr], Field(description="DB tables prefix")] = None,
        ftp_host: Annotated[Optional[StrictStr], Field(description="FTP connection host")] = None,
        ftp_user: Annotated[Optional[StrictStr], Field(description="FTP User")] = None,
        ftp_password: Annotated[Optional[StrictStr], Field(description="FTP Password")] = None,
        ftp_port: Annotated[Optional[StrictInt], Field(description="FTP Port")] = None,
        ftp_store_dir: Annotated[Optional[StrictStr], Field(description="FTP Store dir")] = None,
        api_key_3dcart: Annotated[Optional[StrictStr], Field(description="3DCart API Key")] = None,
        admin_account: Annotated[Optional[StrictStr], Field(description="It's a BigCommerce account for which API is enabled")] = None,
        api_path: Annotated[Optional[StrictStr], Field(description="BigCommerce API URL")] = None,
        api_key: Annotated[Optional[StrictStr], Field(description="Bigcommerce API Key")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Client ID of the requesting app")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="Access token authorizing the app to access resources on behalf of a user")] = None,
        context: Annotated[Optional[StrictStr], Field(description="API Path section unique to the store")] = None,
        access_token2: Annotated[Optional[StrictStr], Field(description="Access token authorizing the app to access resources on behalf of a user")] = None,
        api_key_shopify: Annotated[Optional[StrictStr], Field(description="Shopify API Key")] = None,
        api_password: Annotated[Optional[StrictStr], Field(description="Shopify API Password")] = None,
        access_token_shopify: Annotated[Optional[StrictStr], Field(description="Access token authorizing the app to access resources on behalf of a user")] = None,
        api_key2: Annotated[Optional[StrictStr], Field(description="Neto API Key")] = None,
        api_username: Annotated[Optional[StrictStr], Field(description="Neto User Name")] = None,
        encrypted_password: Annotated[Optional[StrictStr], Field(description="Volusion API Password")] = None,
        login: Annotated[Optional[StrictStr], Field(description="It's a Volusion account for which API is enabled")] = None,
        api_user_adnsf: Annotated[Optional[StrictStr], Field(description="It's a AspDotNetStorefront account for which API is available")] = None,
        api_pass: Annotated[Optional[StrictStr], Field(description="AspDotNetStorefront API Password")] = None,
        private_key: Annotated[Optional[StrictStr], Field(description="3DCart Application Private Key")] = None,
        app_token: Annotated[Optional[StrictStr], Field(description="3DCart Token from Application")] = None,
        etsy_keystring: Annotated[Optional[StrictStr], Field(description="Etsy keystring")] = None,
        etsy_shared_secret: Annotated[Optional[StrictStr], Field(description="Etsy shared secret")] = None,
        token_secret: Annotated[Optional[StrictStr], Field(description="Secret token authorizing the app to access resources on behalf of a user")] = None,
        ebay_client_id: Annotated[Optional[StrictStr], Field(description="Application ID (AppID).")] = None,
        ebay_client_secret: Annotated[Optional[StrictStr], Field(description="Shared Secret from eBay application")] = None,
        ebay_runame: Annotated[Optional[StrictStr], Field(description="The RuName value that eBay assigns to your application.")] = None,
        ebay_access_token: Annotated[Optional[StrictStr], Field(description="Used to authenticate API requests.")] = None,
        ebay_refresh_token: Annotated[Optional[StrictStr], Field(description="Used to renew the access token.")] = None,
        ebay_environment: Annotated[Optional[StrictStr], Field(description="eBay environment")] = None,
        ebay_site_id: Annotated[Optional[StrictInt], Field(description="eBay global ID")] = None,
        dw_client_id: Annotated[Optional[StrictStr], Field(description="Demandware client id")] = None,
        dw_api_pass: Annotated[Optional[StrictStr], Field(description="Demandware api password")] = None,
        demandware_user_name: Annotated[Optional[StrictStr], Field(description="Demandware user name")] = None,
        demandware_user_password: Annotated[Optional[StrictStr], Field(description="Demandware user password")] = None,
        seller_id: Annotated[Optional[StrictStr], Field(description="Seller Id")] = None,
        amazon_secret_key: Annotated[Optional[StrictStr], Field(description="Amazon Secret Key")] = None,
        amazon_access_key_id: Annotated[Optional[StrictStr], Field(description="Amazon Secret Key Id")] = None,
        marketplaces_ids: Annotated[Optional[StrictStr], Field(description="Comma separated marketplaces ids")] = None,
        environment: Optional[StrictStr] = None,
        hybris_client_id: Annotated[Optional[StrictStr], Field(description="Omni Commerce Connector Client ID")] = None,
        hybris_client_secret: Annotated[Optional[StrictStr], Field(description="Omni Commerce Connector Client Secret")] = None,
        hybris_username: Annotated[Optional[StrictStr], Field(description="User Name")] = None,
        hybris_password: Annotated[Optional[StrictStr], Field(description="User password")] = None,
        hybris_websites: Annotated[Optional[List[StrictStr]], Field(description="Websites to stores mapping data")] = None,
        walmart_client_id: Annotated[Optional[StrictStr], Field(description="Walmart client ID")] = None,
        walmart_client_secret: Annotated[Optional[StrictStr], Field(description="Walmart client secret")] = None,
        walmart_environment: Annotated[Optional[StrictStr], Field(description="Walmart environment")] = None,
        walmart_channel_type: Annotated[Optional[StrictStr], Field(description="Walmart WM_CONSUMER.CHANNEL.TYPE header")] = None,
        lightspeed_api_key: Annotated[Optional[StrictStr], Field(description="LightSpeed api key")] = None,
        lightspeed_api_secret: Annotated[Optional[StrictStr], Field(description="LightSpeed api secret")] = None,
        shopware_access_key: Annotated[Optional[StrictStr], Field(description="Shopware access key")] = None,
        shopware_api_key: Annotated[Optional[StrictStr], Field(description="Shopware api key")] = None,
        shopware_api_secret: Annotated[Optional[StrictStr], Field(description="Shopware client secret access key")] = None,
        commercehq_api_key: Annotated[Optional[StrictStr], Field(description="CommerceHQ api key")] = None,
        commercehq_api_password: Annotated[Optional[StrictStr], Field(description="CommerceHQ api password")] = None,
        var_3dcart_private_key: Annotated[Optional[StrictStr], Field(description="3DCart Private Key")] = None,
        var_3dcart_access_token: Annotated[Optional[StrictStr], Field(description="3DCart Token")] = None,
        wc_consumer_key: Annotated[Optional[StrictStr], Field(description="Woocommerce consumer key")] = None,
        wc_consumer_secret: Annotated[Optional[StrictStr], Field(description="Woocommerce consumer secret")] = None,
        magento_consumer_key: Annotated[Optional[StrictStr], Field(description="Magento Consumer Key")] = None,
        magento_consumer_secret: Annotated[Optional[StrictStr], Field(description="Magento Consumer Secret")] = None,
        magento_access_token: Annotated[Optional[StrictStr], Field(description="Magento Access Token")] = None,
        magento_token_secret: Annotated[Optional[StrictStr], Field(description="Magento Token Secret")] = None,
        prestashop_webservice_key: Annotated[Optional[StrictStr], Field(description="Prestashop webservice key")] = None,
        wix_app_id: Annotated[Optional[StrictStr], Field(description="Wix App ID")] = None,
        wix_app_secret_key: Annotated[Optional[StrictStr], Field(description="Wix App Secret Key")] = None,
        wix_refresh_token: Annotated[Optional[StrictStr], Field(description="Wix refresh token")] = None,
        mercado_libre_app_id: Annotated[Optional[StrictStr], Field(description="Mercado Libre App ID")] = None,
        mercado_libre_app_secret_key: Annotated[Optional[StrictStr], Field(description="Mercado Libre App Secret Key")] = None,
        mercado_libre_refresh_token: Annotated[Optional[StrictStr], Field(description="Mercado Libre Refresh Token")] = None,
        zid_client_id: Annotated[Optional[StrictInt], Field(description="Zid Client ID")] = None,
        zid_client_secret: Annotated[Optional[StrictStr], Field(description="Zid Client Secret")] = None,
        zid_access_token: Annotated[Optional[StrictStr], Field(description="Zid Access Token")] = None,
        zid_authorization: Annotated[Optional[StrictStr], Field(description="Zid Authorization")] = None,
        zid_refresh_token: Annotated[Optional[StrictStr], Field(description="Zid refresh token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) cart_create

        Add store to the account

        :param cart_id: Store’s identifier which you can get from cart_list method (required)
        :type cart_id: str
        :param store_url: A web address of a store that you would like to connect to API2Cart (required)
        :type store_url: str
        :param etsy_client_id: Etsy Client Id (required)
        :type etsy_client_id: str
        :param etsy_refresh_token: Etsy Refresh token (required)
        :type etsy_refresh_token: str
        :param store_id: Store Id (required)
        :type store_id: str
        :param bridge_url: This parameter allows to set up store with custom bridge url (also you must use store_root parameter if a bridge folder is not in the root folder of the store)
        :type bridge_url: str
        :param store_root: Absolute path to the store root directory (used with \"bridge_url\" parameter)
        :type store_root: str
        :param store_key: Set this parameter if bridge is already uploaded to store
        :type store_key: str
        :param shared_secret: Shared secret
        :type shared_secret: str
        :param validate_version: Specify if api2cart should validate cart version
        :type validate_version: bool
        :param verify: Enables or disables cart's verification
        :type verify: bool
        :param db_tables_prefix: DB tables prefix
        :type db_tables_prefix: str
        :param ftp_host: FTP connection host
        :type ftp_host: str
        :param ftp_user: FTP User
        :type ftp_user: str
        :param ftp_password: FTP Password
        :type ftp_password: str
        :param ftp_port: FTP Port
        :type ftp_port: int
        :param ftp_store_dir: FTP Store dir
        :type ftp_store_dir: str
        :param api_key_3dcart: 3DCart API Key
        :type api_key_3dcart: str
        :param admin_account: It's a BigCommerce account for which API is enabled
        :type admin_account: str
        :param api_path: BigCommerce API URL
        :type api_path: str
        :param api_key: Bigcommerce API Key
        :type api_key: str
        :param client_id: Client ID of the requesting app
        :type client_id: str
        :param access_token: Access token authorizing the app to access resources on behalf of a user
        :type access_token: str
        :param context: API Path section unique to the store
        :type context: str
        :param access_token2: Access token authorizing the app to access resources on behalf of a user
        :type access_token2: str
        :param api_key_shopify: Shopify API Key
        :type api_key_shopify: str
        :param api_password: Shopify API Password
        :type api_password: str
        :param access_token_shopify: Access token authorizing the app to access resources on behalf of a user
        :type access_token_shopify: str
        :param api_key2: Neto API Key
        :type api_key2: str
        :param api_username: Neto User Name
        :type api_username: str
        :param encrypted_password: Volusion API Password
        :type encrypted_password: str
        :param login: It's a Volusion account for which API is enabled
        :type login: str
        :param api_user_adnsf: It's a AspDotNetStorefront account for which API is available
        :type api_user_adnsf: str
        :param api_pass: AspDotNetStorefront API Password
        :type api_pass: str
        :param private_key: 3DCart Application Private Key
        :type private_key: str
        :param app_token: 3DCart Token from Application
        :type app_token: str
        :param etsy_keystring: Etsy keystring
        :type etsy_keystring: str
        :param etsy_shared_secret: Etsy shared secret
        :type etsy_shared_secret: str
        :param token_secret: Secret token authorizing the app to access resources on behalf of a user
        :type token_secret: str
        :param ebay_client_id: Application ID (AppID).
        :type ebay_client_id: str
        :param ebay_client_secret: Shared Secret from eBay application
        :type ebay_client_secret: str
        :param ebay_runame: The RuName value that eBay assigns to your application.
        :type ebay_runame: str
        :param ebay_access_token: Used to authenticate API requests.
        :type ebay_access_token: str
        :param ebay_refresh_token: Used to renew the access token.
        :type ebay_refresh_token: str
        :param ebay_environment: eBay environment
        :type ebay_environment: str
        :param ebay_site_id: eBay global ID
        :type ebay_site_id: int
        :param dw_client_id: Demandware client id
        :type dw_client_id: str
        :param dw_api_pass: Demandware api password
        :type dw_api_pass: str
        :param demandware_user_name: Demandware user name
        :type demandware_user_name: str
        :param demandware_user_password: Demandware user password
        :type demandware_user_password: str
        :param seller_id: Seller Id
        :type seller_id: str
        :param amazon_secret_key: Amazon Secret Key
        :type amazon_secret_key: str
        :param amazon_access_key_id: Amazon Secret Key Id
        :type amazon_access_key_id: str
        :param marketplaces_ids: Comma separated marketplaces ids
        :type marketplaces_ids: str
        :param environment: 
        :type environment: str
        :param hybris_client_id: Omni Commerce Connector Client ID
        :type hybris_client_id: str
        :param hybris_client_secret: Omni Commerce Connector Client Secret
        :type hybris_client_secret: str
        :param hybris_username: User Name
        :type hybris_username: str
        :param hybris_password: User password
        :type hybris_password: str
        :param hybris_websites: Websites to stores mapping data
        :type hybris_websites: List[str]
        :param walmart_client_id: Walmart client ID
        :type walmart_client_id: str
        :param walmart_client_secret: Walmart client secret
        :type walmart_client_secret: str
        :param walmart_environment: Walmart environment
        :type walmart_environment: str
        :param walmart_channel_type: Walmart WM_CONSUMER.CHANNEL.TYPE header
        :type walmart_channel_type: str
        :param lightspeed_api_key: LightSpeed api key
        :type lightspeed_api_key: str
        :param lightspeed_api_secret: LightSpeed api secret
        :type lightspeed_api_secret: str
        :param shopware_access_key: Shopware access key
        :type shopware_access_key: str
        :param shopware_api_key: Shopware api key
        :type shopware_api_key: str
        :param shopware_api_secret: Shopware client secret access key
        :type shopware_api_secret: str
        :param commercehq_api_key: CommerceHQ api key
        :type commercehq_api_key: str
        :param commercehq_api_password: CommerceHQ api password
        :type commercehq_api_password: str
        :param var_3dcart_private_key: 3DCart Private Key
        :type var_3dcart_private_key: str
        :param var_3dcart_access_token: 3DCart Token
        :type var_3dcart_access_token: str
        :param wc_consumer_key: Woocommerce consumer key
        :type wc_consumer_key: str
        :param wc_consumer_secret: Woocommerce consumer secret
        :type wc_consumer_secret: str
        :param magento_consumer_key: Magento Consumer Key
        :type magento_consumer_key: str
        :param magento_consumer_secret: Magento Consumer Secret
        :type magento_consumer_secret: str
        :param magento_access_token: Magento Access Token
        :type magento_access_token: str
        :param magento_token_secret: Magento Token Secret
        :type magento_token_secret: str
        :param prestashop_webservice_key: Prestashop webservice key
        :type prestashop_webservice_key: str
        :param wix_app_id: Wix App ID
        :type wix_app_id: str
        :param wix_app_secret_key: Wix App Secret Key
        :type wix_app_secret_key: str
        :param wix_refresh_token: Wix refresh token
        :type wix_refresh_token: str
        :param mercado_libre_app_id: Mercado Libre App ID
        :type mercado_libre_app_id: str
        :param mercado_libre_app_secret_key: Mercado Libre App Secret Key
        :type mercado_libre_app_secret_key: str
        :param mercado_libre_refresh_token: Mercado Libre Refresh Token
        :type mercado_libre_refresh_token: str
        :param zid_client_id: Zid Client ID
        :type zid_client_id: int
        :param zid_client_secret: Zid Client Secret
        :type zid_client_secret: str
        :param zid_access_token: Zid Access Token
        :type zid_access_token: str
        :param zid_authorization: Zid Authorization
        :type zid_authorization: str
        :param zid_refresh_token: Zid refresh token
        :type zid_refresh_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /cart.create.json is deprecated.", DeprecationWarning)

        _param = self._cart_create_serialize(
            cart_id=cart_id,
            store_url=store_url,
            etsy_client_id=etsy_client_id,
            etsy_refresh_token=etsy_refresh_token,
            store_id=store_id,
            bridge_url=bridge_url,
            store_root=store_root,
            store_key=store_key,
            shared_secret=shared_secret,
            validate_version=validate_version,
            verify=verify,
            db_tables_prefix=db_tables_prefix,
            ftp_host=ftp_host,
            ftp_user=ftp_user,
            ftp_password=ftp_password,
            ftp_port=ftp_port,
            ftp_store_dir=ftp_store_dir,
            api_key_3dcart=api_key_3dcart,
            admin_account=admin_account,
            api_path=api_path,
            api_key=api_key,
            client_id=client_id,
            access_token=access_token,
            context=context,
            access_token2=access_token2,
            api_key_shopify=api_key_shopify,
            api_password=api_password,
            access_token_shopify=access_token_shopify,
            api_key2=api_key2,
            api_username=api_username,
            encrypted_password=encrypted_password,
            login=login,
            api_user_adnsf=api_user_adnsf,
            api_pass=api_pass,
            private_key=private_key,
            app_token=app_token,
            etsy_keystring=etsy_keystring,
            etsy_shared_secret=etsy_shared_secret,
            token_secret=token_secret,
            ebay_client_id=ebay_client_id,
            ebay_client_secret=ebay_client_secret,
            ebay_runame=ebay_runame,
            ebay_access_token=ebay_access_token,
            ebay_refresh_token=ebay_refresh_token,
            ebay_environment=ebay_environment,
            ebay_site_id=ebay_site_id,
            dw_client_id=dw_client_id,
            dw_api_pass=dw_api_pass,
            demandware_user_name=demandware_user_name,
            demandware_user_password=demandware_user_password,
            seller_id=seller_id,
            amazon_secret_key=amazon_secret_key,
            amazon_access_key_id=amazon_access_key_id,
            marketplaces_ids=marketplaces_ids,
            environment=environment,
            hybris_client_id=hybris_client_id,
            hybris_client_secret=hybris_client_secret,
            hybris_username=hybris_username,
            hybris_password=hybris_password,
            hybris_websites=hybris_websites,
            walmart_client_id=walmart_client_id,
            walmart_client_secret=walmart_client_secret,
            walmart_environment=walmart_environment,
            walmart_channel_type=walmart_channel_type,
            lightspeed_api_key=lightspeed_api_key,
            lightspeed_api_secret=lightspeed_api_secret,
            shopware_access_key=shopware_access_key,
            shopware_api_key=shopware_api_key,
            shopware_api_secret=shopware_api_secret,
            commercehq_api_key=commercehq_api_key,
            commercehq_api_password=commercehq_api_password,
            var_3dcart_private_key=var_3dcart_private_key,
            var_3dcart_access_token=var_3dcart_access_token,
            wc_consumer_key=wc_consumer_key,
            wc_consumer_secret=wc_consumer_secret,
            magento_consumer_key=magento_consumer_key,
            magento_consumer_secret=magento_consumer_secret,
            magento_access_token=magento_access_token,
            magento_token_secret=magento_token_secret,
            prestashop_webservice_key=prestashop_webservice_key,
            wix_app_id=wix_app_id,
            wix_app_secret_key=wix_app_secret_key,
            wix_refresh_token=wix_refresh_token,
            mercado_libre_app_id=mercado_libre_app_id,
            mercado_libre_app_secret_key=mercado_libre_app_secret_key,
            mercado_libre_refresh_token=mercado_libre_refresh_token,
            zid_client_id=zid_client_id,
            zid_client_secret=zid_client_secret,
            zid_access_token=zid_access_token,
            zid_authorization=zid_authorization,
            zid_refresh_token=zid_refresh_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountCartAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_create_serialize(
        self,
        cart_id,
        store_url,
        etsy_client_id,
        etsy_refresh_token,
        store_id,
        bridge_url,
        store_root,
        store_key,
        shared_secret,
        validate_version,
        verify,
        db_tables_prefix,
        ftp_host,
        ftp_user,
        ftp_password,
        ftp_port,
        ftp_store_dir,
        api_key_3dcart,
        admin_account,
        api_path,
        api_key,
        client_id,
        access_token,
        context,
        access_token2,
        api_key_shopify,
        api_password,
        access_token_shopify,
        api_key2,
        api_username,
        encrypted_password,
        login,
        api_user_adnsf,
        api_pass,
        private_key,
        app_token,
        etsy_keystring,
        etsy_shared_secret,
        token_secret,
        ebay_client_id,
        ebay_client_secret,
        ebay_runame,
        ebay_access_token,
        ebay_refresh_token,
        ebay_environment,
        ebay_site_id,
        dw_client_id,
        dw_api_pass,
        demandware_user_name,
        demandware_user_password,
        seller_id,
        amazon_secret_key,
        amazon_access_key_id,
        marketplaces_ids,
        environment,
        hybris_client_id,
        hybris_client_secret,
        hybris_username,
        hybris_password,
        hybris_websites,
        walmart_client_id,
        walmart_client_secret,
        walmart_environment,
        walmart_channel_type,
        lightspeed_api_key,
        lightspeed_api_secret,
        shopware_access_key,
        shopware_api_key,
        shopware_api_secret,
        commercehq_api_key,
        commercehq_api_password,
        var_3dcart_private_key,
        var_3dcart_access_token,
        wc_consumer_key,
        wc_consumer_secret,
        magento_consumer_key,
        magento_consumer_secret,
        magento_access_token,
        magento_token_secret,
        prestashop_webservice_key,
        wix_app_id,
        wix_app_secret_key,
        wix_refresh_token,
        mercado_libre_app_id,
        mercado_libre_app_secret_key,
        mercado_libre_refresh_token,
        zid_client_id,
        zid_client_secret,
        zid_access_token,
        zid_authorization,
        zid_refresh_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'hybris_websites': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cart_id is not None:
            
            _query_params.append(('cart_id', cart_id))
            
        if store_url is not None:
            
            _query_params.append(('store_url', store_url))
            
        if bridge_url is not None:
            
            _query_params.append(('bridge_url', bridge_url))
            
        if store_root is not None:
            
            _query_params.append(('store_root', store_root))
            
        if store_key is not None:
            
            _query_params.append(('store_key', store_key))
            
        if shared_secret is not None:
            
            _query_params.append(('shared_secret', shared_secret))
            
        if validate_version is not None:
            
            _query_params.append(('validate_version', validate_version))
            
        if verify is not None:
            
            _query_params.append(('verify', verify))
            
        if db_tables_prefix is not None:
            
            _query_params.append(('db_tables_prefix', db_tables_prefix))
            
        if ftp_host is not None:
            
            _query_params.append(('ftp_host', ftp_host))
            
        if ftp_user is not None:
            
            _query_params.append(('ftp_user', ftp_user))
            
        if ftp_password is not None:
            
            _query_params.append(('ftp_password', ftp_password))
            
        if ftp_port is not None:
            
            _query_params.append(('ftp_port', ftp_port))
            
        if ftp_store_dir is not None:
            
            _query_params.append(('ftp_store_dir', ftp_store_dir))
            
        if api_key_3dcart is not None:
            
            _query_params.append(('apiKey_3dcart', api_key_3dcart))
            
        if admin_account is not None:
            
            _query_params.append(('AdminAccount', admin_account))
            
        if api_path is not None:
            
            _query_params.append(('ApiPath', api_path))
            
        if api_key is not None:
            
            _query_params.append(('ApiKey', api_key))
            
        if client_id is not None:
            
            _query_params.append(('client_id', client_id))
            
        if access_token is not None:
            
            _query_params.append(('accessToken', access_token))
            
        if context is not None:
            
            _query_params.append(('context', context))
            
        if access_token2 is not None:
            
            _query_params.append(('access_token', access_token2))
            
        if api_key_shopify is not None:
            
            _query_params.append(('apiKey_shopify', api_key_shopify))
            
        if api_password is not None:
            
            _query_params.append(('apiPassword', api_password))
            
        if access_token_shopify is not None:
            
            _query_params.append(('accessToken_shopify', access_token_shopify))
            
        if api_key2 is not None:
            
            _query_params.append(('apiKey', api_key2))
            
        if api_username is not None:
            
            _query_params.append(('apiUsername', api_username))
            
        if encrypted_password is not None:
            
            _query_params.append(('EncryptedPassword', encrypted_password))
            
        if login is not None:
            
            _query_params.append(('Login', login))
            
        if api_user_adnsf is not None:
            
            _query_params.append(('apiUser_adnsf', api_user_adnsf))
            
        if api_pass is not None:
            
            _query_params.append(('apiPass', api_pass))
            
        if private_key is not None:
            
            _query_params.append(('privateKey', private_key))
            
        if app_token is not None:
            
            _query_params.append(('appToken', app_token))
            
        if etsy_keystring is not None:
            
            _query_params.append(('etsy_keystring', etsy_keystring))
            
        if etsy_shared_secret is not None:
            
            _query_params.append(('etsy_shared_secret', etsy_shared_secret))
            
        if token_secret is not None:
            
            _query_params.append(('tokenSecret', token_secret))
            
        if etsy_client_id is not None:
            
            _query_params.append(('etsy_client_id', etsy_client_id))
            
        if etsy_refresh_token is not None:
            
            _query_params.append(('etsy_refresh_token', etsy_refresh_token))
            
        if ebay_client_id is not None:
            
            _query_params.append(('ebay_client_id', ebay_client_id))
            
        if ebay_client_secret is not None:
            
            _query_params.append(('ebay_client_secret', ebay_client_secret))
            
        if ebay_runame is not None:
            
            _query_params.append(('ebay_runame', ebay_runame))
            
        if ebay_access_token is not None:
            
            _query_params.append(('ebay_access_token', ebay_access_token))
            
        if ebay_refresh_token is not None:
            
            _query_params.append(('ebay_refresh_token', ebay_refresh_token))
            
        if ebay_environment is not None:
            
            _query_params.append(('ebay_environment', ebay_environment))
            
        if ebay_site_id is not None:
            
            _query_params.append(('ebay_site_id', ebay_site_id))
            
        if dw_client_id is not None:
            
            _query_params.append(('dw_client_id', dw_client_id))
            
        if dw_api_pass is not None:
            
            _query_params.append(('dw_api_pass', dw_api_pass))
            
        if demandware_user_name is not None:
            
            _query_params.append(('demandware_user_name', demandware_user_name))
            
        if demandware_user_password is not None:
            
            _query_params.append(('demandware_user_password', demandware_user_password))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if seller_id is not None:
            
            _query_params.append(('seller_id', seller_id))
            
        if amazon_secret_key is not None:
            
            _query_params.append(('amazon_secret_key', amazon_secret_key))
            
        if amazon_access_key_id is not None:
            
            _query_params.append(('amazon_access_key_id', amazon_access_key_id))
            
        if marketplaces_ids is not None:
            
            _query_params.append(('marketplaces_ids', marketplaces_ids))
            
        if environment is not None:
            
            _query_params.append(('environment', environment))
            
        if hybris_client_id is not None:
            
            _query_params.append(('hybris_client_id', hybris_client_id))
            
        if hybris_client_secret is not None:
            
            _query_params.append(('hybris_client_secret', hybris_client_secret))
            
        if hybris_username is not None:
            
            _query_params.append(('hybris_username', hybris_username))
            
        if hybris_password is not None:
            
            _query_params.append(('hybris_password', hybris_password))
            
        if hybris_websites is not None:
            
            _query_params.append(('hybris_websites', hybris_websites))
            
        if walmart_client_id is not None:
            
            _query_params.append(('walmart_client_id', walmart_client_id))
            
        if walmart_client_secret is not None:
            
            _query_params.append(('walmart_client_secret', walmart_client_secret))
            
        if walmart_environment is not None:
            
            _query_params.append(('walmart_environment', walmart_environment))
            
        if walmart_channel_type is not None:
            
            _query_params.append(('walmart_channel_type', walmart_channel_type))
            
        if lightspeed_api_key is not None:
            
            _query_params.append(('lightspeed_api_key', lightspeed_api_key))
            
        if lightspeed_api_secret is not None:
            
            _query_params.append(('lightspeed_api_secret', lightspeed_api_secret))
            
        if shopware_access_key is not None:
            
            _query_params.append(('shopware_access_key', shopware_access_key))
            
        if shopware_api_key is not None:
            
            _query_params.append(('shopware_api_key', shopware_api_key))
            
        if shopware_api_secret is not None:
            
            _query_params.append(('shopware_api_secret', shopware_api_secret))
            
        if commercehq_api_key is not None:
            
            _query_params.append(('commercehq_api_key', commercehq_api_key))
            
        if commercehq_api_password is not None:
            
            _query_params.append(('commercehq_api_password', commercehq_api_password))
            
        if var_3dcart_private_key is not None:
            
            _query_params.append(('3dcart_private_key', var_3dcart_private_key))
            
        if var_3dcart_access_token is not None:
            
            _query_params.append(('3dcart_access_token', var_3dcart_access_token))
            
        if wc_consumer_key is not None:
            
            _query_params.append(('wc_consumer_key', wc_consumer_key))
            
        if wc_consumer_secret is not None:
            
            _query_params.append(('wc_consumer_secret', wc_consumer_secret))
            
        if magento_consumer_key is not None:
            
            _query_params.append(('magento_consumer_key', magento_consumer_key))
            
        if magento_consumer_secret is not None:
            
            _query_params.append(('magento_consumer_secret', magento_consumer_secret))
            
        if magento_access_token is not None:
            
            _query_params.append(('magento_access_token', magento_access_token))
            
        if magento_token_secret is not None:
            
            _query_params.append(('magento_token_secret', magento_token_secret))
            
        if prestashop_webservice_key is not None:
            
            _query_params.append(('prestashop_webservice_key', prestashop_webservice_key))
            
        if wix_app_id is not None:
            
            _query_params.append(('wix_app_id', wix_app_id))
            
        if wix_app_secret_key is not None:
            
            _query_params.append(('wix_app_secret_key', wix_app_secret_key))
            
        if wix_refresh_token is not None:
            
            _query_params.append(('wix_refresh_token', wix_refresh_token))
            
        if mercado_libre_app_id is not None:
            
            _query_params.append(('mercado_libre_app_id', mercado_libre_app_id))
            
        if mercado_libre_app_secret_key is not None:
            
            _query_params.append(('mercado_libre_app_secret_key', mercado_libre_app_secret_key))
            
        if mercado_libre_refresh_token is not None:
            
            _query_params.append(('mercado_libre_refresh_token', mercado_libre_refresh_token))
            
        if zid_client_id is not None:
            
            _query_params.append(('zid_client_id', zid_client_id))
            
        if zid_client_secret is not None:
            
            _query_params.append(('zid_client_secret', zid_client_secret))
            
        if zid_access_token is not None:
            
            _query_params.append(('zid_access_token', zid_access_token))
            
        if zid_authorization is not None:
            
            _query_params.append(('zid_authorization', zid_authorization))
            
        if zid_refresh_token is not None:
            
            _query_params.append(('zid_refresh_token', zid_refresh_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/cart.create.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_delete(
        self,
        delete_bridge: Annotated[Optional[StrictBool], Field(description="Identifies if there is a necessity to delete bridge")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartDelete200Response:
        """cart_delete

        Remove store from API2Cart

        :param delete_bridge: Identifies if there is a necessity to delete bridge
        :type delete_bridge: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_delete_serialize(
            delete_bridge=delete_bridge,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_delete_with_http_info(
        self,
        delete_bridge: Annotated[Optional[StrictBool], Field(description="Identifies if there is a necessity to delete bridge")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartDelete200Response]:
        """cart_delete

        Remove store from API2Cart

        :param delete_bridge: Identifies if there is a necessity to delete bridge
        :type delete_bridge: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_delete_serialize(
            delete_bridge=delete_bridge,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_delete_without_preload_content(
        self,
        delete_bridge: Annotated[Optional[StrictBool], Field(description="Identifies if there is a necessity to delete bridge")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_delete

        Remove store from API2Cart

        :param delete_bridge: Identifies if there is a necessity to delete bridge
        :type delete_bridge: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_delete_serialize(
            delete_bridge=delete_bridge,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_delete_serialize(
        self,
        delete_bridge,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if delete_bridge is not None:
            
            _query_params.append(('delete_bridge', delete_bridge))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/cart.delete.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_disconnect(
        self,
        delete_bridge: Annotated[Optional[StrictBool], Field(description="Identifies if there is a necessity to delete bridge")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartDisconnect200Response:
        """(Deprecated) cart_disconnect

        Disconnect with the store and clear store session data.

        :param delete_bridge: Identifies if there is a necessity to delete bridge
        :type delete_bridge: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /cart.disconnect.json is deprecated.", DeprecationWarning)

        _param = self._cart_disconnect_serialize(
            delete_bridge=delete_bridge,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartDisconnect200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_disconnect_with_http_info(
        self,
        delete_bridge: Annotated[Optional[StrictBool], Field(description="Identifies if there is a necessity to delete bridge")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartDisconnect200Response]:
        """(Deprecated) cart_disconnect

        Disconnect with the store and clear store session data.

        :param delete_bridge: Identifies if there is a necessity to delete bridge
        :type delete_bridge: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /cart.disconnect.json is deprecated.", DeprecationWarning)

        _param = self._cart_disconnect_serialize(
            delete_bridge=delete_bridge,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartDisconnect200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_disconnect_without_preload_content(
        self,
        delete_bridge: Annotated[Optional[StrictBool], Field(description="Identifies if there is a necessity to delete bridge")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) cart_disconnect

        Disconnect with the store and clear store session data.

        :param delete_bridge: Identifies if there is a necessity to delete bridge
        :type delete_bridge: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /cart.disconnect.json is deprecated.", DeprecationWarning)

        _param = self._cart_disconnect_serialize(
            delete_bridge=delete_bridge,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartDisconnect200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_disconnect_serialize(
        self,
        delete_bridge,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if delete_bridge is not None:
            
            _query_params.append(('delete_bridge', delete_bridge))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.disconnect.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_giftcard_add(
        self,
        amount: Annotated[Union[StrictFloat, StrictInt], Field(description="Defines the gift card amount value.")],
        code: Annotated[Optional[StrictStr], Field(description="Gift card code")] = None,
        owner_email: Annotated[Optional[StrictStr], Field(description="Gift card owner email")] = None,
        recipient_email: Annotated[Optional[StrictStr], Field(description="Gift card recipient email")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartGiftcardAdd200Response:
        """cart_giftcard_add

        Create new gift card

        :param amount: Defines the gift card amount value. (required)
        :type amount: float
        :param code: Gift card code
        :type code: str
        :param owner_email: Gift card owner email
        :type owner_email: str
        :param recipient_email: Gift card recipient email
        :type recipient_email: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_giftcard_add_serialize(
            amount=amount,
            code=code,
            owner_email=owner_email,
            recipient_email=recipient_email,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartGiftcardAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_giftcard_add_with_http_info(
        self,
        amount: Annotated[Union[StrictFloat, StrictInt], Field(description="Defines the gift card amount value.")],
        code: Annotated[Optional[StrictStr], Field(description="Gift card code")] = None,
        owner_email: Annotated[Optional[StrictStr], Field(description="Gift card owner email")] = None,
        recipient_email: Annotated[Optional[StrictStr], Field(description="Gift card recipient email")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartGiftcardAdd200Response]:
        """cart_giftcard_add

        Create new gift card

        :param amount: Defines the gift card amount value. (required)
        :type amount: float
        :param code: Gift card code
        :type code: str
        :param owner_email: Gift card owner email
        :type owner_email: str
        :param recipient_email: Gift card recipient email
        :type recipient_email: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_giftcard_add_serialize(
            amount=amount,
            code=code,
            owner_email=owner_email,
            recipient_email=recipient_email,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartGiftcardAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_giftcard_add_without_preload_content(
        self,
        amount: Annotated[Union[StrictFloat, StrictInt], Field(description="Defines the gift card amount value.")],
        code: Annotated[Optional[StrictStr], Field(description="Gift card code")] = None,
        owner_email: Annotated[Optional[StrictStr], Field(description="Gift card owner email")] = None,
        recipient_email: Annotated[Optional[StrictStr], Field(description="Gift card recipient email")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_giftcard_add

        Create new gift card

        :param amount: Defines the gift card amount value. (required)
        :type amount: float
        :param code: Gift card code
        :type code: str
        :param owner_email: Gift card owner email
        :type owner_email: str
        :param recipient_email: Gift card recipient email
        :type recipient_email: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_giftcard_add_serialize(
            amount=amount,
            code=code,
            owner_email=owner_email,
            recipient_email=recipient_email,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartGiftcardAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_giftcard_add_serialize(
        self,
        amount,
        code,
        owner_email,
        recipient_email,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if amount is not None:
            
            _query_params.append(('amount', amount))
            
        if code is not None:
            
            _query_params.append(('code', code))
            
        if owner_email is not None:
            
            _query_params.append(('owner_email', owner_email))
            
        if recipient_email is not None:
            
            _query_params.append(('recipient_email', recipient_email))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/cart.giftcard.add.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_giftcard_count(
        self,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartGiftcardCount200Response:
        """cart_giftcard_count

        Get gift cards count.

        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_giftcard_count_serialize(
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartGiftcardCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_giftcard_count_with_http_info(
        self,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartGiftcardCount200Response]:
        """cart_giftcard_count

        Get gift cards count.

        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_giftcard_count_serialize(
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartGiftcardCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_giftcard_count_without_preload_content(
        self,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_giftcard_count

        Get gift cards count.

        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_giftcard_count_serialize(
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartGiftcardCount200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_giftcard_count_serialize(
        self,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.giftcard.count.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_giftcard_list(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelResponseCartGiftCardList:
        """cart_giftcard_list

        Get gift cards list.

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param store_id: Store Id
        :type store_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_giftcard_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            store_id=store_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartGiftCardList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_giftcard_list_with_http_info(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelResponseCartGiftCardList]:
        """cart_giftcard_list

        Get gift cards list.

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param store_id: Store Id
        :type store_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_giftcard_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            store_id=store_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartGiftCardList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_giftcard_list_without_preload_content(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_giftcard_list

        Get gift cards list.

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param store_id: Store Id
        :type store_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_giftcard_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            store_id=store_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartGiftCardList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_giftcard_list_serialize(
        self,
        page_cursor,
        start,
        count,
        store_id,
        params,
        response_fields,
        exclude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page_cursor is not None:
            
            _query_params.append(('page_cursor', page_cursor))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.giftcard.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_info(
        self,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartInfo200Response:
        """cart_info

        Get cart information

        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_info_serialize(
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartInfo200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_info_with_http_info(
        self,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartInfo200Response]:
        """cart_info

        Get cart information

        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_info_serialize(
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartInfo200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_info_without_preload_content(
        self,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_info

        Get cart information

        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_info_serialize(
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartInfo200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_info_serialize(
        self,
        params,
        response_fields,
        exclude,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if params is not None:
            
            _query_params.append(('params', params))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.info.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_list(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartList200Response:
        """(Deprecated) cart_list

        Get list of supported carts

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /cart.list.json is deprecated.", DeprecationWarning)

        _param = self._cart_list_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_list_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartList200Response]:
        """(Deprecated) cart_list

        Get list of supported carts

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /cart.list.json is deprecated.", DeprecationWarning)

        _param = self._cart_list_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_list_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) cart_list

        Get list of supported carts

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /cart.list.json is deprecated.", DeprecationWarning)

        _param = self._cart_list_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_list_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_meta_data_list(
        self,
        entity_id: Annotated[StrictStr, Field(description="Entity Id")],
        entity: Annotated[Optional[StrictStr], Field(description="Entity")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        key: Annotated[Optional[StrictStr], Field(description="Key")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelResponseCartMetaDataList:
        """cart_meta_data_list

        Get entity meta data

        :param entity_id: Entity Id (required)
        :type entity_id: str
        :param entity: Entity
        :type entity: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param key: Key
        :type key: str
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_meta_data_list_serialize(
            entity_id=entity_id,
            entity=entity,
            store_id=store_id,
            lang_id=lang_id,
            key=key,
            count=count,
            page_cursor=page_cursor,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartMetaDataList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_meta_data_list_with_http_info(
        self,
        entity_id: Annotated[StrictStr, Field(description="Entity Id")],
        entity: Annotated[Optional[StrictStr], Field(description="Entity")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        key: Annotated[Optional[StrictStr], Field(description="Key")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelResponseCartMetaDataList]:
        """cart_meta_data_list

        Get entity meta data

        :param entity_id: Entity Id (required)
        :type entity_id: str
        :param entity: Entity
        :type entity: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param key: Key
        :type key: str
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_meta_data_list_serialize(
            entity_id=entity_id,
            entity=entity,
            store_id=store_id,
            lang_id=lang_id,
            key=key,
            count=count,
            page_cursor=page_cursor,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartMetaDataList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_meta_data_list_without_preload_content(
        self,
        entity_id: Annotated[StrictStr, Field(description="Entity Id")],
        entity: Annotated[Optional[StrictStr], Field(description="Entity")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        key: Annotated[Optional[StrictStr], Field(description="Key")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_meta_data_list

        Get entity meta data

        :param entity_id: Entity Id (required)
        :type entity_id: str
        :param entity: Entity
        :type entity: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param key: Key
        :type key: str
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_meta_data_list_serialize(
            entity_id=entity_id,
            entity=entity,
            store_id=store_id,
            lang_id=lang_id,
            key=key,
            count=count,
            page_cursor=page_cursor,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartMetaDataList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_meta_data_list_serialize(
        self,
        entity_id,
        entity,
        store_id,
        lang_id,
        key,
        count,
        page_cursor,
        params,
        response_fields,
        exclude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if entity_id is not None:
            
            _query_params.append(('entity_id', entity_id))
            
        if entity is not None:
            
            _query_params.append(('entity', entity))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if page_cursor is not None:
            
            _query_params.append(('page_cursor', page_cursor))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.meta_data.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_meta_data_set(
        self,
        entity_id: Annotated[StrictStr, Field(description="Entity Id")],
        key: Annotated[StrictStr, Field(description="Key")],
        value: Annotated[StrictStr, Field(description="Value")],
        namespace: Annotated[StrictStr, Field(description="Metafield namespace")],
        entity: Annotated[Optional[StrictStr], Field(description="Entity")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AttributeAdd200Response:
        """cart_meta_data_set

        Set meta data for a specific entity

        :param entity_id: Entity Id (required)
        :type entity_id: str
        :param key: Key (required)
        :type key: str
        :param value: Value (required)
        :type value: str
        :param namespace: Metafield namespace (required)
        :type namespace: str
        :param entity: Entity
        :type entity: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_meta_data_set_serialize(
            entity_id=entity_id,
            key=key,
            value=value,
            namespace=namespace,
            entity=entity,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_meta_data_set_with_http_info(
        self,
        entity_id: Annotated[StrictStr, Field(description="Entity Id")],
        key: Annotated[StrictStr, Field(description="Key")],
        value: Annotated[StrictStr, Field(description="Value")],
        namespace: Annotated[StrictStr, Field(description="Metafield namespace")],
        entity: Annotated[Optional[StrictStr], Field(description="Entity")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AttributeAdd200Response]:
        """cart_meta_data_set

        Set meta data for a specific entity

        :param entity_id: Entity Id (required)
        :type entity_id: str
        :param key: Key (required)
        :type key: str
        :param value: Value (required)
        :type value: str
        :param namespace: Metafield namespace (required)
        :type namespace: str
        :param entity: Entity
        :type entity: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_meta_data_set_serialize(
            entity_id=entity_id,
            key=key,
            value=value,
            namespace=namespace,
            entity=entity,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_meta_data_set_without_preload_content(
        self,
        entity_id: Annotated[StrictStr, Field(description="Entity Id")],
        key: Annotated[StrictStr, Field(description="Key")],
        value: Annotated[StrictStr, Field(description="Value")],
        namespace: Annotated[StrictStr, Field(description="Metafield namespace")],
        entity: Annotated[Optional[StrictStr], Field(description="Entity")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        lang_id: Annotated[Optional[StrictStr], Field(description="Language id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_meta_data_set

        Set meta data for a specific entity

        :param entity_id: Entity Id (required)
        :type entity_id: str
        :param key: Key (required)
        :type key: str
        :param value: Value (required)
        :type value: str
        :param namespace: Metafield namespace (required)
        :type namespace: str
        :param entity: Entity
        :type entity: str
        :param store_id: Store Id
        :type store_id: str
        :param lang_id: Language id
        :type lang_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_meta_data_set_serialize(
            entity_id=entity_id,
            key=key,
            value=value,
            namespace=namespace,
            entity=entity,
            store_id=store_id,
            lang_id=lang_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AttributeAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_meta_data_set_serialize(
        self,
        entity_id,
        key,
        value,
        namespace,
        entity,
        store_id,
        lang_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if entity_id is not None:
            
            _query_params.append(('entity_id', entity_id))
            
        if entity is not None:
            
            _query_params.append(('entity', entity))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if lang_id is not None:
            
            _query_params.append(('lang_id', lang_id))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if value is not None:
            
            _query_params.append(('value', value))
            
        if namespace is not None:
            
            _query_params.append(('namespace', namespace))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/cart.meta_data.set.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_meta_data_unset(
        self,
        entity_id: Annotated[StrictStr, Field(description="Entity Id")],
        key: Annotated[StrictStr, Field(description="Key")],
        id: Annotated[StrictStr, Field(description="Entity id")],
        entity: Annotated[Optional[StrictStr], Field(description="Entity")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BasketLiveShippingServiceDelete200Response:
        """cart_meta_data_unset

        Unset meta data for a specific entity

        :param entity_id: Entity Id (required)
        :type entity_id: str
        :param key: Key (required)
        :type key: str
        :param id: Entity id (required)
        :type id: str
        :param entity: Entity
        :type entity: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_meta_data_unset_serialize(
            entity_id=entity_id,
            key=key,
            id=id,
            entity=entity,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BasketLiveShippingServiceDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_meta_data_unset_with_http_info(
        self,
        entity_id: Annotated[StrictStr, Field(description="Entity Id")],
        key: Annotated[StrictStr, Field(description="Key")],
        id: Annotated[StrictStr, Field(description="Entity id")],
        entity: Annotated[Optional[StrictStr], Field(description="Entity")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BasketLiveShippingServiceDelete200Response]:
        """cart_meta_data_unset

        Unset meta data for a specific entity

        :param entity_id: Entity Id (required)
        :type entity_id: str
        :param key: Key (required)
        :type key: str
        :param id: Entity id (required)
        :type id: str
        :param entity: Entity
        :type entity: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_meta_data_unset_serialize(
            entity_id=entity_id,
            key=key,
            id=id,
            entity=entity,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BasketLiveShippingServiceDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_meta_data_unset_without_preload_content(
        self,
        entity_id: Annotated[StrictStr, Field(description="Entity Id")],
        key: Annotated[StrictStr, Field(description="Key")],
        id: Annotated[StrictStr, Field(description="Entity id")],
        entity: Annotated[Optional[StrictStr], Field(description="Entity")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_meta_data_unset

        Unset meta data for a specific entity

        :param entity_id: Entity Id (required)
        :type entity_id: str
        :param key: Key (required)
        :type key: str
        :param id: Entity id (required)
        :type id: str
        :param entity: Entity
        :type entity: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_meta_data_unset_serialize(
            entity_id=entity_id,
            key=key,
            id=id,
            entity=entity,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BasketLiveShippingServiceDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_meta_data_unset_serialize(
        self,
        entity_id,
        key,
        id,
        entity,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if entity_id is not None:
            
            _query_params.append(('entity_id', entity_id))
            
        if entity is not None:
            
            _query_params.append(('entity', entity))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/cart.meta_data.unset.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_methods(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartMethods200Response:
        """cart_methods

        Get list of cart methods

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_methods_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartMethods200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_methods_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartMethods200Response]:
        """cart_methods

        Get list of cart methods

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_methods_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartMethods200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_methods_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_methods

        Get list of cart methods

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_methods_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartMethods200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_methods_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.methods.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_plugin_list(
        self,
        store_key: Annotated[Optional[StrictStr], Field(description="Set this parameter if bridge is already uploaded to store")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartPluginList200Response:
        """cart_plugin_list

        Get list of installed plugins

        :param store_key: Set this parameter if bridge is already uploaded to store
        :type store_key: str
        :param store_id: Store Id
        :type store_id: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_plugin_list_serialize(
            store_key=store_key,
            store_id=store_id,
            start=start,
            count=count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartPluginList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_plugin_list_with_http_info(
        self,
        store_key: Annotated[Optional[StrictStr], Field(description="Set this parameter if bridge is already uploaded to store")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartPluginList200Response]:
        """cart_plugin_list

        Get list of installed plugins

        :param store_key: Set this parameter if bridge is already uploaded to store
        :type store_key: str
        :param store_id: Store Id
        :type store_id: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_plugin_list_serialize(
            store_key=store_key,
            store_id=store_id,
            start=start,
            count=count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartPluginList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_plugin_list_without_preload_content(
        self,
        store_key: Annotated[Optional[StrictStr], Field(description="Set this parameter if bridge is already uploaded to store")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_plugin_list

        Get list of installed plugins

        :param store_key: Set this parameter if bridge is already uploaded to store
        :type store_key: str
        :param store_id: Store Id
        :type store_id: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_plugin_list_serialize(
            store_key=store_key,
            store_id=store_id,
            start=start,
            count=count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartPluginList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_plugin_list_serialize(
        self,
        store_key,
        store_id,
        start,
        count,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if store_key is not None:
            
            _query_params.append(('store_key', store_key))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.plugin.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_script_add(
        self,
        name: Annotated[Optional[StrictStr], Field(description="The user-friendly script name")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The user-friendly description")] = None,
        html: Annotated[Optional[StrictStr], Field(description="An html string containing exactly one `script` tag.")] = None,
        src: Annotated[Optional[StrictStr], Field(description="The URL of the remote script")] = None,
        load_method: Annotated[Optional[StrictStr], Field(description="The load method to use for the script")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="The page or pages on the online store where the script should be included")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartScriptAdd200Response:
        """cart_script_add

        Add new script to the storefront

        :param name: The user-friendly script name
        :type name: str
        :param description: The user-friendly description
        :type description: str
        :param html: An html string containing exactly one `script` tag.
        :type html: str
        :param src: The URL of the remote script
        :type src: str
        :param load_method: The load method to use for the script
        :type load_method: str
        :param scope: The page or pages on the online store where the script should be included
        :type scope: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_script_add_serialize(
            name=name,
            description=description,
            html=html,
            src=src,
            load_method=load_method,
            scope=scope,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartScriptAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_script_add_with_http_info(
        self,
        name: Annotated[Optional[StrictStr], Field(description="The user-friendly script name")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The user-friendly description")] = None,
        html: Annotated[Optional[StrictStr], Field(description="An html string containing exactly one `script` tag.")] = None,
        src: Annotated[Optional[StrictStr], Field(description="The URL of the remote script")] = None,
        load_method: Annotated[Optional[StrictStr], Field(description="The load method to use for the script")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="The page or pages on the online store where the script should be included")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartScriptAdd200Response]:
        """cart_script_add

        Add new script to the storefront

        :param name: The user-friendly script name
        :type name: str
        :param description: The user-friendly description
        :type description: str
        :param html: An html string containing exactly one `script` tag.
        :type html: str
        :param src: The URL of the remote script
        :type src: str
        :param load_method: The load method to use for the script
        :type load_method: str
        :param scope: The page or pages on the online store where the script should be included
        :type scope: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_script_add_serialize(
            name=name,
            description=description,
            html=html,
            src=src,
            load_method=load_method,
            scope=scope,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartScriptAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_script_add_without_preload_content(
        self,
        name: Annotated[Optional[StrictStr], Field(description="The user-friendly script name")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The user-friendly description")] = None,
        html: Annotated[Optional[StrictStr], Field(description="An html string containing exactly one `script` tag.")] = None,
        src: Annotated[Optional[StrictStr], Field(description="The URL of the remote script")] = None,
        load_method: Annotated[Optional[StrictStr], Field(description="The load method to use for the script")] = None,
        scope: Annotated[Optional[StrictStr], Field(description="The page or pages on the online store where the script should be included")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_script_add

        Add new script to the storefront

        :param name: The user-friendly script name
        :type name: str
        :param description: The user-friendly description
        :type description: str
        :param html: An html string containing exactly one `script` tag.
        :type html: str
        :param src: The URL of the remote script
        :type src: str
        :param load_method: The load method to use for the script
        :type load_method: str
        :param scope: The page or pages on the online store where the script should be included
        :type scope: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_script_add_serialize(
            name=name,
            description=description,
            html=html,
            src=src,
            load_method=load_method,
            scope=scope,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartScriptAdd200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_script_add_serialize(
        self,
        name,
        description,
        html,
        src,
        load_method,
        scope,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if html is not None:
            
            _query_params.append(('html', html))
            
        if src is not None:
            
            _query_params.append(('src', src))
            
        if load_method is not None:
            
            _query_params.append(('load_method', load_method))
            
        if scope is not None:
            
            _query_params.append(('scope', scope))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/cart.script.add.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_script_delete(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BridgeDelete200Response:
        """cart_script_delete

        Remove script from the storefront

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_script_delete_serialize(
            id=id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BridgeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_script_delete_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BridgeDelete200Response]:
        """cart_script_delete

        Remove script from the storefront

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_script_delete_serialize(
            id=id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BridgeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_script_delete_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Entity id")],
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_script_delete

        Remove script from the storefront

        :param id: Entity id (required)
        :type id: str
        :param store_id: Store Id
        :type store_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_script_delete_serialize(
            id=id,
            store_id=store_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BridgeDelete200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_script_delete_serialize(
        self,
        id,
        store_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/cart.script.delete.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_script_list(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        created_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their creation date")] = None,
        created_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their creation date")] = None,
        modified_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their modification date")] = None,
        modified_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their modification date")] = None,
        script_ids: Annotated[Optional[StrictStr], Field(description="Retrieves only scripts with specific ids")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModelResponseCartScriptList:
        """cart_script_list

        Get scripts installed to the storefront

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param created_from: Retrieve entities from their creation date
        :type created_from: str
        :param created_to: Retrieve entities to their creation date
        :type created_to: str
        :param modified_from: Retrieve entities from their modification date
        :type modified_from: str
        :param modified_to: Retrieve entities to their modification date
        :type modified_to: str
        :param script_ids: Retrieves only scripts with specific ids
        :type script_ids: str
        :param store_id: Store Id
        :type store_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_script_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            created_from=created_from,
            created_to=created_to,
            modified_from=modified_from,
            modified_to=modified_to,
            script_ids=script_ids,
            store_id=store_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartScriptList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_script_list_with_http_info(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        created_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their creation date")] = None,
        created_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their creation date")] = None,
        modified_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their modification date")] = None,
        modified_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their modification date")] = None,
        script_ids: Annotated[Optional[StrictStr], Field(description="Retrieves only scripts with specific ids")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModelResponseCartScriptList]:
        """cart_script_list

        Get scripts installed to the storefront

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param created_from: Retrieve entities from their creation date
        :type created_from: str
        :param created_to: Retrieve entities to their creation date
        :type created_to: str
        :param modified_from: Retrieve entities from their modification date
        :type modified_from: str
        :param modified_to: Retrieve entities to their modification date
        :type modified_to: str
        :param script_ids: Retrieves only scripts with specific ids
        :type script_ids: str
        :param store_id: Store Id
        :type store_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_script_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            created_from=created_from,
            created_to=created_to,
            modified_from=modified_from,
            modified_to=modified_to,
            script_ids=script_ids,
            store_id=store_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartScriptList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_script_list_without_preload_content(
        self,
        page_cursor: Annotated[Optional[StrictStr], Field(description="Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        created_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their creation date")] = None,
        created_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their creation date")] = None,
        modified_from: Annotated[Optional[StrictStr], Field(description="Retrieve entities from their modification date")] = None,
        modified_to: Annotated[Optional[StrictStr], Field(description="Retrieve entities to their modification date")] = None,
        script_ids: Annotated[Optional[StrictStr], Field(description="Retrieves only scripts with specific ids")] = None,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_script_list

        Get scripts installed to the storefront

        :param page_cursor: Used to retrieve entities via cursor-based pagination (it can't be used with any other filtering parameter)
        :type page_cursor: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param created_from: Retrieve entities from their creation date
        :type created_from: str
        :param created_to: Retrieve entities to their creation date
        :type created_to: str
        :param modified_from: Retrieve entities from their modification date
        :type modified_from: str
        :param modified_to: Retrieve entities to their modification date
        :type modified_to: str
        :param script_ids: Retrieves only scripts with specific ids
        :type script_ids: str
        :param store_id: Store Id
        :type store_id: str
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_script_list_serialize(
            page_cursor=page_cursor,
            start=start,
            count=count,
            created_from=created_from,
            created_to=created_to,
            modified_from=modified_from,
            modified_to=modified_to,
            script_ids=script_ids,
            store_id=store_id,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModelResponseCartScriptList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_script_list_serialize(
        self,
        page_cursor,
        start,
        count,
        created_from,
        created_to,
        modified_from,
        modified_to,
        script_ids,
        store_id,
        params,
        response_fields,
        exclude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page_cursor is not None:
            
            _query_params.append(('page_cursor', page_cursor))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if created_from is not None:
            
            _query_params.append(('created_from', created_from))
            
        if created_to is not None:
            
            _query_params.append(('created_to', created_to))
            
        if modified_from is not None:
            
            _query_params.append(('modified_from', modified_from))
            
        if modified_to is not None:
            
            _query_params.append(('modified_to', modified_to))
            
        if script_ids is not None:
            
            _query_params.append(('script_ids', script_ids))
            
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.script.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_shipping_zones_list(
        self,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartShippingZonesList200Response:
        """cart_shipping_zones_list

        Get list of shipping zones

        :param store_id: Store Id
        :type store_id: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_shipping_zones_list_serialize(
            store_id=store_id,
            start=start,
            count=count,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartShippingZonesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_shipping_zones_list_with_http_info(
        self,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartShippingZonesList200Response]:
        """cart_shipping_zones_list

        Get list of shipping zones

        :param store_id: Store Id
        :type store_id: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_shipping_zones_list_serialize(
            store_id=store_id,
            start=start,
            count=count,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartShippingZonesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_shipping_zones_list_without_preload_content(
        self,
        store_id: Annotated[Optional[StrictStr], Field(description="Store Id")] = None,
        start: Annotated[Optional[StrictInt], Field(description="This parameter sets the number from which you want to get entities")] = None,
        count: Annotated[Optional[StrictInt], Field(description="This parameter sets the entity amount that has to be retrieved. Max allowed count=250")] = None,
        params: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        response_fields: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to retrieve")] = None,
        exclude: Annotated[Optional[StrictStr], Field(description="Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_shipping_zones_list

        Get list of shipping zones

        :param store_id: Store Id
        :type store_id: str
        :param start: This parameter sets the number from which you want to get entities
        :type start: int
        :param count: This parameter sets the entity amount that has to be retrieved. Max allowed count=250
        :type count: int
        :param params: Set this parameter in order to choose which entity fields you want to retrieve
        :type params: str
        :param response_fields: Set this parameter in order to choose which entity fields you want to retrieve
        :type response_fields: str
        :param exclude: Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter `params` equal force_all
        :type exclude: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_shipping_zones_list_serialize(
            store_id=store_id,
            start=start,
            count=count,
            params=params,
            response_fields=response_fields,
            exclude=exclude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartShippingZonesList200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_shipping_zones_list_serialize(
        self,
        store_id,
        start,
        count,
        params,
        response_fields,
        exclude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if store_id is not None:
            
            _query_params.append(('store_id', store_id))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if params is not None:
            
            _query_params.append(('params', params))
            
        if response_fields is not None:
            
            _query_params.append(('response_fields', response_fields))
            
        if exclude is not None:
            
            _query_params.append(('exclude', exclude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.shipping_zones.list.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cart_validate(
        self,
        validate_version: Annotated[Optional[StrictBool], Field(description="Specify if api2cart should validate cart version")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CartValidate200Response:
        """cart_validate

        Check store availability, bridge connection for the downloadable carts, identify DB prefix, validate API accesses for API carts.

        :param validate_version: Specify if api2cart should validate cart version
        :type validate_version: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_validate_serialize(
            validate_version=validate_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartValidate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cart_validate_with_http_info(
        self,
        validate_version: Annotated[Optional[StrictBool], Field(description="Specify if api2cart should validate cart version")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CartValidate200Response]:
        """cart_validate

        Check store availability, bridge connection for the downloadable carts, identify DB prefix, validate API accesses for API carts.

        :param validate_version: Specify if api2cart should validate cart version
        :type validate_version: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_validate_serialize(
            validate_version=validate_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartValidate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cart_validate_without_preload_content(
        self,
        validate_version: Annotated[Optional[StrictBool], Field(description="Specify if api2cart should validate cart version")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """cart_validate

        Check store availability, bridge connection for the downloadable carts, identify DB prefix, validate API accesses for API carts.

        :param validate_version: Specify if api2cart should validate cart version
        :type validate_version: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cart_validate_serialize(
            validate_version=validate_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CartValidate200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cart_validate_serialize(
        self,
        validate_version,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if validate_version is not None:
            
            _query_params.append(('validate_version', validate_version))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key', 
            'store_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/cart.validate.json',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


