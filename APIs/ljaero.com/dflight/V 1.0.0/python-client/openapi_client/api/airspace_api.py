# coding: utf-8

"""
    DFlight API

    [DFlight API](https://ljaero.com/solutions/dflight/) supplies the up-to-date information needed for compliance with UAV preflight assessment requirements. Separate endpoints are available for each of the following information categories: - Airspace - Weather - Temporary Flight Restrictions - Special Security Areas - Restricted Public Venues - Surface Obstacles - Aerodromes - UAS Operating Areas  You can define your geographic area of interest in one of three convenient ways: - Providing a latitude/longitude point and distance around that point - Providing a GeoJSON LineString defining your route - Providing an arbitrary GeoJSON Polygon defining your area of interest

    The version of the OpenAPI document: V 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import StrictStr
from typing import Optional
from openapi_client.models.airspace_by_distance import AirspaceByDistance
from openapi_client.models.airspace_by_polygon import AirspaceByPolygon
from openapi_client.models.airspace_by_route import AirspaceByRoute
from openapi_client.models.airspace_distance_response import AirspaceDistanceResponse
from openapi_client.models.airspace_poly_response import AirspacePolyResponse
from openapi_client.models.airspace_route_response import AirspaceRouteResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class AirspaceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def asp_by_distance_us_v1_airspace_distance_query_post(
        self,
        airspace_by_distance: AirspaceByDistance,
        x_api_key: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AirspaceDistanceResponse:
        """Retrieve all requested types of airspace located within given distance of location.

        Retrieve selected types of airspace existing within given distance from a point. Request body parameters are: * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees * distance:  distance in meters (max allowed value is 25000) * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.  Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows: * CAS (Controlled Airspace)     - *name*     - *cas_class*: B, C, D, or E2     - *floor*: integer value in ft MSL     - *ceiling*: integer value in ft MSL     - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC * SUA (Special Use Airspace)     - *name*     - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area     - *floor*: lower limit of the airspace     - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling*: upper limit of the airspace     - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *schedule*: default activation days/times (other times by NOTAM) * MAA (Miscellaneous Activity Area)     - *name*     - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY     - *use_times*: textual description of days/times when activity in the area should be expected * MTR (Military Training Route)     - *name*     - *use_times*: textual description of days/times when MTR is active/hot     - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route     - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline

        :param airspace_by_distance: (required)
        :type airspace_by_distance: AirspaceByDistance
        :param x_api_key:
        :type x_api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asp_by_distance_us_v1_airspace_distance_query_post_serialize(
            airspace_by_distance=airspace_by_distance,
            x_api_key=x_api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AirspaceDistanceResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def asp_by_distance_us_v1_airspace_distance_query_post_with_http_info(
        self,
        airspace_by_distance: AirspaceByDistance,
        x_api_key: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AirspaceDistanceResponse]:
        """Retrieve all requested types of airspace located within given distance of location.

        Retrieve selected types of airspace existing within given distance from a point. Request body parameters are: * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees * distance:  distance in meters (max allowed value is 25000) * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.  Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows: * CAS (Controlled Airspace)     - *name*     - *cas_class*: B, C, D, or E2     - *floor*: integer value in ft MSL     - *ceiling*: integer value in ft MSL     - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC * SUA (Special Use Airspace)     - *name*     - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area     - *floor*: lower limit of the airspace     - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling*: upper limit of the airspace     - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *schedule*: default activation days/times (other times by NOTAM) * MAA (Miscellaneous Activity Area)     - *name*     - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY     - *use_times*: textual description of days/times when activity in the area should be expected * MTR (Military Training Route)     - *name*     - *use_times*: textual description of days/times when MTR is active/hot     - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route     - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline

        :param airspace_by_distance: (required)
        :type airspace_by_distance: AirspaceByDistance
        :param x_api_key:
        :type x_api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asp_by_distance_us_v1_airspace_distance_query_post_serialize(
            airspace_by_distance=airspace_by_distance,
            x_api_key=x_api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AirspaceDistanceResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def asp_by_distance_us_v1_airspace_distance_query_post_without_preload_content(
        self,
        airspace_by_distance: AirspaceByDistance,
        x_api_key: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve all requested types of airspace located within given distance of location.

        Retrieve selected types of airspace existing within given distance from a point. Request body parameters are: * latitude:  WGS84 latitude coordinate of your selected point, in decimal degrees * longitude:  WGS84 longitude coordinate of your selected point, in decimal degrees * distance:  distance in meters (max allowed value is 25000) * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.  Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows: * CAS (Controlled Airspace)     - *name*     - *cas_class*: B, C, D, or E2     - *floor*: integer value in ft MSL     - *ceiling*: integer value in ft MSL     - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC * SUA (Special Use Airspace)     - *name*     - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area     - *floor*: lower limit of the airspace     - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling*: upper limit of the airspace     - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *schedule*: default activation days/times (other times by NOTAM) * MAA (Miscellaneous Activity Area)     - *name*     - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY     - *use_times*: textual description of days/times when activity in the area should be expected * MTR (Military Training Route)     - *name*     - *use_times*: textual description of days/times when MTR is active/hot     - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route     - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline

        :param airspace_by_distance: (required)
        :type airspace_by_distance: AirspaceByDistance
        :param x_api_key:
        :type x_api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asp_by_distance_us_v1_airspace_distance_query_post_serialize(
            airspace_by_distance=airspace_by_distance,
            x_api_key=x_api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AirspaceDistanceResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _asp_by_distance_us_v1_airspace_distance_query_post_serialize(
        self,
        airspace_by_distance,
        x_api_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if airspace_by_distance is not None:
            _body_params = airspace_by_distance


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/us/v1/airspace/distance-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def asp_by_poly_us_v1_airspace_polygon_query_post(
        self,
        airspace_by_polygon: AirspaceByPolygon,
        x_api_key: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AirspacePolyResponse:
        """Retrieve all requested types of airspace located within given GeoJSON Polygon.

        Retrieve selected types of airspace located within given area. Request body parameters are: * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2. * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.  Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows: * CAS (Controlled Airspace)     - *name*     - *cas_class*: B, C, D, or E2     - *floor*: integer value in ft MSL     - *ceiling*: integer value in ft MSL     - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC * SUA (Special Use Airspace)     - *name*     - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area     - *floor*: lower limit of the airspace     - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling*: upper limit of the airspace     - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *schedule*: default activation days/times (other times by NOTAM) * MAA (Miscellaneous Activity Area)     - *name*     - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY     - *use_times*: textual description of days/times when activity in the area should be expected * MTR (Military Training Route)     - *name*     - *use_times*: textual description of days/times when MTR is active/hot     - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route     - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline

        :param airspace_by_polygon: (required)
        :type airspace_by_polygon: AirspaceByPolygon
        :param x_api_key:
        :type x_api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asp_by_poly_us_v1_airspace_polygon_query_post_serialize(
            airspace_by_polygon=airspace_by_polygon,
            x_api_key=x_api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AirspacePolyResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def asp_by_poly_us_v1_airspace_polygon_query_post_with_http_info(
        self,
        airspace_by_polygon: AirspaceByPolygon,
        x_api_key: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AirspacePolyResponse]:
        """Retrieve all requested types of airspace located within given GeoJSON Polygon.

        Retrieve selected types of airspace located within given area. Request body parameters are: * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2. * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.  Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows: * CAS (Controlled Airspace)     - *name*     - *cas_class*: B, C, D, or E2     - *floor*: integer value in ft MSL     - *ceiling*: integer value in ft MSL     - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC * SUA (Special Use Airspace)     - *name*     - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area     - *floor*: lower limit of the airspace     - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling*: upper limit of the airspace     - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *schedule*: default activation days/times (other times by NOTAM) * MAA (Miscellaneous Activity Area)     - *name*     - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY     - *use_times*: textual description of days/times when activity in the area should be expected * MTR (Military Training Route)     - *name*     - *use_times*: textual description of days/times when MTR is active/hot     - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route     - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline

        :param airspace_by_polygon: (required)
        :type airspace_by_polygon: AirspaceByPolygon
        :param x_api_key:
        :type x_api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asp_by_poly_us_v1_airspace_polygon_query_post_serialize(
            airspace_by_polygon=airspace_by_polygon,
            x_api_key=x_api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AirspacePolyResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def asp_by_poly_us_v1_airspace_polygon_query_post_without_preload_content(
        self,
        airspace_by_polygon: AirspaceByPolygon,
        x_api_key: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve all requested types of airspace located within given GeoJSON Polygon.

        Retrieve selected types of airspace located within given area. Request body parameters are: * poly:  [GeoJSON Polygon](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the area. Max allowed area is 1000 km^2. * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.  Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows: * CAS (Controlled Airspace)     - *name*     - *cas_class*: B, C, D, or E2     - *floor*: integer value in ft MSL     - *ceiling*: integer value in ft MSL     - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC * SUA (Special Use Airspace)     - *name*     - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area     - *floor*: lower limit of the airspace     - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling*: upper limit of the airspace     - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *schedule*: default activation days/times (other times by NOTAM) * MAA (Miscellaneous Activity Area)     - *name*     - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY     - *use_times*: textual description of days/times when activity in the area should be expected * MTR (Military Training Route)     - *name*     - *use_times*: textual description of days/times when MTR is active/hot     - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route     - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline

        :param airspace_by_polygon: (required)
        :type airspace_by_polygon: AirspaceByPolygon
        :param x_api_key:
        :type x_api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asp_by_poly_us_v1_airspace_polygon_query_post_serialize(
            airspace_by_polygon=airspace_by_polygon,
            x_api_key=x_api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AirspacePolyResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _asp_by_poly_us_v1_airspace_polygon_query_post_serialize(
        self,
        airspace_by_polygon,
        x_api_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if airspace_by_polygon is not None:
            _body_params = airspace_by_polygon


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/us/v1/airspace/polygon-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def asp_by_route_us_v1_airspace_route_query_post(
        self,
        airspace_by_route: AirspaceByRoute,
        x_api_key: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AirspaceRouteResponse:
        """Retrieve all requested types of airspace traversed by route.

        Retrieve selected types of airspace traversed by route. Request body parameters are: * route:  [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km. * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.  Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows: * CAS (Controlled Airspace)     - *name*     - *cas_class*: B, C, D, or E2     - *floor*: integer value in ft MSL     - *ceiling*: integer value in ft MSL     - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC * SUA (Special Use Airspace)     - *name*     - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area     - *floor*: lower limit of the airspace     - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling*: upper limit of the airspace     - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *schedule*: default activation days/times (other times by NOTAM) * MAA (Miscellaneous Activity Area)     - *name*     - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY     - *use_times*: textual description of days/times when activity in the area should be expected * MTR (Military Training Route)     - *name*     - *use_times*: textual description of days/times when MTR is active/hot     - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route     - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline

        :param airspace_by_route: (required)
        :type airspace_by_route: AirspaceByRoute
        :param x_api_key:
        :type x_api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asp_by_route_us_v1_airspace_route_query_post_serialize(
            airspace_by_route=airspace_by_route,
            x_api_key=x_api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AirspaceRouteResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def asp_by_route_us_v1_airspace_route_query_post_with_http_info(
        self,
        airspace_by_route: AirspaceByRoute,
        x_api_key: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AirspaceRouteResponse]:
        """Retrieve all requested types of airspace traversed by route.

        Retrieve selected types of airspace traversed by route. Request body parameters are: * route:  [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km. * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.  Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows: * CAS (Controlled Airspace)     - *name*     - *cas_class*: B, C, D, or E2     - *floor*: integer value in ft MSL     - *ceiling*: integer value in ft MSL     - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC * SUA (Special Use Airspace)     - *name*     - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area     - *floor*: lower limit of the airspace     - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling*: upper limit of the airspace     - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *schedule*: default activation days/times (other times by NOTAM) * MAA (Miscellaneous Activity Area)     - *name*     - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY     - *use_times*: textual description of days/times when activity in the area should be expected * MTR (Military Training Route)     - *name*     - *use_times*: textual description of days/times when MTR is active/hot     - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route     - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline

        :param airspace_by_route: (required)
        :type airspace_by_route: AirspaceByRoute
        :param x_api_key:
        :type x_api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asp_by_route_us_v1_airspace_route_query_post_serialize(
            airspace_by_route=airspace_by_route,
            x_api_key=x_api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AirspaceRouteResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def asp_by_route_us_v1_airspace_route_query_post_without_preload_content(
        self,
        airspace_by_route: AirspaceByRoute,
        x_api_key: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve all requested types of airspace traversed by route.

        Retrieve selected types of airspace traversed by route. Request body parameters are: * route:  [GeoJSON Linestring](https://www.rfc-editor.org/rfc/rfc7946.html#appendix-A) defining the route. Max allowed length is 50 km. * asptypes:  list of one or more airspace types you wish to retrieve. Allowed values are 'CAS', 'SUA', 'MAA', and 'MTR'.  Successful requests return a list of GeoJSON FeatureCollections, one for each Airspace type indicated in the request. Within each feature collection, there will be a separate Feature for each Airspace instance found. All Features will include a property indicating the *airspace_type*. Additional properties for each *airspace_type* are as follows: * CAS (Controlled Airspace)     - *name*     - *cas_class*: B, C, D, or E2     - *floor*: integer value in ft MSL     - *ceiling*: integer value in ft MSL     - *lannc*: true/false indicating whether or not authorization for this airspace may be obtained via LAANC * SUA (Special Use Airspace)     - *name*     - *sua_type*: AA = Alert Area, MOA = Military Operations Area, NSA = National Security Area, PA = Prohibited Area, RA = Restricted Area, WA = Warning Area     - *floor*: lower limit of the airspace     - *floor_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *floor_ref*: reference level used for the numeric floor value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *ceiling*: upper limit of the airspace     - *ceiling_uom*: unit of measure used for the numeric floor value: FT (feet) or FL (flight level)     - *ceiling_ref*: reference level used for the numeric ceiling value: AGL, MSL, or STD (standard atmosphere, used for flight level values)     - *schedule*: default activation days/times (other times by NOTAM) * MAA (Miscellaneous Activity Area)     - *name*     - *maa_type*: one of the following - ULTRALIGHT, PARACHUTE JUMP AREA, AEROBATIC PRACTICE, GLIDER, HANG GLIDER, SPACE LAUNCH ACTIVITY     - *use_times*: textual description of days/times when activity in the area should be expected * MTR (Military Training Route)     - *name*     - *use_times*: textual description of days/times when MTR is active/hot     - *terrain_following*: boolean value indicating whether terrain following activity occurs on the route     - *max_extent_nm*: maximum distance that aircraft can deviate from route centerline

        :param airspace_by_route: (required)
        :type airspace_by_route: AirspaceByRoute
        :param x_api_key:
        :type x_api_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asp_by_route_us_v1_airspace_route_query_post_serialize(
            airspace_by_route=airspace_by_route,
            x_api_key=x_api_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AirspaceRouteResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _asp_by_route_us_v1_airspace_route_query_post_serialize(
        self,
        airspace_by_route,
        x_api_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_api_key is not None:
            _header_params['x-api-key'] = x_api_key
        # process the form parameters
        # process the body parameter
        if airspace_by_route is not None:
            _body_params = airspace_by_route


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/us/v1/airspace/route-query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


