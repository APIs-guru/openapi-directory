# coding: utf-8

"""
    Verify API

    The Verify API helps you to implement 2FA (two-factor authentication) in your applications. This is useful for:  * Protecting against spam, by preventing spammers from creating multiple accounts * Monitoring suspicious activity, by forcing an account user to verify ownership of a number * Ensuring that you can reach your users at any time because you have their correct phone number More information is available at <https://developer.nexmo.com/verify>

    The version of the OpenAPI document: 1.2.4
    Contact: devrel@vonage.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class CheckResponse(BaseModel):
    """
    Success
    """ # noqa: E501
    currency: Optional[StrictStr] = Field(default=None, description="The currency code.")
    estimated_price_messages_sent: Optional[StrictStr] = Field(default=None, description="This field may not be present, depending on your pricing model. The value indicates the cost (in EUR) of the calls made and messages sent for the verification process. This value may be updated during and shortly after the request completes because user input events can overlap with message/call events. When this field is present, the total cost of the verification is the sum of this field and the `price` field. ")
    event_id: Optional[StrictStr] = Field(default=None, description="The ID of the verification event, such as an SMS or TTS call.")
    price: Optional[StrictStr] = Field(default=None, description="The cost incurred for this request.")
    request_id: Optional[StrictStr] = Field(default=None, description="The `request_id` that you received in the response to the Verify request and used in the Verify check request.")
    status: Optional[StrictStr] = Field(default=None, description="A value of `0` indicates that your user entered the correct code. If it is non-zero, check the `error_text`.")
    __properties: ClassVar[List[str]] = ["currency", "estimated_price_messages_sent", "event_id", "price", "request_id", "status"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CheckResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CheckResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "currency": obj.get("currency"),
            "estimated_price_messages_sent": obj.get("estimated_price_messages_sent"),
            "event_id": obj.get("event_id"),
            "price": obj.get("price"),
            "request_id": obj.get("request_id"),
            "status": obj.get("status")
        })
        return _obj


