# coding: utf-8

"""
    Verify API

    The Verify API helps you to implement 2FA (two-factor authentication) in your applications. This is useful for:  * Protecting against spam, by preventing spammers from creating multiple accounts * Monitoring suspicious activity, by forcing an account user to verify ownership of a number * Ensuring that you can reach your users at any time because you have their correct phone number More information is available at <https://developer.nexmo.com/verify>

    The version of the OpenAPI document: 1.2.4
    Contact: devrel@vonage.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.search_response_checks_inner import SearchResponseChecksInner
from openapi_client.models.search_response_events_inner import SearchResponseEventsInner
from typing import Optional, Set
from typing_extensions import Self

class SearchResponse(BaseModel):
    """
    Success
    """ # noqa: E501
    account_id: Optional[StrictStr] = Field(default=None, description="The Vonage account ID the request was for.")
    checks: Optional[List[SearchResponseChecksInner]] = Field(default=None, description="The list of checks made for this verification and their outcomes.")
    currency: Optional[StrictStr] = Field(default=None, description="The currency code.")
    date_finalized: Optional[StrictStr] = Field(default=None, description="The date and time the verification request was completed. This response parameter is in the following format YYYY-MM-DD HH:MM:SS.")
    date_submitted: Optional[StrictStr] = Field(default=None, description="The date and time the verification request was submitted, in the following format YYYY-MM-DD HH:MM:SS.")
    estimated_price_messages_sent: Optional[StrictStr] = Field(default=None, description="This field may not be present, depending on your pricing model. The value indicates the cost (in EUR) of the calls made and messages sent for the verification process. This value may be updated during and shortly after the request completes because user input events can overlap with message/call events. When this field is present, the total cost of the verification is the sum of this field and the `price` field. ")
    events: Optional[List[SearchResponseEventsInner]] = Field(default=None, description="The events that have taken place to verify this number, and their unique identifiers.")
    first_event_date: Optional[StrictStr] = Field(default=None, description="The time the first verification attempt was made, in the following format YYYY-MM-DD HH:MM:SS.")
    last_event_date: Optional[StrictStr] = Field(default=None, description="The time the last verification attempt was made, in the following format YYYY-MM-DD HH:MM:SS.")
    number: Optional[StrictStr] = Field(default=None, description="The phone number this verification request was used for.")
    price: Optional[StrictStr] = Field(default=None, description="The cost incurred for this verification request.")
    request_id: Optional[StrictStr] = Field(default=None, description="The `request_id` that you received in the response to the Verify request and used in the Verify search request.")
    sender_id: Optional[StrictStr] = Field(default='verify', description="The `sender_id` you provided in the Verify request.")
    status: Optional[StrictStr] = Field(default=None, description="Code | Description -- | -- IN PROGRESS | The search is still in progress. SUCCESS | Your user entered a correct verification code. FAILED | Your user entered an incorrect code more than three times. EXPIRED | Your user did not enter a code before the `pin_expiry` time elapsed. CANCELLED | The verification process was cancelled by a Verify control request. ")
    __properties: ClassVar[List[str]] = ["account_id", "checks", "currency", "date_finalized", "date_submitted", "estimated_price_messages_sent", "events", "first_event_date", "last_event_date", "number", "price", "request_id", "sender_id", "status"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['IN PROGRESS', 'SUCCESS', 'FAILED', 'EXPIRED', 'CANCELLED']):
            raise ValueError("must be one of enum values ('IN PROGRESS', 'SUCCESS', 'FAILED', 'EXPIRED', 'CANCELLED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SearchResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in checks (list)
        _items = []
        if self.checks:
            for _item_checks in self.checks:
                if _item_checks:
                    _items.append(_item_checks.to_dict())
            _dict['checks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in events (list)
        _items = []
        if self.events:
            for _item_events in self.events:
                if _item_events:
                    _items.append(_item_events.to_dict())
            _dict['events'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SearchResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_id": obj.get("account_id"),
            "checks": [SearchResponseChecksInner.from_dict(_item) for _item in obj["checks"]] if obj.get("checks") is not None else None,
            "currency": obj.get("currency"),
            "date_finalized": obj.get("date_finalized"),
            "date_submitted": obj.get("date_submitted"),
            "estimated_price_messages_sent": obj.get("estimated_price_messages_sent"),
            "events": [SearchResponseEventsInner.from_dict(_item) for _item in obj["events"]] if obj.get("events") is not None else None,
            "first_event_date": obj.get("first_event_date"),
            "last_event_date": obj.get("last_event_date"),
            "number": obj.get("number"),
            "price": obj.get("price"),
            "request_id": obj.get("request_id"),
            "sender_id": obj.get("sender_id") if obj.get("sender_id") is not None else 'verify',
            "status": obj.get("status")
        })
        return _obj


