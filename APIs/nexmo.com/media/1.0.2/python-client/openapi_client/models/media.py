# coding: utf-8

"""
    Media API

    The Media API can be used to query, download and delete media items such as audio files for use with other Nexmo APIs.

    The version of the OpenAPI document: 1.0.2
    Contact: devrel@nexmo.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class Media(BaseModel):
    """
    Media
    """ # noqa: E501
    account_id: Optional[StrictStr] = Field(default=None, description="The ID of your Nexmo account. This is the same as your API key.")
    etag: Optional[StrictStr] = Field(default=None, description="An identifier for the content. This will change if the content of the file has been changed (i.e. if you upload a new version of the file). For more information see Wikipedia: [HTTP ETag](https://en.wikipedia.org/wiki/HTTP_ETag)")
    id: Optional[StrictStr] = Field(default=None, description="A UUID representing the object.")
    max_downloads_allowed: Optional[StrictInt] = Field(default=None, description="The maximum number of times the file may be downloaded.")
    media_size: Optional[StrictInt] = Field(default=None, description="The size of the file in bytes")
    metadata_primary: Optional[StrictStr] = Field(default=None, description="A user set string containing metadata about the media file.")
    metadata_secondary: Optional[StrictStr] = Field(default=None, description="A user set string containing further metadata about the media file.")
    mime_type: Optional[StrictStr] = Field(default=None, description="The IETF MIME type of the file.")
    original_file_name: Optional[StrictStr] = Field(default=None, description="The filename of the object as it was originally uploaded.")
    public: Optional[StrictBool] = Field(default=None, description="Whether the item is available for download without authentication.")
    store_id: Optional[StrictStr] = Field(default=None, description="An internal identifier of how the file is stored.")
    time_created: Optional[StrictStr] = Field(default=None, description="A timestamp for the time that the file was created")
    time_last_updated: Optional[StrictStr] = Field(default=None, description="A timestamp for the time that the file was last modified")
    times_downloaded: Optional[StrictInt] = Field(default=None, description="The number of times the file has been downloaded.")
    __properties: ClassVar[List[str]] = ["account_id", "etag", "id", "max_downloads_allowed", "media_size", "metadata_primary", "metadata_secondary", "mime_type", "original_file_name", "public", "store_id", "time_created", "time_last_updated", "times_downloaded"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Media from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Media from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_id": obj.get("account_id"),
            "etag": obj.get("etag"),
            "id": obj.get("id"),
            "max_downloads_allowed": obj.get("max_downloads_allowed"),
            "media_size": obj.get("media_size"),
            "metadata_primary": obj.get("metadata_primary"),
            "metadata_secondary": obj.get("metadata_secondary"),
            "mime_type": obj.get("mime_type"),
            "original_file_name": obj.get("original_file_name"),
            "public": obj.get("public"),
            "store_id": obj.get("store_id"),
            "time_created": obj.get("time_created"),
            "time_last_updated": obj.get("time_last_updated"),
            "times_downloaded": obj.get("times_downloaded")
        })
        return _obj


