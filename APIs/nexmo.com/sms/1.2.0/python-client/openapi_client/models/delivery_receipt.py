# coding: utf-8

"""
    SMS API

    With the SMS API you can send SMS from your account and lookup messages both messages that you've sent as well as messages sent to your virtual numbers. Numbers are specified in E.164 format. More SMS API documentation is at <https://developer.nexmo.com/messaging/sms/overview>

    The version of the OpenAPI document: 1.2.0
    Contact: devrel@vonage.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class DeliveryReceipt(BaseModel):
    """
    DeliveryReceipt
    """ # noqa: E501
    api_key: Optional[StrictStr] = Field(default=None, description="The API key that sent the SMS. This is useful when multiple accounts are sending webhooks to the same endpoint.", alias="api-key")
    client_ref: Optional[StrictStr] = Field(default=None, description="If the `client-ref` is set when the SMS is sent, it will be included in the delivery receipt", alias="client-ref")
    err_code: Optional[StrictStr] = Field(default=None, description="The status of the request. Will be a non `0` value if there has been an error, or if the status is unknown. See the [Delivery Receipt documentation](/messaging/sms/guides/delivery-receipts#dlr-error-codes) for more details", alias="err-code")
    message_timestamp: Optional[StrictStr] = Field(default=None, description="The time when Vonage started to push this Delivery Receipt to your webhook endpoint.", alias="message-timestamp")
    message_id: Optional[StrictStr] = Field(default=None, description="The Vonage ID for this message.", alias="messageId")
    msisdn: Optional[StrictStr] = Field(default=None, description="The number the message was sent to. Numbers are specified in E.164 format.")
    network_code: Optional[StrictStr] = Field(default=None, description="The Mobile Country Code Mobile Network Code (MCCMNC) of the carrier this phone number is registered with.", alias="network-code")
    nonce: Optional[StrictStr] = Field(default=None, description="A random string to be used when calculating the signature. _Only included if you have signatures enabled_")
    price: Optional[StrictStr] = Field(default=None, description="The cost of the message")
    scts: Optional[StrictStr] = Field(default=None, description="When the DLR was received from the carrier in the following format `YYMMDDHHMM`. For example, `2001011400` is at `2020-01-01 14:00`")
    sig: Optional[StrictStr] = Field(default=None, description="The signature to enable verification of the source of this webhook. Please see the [developer documentation for validating signatures](/concepts/guides/signing-messages) for more information, or use one of our published SDKs. _Only included if you have signatures enabled_")
    status: Optional[StrictStr] = Field(default=None, description="A code that explains where the message is in the delivery process.")
    timestamp: Optional[StrictStr] = Field(default=None, description="A timestamp in Unix (seconds since the epoch) format. _Only included if you have signatures enabled_")
    to: Optional[StrictStr] = Field(default=None, description="The SenderID you set in `from` in your request.")
    __properties: ClassVar[List[str]] = ["api-key", "client-ref", "err-code", "message-timestamp", "messageId", "msisdn", "network-code", "nonce", "price", "scts", "sig", "status", "timestamp", "to"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DeliveryReceipt from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DeliveryReceipt from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "api-key": obj.get("api-key"),
            "client-ref": obj.get("client-ref"),
            "err-code": obj.get("err-code"),
            "message-timestamp": obj.get("message-timestamp"),
            "messageId": obj.get("messageId"),
            "msisdn": obj.get("msisdn"),
            "network-code": obj.get("network-code"),
            "nonce": obj.get("nonce"),
            "price": obj.get("price"),
            "scts": obj.get("scts"),
            "sig": obj.get("sig"),
            "status": obj.get("status"),
            "timestamp": obj.get("timestamp"),
            "to": obj.get("to")
        })
        return _obj


