# coding: utf-8

"""
    SMS API

    With the SMS API you can send SMS from your account and lookup messages both messages that you've sent as well as messages sent to your virtual numbers. Numbers are specified in E.164 format. More SMS API documentation is at <https://developer.nexmo.com/messaging/sms/overview>

    The version of the OpenAPI document: 1.2.0
    Contact: devrel@vonage.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBytes, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Tuple, Union
from typing import Optional, Set
from typing_extensions import Self

class InboundMessage(BaseModel):
    """
    InboundMessage
    """ # noqa: E501
    api_key: StrictStr = Field(description="The Vonage API Key of the receiving account.", alias="api-key")
    concat: Optional[StrictStr] = Field(default=None, description="True - if this is a concatenated message. This field does not exist if it is a single message")
    concat_part: Optional[StrictStr] = Field(default=None, description="The number of this part in the message. Counting starts at 1.", alias="concat-part")
    concat_ref: Optional[StrictStr] = Field(default=None, description="The transaction reference. All parts of this message share this value.", alias="concat-ref")
    concat_total: Optional[StrictStr] = Field(default=None, description="The number of parts in this concatenated message.", alias="concat-total")
    data: Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]] = Field(default=None, description="The content of this message, if type is binary.")
    keyword: StrictStr = Field(description="The first word in the message body. Converted to upper case.")
    message_timestamp: StrictStr = Field(description="The time when Vonage started to push this Delivery Receipt to your webhook endpoint.", alias="message-timestamp")
    message_id: StrictStr = Field(description="The ID of the message", alias="messageId")
    msisdn: StrictStr = Field(description="The phone number that this inbound message was sent from. Numbers are specified in E.164 format.")
    nonce: Optional[StrictStr] = Field(default=None, description="A random string that forms part of the signed set of parameters, it adds an extra element of unpredictability into the signature for the request. You use the nonce and timestamp parameters with your shared secret to calculate and validate the signature for inbound messages.")
    text: StrictStr = Field(description="The message body for this inbound message.")
    timestamp: Optional[StrictStr] = Field(default=None, description="A unix timestamp representation of message-timestamp.")
    to: StrictStr = Field(description="The phone number the message was sent to. **This is your virtual number**. Numbers are specified in E.164 format.")
    type: StrictStr = Field(description="Possible values are:    - `text` - standard text.   - `unicode` - URLencoded   unicode  . This is valid for standard GSM, Arabic, Chinese, double-encoded characters and so on.   - `binary` - a binary message. ")
    udh: Optional[StrictStr] = Field(default=None, description="The hex encoded User Data Header, if type is binary")
    __properties: ClassVar[List[str]] = ["api-key", "concat", "concat-part", "concat-ref", "concat-total", "data", "keyword", "message-timestamp", "messageId", "msisdn", "nonce", "text", "timestamp", "to", "type", "udh"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of InboundMessage from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of InboundMessage from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "api-key": obj.get("api-key"),
            "concat": obj.get("concat"),
            "concat-part": obj.get("concat-part"),
            "concat-ref": obj.get("concat-ref"),
            "concat-total": obj.get("concat-total"),
            "data": obj.get("data"),
            "keyword": obj.get("keyword"),
            "message-timestamp": obj.get("message-timestamp"),
            "messageId": obj.get("messageId"),
            "msisdn": obj.get("msisdn"),
            "nonce": obj.get("nonce"),
            "text": obj.get("text"),
            "timestamp": obj.get("timestamp"),
            "to": obj.get("to"),
            "type": obj.get("type"),
            "udh": obj.get("udh")
        })
        return _obj


