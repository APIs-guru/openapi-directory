# coding: utf-8

"""
    Nexmo Application API

    <div class=\"Vlt-callout Vlt-callout--critical\"> <i></i> <div class=\"Vlt-callout__content\">   <h4>Applications V1 is deprecated</h4>   This version of the API has been deprecated. Please use <a href=\"/api/application.v2\">version 2</a> going forwards </div> </div> A Nexmo application contains the security and configuration information you need to connect to Nexmo endpoints and easily use our products.

    The version of the OpenAPI document: 1.0.2
    Contact: devrel@nexmo.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class CreateApplicationRequest(BaseModel):
    """
    CreateApplicationRequest
    """ # noqa: E501
    answer_method: Optional[StrictStr] = Field(default=None, description="The HTTP method used to make the request to `answer_url`. The default value is `GET`.")
    answer_url: Optional[StrictStr] = Field(default=None, description="The URL where your webhook delivers the Nexmo Call Control Object that governs this call. As soon as your user answers a call Nexmo makes a request to `answer_url`. Required for inbound calls only.")
    api_key: StrictStr = Field(description="You can find your API key in your [account overview](https://dashboard.nexmo.com/account-overview)")
    api_secret: StrictStr = Field(description="You can find your API secret in your [account overview](https://dashboard.nexmo.com/account-overview)")
    event_method: Optional[StrictStr] = Field(default=None, description="The HTTP method used to send event information to `event_url`. The default value is `POST`. For `voice` type applications only.")
    event_url: Optional[StrictStr] = Field(default=None, description="Nexmo sends event information asynchronously to this URL when status changes for `voice` applications. Always required for `voice` applications.")
    inbound_method: Optional[StrictStr] = Field(default=None, description="The HTTP method used to send event information to `inbound_url`. The default value is `POST`. For `messages` type applications only.")
    inbound_url: Optional[StrictStr] = Field(default=None, description="Nexmo sends a request to this URL when an inbound message is received. Required for `messages` type applications only.")
    name: StrictStr = Field(description="The name of your application.")
    status_method: Optional[StrictStr] = Field(default=None, description="The HTTP method used to send event information to `status_url`. The default value is `POST`. For `messages` type applications only.")
    status_url: Optional[StrictStr] = Field(default=None, description="Nexmo sends event information asynchronously to this URL when status changes. Required for `messages` type applications only.")
    type: StrictStr = Field(description="The Nexmo product or products that you access with this application. Currently `voice` and `messages` application types are supported.")
    __properties: ClassVar[List[str]] = ["answer_method", "answer_url", "api_key", "api_secret", "event_method", "event_url", "inbound_method", "inbound_url", "name", "status_method", "status_url", "type"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['voice', 'messages']):
            raise ValueError("must be one of enum values ('voice', 'messages')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateApplicationRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateApplicationRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "answer_method": obj.get("answer_method"),
            "answer_url": obj.get("answer_url"),
            "api_key": obj.get("api_key"),
            "api_secret": obj.get("api_secret"),
            "event_method": obj.get("event_method"),
            "event_url": obj.get("event_url"),
            "inbound_method": obj.get("inbound_method"),
            "inbound_url": obj.get("inbound_url"),
            "name": obj.get("name"),
            "status_method": obj.get("status_method"),
            "status_url": obj.get("status_url"),
            "type": obj.get("type")
        })
        return _obj


