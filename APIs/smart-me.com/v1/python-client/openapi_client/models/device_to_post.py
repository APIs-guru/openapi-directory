# coding: utf-8

"""
    smart-me

    With the smart-me REST API you get Access to all your devices in the smart-me Cloud and you can add your own devices. So its an easy way to add the smart-me Cloud support to your Hardware or Software Product.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class DeviceToPost(BaseModel):
    """
    Container Class for the Web API
    """ # noqa: E501
    active_power: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Active Power or current flow rate. In kW or m3/h", alias="ActivePower")
    counter_reading: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading (Total Energy used) in kWh or m3.", alias="CounterReading")
    counter_reading_export: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading only export", alias="CounterReadingExport")
    counter_reading_export_t1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading only export (Tariff 1)", alias="CounterReadingExportT1")
    counter_reading_export_t2: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading only export (Tariff 2)", alias="CounterReadingExportT2")
    counter_reading_t1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading Tariff 1 in kWh or m3.", alias="CounterReadingT1")
    counter_reading_t2: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading Tariff 2 in kWh or m3.", alias="CounterReadingT2")
    current: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Current (in A)", alias="Current")
    current_l1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Current Phase L1 (in A)", alias="CurrentL1")
    current_l2: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Current Phase L2 (in A)", alias="CurrentL2")
    current_l3: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Current Phase L3 (in A)", alias="CurrentL3")
    device_energy_type: Optional[StrictStr] = Field(default=None, description="The Energy Type of this device", alias="DeviceEnergyType")
    digital_input1: Optional[StrictBool] = Field(default=None, description="The digital input number 1", alias="DigitalInput1")
    id: Optional[StrictStr] = Field(default=None, description="The ID of the device", alias="Id")
    meter_sub_type: Optional[StrictStr] = Field(default=None, description="The Sub Type of this Meter.", alias="MeterSubType")
    name: Optional[StrictStr] = Field(default=None, description="The Name of the Device", alias="Name")
    power_factor: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Power Factor (cos phi). Range: 0 - 1", alias="PowerFactor")
    power_factor_l1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Power Factor (cos phi) Phase L1. Range: 0 - 1", alias="PowerFactorL1")
    power_factor_l2: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Power Factor (cos phi) Phase L2. Range: 0 - 1", alias="PowerFactorL2")
    power_factor_l3: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Power Factor (cos phi) Phase L3. Range: 0 - 1", alias="PowerFactorL3")
    serial: Optional[StrictInt] = Field(default=None, description="The Serial number", alias="Serial")
    temperature: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Temperature (in degree celsius)", alias="Temperature")
    value_date: Optional[datetime] = Field(default=None, description="The Date of the Value (in UTC). If this is null the Server Time is used.", alias="ValueDate")
    voltage: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Voltage (in V)", alias="Voltage")
    voltage_l1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Voltage Phase L1 (in V)", alias="VoltageL1")
    voltage_l2: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Voltage Phase L2 (in V)", alias="VoltageL2")
    voltage_l3: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Voltage Phase L3 (in V)", alias="VoltageL3")
    __properties: ClassVar[List[str]] = ["ActivePower", "CounterReading", "CounterReadingExport", "CounterReadingExportT1", "CounterReadingExportT2", "CounterReadingT1", "CounterReadingT2", "Current", "CurrentL1", "CurrentL2", "CurrentL3", "DeviceEnergyType", "DigitalInput1", "Id", "MeterSubType", "Name", "PowerFactor", "PowerFactorL1", "PowerFactorL2", "PowerFactorL3", "Serial", "Temperature", "ValueDate", "Voltage", "VoltageL1", "VoltageL2", "VoltageL3"]

    @field_validator('device_energy_type')
    def device_energy_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MeterTypeUnknown', 'MeterTypeElectricity', 'MeterTypeWater', 'MeterTypeGas', 'MeterTypeHeat', 'MeterTypeHCA', 'MeterTypeAllMeters', 'MeterTypeTemperature', 'MeterTypeMBusGateway', 'MeterTypeRS485Gateway', 'MeterTypeCustomDevice', 'MeterTypeCompressedAir', 'MeterTypeSolarLog', 'MeterTypeVirtualMeter', 'MeterTypeWMBusGateway']):
            raise ValueError("must be one of enum values ('MeterTypeUnknown', 'MeterTypeElectricity', 'MeterTypeWater', 'MeterTypeGas', 'MeterTypeHeat', 'MeterTypeHCA', 'MeterTypeAllMeters', 'MeterTypeTemperature', 'MeterTypeMBusGateway', 'MeterTypeRS485Gateway', 'MeterTypeCustomDevice', 'MeterTypeCompressedAir', 'MeterTypeSolarLog', 'MeterTypeVirtualMeter', 'MeterTypeWMBusGateway')")
        return value

    @field_validator('meter_sub_type')
    def meter_sub_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MeterSubTypeUnknown', 'MeterSubTypeCold', 'MeterSubTypeHeat', 'MeterSubTypeChargingStation', 'MeterSubTypeElectricity', 'MeterSubTypeWater', 'MeterSubTypeGas', 'MeterSubTypeElectricityHeat', 'MeterSubTypeTemperature', 'MeterSubTypeVirtualBattery']):
            raise ValueError("must be one of enum values ('MeterSubTypeUnknown', 'MeterSubTypeCold', 'MeterSubTypeHeat', 'MeterSubTypeChargingStation', 'MeterSubTypeElectricity', 'MeterSubTypeWater', 'MeterSubTypeGas', 'MeterSubTypeElectricityHeat', 'MeterSubTypeTemperature', 'MeterSubTypeVirtualBattery')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DeviceToPost from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DeviceToPost from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ActivePower": obj.get("ActivePower"),
            "CounterReading": obj.get("CounterReading"),
            "CounterReadingExport": obj.get("CounterReadingExport"),
            "CounterReadingExportT1": obj.get("CounterReadingExportT1"),
            "CounterReadingExportT2": obj.get("CounterReadingExportT2"),
            "CounterReadingT1": obj.get("CounterReadingT1"),
            "CounterReadingT2": obj.get("CounterReadingT2"),
            "Current": obj.get("Current"),
            "CurrentL1": obj.get("CurrentL1"),
            "CurrentL2": obj.get("CurrentL2"),
            "CurrentL3": obj.get("CurrentL3"),
            "DeviceEnergyType": obj.get("DeviceEnergyType"),
            "DigitalInput1": obj.get("DigitalInput1"),
            "Id": obj.get("Id"),
            "MeterSubType": obj.get("MeterSubType"),
            "Name": obj.get("Name"),
            "PowerFactor": obj.get("PowerFactor"),
            "PowerFactorL1": obj.get("PowerFactorL1"),
            "PowerFactorL2": obj.get("PowerFactorL2"),
            "PowerFactorL3": obj.get("PowerFactorL3"),
            "Serial": obj.get("Serial"),
            "Temperature": obj.get("Temperature"),
            "ValueDate": obj.get("ValueDate"),
            "Voltage": obj.get("Voltage"),
            "VoltageL1": obj.get("VoltageL1"),
            "VoltageL2": obj.get("VoltageL2"),
            "VoltageL3": obj.get("VoltageL3")
        })
        return _obj


