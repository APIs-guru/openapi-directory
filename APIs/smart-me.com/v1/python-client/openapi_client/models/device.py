# coding: utf-8

"""
    smart-me

    With the smart-me REST API you get Access to all your devices in the smart-me Cloud and you can add your own devices. So its an easy way to add the smart-me Cloud support to your Hardware or Software Product.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class Device(BaseModel):
    """
    Container Class for the Web API
    """ # noqa: E501
    active_power: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Actvie Power or current flow rate", alias="ActivePower")
    active_power_l1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Actvie Power Phase L1", alias="ActivePowerL1")
    active_power_l2: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Actvie Power Phase L2", alias="ActivePowerL2")
    active_power_l3: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Actvie Power Phase L3", alias="ActivePowerL3")
    active_power_unit: Optional[StrictStr] = Field(default=None, description="The Unit of the Active Power Value", alias="ActivePowerUnit")
    active_tariff: Optional[StrictInt] = Field(default=None, description="The Number of the Active Tariff", alias="ActiveTariff")
    additional_meter_serial_number: Optional[StrictStr] = Field(default=None, description="An additional Meter serial number. e.g. the number of a meter a smart-me device is connected to.", alias="AdditionalMeterSerialNumber")
    analog_output1: Optional[StrictInt] = Field(default=None, description="The analog output number 1 (PWM signal) (0 - 32183)", alias="AnalogOutput1")
    analog_output2: Optional[StrictInt] = Field(default=None, description="The analog output number 2 (PWM signal) (0 - 32183)", alias="AnalogOutput2")
    charging_station_state: Optional[StrictStr] = Field(default=None, description="The state of a pico charging station. (Only available for pico charging stations)", alias="ChargingStationState")
    counter_reading: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading (Total Energy used)", alias="CounterReading")
    counter_reading_export: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading only export", alias="CounterReadingExport")
    counter_reading_import: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading only import", alias="CounterReadingImport")
    counter_reading_t1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading Tariff 1", alias="CounterReadingT1")
    counter_reading_t2: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading Tariff 2", alias="CounterReadingT2")
    counter_reading_t3: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading Tariff 3", alias="CounterReadingT3")
    counter_reading_t4: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Meter Counter Reading Tariff 4", alias="CounterReadingT4")
    counter_reading_unit: Optional[StrictStr] = Field(default=None, description="The Unit of the Counter Reading", alias="CounterReadingUnit")
    current: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Current (in A)", alias="Current")
    current_l1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Current Phase L1 (in A)", alias="CurrentL1")
    current_l2: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Current Phase L2 (in A)", alias="CurrentL2")
    current_l3: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Current Phase L3 (in A)", alias="CurrentL3")
    device_energy_type: Optional[StrictStr] = Field(default=None, description="The Energy Type of this device", alias="DeviceEnergyType")
    digital_input1: Optional[StrictBool] = Field(default=None, description="The digital input number 1", alias="DigitalInput1")
    digital_input2: Optional[StrictBool] = Field(default=None, description="The digital input number 2", alias="DigitalInput2")
    digital_output1: Optional[StrictBool] = Field(default=None, description="The digital output number 1", alias="DigitalOutput1")
    digital_output2: Optional[StrictBool] = Field(default=None, description="The digital output number 2", alias="DigitalOutput2")
    family_type: Optional[StrictStr] = Field(default=None, description="The Family Type of the device.", alias="FamilyType")
    flow_rate: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The current flow rate (e.g. m3/h)", alias="FlowRate")
    id: Optional[StrictStr] = Field(default=None, description="The ID of the device", alias="Id")
    meter_sub_type: Optional[StrictStr] = Field(default=None, description="The sub meter type (e.g. warmwater or coldwater)", alias="MeterSubType")
    name: Optional[StrictStr] = Field(default=None, description="The Name of the Device", alias="Name")
    power_factor: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Power Factor (cos phi). Range: 0 - 1", alias="PowerFactor")
    power_factor_l1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Power Factor (cos phi) Phase L1. Range: 0 - 1", alias="PowerFactorL1")
    power_factor_l2: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Power Factor (cos phi) Phase L2. Range: 0 - 1", alias="PowerFactorL2")
    power_factor_l3: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Power Factor (cos phi) Phase L3. Range: 0 - 1", alias="PowerFactorL3")
    serial: Optional[StrictInt] = Field(default=None, description="The Serial number", alias="Serial")
    switch_on: Optional[StrictBool] = Field(default=None, description="Flag if the Switch is on on this device.", alias="SwitchOn")
    switch_phase_l1_on: Optional[StrictBool] = Field(default=None, description="Flag if the Phase L1 is on on this device.", alias="SwitchPhaseL1On")
    switch_phase_l2_on: Optional[StrictBool] = Field(default=None, description="Flag if the Phase L2 is on on this device.", alias="SwitchPhaseL2On")
    switch_phase_l3_on: Optional[StrictBool] = Field(default=None, description="Flag if the Phase L3 is on on this device.", alias="SwitchPhaseL3On")
    temperature: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Temperature (in degree celsius)", alias="Temperature")
    value_date: Optional[datetime] = Field(default=None, description="Time of last successful connection the the smart-me Cloud.", alias="ValueDate")
    voltage: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Voltage (in V)", alias="Voltage")
    voltage_l1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Voltage Phase L1 (in V)", alias="VoltageL1")
    voltage_l2: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Voltage Phase L2 (in V)", alias="VoltageL2")
    voltage_l3: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The Voltage Phase L3 (in V)", alias="VoltageL3")
    __properties: ClassVar[List[str]] = ["ActivePower", "ActivePowerL1", "ActivePowerL2", "ActivePowerL3", "ActivePowerUnit", "ActiveTariff", "AdditionalMeterSerialNumber", "AnalogOutput1", "AnalogOutput2", "ChargingStationState", "CounterReading", "CounterReadingExport", "CounterReadingImport", "CounterReadingT1", "CounterReadingT2", "CounterReadingT3", "CounterReadingT4", "CounterReadingUnit", "Current", "CurrentL1", "CurrentL2", "CurrentL3", "DeviceEnergyType", "DigitalInput1", "DigitalInput2", "DigitalOutput1", "DigitalOutput2", "FamilyType", "FlowRate", "Id", "MeterSubType", "Name", "PowerFactor", "PowerFactorL1", "PowerFactorL2", "PowerFactorL3", "Serial", "SwitchOn", "SwitchPhaseL1On", "SwitchPhaseL2On", "SwitchPhaseL3On", "Temperature", "ValueDate", "Voltage", "VoltageL1", "VoltageL2", "VoltageL3"]

    @field_validator('charging_station_state')
    def charging_station_state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Booting', 'ReadyNoCarConnected', 'ReadyCarConnected', 'StartedWaitForCar', 'Charging', 'Installation', 'Authorize', 'Offline']):
            raise ValueError("must be one of enum values ('Booting', 'ReadyNoCarConnected', 'ReadyCarConnected', 'StartedWaitForCar', 'Charging', 'Installation', 'Authorize', 'Offline')")
        return value

    @field_validator('device_energy_type')
    def device_energy_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MeterTypeUnknown', 'MeterTypeElectricity', 'MeterTypeWater', 'MeterTypeGas', 'MeterTypeHeat', 'MeterTypeHCA', 'MeterTypeAllMeters', 'MeterTypeTemperature', 'MeterTypeMBusGateway', 'MeterTypeRS485Gateway', 'MeterTypeCustomDevice', 'MeterTypeCompressedAir', 'MeterTypeSolarLog', 'MeterTypeVirtualMeter', 'MeterTypeWMBusGateway']):
            raise ValueError("must be one of enum values ('MeterTypeUnknown', 'MeterTypeElectricity', 'MeterTypeWater', 'MeterTypeGas', 'MeterTypeHeat', 'MeterTypeHCA', 'MeterTypeAllMeters', 'MeterTypeTemperature', 'MeterTypeMBusGateway', 'MeterTypeRS485Gateway', 'MeterTypeCustomDevice', 'MeterTypeCompressedAir', 'MeterTypeSolarLog', 'MeterTypeVirtualMeter', 'MeterTypeWMBusGateway')")
        return value

    @field_validator('family_type')
    def family_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MeterFamilyTypeUnknown', 'MeterFamilyTypeSmartMeConnectV1', 'MeterFamiliyTypeSmartMeMeter', 'MeterFamiliyTypeSmartMeMeterWithSwitch', 'MeterFamilyTypeMBusGatewayV1', 'MeterFamilyTypeRS485GatewayV1', 'MeterFamilyTypeKamstrupModule', 'MeterFamilyTypeSmartMe3PhaseMeter80A', 'MeterFamilyTypeSmartMe3PhaseMeter32A', 'MeterFamilyTypeSmartMe3PhaseTelstarTransformer', 'MeterFamilyTypeLandisGyrModule', 'MeterFamilyTypeFnnOpticalModule', 'MeterFamilyTypeSmartMe3PhaseTelstar80AWiFi', 'MeterFamilyTypeSmartMe3PhaseTelstar80AMobile', 'MeterFamilyTypeSmartMe1PhaseMeter80AV2WiFi', 'MeterFamilyTypeSmartMe1PhaseMeter32AV2WiFi', 'MeterFamilyTypeSmartMe1PhaseMeter80AGprs', 'MeterFamilyTypeSmartMe1PhaseMeter32AGprs', 'MeterFamilyTypeWMBusGatewayV1', 'MeterFamilyTypeSmartMe3PhaseTelstarTransformerMobile', 'MeterFamilyTypeMithralHallV1', 'MeterFamilyTypeRestApiMeter', 'MeterFamilyTypeVirtualBillingMeter']):
            raise ValueError("must be one of enum values ('MeterFamilyTypeUnknown', 'MeterFamilyTypeSmartMeConnectV1', 'MeterFamiliyTypeSmartMeMeter', 'MeterFamiliyTypeSmartMeMeterWithSwitch', 'MeterFamilyTypeMBusGatewayV1', 'MeterFamilyTypeRS485GatewayV1', 'MeterFamilyTypeKamstrupModule', 'MeterFamilyTypeSmartMe3PhaseMeter80A', 'MeterFamilyTypeSmartMe3PhaseMeter32A', 'MeterFamilyTypeSmartMe3PhaseTelstarTransformer', 'MeterFamilyTypeLandisGyrModule', 'MeterFamilyTypeFnnOpticalModule', 'MeterFamilyTypeSmartMe3PhaseTelstar80AWiFi', 'MeterFamilyTypeSmartMe3PhaseTelstar80AMobile', 'MeterFamilyTypeSmartMe1PhaseMeter80AV2WiFi', 'MeterFamilyTypeSmartMe1PhaseMeter32AV2WiFi', 'MeterFamilyTypeSmartMe1PhaseMeter80AGprs', 'MeterFamilyTypeSmartMe1PhaseMeter32AGprs', 'MeterFamilyTypeWMBusGatewayV1', 'MeterFamilyTypeSmartMe3PhaseTelstarTransformerMobile', 'MeterFamilyTypeMithralHallV1', 'MeterFamilyTypeRestApiMeter', 'MeterFamilyTypeVirtualBillingMeter')")
        return value

    @field_validator('meter_sub_type')
    def meter_sub_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MeterSubTypeUnknown', 'MeterSubTypeCold', 'MeterSubTypeHeat', 'MeterSubTypeChargingStation', 'MeterSubTypeElectricity', 'MeterSubTypeWater', 'MeterSubTypeGas', 'MeterSubTypeElectricityHeat', 'MeterSubTypeTemperature', 'MeterSubTypeVirtualBattery']):
            raise ValueError("must be one of enum values ('MeterSubTypeUnknown', 'MeterSubTypeCold', 'MeterSubTypeHeat', 'MeterSubTypeChargingStation', 'MeterSubTypeElectricity', 'MeterSubTypeWater', 'MeterSubTypeGas', 'MeterSubTypeElectricityHeat', 'MeterSubTypeTemperature', 'MeterSubTypeVirtualBattery')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Device from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Device from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ActivePower": obj.get("ActivePower"),
            "ActivePowerL1": obj.get("ActivePowerL1"),
            "ActivePowerL2": obj.get("ActivePowerL2"),
            "ActivePowerL3": obj.get("ActivePowerL3"),
            "ActivePowerUnit": obj.get("ActivePowerUnit"),
            "ActiveTariff": obj.get("ActiveTariff"),
            "AdditionalMeterSerialNumber": obj.get("AdditionalMeterSerialNumber"),
            "AnalogOutput1": obj.get("AnalogOutput1"),
            "AnalogOutput2": obj.get("AnalogOutput2"),
            "ChargingStationState": obj.get("ChargingStationState"),
            "CounterReading": obj.get("CounterReading"),
            "CounterReadingExport": obj.get("CounterReadingExport"),
            "CounterReadingImport": obj.get("CounterReadingImport"),
            "CounterReadingT1": obj.get("CounterReadingT1"),
            "CounterReadingT2": obj.get("CounterReadingT2"),
            "CounterReadingT3": obj.get("CounterReadingT3"),
            "CounterReadingT4": obj.get("CounterReadingT4"),
            "CounterReadingUnit": obj.get("CounterReadingUnit"),
            "Current": obj.get("Current"),
            "CurrentL1": obj.get("CurrentL1"),
            "CurrentL2": obj.get("CurrentL2"),
            "CurrentL3": obj.get("CurrentL3"),
            "DeviceEnergyType": obj.get("DeviceEnergyType"),
            "DigitalInput1": obj.get("DigitalInput1"),
            "DigitalInput2": obj.get("DigitalInput2"),
            "DigitalOutput1": obj.get("DigitalOutput1"),
            "DigitalOutput2": obj.get("DigitalOutput2"),
            "FamilyType": obj.get("FamilyType"),
            "FlowRate": obj.get("FlowRate"),
            "Id": obj.get("Id"),
            "MeterSubType": obj.get("MeterSubType"),
            "Name": obj.get("Name"),
            "PowerFactor": obj.get("PowerFactor"),
            "PowerFactorL1": obj.get("PowerFactorL1"),
            "PowerFactorL2": obj.get("PowerFactorL2"),
            "PowerFactorL3": obj.get("PowerFactorL3"),
            "Serial": obj.get("Serial"),
            "SwitchOn": obj.get("SwitchOn"),
            "SwitchPhaseL1On": obj.get("SwitchPhaseL1On"),
            "SwitchPhaseL2On": obj.get("SwitchPhaseL2On"),
            "SwitchPhaseL3On": obj.get("SwitchPhaseL3On"),
            "Temperature": obj.get("Temperature"),
            "ValueDate": obj.get("ValueDate"),
            "Voltage": obj.get("Voltage"),
            "VoltageL1": obj.get("VoltageL1"),
            "VoltageL2": obj.get("VoltageL2"),
            "VoltageL3": obj.get("VoltageL3")
        })
        return _obj


