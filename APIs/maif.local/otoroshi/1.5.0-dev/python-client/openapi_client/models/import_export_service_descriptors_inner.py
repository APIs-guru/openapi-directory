# coding: utf-8

"""
    Otoroshi Admin API

    Admin API of the Otoroshi reverse proxy

    The version of the OpenAPI document: 1.5.0-dev
    Contact: oss@maif.fr
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.canary import Canary
from openapi_client.models.chaos_config import ChaosConfig
from openapi_client.models.client_config import ClientConfig
from openapi_client.models.cors_settings import CorsSettings
from openapi_client.models.exposed_api import ExposedApi
from openapi_client.models.global_jwt_verifier_algo_settings import GlobalJwtVerifierAlgoSettings
from openapi_client.models.gzip import Gzip
from openapi_client.models.health_check import HealthCheck
from openapi_client.models.import_export_service_descriptors_inner_jwt_verifier import ImportExportServiceDescriptorsInnerJwtVerifier
from openapi_client.models.ip_filtering import IpFiltering
from openapi_client.models.redirection_settings import RedirectionSettings
from openapi_client.models.statsd_config import StatsdConfig
from openapi_client.models.target import Target
from typing import Optional, Set
from typing_extensions import Self

class ImportExportServiceDescriptorsInner(BaseModel):
    """
    An otoroshi service descriptor. Represent a forward HTTP call on a domain to another location with some optional api management mecanism
    """ # noqa: E501
    canary: Optional[Canary] = Field(default=None, alias="Canary")
    additional_headers: Optional[Dict[str, StrictStr]] = Field(default=None, description="Specify headers that will be added to each client request. Useful to add authentication", alias="additionalHeaders")
    api: Optional[ExposedApi] = None
    auth_config_ref: Optional[StrictStr] = Field(default=None, description="A reference to a global auth module config", alias="authConfigRef")
    build_mode: StrictBool = Field(description="Display a construction page when a user try to use the service", alias="buildMode")
    chaos_config: Optional[ChaosConfig] = Field(default=None, alias="chaosConfig")
    client_config: Optional[ClientConfig] = Field(default=None, alias="clientConfig")
    client_validator_ref: Optional[StrictStr] = Field(default=None, description="A reference to validation authority", alias="clientValidatorRef")
    cors: Optional[CorsSettings] = None
    domain: StrictStr = Field(description="The domain on which the service is available.")
    enabled: StrictBool = Field(description="Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist")
    enforce_secure_communication: StrictBool = Field(description="When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside", alias="enforceSecureCommunication")
    env: StrictStr = Field(description="The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is 'foo' and line is 'preprod', then the exposed service will be available at 'foo.preprod.mydomain'")
    force_https: StrictBool = Field(description="Will force redirection to https:// if not present", alias="forceHttps")
    groups: List[StrictStr] = Field(description="Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group")
    gzip: Optional[Gzip] = None
    headers_verification: Optional[Dict[str, StrictStr]] = Field(default=None, description="Specify headers that will be verified after routing.", alias="headersVerification")
    health_check: Optional[HealthCheck] = Field(default=None, alias="healthCheck")
    id: StrictStr = Field(description="A unique random string to identify your service")
    ip_filtering: Optional[IpFiltering] = Field(default=None, alias="ipFiltering")
    jwt_verifier: Optional[ImportExportServiceDescriptorsInnerJwtVerifier] = Field(default=None, alias="jwtVerifier")
    local_host: Optional[StrictStr] = Field(default=None, description="The host used localy, mainly localhost:xxxx", alias="localHost")
    local_scheme: Optional[StrictStr] = Field(default=None, description="The scheme used localy, mainly http", alias="localScheme")
    maintenance_mode: StrictBool = Field(description="Display a maintainance page when a user try to use the service", alias="maintenanceMode")
    matching_headers: Optional[Dict[str, StrictStr]] = Field(default=None, description="Specify headers that MUST be present on client request to route it. Useful to implement versioning", alias="matchingHeaders")
    matching_root: Optional[StrictStr] = Field(default=None, description="The root path on which the service is available", alias="matchingRoot")
    metadata: Optional[Dict[str, StrictStr]] = Field(default=None, description="Just a bunch of random properties")
    name: StrictStr = Field(description="The name of your service. Only for debug and human readability purposes")
    override_host: Optional[StrictBool] = Field(default=None, description="Host header will be overriden with Host of the target", alias="overrideHost")
    private_app: StrictBool = Field(description="When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain", alias="privateApp")
    private_patterns: Optional[List[StrictStr]] = Field(default=None, description="If you define a public pattern that is a little bit too much, you can make some of public URL private again", alias="privatePatterns")
    public_patterns: Optional[List[StrictStr]] = Field(default=None, description="By default, every services are private only and you'll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use '/.*'", alias="publicPatterns")
    redirect_to_local: Optional[StrictBool] = Field(default=None, description="If you work locally with Otoroshi, you may want to use that feature to redirect one particuliar service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests", alias="redirectToLocal")
    redirection: Optional[RedirectionSettings] = None
    root: StrictStr = Field(description="Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar")
    sec_com_excluded_patterns: Optional[List[StrictStr]] = Field(default=None, description="URI patterns excluded from secured communications", alias="secComExcludedPatterns")
    sec_com_settings: Optional[GlobalJwtVerifierAlgoSettings] = Field(default=None, alias="secComSettings")
    send_otoroshi_headers_back: Optional[StrictBool] = Field(default=None, description="When enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ...", alias="sendOtoroshiHeadersBack")
    statsd_config: Optional[StatsdConfig] = Field(default=None, alias="statsdConfig")
    subdomain: StrictStr = Field(description="The subdomain on which the service is available")
    targets: List[Target] = Field(description="The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures")
    transformer_ref: Optional[StrictStr] = Field(default=None, description="A reference to a request transformer", alias="transformerRef")
    user_facing: Optional[StrictBool] = Field(default=None, description="The fact that this service will be seen by users and cannot be impacted by the Snow Monkey", alias="userFacing")
    x_forwarded_headers: Optional[StrictBool] = Field(default=None, description="Send X-Forwarded-* headers", alias="xForwardedHeaders")
    __properties: ClassVar[List[str]] = ["Canary", "additionalHeaders", "api", "authConfigRef", "buildMode", "chaosConfig", "clientConfig", "clientValidatorRef", "cors", "domain", "enabled", "enforceSecureCommunication", "env", "forceHttps", "groups", "gzip", "headersVerification", "healthCheck", "id", "ipFiltering", "jwtVerifier", "localHost", "localScheme", "maintenanceMode", "matchingHeaders", "matchingRoot", "metadata", "name", "overrideHost", "privateApp", "privatePatterns", "publicPatterns", "redirectToLocal", "redirection", "root", "secComExcludedPatterns", "secComSettings", "sendOtoroshiHeadersBack", "statsdConfig", "subdomain", "targets", "transformerRef", "userFacing", "xForwardedHeaders"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ImportExportServiceDescriptorsInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of canary
        if self.canary:
            _dict['Canary'] = self.canary.to_dict()
        # override the default output from pydantic by calling `to_dict()` of api
        if self.api:
            _dict['api'] = self.api.to_dict()
        # override the default output from pydantic by calling `to_dict()` of chaos_config
        if self.chaos_config:
            _dict['chaosConfig'] = self.chaos_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of client_config
        if self.client_config:
            _dict['clientConfig'] = self.client_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cors
        if self.cors:
            _dict['cors'] = self.cors.to_dict()
        # override the default output from pydantic by calling `to_dict()` of gzip
        if self.gzip:
            _dict['gzip'] = self.gzip.to_dict()
        # override the default output from pydantic by calling `to_dict()` of health_check
        if self.health_check:
            _dict['healthCheck'] = self.health_check.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ip_filtering
        if self.ip_filtering:
            _dict['ipFiltering'] = self.ip_filtering.to_dict()
        # override the default output from pydantic by calling `to_dict()` of jwt_verifier
        if self.jwt_verifier:
            _dict['jwtVerifier'] = self.jwt_verifier.to_dict()
        # override the default output from pydantic by calling `to_dict()` of redirection
        if self.redirection:
            _dict['redirection'] = self.redirection.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sec_com_settings
        if self.sec_com_settings:
            _dict['secComSettings'] = self.sec_com_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of statsd_config
        if self.statsd_config:
            _dict['statsdConfig'] = self.statsd_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in targets (list)
        _items = []
        if self.targets:
            for _item_targets in self.targets:
                if _item_targets:
                    _items.append(_item_targets.to_dict())
            _dict['targets'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ImportExportServiceDescriptorsInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "Canary": Canary.from_dict(obj["Canary"]) if obj.get("Canary") is not None else None,
            "additionalHeaders": obj.get("additionalHeaders"),
            "api": ExposedApi.from_dict(obj["api"]) if obj.get("api") is not None else None,
            "authConfigRef": obj.get("authConfigRef"),
            "buildMode": obj.get("buildMode"),
            "chaosConfig": ChaosConfig.from_dict(obj["chaosConfig"]) if obj.get("chaosConfig") is not None else None,
            "clientConfig": ClientConfig.from_dict(obj["clientConfig"]) if obj.get("clientConfig") is not None else None,
            "clientValidatorRef": obj.get("clientValidatorRef"),
            "cors": CorsSettings.from_dict(obj["cors"]) if obj.get("cors") is not None else None,
            "domain": obj.get("domain"),
            "enabled": obj.get("enabled"),
            "enforceSecureCommunication": obj.get("enforceSecureCommunication"),
            "env": obj.get("env"),
            "forceHttps": obj.get("forceHttps"),
            "groups": obj.get("groups"),
            "gzip": Gzip.from_dict(obj["gzip"]) if obj.get("gzip") is not None else None,
            "headersVerification": obj.get("headersVerification"),
            "healthCheck": HealthCheck.from_dict(obj["healthCheck"]) if obj.get("healthCheck") is not None else None,
            "id": obj.get("id"),
            "ipFiltering": IpFiltering.from_dict(obj["ipFiltering"]) if obj.get("ipFiltering") is not None else None,
            "jwtVerifier": ImportExportServiceDescriptorsInnerJwtVerifier.from_dict(obj["jwtVerifier"]) if obj.get("jwtVerifier") is not None else None,
            "localHost": obj.get("localHost"),
            "localScheme": obj.get("localScheme"),
            "maintenanceMode": obj.get("maintenanceMode"),
            "matchingHeaders": obj.get("matchingHeaders"),
            "matchingRoot": obj.get("matchingRoot"),
            "metadata": obj.get("metadata"),
            "name": obj.get("name"),
            "overrideHost": obj.get("overrideHost"),
            "privateApp": obj.get("privateApp"),
            "privatePatterns": obj.get("privatePatterns"),
            "publicPatterns": obj.get("publicPatterns"),
            "redirectToLocal": obj.get("redirectToLocal"),
            "redirection": RedirectionSettings.from_dict(obj["redirection"]) if obj.get("redirection") is not None else None,
            "root": obj.get("root"),
            "secComExcludedPatterns": obj.get("secComExcludedPatterns"),
            "secComSettings": GlobalJwtVerifierAlgoSettings.from_dict(obj["secComSettings"]) if obj.get("secComSettings") is not None else None,
            "sendOtoroshiHeadersBack": obj.get("sendOtoroshiHeadersBack"),
            "statsdConfig": StatsdConfig.from_dict(obj["statsdConfig"]) if obj.get("statsdConfig") is not None else None,
            "subdomain": obj.get("subdomain"),
            "targets": [Target.from_dict(_item) for _item in obj["targets"]] if obj.get("targets") is not None else None,
            "transformerRef": obj.get("transformerRef"),
            "userFacing": obj.get("userFacing"),
            "xForwardedHeaders": obj.get("xForwardedHeaders")
        })
        return _obj


