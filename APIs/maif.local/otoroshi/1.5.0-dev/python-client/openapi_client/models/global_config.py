# coding: utf-8

"""
    Otoroshi Admin API

    Admin API of the Otoroshi reverse proxy

    The version of the OpenAPI document: 1.5.0-dev
    Contact: oss@maif.fr
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.auth0_config import Auth0Config
from openapi_client.models.clever_settings import CleverSettings
from openapi_client.models.elastic_config import ElasticConfig
from openapi_client.models.ip_filtering import IpFiltering
from openapi_client.models.mailer_settings import MailerSettings
from openapi_client.models.webhook import Webhook
from typing import Optional, Set
from typing_extensions import Self

class GlobalConfig(BaseModel):
    """
    The global config object of Otoroshi, used to customize settings of the current Otoroshi instance
    """ # noqa: E501
    alerts_emails: List[StrictStr] = Field(description="Email addresses that will receive all Otoroshi alert events", alias="alertsEmails")
    alerts_webhooks: List[Webhook] = Field(description="Webhook that will receive all Otoroshi alert events", alias="alertsWebhooks")
    analytics_webhooks: List[Webhook] = Field(description="Webhook that will receive all internal Otoroshi events", alias="analyticsWebhooks")
    api_read_only: StrictBool = Field(description="If enabled, Admin API won't be able to write/update/delete entities", alias="apiReadOnly")
    auto_link_to_default_group: StrictBool = Field(description="If not defined, every new service descriptor will be added to the default group", alias="autoLinkToDefaultGroup")
    backoffice_auth0_config: Optional[Auth0Config] = Field(default=None, alias="backofficeAuth0Config")
    clever_settings: Optional[CleverSettings] = Field(default=None, alias="cleverSettings")
    elastic_reads_config: Optional[ElasticConfig] = Field(default=None, alias="elasticReadsConfig")
    elastic_writes_configs: Optional[List[ElasticConfig]] = Field(default=None, description="Configs. for Elastic writes", alias="elasticWritesConfigs")
    endless_ip_addresses: List[StrictStr] = Field(description="IP addresses for which any request to Otoroshi will respond with 128 Gb of zeros", alias="endlessIpAddresses")
    ip_filtering: IpFiltering = Field(alias="ipFiltering")
    limit_concurrent_requests: StrictBool = Field(description="If enabled, Otoroshi will reject new request if too much at the same time", alias="limitConcurrentRequests")
    lines: Optional[List[StrictStr]] = Field(default=None, description="Possibles lines for Otoroshi")
    mailer_settings: Optional[MailerSettings] = Field(default=None, alias="mailerSettings")
    max_concurrent_requests: StrictInt = Field(description="The number of authorized request processed at the same time", alias="maxConcurrentRequests")
    max_http10_response_size: Optional[StrictInt] = Field(default=None, description="The max size in bytes of an HTTP 1.0 response", alias="maxHttp10ResponseSize")
    max_logs_size: Optional[StrictInt] = Field(default=None, description="Number of events kept locally", alias="maxLogsSize")
    middle_fingers: Optional[StrictBool] = Field(default=None, description="Use middle finger emoji as a response character for endless HTTP responses", alias="middleFingers")
    per_ip_throttling_quota: StrictInt = Field(description="Authorized number of calls per second globally per IP address, measured on 10 seconds", alias="perIpThrottlingQuota")
    private_apps_auth0_config: Optional[Auth0Config] = Field(default=None, alias="privateAppsAuth0Config")
    stream_entity_only: StrictBool = Field(description="HTTP will be streamed only. Doesn't work with old browsers", alias="streamEntityOnly")
    throttling_quota: StrictInt = Field(description="Authorized number of calls per second globally, measured on 10 seconds", alias="throttlingQuota")
    u2f_login_only: StrictBool = Field(description="If enabled, login to backoffice through Auth0 will be disabled", alias="u2fLoginOnly")
    use_circuit_breakers: StrictBool = Field(description="If enabled, services will be authorized to use circuit breakers", alias="useCircuitBreakers")
    __properties: ClassVar[List[str]] = ["alertsEmails", "alertsWebhooks", "analyticsWebhooks", "apiReadOnly", "autoLinkToDefaultGroup", "backofficeAuth0Config", "cleverSettings", "elasticReadsConfig", "elasticWritesConfigs", "endlessIpAddresses", "ipFiltering", "limitConcurrentRequests", "lines", "mailerSettings", "maxConcurrentRequests", "maxHttp10ResponseSize", "maxLogsSize", "middleFingers", "perIpThrottlingQuota", "privateAppsAuth0Config", "streamEntityOnly", "throttlingQuota", "u2fLoginOnly", "useCircuitBreakers"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GlobalConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in alerts_webhooks (list)
        _items = []
        if self.alerts_webhooks:
            for _item_alerts_webhooks in self.alerts_webhooks:
                if _item_alerts_webhooks:
                    _items.append(_item_alerts_webhooks.to_dict())
            _dict['alertsWebhooks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in analytics_webhooks (list)
        _items = []
        if self.analytics_webhooks:
            for _item_analytics_webhooks in self.analytics_webhooks:
                if _item_analytics_webhooks:
                    _items.append(_item_analytics_webhooks.to_dict())
            _dict['analyticsWebhooks'] = _items
        # override the default output from pydantic by calling `to_dict()` of backoffice_auth0_config
        if self.backoffice_auth0_config:
            _dict['backofficeAuth0Config'] = self.backoffice_auth0_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of clever_settings
        if self.clever_settings:
            _dict['cleverSettings'] = self.clever_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of elastic_reads_config
        if self.elastic_reads_config:
            _dict['elasticReadsConfig'] = self.elastic_reads_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in elastic_writes_configs (list)
        _items = []
        if self.elastic_writes_configs:
            for _item_elastic_writes_configs in self.elastic_writes_configs:
                if _item_elastic_writes_configs:
                    _items.append(_item_elastic_writes_configs.to_dict())
            _dict['elasticWritesConfigs'] = _items
        # override the default output from pydantic by calling `to_dict()` of ip_filtering
        if self.ip_filtering:
            _dict['ipFiltering'] = self.ip_filtering.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mailer_settings
        if self.mailer_settings:
            _dict['mailerSettings'] = self.mailer_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of private_apps_auth0_config
        if self.private_apps_auth0_config:
            _dict['privateAppsAuth0Config'] = self.private_apps_auth0_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GlobalConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "alertsEmails": obj.get("alertsEmails"),
            "alertsWebhooks": [Webhook.from_dict(_item) for _item in obj["alertsWebhooks"]] if obj.get("alertsWebhooks") is not None else None,
            "analyticsWebhooks": [Webhook.from_dict(_item) for _item in obj["analyticsWebhooks"]] if obj.get("analyticsWebhooks") is not None else None,
            "apiReadOnly": obj.get("apiReadOnly"),
            "autoLinkToDefaultGroup": obj.get("autoLinkToDefaultGroup"),
            "backofficeAuth0Config": Auth0Config.from_dict(obj["backofficeAuth0Config"]) if obj.get("backofficeAuth0Config") is not None else None,
            "cleverSettings": CleverSettings.from_dict(obj["cleverSettings"]) if obj.get("cleverSettings") is not None else None,
            "elasticReadsConfig": ElasticConfig.from_dict(obj["elasticReadsConfig"]) if obj.get("elasticReadsConfig") is not None else None,
            "elasticWritesConfigs": [ElasticConfig.from_dict(_item) for _item in obj["elasticWritesConfigs"]] if obj.get("elasticWritesConfigs") is not None else None,
            "endlessIpAddresses": obj.get("endlessIpAddresses"),
            "ipFiltering": IpFiltering.from_dict(obj["ipFiltering"]) if obj.get("ipFiltering") is not None else None,
            "limitConcurrentRequests": obj.get("limitConcurrentRequests"),
            "lines": obj.get("lines"),
            "mailerSettings": MailerSettings.from_dict(obj["mailerSettings"]) if obj.get("mailerSettings") is not None else None,
            "maxConcurrentRequests": obj.get("maxConcurrentRequests"),
            "maxHttp10ResponseSize": obj.get("maxHttp10ResponseSize"),
            "maxLogsSize": obj.get("maxLogsSize"),
            "middleFingers": obj.get("middleFingers"),
            "perIpThrottlingQuota": obj.get("perIpThrottlingQuota"),
            "privateAppsAuth0Config": Auth0Config.from_dict(obj["privateAppsAuth0Config"]) if obj.get("privateAppsAuth0Config") is not None else None,
            "streamEntityOnly": obj.get("streamEntityOnly"),
            "throttlingQuota": obj.get("throttlingQuota"),
            "u2fLoginOnly": obj.get("u2fLoginOnly"),
            "useCircuitBreakers": obj.get("useCircuitBreakers")
        })
        return _obj


