# coding: utf-8

"""
    Meraki Dashboard API

    The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 23 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 

    The version of the OpenAPI document: 0.0.0-streaming
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.update_network_ssid_request_ap_tags_and_vlan_ids_inner import UpdateNetworkSsidRequestApTagsAndVlanIdsInner
from openapi_client.models.update_network_ssid_request_radius_accounting_servers_inner import UpdateNetworkSsidRequestRadiusAccountingServersInner
from openapi_client.models.update_network_ssid_request_radius_servers_inner import UpdateNetworkSsidRequestRadiusServersInner
from typing import Optional, Set
from typing_extensions import Self

class UpdateNetworkSsidRequest(BaseModel):
    """
    UpdateNetworkSsidRequest
    """ # noqa: E501
    ap_tags_and_vlan_ids: Optional[List[UpdateNetworkSsidRequestApTagsAndVlanIdsInner]] = Field(default=None, description="The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'", alias="apTagsAndVlanIds")
    auth_mode: Optional[StrictStr] = Field(default=None, description="The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', 'open-with-nac', '8021x-meraki', '8021x-nac', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')", alias="authMode")
    availability_tags: Optional[List[StrictStr]] = Field(default=None, description="Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.", alias="availabilityTags")
    available_on_all_aps: Optional[StrictBool] = Field(default=None, description="Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.", alias="availableOnAllAps")
    band_selection: Optional[StrictStr] = Field(default=None, description="The client-serving radio frequencies of this SSID in the default indoor RF profile. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')", alias="bandSelection")
    concentrator_network_id: Optional[StrictStr] = Field(default=None, description="The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.", alias="concentratorNetworkId")
    default_vlan_id: Optional[StrictInt] = Field(default=None, description="The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'", alias="defaultVlanId")
    disassociate_clients_on_vpn_failover: Optional[StrictBool] = Field(default=None, description="Disassociate clients when 'VPN' concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is 'VPN'.", alias="disassociateClientsOnVpnFailover")
    enabled: Optional[StrictBool] = Field(default=None, description="Whether or not the SSID is enabled")
    encryption_mode: Optional[StrictStr] = Field(default=None, description="The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'", alias="encryptionMode")
    enterprise_admin_access: Optional[StrictStr] = Field(default=None, description="Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')", alias="enterpriseAdminAccess")
    ip_assignment_mode: Optional[StrictStr] = Field(default=None, description="The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Ethernet over GRE', 'Layer 3 roaming with a concentrator' or 'VPN')", alias="ipAssignmentMode")
    lan_isolation_enabled: Optional[StrictBool] = Field(default=None, description="Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.", alias="lanIsolationEnabled")
    min_bitrate: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The minimum bitrate in Mbps of this SSID in the default indoor RF profile. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')", alias="minBitrate")
    name: Optional[StrictStr] = Field(default=None, description="The name of the SSID")
    per_client_bandwidth_limit_down: Optional[StrictInt] = Field(default=None, description="The download bandwidth limit in Kbps. (0 represents no limit.)", alias="perClientBandwidthLimitDown")
    per_client_bandwidth_limit_up: Optional[StrictInt] = Field(default=None, description="The upload bandwidth limit in Kbps. (0 represents no limit.)", alias="perClientBandwidthLimitUp")
    psk: Optional[StrictStr] = Field(default=None, description="The passkey for the SSID. This param is only valid if the authMode is 'psk'")
    radius_accounting_enabled: Optional[StrictBool] = Field(default=None, description="Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'", alias="radiusAccountingEnabled")
    radius_accounting_servers: Optional[List[UpdateNetworkSsidRequestRadiusAccountingServersInner]] = Field(default=None, description="The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'", alias="radiusAccountingServers")
    radius_attribute_for_group_policies: Optional[StrictStr] = Field(default=None, description="Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message", alias="radiusAttributeForGroupPolicies")
    radius_coa_enabled: Optional[StrictBool] = Field(default=None, description="If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.", alias="radiusCoaEnabled")
    radius_failover_policy: Optional[StrictStr] = Field(default=None, description="This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')", alias="radiusFailoverPolicy")
    radius_load_balancing_policy: Optional[StrictStr] = Field(default=None, description="This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')", alias="radiusLoadBalancingPolicy")
    radius_override: Optional[StrictBool] = Field(default=None, description="If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.", alias="radiusOverride")
    radius_servers: Optional[List[UpdateNetworkSsidRequestRadiusServersInner]] = Field(default=None, description="The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'", alias="radiusServers")
    secondary_concentrator_network_id: Optional[StrictStr] = Field(default=None, description="The secondary concentrator to use when the ipAssignmentMode is 'VPN'. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. ('disabled' represents no secondary concentrator.)", alias="secondaryConcentratorNetworkId")
    splash_page: Optional[StrictStr] = Field(default=None, description="The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.", alias="splashPage")
    use_vlan_tagging: Optional[StrictBool] = Field(default=None, description="Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'", alias="useVlanTagging")
    visible: Optional[StrictBool] = Field(default=None, description="Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true")
    vlan_id: Optional[StrictInt] = Field(default=None, description="The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'", alias="vlanId")
    walled_garden_enabled: Optional[StrictBool] = Field(default=None, description="Allow access to a configurable list of IP ranges, which users may access prior to sign-on.", alias="walledGardenEnabled")
    walled_garden_ranges: Optional[StrictStr] = Field(default=None, description="Specify your walled garden by entering space-separated addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. 192.168.1.1/24 192.168.37.10/32 www.yahoo.com *.google.com). Meraki's splash page is automatically included in your walled garden.", alias="walledGardenRanges")
    wpa_encryption_mode: Optional[StrictStr] = Field(default=None, description="The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode', 'WPA3 only' or 'WPA3 192-bit Security')", alias="wpaEncryptionMode")
    __properties: ClassVar[List[str]] = ["apTagsAndVlanIds", "authMode", "availabilityTags", "availableOnAllAps", "bandSelection", "concentratorNetworkId", "defaultVlanId", "disassociateClientsOnVpnFailover", "enabled", "encryptionMode", "enterpriseAdminAccess", "ipAssignmentMode", "lanIsolationEnabled", "minBitrate", "name", "perClientBandwidthLimitDown", "perClientBandwidthLimitUp", "psk", "radiusAccountingEnabled", "radiusAccountingServers", "radiusAttributeForGroupPolicies", "radiusCoaEnabled", "radiusFailoverPolicy", "radiusLoadBalancingPolicy", "radiusOverride", "radiusServers", "secondaryConcentratorNetworkId", "splashPage", "useVlanTagging", "visible", "vlanId", "walledGardenEnabled", "walledGardenRanges", "wpaEncryptionMode"]

    @field_validator('auth_mode')
    def auth_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['8021x-google', '8021x-localradius', '8021x-meraki', '8021x-nac', '8021x-radius', 'ipsk-with-radius', 'ipsk-without-radius', 'open', 'open-enhanced', 'open-with-nac', 'open-with-radius', 'psk']):
            raise ValueError("must be one of enum values ('8021x-google', '8021x-localradius', '8021x-meraki', '8021x-nac', '8021x-radius', 'ipsk-with-radius', 'ipsk-without-radius', 'open', 'open-enhanced', 'open-with-nac', 'open-with-radius', 'psk')")
        return value

    @field_validator('encryption_mode')
    def encryption_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['wep', 'wpa']):
            raise ValueError("must be one of enum values ('wep', 'wpa')")
        return value

    @field_validator('enterprise_admin_access')
    def enterprise_admin_access_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['access disabled', 'access enabled']):
            raise ValueError("must be one of enum values ('access disabled', 'access enabled')")
        return value

    @field_validator('radius_failover_policy')
    def radius_failover_policy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Allow access', 'Deny access']):
            raise ValueError("must be one of enum values ('Allow access', 'Deny access')")
        return value

    @field_validator('radius_load_balancing_policy')
    def radius_load_balancing_policy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Round robin', 'Strict priority order']):
            raise ValueError("must be one of enum values ('Round robin', 'Strict priority order')")
        return value

    @field_validator('splash_page')
    def splash_page_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Billing', 'Cisco ISE', 'Click-through splash page', 'Facebook Wi-Fi', 'Google Apps domain', 'Google OAuth', 'None', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'SMS authentication', 'Sponsored guest', 'Systems Manager Sentry']):
            raise ValueError("must be one of enum values ('Billing', 'Cisco ISE', 'Click-through splash page', 'Facebook Wi-Fi', 'Google Apps domain', 'Google OAuth', 'None', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'SMS authentication', 'Sponsored guest', 'Systems Manager Sentry')")
        return value

    @field_validator('wpa_encryption_mode')
    def wpa_encryption_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['WPA1 and WPA2', 'WPA1 only', 'WPA2 only', 'WPA3 192-bit Security', 'WPA3 Transition Mode', 'WPA3 only']):
            raise ValueError("must be one of enum values ('WPA1 and WPA2', 'WPA1 only', 'WPA2 only', 'WPA3 192-bit Security', 'WPA3 Transition Mode', 'WPA3 only')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UpdateNetworkSsidRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in ap_tags_and_vlan_ids (list)
        _items = []
        if self.ap_tags_and_vlan_ids:
            for _item_ap_tags_and_vlan_ids in self.ap_tags_and_vlan_ids:
                if _item_ap_tags_and_vlan_ids:
                    _items.append(_item_ap_tags_and_vlan_ids.to_dict())
            _dict['apTagsAndVlanIds'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in radius_accounting_servers (list)
        _items = []
        if self.radius_accounting_servers:
            for _item_radius_accounting_servers in self.radius_accounting_servers:
                if _item_radius_accounting_servers:
                    _items.append(_item_radius_accounting_servers.to_dict())
            _dict['radiusAccountingServers'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in radius_servers (list)
        _items = []
        if self.radius_servers:
            for _item_radius_servers in self.radius_servers:
                if _item_radius_servers:
                    _items.append(_item_radius_servers.to_dict())
            _dict['radiusServers'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UpdateNetworkSsidRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "apTagsAndVlanIds": [UpdateNetworkSsidRequestApTagsAndVlanIdsInner.from_dict(_item) for _item in obj["apTagsAndVlanIds"]] if obj.get("apTagsAndVlanIds") is not None else None,
            "authMode": obj.get("authMode"),
            "availabilityTags": obj.get("availabilityTags"),
            "availableOnAllAps": obj.get("availableOnAllAps"),
            "bandSelection": obj.get("bandSelection"),
            "concentratorNetworkId": obj.get("concentratorNetworkId"),
            "defaultVlanId": obj.get("defaultVlanId"),
            "disassociateClientsOnVpnFailover": obj.get("disassociateClientsOnVpnFailover"),
            "enabled": obj.get("enabled"),
            "encryptionMode": obj.get("encryptionMode"),
            "enterpriseAdminAccess": obj.get("enterpriseAdminAccess"),
            "ipAssignmentMode": obj.get("ipAssignmentMode"),
            "lanIsolationEnabled": obj.get("lanIsolationEnabled"),
            "minBitrate": obj.get("minBitrate"),
            "name": obj.get("name"),
            "perClientBandwidthLimitDown": obj.get("perClientBandwidthLimitDown"),
            "perClientBandwidthLimitUp": obj.get("perClientBandwidthLimitUp"),
            "psk": obj.get("psk"),
            "radiusAccountingEnabled": obj.get("radiusAccountingEnabled"),
            "radiusAccountingServers": [UpdateNetworkSsidRequestRadiusAccountingServersInner.from_dict(_item) for _item in obj["radiusAccountingServers"]] if obj.get("radiusAccountingServers") is not None else None,
            "radiusAttributeForGroupPolicies": obj.get("radiusAttributeForGroupPolicies"),
            "radiusCoaEnabled": obj.get("radiusCoaEnabled"),
            "radiusFailoverPolicy": obj.get("radiusFailoverPolicy"),
            "radiusLoadBalancingPolicy": obj.get("radiusLoadBalancingPolicy"),
            "radiusOverride": obj.get("radiusOverride"),
            "radiusServers": [UpdateNetworkSsidRequestRadiusServersInner.from_dict(_item) for _item in obj["radiusServers"]] if obj.get("radiusServers") is not None else None,
            "secondaryConcentratorNetworkId": obj.get("secondaryConcentratorNetworkId"),
            "splashPage": obj.get("splashPage"),
            "useVlanTagging": obj.get("useVlanTagging"),
            "visible": obj.get("visible"),
            "vlanId": obj.get("vlanId"),
            "walledGardenEnabled": obj.get("walledGardenEnabled"),
            "walledGardenRanges": obj.get("walledGardenRanges"),
            "wpaEncryptionMode": obj.get("wpaEncryptionMode")
        })
        return _obj


