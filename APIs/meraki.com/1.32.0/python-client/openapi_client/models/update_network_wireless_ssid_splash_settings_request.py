# coding: utf-8

"""
    Meraki Dashboard API

    The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 05 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 

    The version of the OpenAPI document: 1.32.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.update_network_wireless_ssid_splash_settings_request_billing import UpdateNetworkWirelessSsidSplashSettingsRequestBilling
from openapi_client.models.update_network_wireless_ssid_splash_settings_request_guest_sponsorship import UpdateNetworkWirelessSsidSplashSettingsRequestGuestSponsorship
from openapi_client.models.update_network_wireless_ssid_splash_settings_request_sentry_enrollment import UpdateNetworkWirelessSsidSplashSettingsRequestSentryEnrollment
from openapi_client.models.update_network_wireless_ssid_splash_settings_request_splash_image import UpdateNetworkWirelessSsidSplashSettingsRequestSplashImage
from openapi_client.models.update_network_wireless_ssid_splash_settings_request_splash_logo import UpdateNetworkWirelessSsidSplashSettingsRequestSplashLogo
from openapi_client.models.update_network_wireless_ssid_splash_settings_request_splash_prepaid_front import UpdateNetworkWirelessSsidSplashSettingsRequestSplashPrepaidFront
from typing import Optional, Set
from typing_extensions import Self

class UpdateNetworkWirelessSsidSplashSettingsRequest(BaseModel):
    """
    UpdateNetworkWirelessSsidSplashSettingsRequest
    """ # noqa: E501
    allow_simultaneous_logins: Optional[StrictBool] = Field(default=None, description="Whether or not to allow simultaneous logins from different devices.", alias="allowSimultaneousLogins")
    billing: Optional[UpdateNetworkWirelessSsidSplashSettingsRequestBilling] = None
    block_all_traffic_before_sign_on: Optional[StrictBool] = Field(default=None, description="How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.", alias="blockAllTrafficBeforeSignOn")
    controller_disconnection_behavior: Optional[StrictStr] = Field(default=None, description="How login attempts should be handled when the controller is unreachable. Can be either 'open', 'restricted', or 'default'.", alias="controllerDisconnectionBehavior")
    guest_sponsorship: Optional[UpdateNetworkWirelessSsidSplashSettingsRequestGuestSponsorship] = Field(default=None, alias="guestSponsorship")
    redirect_url: Optional[StrictStr] = Field(default=None, description="The custom redirect URL where the users will go after the splash page.", alias="redirectUrl")
    sentry_enrollment: Optional[UpdateNetworkWirelessSsidSplashSettingsRequestSentryEnrollment] = Field(default=None, alias="sentryEnrollment")
    splash_image: Optional[UpdateNetworkWirelessSsidSplashSettingsRequestSplashImage] = Field(default=None, alias="splashImage")
    splash_logo: Optional[UpdateNetworkWirelessSsidSplashSettingsRequestSplashLogo] = Field(default=None, alias="splashLogo")
    splash_prepaid_front: Optional[UpdateNetworkWirelessSsidSplashSettingsRequestSplashPrepaidFront] = Field(default=None, alias="splashPrepaidFront")
    splash_timeout: Optional[StrictInt] = Field(default=None, description="Splash timeout in minutes. This will determine how often users will see the splash page.", alias="splashTimeout")
    splash_url: Optional[StrictStr] = Field(default=None, description="[optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl'", alias="splashUrl")
    use_redirect_url: Optional[StrictBool] = Field(default=None, description="The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page. A custom redirect URL must be set if this is true.", alias="useRedirectUrl")
    use_splash_url: Optional[StrictBool] = Field(default=None, description="[optional] Boolean indicating whether the users will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL.", alias="useSplashUrl")
    welcome_message: Optional[StrictStr] = Field(default=None, description="The welcome message for the users on the splash page.", alias="welcomeMessage")
    __properties: ClassVar[List[str]] = ["allowSimultaneousLogins", "billing", "blockAllTrafficBeforeSignOn", "controllerDisconnectionBehavior", "guestSponsorship", "redirectUrl", "sentryEnrollment", "splashImage", "splashLogo", "splashPrepaidFront", "splashTimeout", "splashUrl", "useRedirectUrl", "useSplashUrl", "welcomeMessage"]

    @field_validator('controller_disconnection_behavior')
    def controller_disconnection_behavior_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['default', 'open', 'restricted']):
            raise ValueError("must be one of enum values ('default', 'open', 'restricted')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UpdateNetworkWirelessSsidSplashSettingsRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of billing
        if self.billing:
            _dict['billing'] = self.billing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of guest_sponsorship
        if self.guest_sponsorship:
            _dict['guestSponsorship'] = self.guest_sponsorship.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sentry_enrollment
        if self.sentry_enrollment:
            _dict['sentryEnrollment'] = self.sentry_enrollment.to_dict()
        # override the default output from pydantic by calling `to_dict()` of splash_image
        if self.splash_image:
            _dict['splashImage'] = self.splash_image.to_dict()
        # override the default output from pydantic by calling `to_dict()` of splash_logo
        if self.splash_logo:
            _dict['splashLogo'] = self.splash_logo.to_dict()
        # override the default output from pydantic by calling `to_dict()` of splash_prepaid_front
        if self.splash_prepaid_front:
            _dict['splashPrepaidFront'] = self.splash_prepaid_front.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UpdateNetworkWirelessSsidSplashSettingsRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "allowSimultaneousLogins": obj.get("allowSimultaneousLogins"),
            "billing": UpdateNetworkWirelessSsidSplashSettingsRequestBilling.from_dict(obj["billing"]) if obj.get("billing") is not None else None,
            "blockAllTrafficBeforeSignOn": obj.get("blockAllTrafficBeforeSignOn"),
            "controllerDisconnectionBehavior": obj.get("controllerDisconnectionBehavior"),
            "guestSponsorship": UpdateNetworkWirelessSsidSplashSettingsRequestGuestSponsorship.from_dict(obj["guestSponsorship"]) if obj.get("guestSponsorship") is not None else None,
            "redirectUrl": obj.get("redirectUrl"),
            "sentryEnrollment": UpdateNetworkWirelessSsidSplashSettingsRequestSentryEnrollment.from_dict(obj["sentryEnrollment"]) if obj.get("sentryEnrollment") is not None else None,
            "splashImage": UpdateNetworkWirelessSsidSplashSettingsRequestSplashImage.from_dict(obj["splashImage"]) if obj.get("splashImage") is not None else None,
            "splashLogo": UpdateNetworkWirelessSsidSplashSettingsRequestSplashLogo.from_dict(obj["splashLogo"]) if obj.get("splashLogo") is not None else None,
            "splashPrepaidFront": UpdateNetworkWirelessSsidSplashSettingsRequestSplashPrepaidFront.from_dict(obj["splashPrepaidFront"]) if obj.get("splashPrepaidFront") is not None else None,
            "splashTimeout": obj.get("splashTimeout"),
            "splashUrl": obj.get("splashUrl"),
            "useRedirectUrl": obj.get("useRedirectUrl"),
            "useSplashUrl": obj.get("useSplashUrl"),
            "welcomeMessage": obj.get("welcomeMessage")
        })
        return _obj


