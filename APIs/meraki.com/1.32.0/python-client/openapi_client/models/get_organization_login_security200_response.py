# coding: utf-8

"""
    Meraki Dashboard API

    The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 05 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 

    The version of the OpenAPI document: 1.32.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.get_organization_login_security200_response_api_authentication import GetOrganizationLoginSecurity200ResponseApiAuthentication
from typing import Optional, Set
from typing_extensions import Self

class GetOrganizationLoginSecurity200Response(BaseModel):
    """
    GetOrganizationLoginSecurity200Response
    """ # noqa: E501
    account_lockout_attempts: Optional[StrictInt] = Field(default=None, description="Number of consecutive failed login attempts after which users' accounts will be locked.", alias="accountLockoutAttempts")
    api_authentication: Optional[GetOrganizationLoginSecurity200ResponseApiAuthentication] = Field(default=None, alias="apiAuthentication")
    enforce_account_lockout: Optional[StrictBool] = Field(default=None, description="Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts.", alias="enforceAccountLockout")
    enforce_different_passwords: Optional[StrictBool] = Field(default=None, description="Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords.", alias="enforceDifferentPasswords")
    enforce_idle_timeout: Optional[StrictBool] = Field(default=None, description="Boolean indicating whether users will be logged out after being idle for the specified number of minutes.", alias="enforceIdleTimeout")
    enforce_login_ip_ranges: Optional[StrictBool] = Field(default=None, description="Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses.", alias="enforceLoginIpRanges")
    enforce_password_expiration: Optional[StrictBool] = Field(default=None, description="Boolean indicating whether users are forced to change their password every X number of days.", alias="enforcePasswordExpiration")
    enforce_strong_passwords: Optional[StrictBool] = Field(default=None, description="Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol", alias="enforceStrongPasswords")
    enforce_two_factor_auth: Optional[StrictBool] = Field(default=None, description="Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application.", alias="enforceTwoFactorAuth")
    idle_timeout_minutes: Optional[StrictInt] = Field(default=None, description="Number of minutes users can remain idle before being logged out of their accounts.", alias="idleTimeoutMinutes")
    login_ip_ranges: Optional[List[StrictStr]] = Field(default=None, description="List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.", alias="loginIpRanges")
    num_different_passwords: Optional[StrictInt] = Field(default=None, description="Number of recent passwords that new password must be distinct from.", alias="numDifferentPasswords")
    password_expiration_days: Optional[StrictInt] = Field(default=None, description="Number of days after which users will be forced to change their password.", alias="passwordExpirationDays")
    __properties: ClassVar[List[str]] = ["accountLockoutAttempts", "apiAuthentication", "enforceAccountLockout", "enforceDifferentPasswords", "enforceIdleTimeout", "enforceLoginIpRanges", "enforcePasswordExpiration", "enforceStrongPasswords", "enforceTwoFactorAuth", "idleTimeoutMinutes", "loginIpRanges", "numDifferentPasswords", "passwordExpirationDays"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GetOrganizationLoginSecurity200Response from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of api_authentication
        if self.api_authentication:
            _dict['apiAuthentication'] = self.api_authentication.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GetOrganizationLoginSecurity200Response from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accountLockoutAttempts": obj.get("accountLockoutAttempts"),
            "apiAuthentication": GetOrganizationLoginSecurity200ResponseApiAuthentication.from_dict(obj["apiAuthentication"]) if obj.get("apiAuthentication") is not None else None,
            "enforceAccountLockout": obj.get("enforceAccountLockout"),
            "enforceDifferentPasswords": obj.get("enforceDifferentPasswords"),
            "enforceIdleTimeout": obj.get("enforceIdleTimeout"),
            "enforceLoginIpRanges": obj.get("enforceLoginIpRanges"),
            "enforcePasswordExpiration": obj.get("enforcePasswordExpiration"),
            "enforceStrongPasswords": obj.get("enforceStrongPasswords"),
            "enforceTwoFactorAuth": obj.get("enforceTwoFactorAuth"),
            "idleTimeoutMinutes": obj.get("idleTimeoutMinutes"),
            "loginIpRanges": obj.get("loginIpRanges"),
            "numDifferentPasswords": obj.get("numDifferentPasswords"),
            "passwordExpirationDays": obj.get("passwordExpirationDays")
        })
        return _obj


