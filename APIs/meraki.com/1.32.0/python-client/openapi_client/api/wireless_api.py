# coding: utf-8

"""
    Meraki Dashboard API

    The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 05 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 

    The version of the OpenAPI document: 1.32.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.create_network_wireless_rf_profile201_response import CreateNetworkWirelessRfProfile201Response
from openapi_client.models.create_network_wireless_rf_profile_request import CreateNetworkWirelessRfProfileRequest
from openapi_client.models.create_network_wireless_ssid_identity_psk_request import CreateNetworkWirelessSsidIdentityPskRequest
from openapi_client.models.get_device_wireless_bluetooth_settings200_response import GetDeviceWirelessBluetoothSettings200Response
from openapi_client.models.get_device_wireless_connection_stats200_response import GetDeviceWirelessConnectionStats200Response
from openapi_client.models.get_network_wireless_bluetooth_settings200_response import GetNetworkWirelessBluetoothSettings200Response
from openapi_client.models.get_network_wireless_channel_utilization_history200_response_inner import GetNetworkWirelessChannelUtilizationHistory200ResponseInner
from openapi_client.models.get_network_wireless_client_count_history200_response_inner import GetNetworkWirelessClientCountHistory200ResponseInner
from openapi_client.models.get_network_wireless_connection_stats200_response import GetNetworkWirelessConnectionStats200Response
from openapi_client.models.get_network_wireless_data_rate_history200_response_inner import GetNetworkWirelessDataRateHistory200ResponseInner
from openapi_client.models.get_network_wireless_failed_connections200_response_inner import GetNetworkWirelessFailedConnections200ResponseInner
from openapi_client.models.get_network_wireless_latency_history200_response_inner import GetNetworkWirelessLatencyHistory200ResponseInner
from openapi_client.models.get_network_wireless_settings200_response import GetNetworkWirelessSettings200Response
from openapi_client.models.get_network_wireless_signal_quality_history200_response_inner import GetNetworkWirelessSignalQualityHistory200ResponseInner
from openapi_client.models.get_network_wireless_ssid_eap_override200_response import GetNetworkWirelessSsidEapOverride200Response
from openapi_client.models.get_network_wireless_ssid_identity_psks200_response_inner import GetNetworkWirelessSsidIdentityPsks200ResponseInner
from openapi_client.models.get_network_wireless_ssid_splash_settings200_response import GetNetworkWirelessSsidSplashSettings200Response
from openapi_client.models.get_network_wireless_usage_history200_response_inner import GetNetworkWirelessUsageHistory200ResponseInner
from openapi_client.models.get_organization_wireless_devices_ethernet_statuses200_response_inner import GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner
from openapi_client.models.update_device_wireless_bluetooth_settings_request import UpdateDeviceWirelessBluetoothSettingsRequest
from openapi_client.models.update_device_wireless_radio_settings_request import UpdateDeviceWirelessRadioSettingsRequest
from openapi_client.models.update_network_wireless_alternate_management_interface_request import UpdateNetworkWirelessAlternateManagementInterfaceRequest
from openapi_client.models.update_network_wireless_billing_request import UpdateNetworkWirelessBillingRequest
from openapi_client.models.update_network_wireless_bluetooth_settings_request import UpdateNetworkWirelessBluetoothSettingsRequest
from openapi_client.models.update_network_wireless_rf_profile_request import UpdateNetworkWirelessRfProfileRequest
from openapi_client.models.update_network_wireless_settings_request import UpdateNetworkWirelessSettingsRequest
from openapi_client.models.update_network_wireless_ssid_bonjour_forwarding_request import UpdateNetworkWirelessSsidBonjourForwardingRequest
from openapi_client.models.update_network_wireless_ssid_device_type_group_policies_request import UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesRequest
from openapi_client.models.update_network_wireless_ssid_eap_override_request import UpdateNetworkWirelessSsidEapOverrideRequest
from openapi_client.models.update_network_wireless_ssid_firewall_l3_firewall_rules_request import UpdateNetworkWirelessSsidFirewallL3FirewallRulesRequest
from openapi_client.models.update_network_wireless_ssid_firewall_l7_firewall_rules_request import UpdateNetworkWirelessSsidFirewallL7FirewallRulesRequest
from openapi_client.models.update_network_wireless_ssid_hotspot20_request import UpdateNetworkWirelessSsidHotspot20Request
from openapi_client.models.update_network_wireless_ssid_identity_psk_request import UpdateNetworkWirelessSsidIdentityPskRequest
from openapi_client.models.update_network_wireless_ssid_request import UpdateNetworkWirelessSsidRequest
from openapi_client.models.update_network_wireless_ssid_schedules_request import UpdateNetworkWirelessSsidSchedulesRequest
from openapi_client.models.update_network_wireless_ssid_splash_settings_request import UpdateNetworkWirelessSsidSplashSettingsRequest
from openapi_client.models.update_network_wireless_ssid_traffic_shaping_rules_request import UpdateNetworkWirelessSsidTrafficShapingRulesRequest
from openapi_client.models.update_network_wireless_ssid_vpn_request import UpdateNetworkWirelessSsidVpnRequest

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class WirelessApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_network_wireless_rf_profile(
        self,
        network_id: StrictStr,
        create_network_wireless_rf_profile_request: CreateNetworkWirelessRfProfileRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateNetworkWirelessRfProfile201Response:
        """Creates new RF profile for this network

        Creates new RF profile for this network

        :param network_id: (required)
        :type network_id: str
        :param create_network_wireless_rf_profile_request: (required)
        :type create_network_wireless_rf_profile_request: CreateNetworkWirelessRfProfileRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_network_wireless_rf_profile_serialize(
            network_id=network_id,
            create_network_wireless_rf_profile_request=create_network_wireless_rf_profile_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateNetworkWirelessRfProfile201Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_network_wireless_rf_profile_with_http_info(
        self,
        network_id: StrictStr,
        create_network_wireless_rf_profile_request: CreateNetworkWirelessRfProfileRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateNetworkWirelessRfProfile201Response]:
        """Creates new RF profile for this network

        Creates new RF profile for this network

        :param network_id: (required)
        :type network_id: str
        :param create_network_wireless_rf_profile_request: (required)
        :type create_network_wireless_rf_profile_request: CreateNetworkWirelessRfProfileRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_network_wireless_rf_profile_serialize(
            network_id=network_id,
            create_network_wireless_rf_profile_request=create_network_wireless_rf_profile_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateNetworkWirelessRfProfile201Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_network_wireless_rf_profile_without_preload_content(
        self,
        network_id: StrictStr,
        create_network_wireless_rf_profile_request: CreateNetworkWirelessRfProfileRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Creates new RF profile for this network

        Creates new RF profile for this network

        :param network_id: (required)
        :type network_id: str
        :param create_network_wireless_rf_profile_request: (required)
        :type create_network_wireless_rf_profile_request: CreateNetworkWirelessRfProfileRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_network_wireless_rf_profile_serialize(
            network_id=network_id,
            create_network_wireless_rf_profile_request=create_network_wireless_rf_profile_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateNetworkWirelessRfProfile201Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_network_wireless_rf_profile_serialize(
        self,
        network_id,
        create_network_wireless_rf_profile_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_network_wireless_rf_profile_request is not None:
            _body_params = create_network_wireless_rf_profile_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/networks/{networkId}/wireless/rfProfiles',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_network_wireless_ssid_identity_psk(
        self,
        network_id: StrictStr,
        number: StrictStr,
        create_network_wireless_ssid_identity_psk_request: CreateNetworkWirelessSsidIdentityPskRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Create an Identity PSK

        Create an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param create_network_wireless_ssid_identity_psk_request: (required)
        :type create_network_wireless_ssid_identity_psk_request: CreateNetworkWirelessSsidIdentityPskRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            create_network_wireless_ssid_identity_psk_request=create_network_wireless_ssid_identity_psk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_network_wireless_ssid_identity_psk_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        create_network_wireless_ssid_identity_psk_request: CreateNetworkWirelessSsidIdentityPskRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Create an Identity PSK

        Create an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param create_network_wireless_ssid_identity_psk_request: (required)
        :type create_network_wireless_ssid_identity_psk_request: CreateNetworkWirelessSsidIdentityPskRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            create_network_wireless_ssid_identity_psk_request=create_network_wireless_ssid_identity_psk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_network_wireless_ssid_identity_psk_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        create_network_wireless_ssid_identity_psk_request: CreateNetworkWirelessSsidIdentityPskRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create an Identity PSK

        Create an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param create_network_wireless_ssid_identity_psk_request: (required)
        :type create_network_wireless_ssid_identity_psk_request: CreateNetworkWirelessSsidIdentityPskRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            create_network_wireless_ssid_identity_psk_request=create_network_wireless_ssid_identity_psk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_network_wireless_ssid_identity_psk_serialize(
        self,
        network_id,
        number,
        create_network_wireless_ssid_identity_psk_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_network_wireless_ssid_identity_psk_request is not None:
            _body_params = create_network_wireless_ssid_identity_psk_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/identityPsks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_network_wireless_rf_profile(
        self,
        network_id: StrictStr,
        rf_profile_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete a RF Profile

        Delete a RF Profile

        :param network_id: (required)
        :type network_id: str
        :param rf_profile_id: (required)
        :type rf_profile_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_wireless_rf_profile_serialize(
            network_id=network_id,
            rf_profile_id=rf_profile_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_network_wireless_rf_profile_with_http_info(
        self,
        network_id: StrictStr,
        rf_profile_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete a RF Profile

        Delete a RF Profile

        :param network_id: (required)
        :type network_id: str
        :param rf_profile_id: (required)
        :type rf_profile_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_wireless_rf_profile_serialize(
            network_id=network_id,
            rf_profile_id=rf_profile_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_network_wireless_rf_profile_without_preload_content(
        self,
        network_id: StrictStr,
        rf_profile_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a RF Profile

        Delete a RF Profile

        :param network_id: (required)
        :type network_id: str
        :param rf_profile_id: (required)
        :type rf_profile_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_wireless_rf_profile_serialize(
            network_id=network_id,
            rf_profile_id=rf_profile_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_network_wireless_rf_profile_serialize(
        self,
        network_id,
        rf_profile_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if rf_profile_id is not None:
            _path_params['rfProfileId'] = rf_profile_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/networks/{networkId}/wireless/rfProfiles/{rfProfileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_network_wireless_ssid_identity_psk(
        self,
        network_id: StrictStr,
        number: StrictStr,
        identity_psk_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete an Identity PSK

        Delete an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param identity_psk_id: (required)
        :type identity_psk_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            identity_psk_id=identity_psk_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_network_wireless_ssid_identity_psk_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        identity_psk_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete an Identity PSK

        Delete an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param identity_psk_id: (required)
        :type identity_psk_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            identity_psk_id=identity_psk_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_network_wireless_ssid_identity_psk_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        identity_psk_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete an Identity PSK

        Delete an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param identity_psk_id: (required)
        :type identity_psk_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            identity_psk_id=identity_psk_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_network_wireless_ssid_identity_psk_serialize(
        self,
        network_id,
        number,
        identity_psk_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        if identity_psk_id is not None:
            _path_params['identityPskId'] = identity_psk_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_device_wireless_bluetooth_settings(
        self,
        serial: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetDeviceWirelessBluetoothSettings200Response:
        """Return the bluetooth settings for a wireless device

        Return the bluetooth settings for a wireless device

        :param serial: (required)
        :type serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_bluetooth_settings_serialize(
            serial=serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_device_wireless_bluetooth_settings_with_http_info(
        self,
        serial: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetDeviceWirelessBluetoothSettings200Response]:
        """Return the bluetooth settings for a wireless device

        Return the bluetooth settings for a wireless device

        :param serial: (required)
        :type serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_bluetooth_settings_serialize(
            serial=serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_device_wireless_bluetooth_settings_without_preload_content(
        self,
        serial: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the bluetooth settings for a wireless device

        Return the bluetooth settings for a wireless device

        :param serial: (required)
        :type serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_bluetooth_settings_serialize(
            serial=serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_device_wireless_bluetooth_settings_serialize(
        self,
        serial,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if serial is not None:
            _path_params['serial'] = serial
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/devices/{serial}/wireless/bluetooth/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_device_wireless_connection_stats(
        self,
        serial: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetDeviceWirelessConnectionStats200Response:
        """Aggregated connectivity info for a given AP on this network

        Aggregated connectivity info for a given AP on this network

        :param serial: (required)
        :type serial: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_connection_stats_serialize(
            serial=serial,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceWirelessConnectionStats200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_device_wireless_connection_stats_with_http_info(
        self,
        serial: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetDeviceWirelessConnectionStats200Response]:
        """Aggregated connectivity info for a given AP on this network

        Aggregated connectivity info for a given AP on this network

        :param serial: (required)
        :type serial: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_connection_stats_serialize(
            serial=serial,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceWirelessConnectionStats200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_device_wireless_connection_stats_without_preload_content(
        self,
        serial: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Aggregated connectivity info for a given AP on this network

        Aggregated connectivity info for a given AP on this network

        :param serial: (required)
        :type serial: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_connection_stats_serialize(
            serial=serial,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceWirelessConnectionStats200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_device_wireless_connection_stats_serialize(
        self,
        serial,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if serial is not None:
            _path_params['serial'] = serial
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/devices/{serial}/wireless/connectionStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_device_wireless_latency_stats(
        self,
        serial: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Aggregated latency info for a given AP on this network

        Aggregated latency info for a given AP on this network

        :param serial: (required)
        :type serial: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_latency_stats_serialize(
            serial=serial,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_device_wireless_latency_stats_with_http_info(
        self,
        serial: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Aggregated latency info for a given AP on this network

        Aggregated latency info for a given AP on this network

        :param serial: (required)
        :type serial: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_latency_stats_serialize(
            serial=serial,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_device_wireless_latency_stats_without_preload_content(
        self,
        serial: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Aggregated latency info for a given AP on this network

        Aggregated latency info for a given AP on this network

        :param serial: (required)
        :type serial: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_latency_stats_serialize(
            serial=serial,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_device_wireless_latency_stats_serialize(
        self,
        serial,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if serial is not None:
            _path_params['serial'] = serial
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/devices/{serial}/wireless/latencyStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_device_wireless_radio_settings(
        self,
        serial: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Return the radio settings of a device

        Return the radio settings of a device

        :param serial: (required)
        :type serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_radio_settings_serialize(
            serial=serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_device_wireless_radio_settings_with_http_info(
        self,
        serial: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Return the radio settings of a device

        Return the radio settings of a device

        :param serial: (required)
        :type serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_radio_settings_serialize(
            serial=serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_device_wireless_radio_settings_without_preload_content(
        self,
        serial: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the radio settings of a device

        Return the radio settings of a device

        :param serial: (required)
        :type serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_radio_settings_serialize(
            serial=serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_device_wireless_radio_settings_serialize(
        self,
        serial,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if serial is not None:
            _path_params['serial'] = serial
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/devices/{serial}/wireless/radio/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_device_wireless_status(
        self,
        serial: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Return the SSID statuses of an access point

        Return the SSID statuses of an access point

        :param serial: (required)
        :type serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_status_serialize(
            serial=serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_device_wireless_status_with_http_info(
        self,
        serial: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Return the SSID statuses of an access point

        Return the SSID statuses of an access point

        :param serial: (required)
        :type serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_status_serialize(
            serial=serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_device_wireless_status_without_preload_content(
        self,
        serial: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the SSID statuses of an access point

        Return the SSID statuses of an access point

        :param serial: (required)
        :type serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_wireless_status_serialize(
            serial=serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_device_wireless_status_serialize(
        self,
        serial,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if serial is not None:
            _path_params['serial'] = serial
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/devices/{serial}/wireless/status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_air_marshal(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """List Air Marshal scan results from a network

        List Air Marshal scan results from a network

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_air_marshal_serialize(
            network_id=network_id,
            t0=t0,
            timespan=timespan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_air_marshal_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """List Air Marshal scan results from a network

        List Air Marshal scan results from a network

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_air_marshal_serialize(
            network_id=network_id,
            t0=t0,
            timespan=timespan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_air_marshal_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Air Marshal scan results from a network

        List Air Marshal scan results from a network

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_air_marshal_serialize(
            network_id=network_id,
            t0=t0,
            timespan=timespan,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_air_marshal_serialize(
        self,
        network_id,
        t0,
        timespan,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/airMarshal',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_alternate_management_interface(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Return alternate management interface and devices with IP assigned

        Return alternate management interface and devices with IP assigned

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_alternate_management_interface_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_alternate_management_interface_with_http_info(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Return alternate management interface and devices with IP assigned

        Return alternate management interface and devices with IP assigned

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_alternate_management_interface_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_alternate_management_interface_without_preload_content(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return alternate management interface and devices with IP assigned

        Return alternate management interface and devices with IP assigned

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_alternate_management_interface_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_alternate_management_interface_serialize(
        self,
        network_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/alternateManagementInterface',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_billing(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Return the billing settings of this network

        Return the billing settings of this network

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_billing_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_billing_with_http_info(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Return the billing settings of this network

        Return the billing settings of this network

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_billing_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_billing_without_preload_content(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the billing settings of this network

        Return the billing settings of this network

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_billing_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_billing_serialize(
        self,
        network_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/billing',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_bluetooth_settings(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkWirelessBluetoothSettings200Response:
        """Return the Bluetooth settings for a network. <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a> must be enabled on the network.

        Return the Bluetooth settings for a network. <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a> must be enabled on the network.

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_bluetooth_settings_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_bluetooth_settings_with_http_info(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkWirelessBluetoothSettings200Response]:
        """Return the Bluetooth settings for a network. <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a> must be enabled on the network.

        Return the Bluetooth settings for a network. <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a> must be enabled on the network.

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_bluetooth_settings_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_bluetooth_settings_without_preload_content(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the Bluetooth settings for a network. <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a> must be enabled on the network.

        Return the Bluetooth settings for a network. <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a> must be enabled on the network.

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_bluetooth_settings_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_bluetooth_settings_serialize(
        self,
        network_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/bluetooth/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_channel_utilization_history(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client's connection history.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetNetworkWirelessChannelUtilizationHistory200ResponseInner]:
        """Return AP channel utilization over time for a device or network client

        Return AP channel utilization over time for a device or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client's connection history.
        :type client_id: str
        :param device_serial: Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_channel_utilization_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessChannelUtilizationHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_channel_utilization_history_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client's connection history.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetNetworkWirelessChannelUtilizationHistory200ResponseInner]]:
        """Return AP channel utilization over time for a device or network client

        Return AP channel utilization over time for a device or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client's connection history.
        :type client_id: str
        :param device_serial: Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_channel_utilization_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessChannelUtilizationHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_channel_utilization_history_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client's connection history.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return AP channel utilization over time for a device or network client

        Return AP channel utilization over time for a device or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client's connection history.
        :type client_id: str
        :param device_serial: Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_channel_utilization_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessChannelUtilizationHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_channel_utilization_history_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        resolution,
        auto_resolution,
        client_id,
        device_serial,
        ap_tag,
        band,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if auto_resolution is not None:
            
            _query_params.append(('autoResolution', auto_resolution))
            
        if client_id is not None:
            
            _query_params.append(('clientId', client_id))
            
        if device_serial is not None:
            
            _query_params.append(('deviceSerial', device_serial))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/channelUtilizationHistory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_client_connection_stats(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Aggregated connectivity info for a given client on this network

        Aggregated connectivity info for a given client on this network. Clients are identified by their MAC.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_connection_stats_serialize(
            network_id=network_id,
            client_id=client_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_client_connection_stats_with_http_info(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Aggregated connectivity info for a given client on this network

        Aggregated connectivity info for a given client on this network. Clients are identified by their MAC.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_connection_stats_serialize(
            network_id=network_id,
            client_id=client_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_client_connection_stats_without_preload_content(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Aggregated connectivity info for a given client on this network

        Aggregated connectivity info for a given client on this network. Clients are identified by their MAC.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_connection_stats_serialize(
            network_id=network_id,
            client_id=client_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_client_connection_stats_serialize(
        self,
        network_id,
        client_id,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if client_id is not None:
            _path_params['clientId'] = client_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/clients/{clientId}/connectionStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_client_connectivity_events(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        per_page: Annotated[Optional[StrictInt], Field(description="The number of entries per page returned. Acceptable range is 3 - 1000.")] = None,
        starting_after: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        ending_before: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.")] = None,
        types: Annotated[Optional[List[StrictStr]], Field(description="A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.")] = None,
        included_severities: Annotated[Optional[List[StrictStr]], Field(description="A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5', '6').")] = None,
        ssid_number: Annotated[Optional[StrictInt], Field(description="An SSID number to include. If not specified, events for all SSIDs will be returned.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by an AP's serial number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """List the wireless connectivity events for a client within a network in the timespan.

        List the wireless connectivity events for a client within a network in the timespan.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param per_page: The number of entries per page returned. Acceptable range is 3 - 1000.
        :type per_page: int
        :param starting_after: A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type starting_after: str
        :param ending_before: A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type ending_before: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
        :type timespan: float
        :param types: A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.
        :type types: List[str]
        :param included_severities: A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'.
        :type included_severities: List[str]
        :param band: Filter results by band (either '2.4', '5', '6').
        :type band: str
        :param ssid_number: An SSID number to include. If not specified, events for all SSIDs will be returned.
        :type ssid_number: int
        :param device_serial: Filter results by an AP's serial number.
        :type device_serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_connectivity_events_serialize(
            network_id=network_id,
            client_id=client_id,
            per_page=per_page,
            starting_after=starting_after,
            ending_before=ending_before,
            t0=t0,
            t1=t1,
            timespan=timespan,
            types=types,
            included_severities=included_severities,
            band=band,
            ssid_number=ssid_number,
            device_serial=device_serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_client_connectivity_events_with_http_info(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        per_page: Annotated[Optional[StrictInt], Field(description="The number of entries per page returned. Acceptable range is 3 - 1000.")] = None,
        starting_after: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        ending_before: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.")] = None,
        types: Annotated[Optional[List[StrictStr]], Field(description="A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.")] = None,
        included_severities: Annotated[Optional[List[StrictStr]], Field(description="A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5', '6').")] = None,
        ssid_number: Annotated[Optional[StrictInt], Field(description="An SSID number to include. If not specified, events for all SSIDs will be returned.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by an AP's serial number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """List the wireless connectivity events for a client within a network in the timespan.

        List the wireless connectivity events for a client within a network in the timespan.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param per_page: The number of entries per page returned. Acceptable range is 3 - 1000.
        :type per_page: int
        :param starting_after: A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type starting_after: str
        :param ending_before: A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type ending_before: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
        :type timespan: float
        :param types: A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.
        :type types: List[str]
        :param included_severities: A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'.
        :type included_severities: List[str]
        :param band: Filter results by band (either '2.4', '5', '6').
        :type band: str
        :param ssid_number: An SSID number to include. If not specified, events for all SSIDs will be returned.
        :type ssid_number: int
        :param device_serial: Filter results by an AP's serial number.
        :type device_serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_connectivity_events_serialize(
            network_id=network_id,
            client_id=client_id,
            per_page=per_page,
            starting_after=starting_after,
            ending_before=ending_before,
            t0=t0,
            t1=t1,
            timespan=timespan,
            types=types,
            included_severities=included_severities,
            band=band,
            ssid_number=ssid_number,
            device_serial=device_serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_client_connectivity_events_without_preload_content(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        per_page: Annotated[Optional[StrictInt], Field(description="The number of entries per page returned. Acceptable range is 3 - 1000.")] = None,
        starting_after: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        ending_before: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.")] = None,
        types: Annotated[Optional[List[StrictStr]], Field(description="A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.")] = None,
        included_severities: Annotated[Optional[List[StrictStr]], Field(description="A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5', '6').")] = None,
        ssid_number: Annotated[Optional[StrictInt], Field(description="An SSID number to include. If not specified, events for all SSIDs will be returned.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by an AP's serial number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List the wireless connectivity events for a client within a network in the timespan.

        List the wireless connectivity events for a client within a network in the timespan.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param per_page: The number of entries per page returned. Acceptable range is 3 - 1000.
        :type per_page: int
        :param starting_after: A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type starting_after: str
        :param ending_before: A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type ending_before: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
        :type timespan: float
        :param types: A list of event types to include. If not specified, events of all types will be returned. Valid types are 'assoc', 'disassoc', 'auth', 'deauth', 'dns', 'dhcp', 'roam', 'connection' and/or 'sticky'.
        :type types: List[str]
        :param included_severities: A list of severities to include. If not specified, events of all severities will be returned. Valid severities are 'good', 'info', 'warn' and/or 'bad'.
        :type included_severities: List[str]
        :param band: Filter results by band (either '2.4', '5', '6').
        :type band: str
        :param ssid_number: An SSID number to include. If not specified, events for all SSIDs will be returned.
        :type ssid_number: int
        :param device_serial: Filter results by an AP's serial number.
        :type device_serial: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_connectivity_events_serialize(
            network_id=network_id,
            client_id=client_id,
            per_page=per_page,
            starting_after=starting_after,
            ending_before=ending_before,
            t0=t0,
            t1=t1,
            timespan=timespan,
            types=types,
            included_severities=included_severities,
            band=band,
            ssid_number=ssid_number,
            device_serial=device_serial,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_client_connectivity_events_serialize(
        self,
        network_id,
        client_id,
        per_page,
        starting_after,
        ending_before,
        t0,
        t1,
        timespan,
        types,
        included_severities,
        band,
        ssid_number,
        device_serial,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'types': 'csv',
            'includedSeverities': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if client_id is not None:
            _path_params['clientId'] = client_id
        # process the query parameters
        if per_page is not None:
            
            _query_params.append(('perPage', per_page))
            
        if starting_after is not None:
            
            _query_params.append(('startingAfter', starting_after))
            
        if ending_before is not None:
            
            _query_params.append(('endingBefore', ending_before))
            
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if included_severities is not None:
            
            _query_params.append(('includedSeverities', included_severities))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid_number is not None:
            
            _query_params.append(('ssidNumber', ssid_number))
            
        if device_serial is not None:
            
            _query_params.append(('deviceSerial', device_serial))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/clients/{clientId}/connectivityEvents',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_client_count_history(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client to return per-device client counts over time inner joined by the queried client's connection history.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetNetworkWirelessClientCountHistory200ResponseInner]:
        """Return wireless client counts over time for a network, device, or network client

        Return wireless client counts over time for a network, device, or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client to return per-device client counts over time inner joined by the queried client's connection history.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_count_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessClientCountHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_client_count_history_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client to return per-device client counts over time inner joined by the queried client's connection history.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetNetworkWirelessClientCountHistory200ResponseInner]]:
        """Return wireless client counts over time for a network, device, or network client

        Return wireless client counts over time for a network, device, or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client to return per-device client counts over time inner joined by the queried client's connection history.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_count_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessClientCountHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_client_count_history_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client to return per-device client counts over time inner joined by the queried client's connection history.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return wireless client counts over time for a network, device, or network client

        Return wireless client counts over time for a network, device, or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client to return per-device client counts over time inner joined by the queried client's connection history.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_count_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessClientCountHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_client_count_history_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        resolution,
        auto_resolution,
        client_id,
        device_serial,
        ap_tag,
        band,
        ssid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if auto_resolution is not None:
            
            _query_params.append(('autoResolution', auto_resolution))
            
        if client_id is not None:
            
            _query_params.append(('clientId', client_id))
            
        if device_serial is not None:
            
            _query_params.append(('deviceSerial', device_serial))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/clientCountHistory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_client_latency_history(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 791 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 791 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Return the latency history for a client

        Return the latency history for a client. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP. The latency data is from a sample of 2% of packets and is grouped into 4 traffic categories: background, best effort, video, voice. Within these categories the sampled packet counters are bucketed by latency in milliseconds.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 791 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.
        :type resolution: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_latency_history_serialize(
            network_id=network_id,
            client_id=client_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_client_latency_history_with_http_info(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 791 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 791 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Return the latency history for a client

        Return the latency history for a client. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP. The latency data is from a sample of 2% of packets and is grouped into 4 traffic categories: background, best effort, video, voice. Within these categories the sampled packet counters are bucketed by latency in milliseconds.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 791 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.
        :type resolution: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_latency_history_serialize(
            network_id=network_id,
            client_id=client_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_client_latency_history_without_preload_content(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 791 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 791 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the latency history for a client

        Return the latency history for a client. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP. The latency data is from a sample of 2% of packets and is grouped into 4 traffic categories: background, best effort, video, voice. Within these categories the sampled packet counters are bucketed by latency in milliseconds.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 791 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 791 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400.
        :type resolution: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_latency_history_serialize(
            network_id=network_id,
            client_id=client_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_client_latency_history_serialize(
        self,
        network_id,
        client_id,
        t0,
        t1,
        timespan,
        resolution,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if client_id is not None:
            _path_params['clientId'] = client_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/clients/{clientId}/latencyHistory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_client_latency_stats(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Aggregated latency info for a given client on this network

        Aggregated latency info for a given client on this network. Clients are identified by their MAC.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_latency_stats_serialize(
            network_id=network_id,
            client_id=client_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_client_latency_stats_with_http_info(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Aggregated latency info for a given client on this network

        Aggregated latency info for a given client on this network. Clients are identified by their MAC.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_latency_stats_serialize(
            network_id=network_id,
            client_id=client_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_client_latency_stats_without_preload_content(
        self,
        network_id: StrictStr,
        client_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Aggregated latency info for a given client on this network

        Aggregated latency info for a given client on this network. Clients are identified by their MAC.

        :param network_id: (required)
        :type network_id: str
        :param client_id: (required)
        :type client_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_client_latency_stats_serialize(
            network_id=network_id,
            client_id=client_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_client_latency_stats_serialize(
        self,
        network_id,
        client_id,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if client_id is not None:
            _path_params['clientId'] = client_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/clients/{clientId}/latencyStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_clients_connection_stats(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Aggregated connectivity info for this network, grouped by clients

        Aggregated connectivity info for this network, grouped by clients

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_clients_connection_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_clients_connection_stats_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Aggregated connectivity info for this network, grouped by clients

        Aggregated connectivity info for this network, grouped by clients

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_clients_connection_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_clients_connection_stats_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Aggregated connectivity info for this network, grouped by clients

        Aggregated connectivity info for this network, grouped by clients

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_clients_connection_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_clients_connection_stats_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/clients/connectionStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_clients_latency_stats(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Aggregated latency info for this network, grouped by clients

        Aggregated latency info for this network, grouped by clients

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_clients_latency_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_clients_latency_stats_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Aggregated latency info for this network, grouped by clients

        Aggregated latency info for this network, grouped by clients

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_clients_latency_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_clients_latency_stats_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Aggregated latency info for this network, grouped by clients

        Aggregated latency info for this network, grouped by clients

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_clients_latency_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_clients_latency_stats_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/clients/latencyStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_connection_stats(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkWirelessConnectionStats200Response:
        """Aggregated connectivity info for this network

        Aggregated connectivity info for this network

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_connection_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessConnectionStats200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_connection_stats_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkWirelessConnectionStats200Response]:
        """Aggregated connectivity info for this network

        Aggregated connectivity info for this network

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_connection_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessConnectionStats200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_connection_stats_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Aggregated connectivity info for this network

        Aggregated connectivity info for this network

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_connection_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessConnectionStats200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_connection_stats_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/connectionStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_data_rate_history(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetNetworkWirelessDataRateHistory200ResponseInner]:
        """Return PHY data rates over time for a network, device, or network client

        Return PHY data rates over time for a network, device, or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_data_rate_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessDataRateHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_data_rate_history_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetNetworkWirelessDataRateHistory200ResponseInner]]:
        """Return PHY data rates over time for a network, device, or network client

        Return PHY data rates over time for a network, device, or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_data_rate_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessDataRateHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_data_rate_history_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return PHY data rates over time for a network, device, or network client

        Return PHY data rates over time for a network, device, or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_data_rate_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessDataRateHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_data_rate_history_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        resolution,
        auto_resolution,
        client_id,
        device_serial,
        ap_tag,
        band,
        ssid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if auto_resolution is not None:
            
            _query_params.append(('autoResolution', auto_resolution))
            
        if client_id is not None:
            
            _query_params.append(('clientId', client_id))
            
        if device_serial is not None:
            
            _query_params.append(('deviceSerial', device_serial))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/dataRateHistory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_devices_connection_stats(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetDeviceWirelessConnectionStats200Response]:
        """Aggregated connectivity info for this network, grouped by node

        Aggregated connectivity info for this network, grouped by node

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_devices_connection_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetDeviceWirelessConnectionStats200Response]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_devices_connection_stats_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetDeviceWirelessConnectionStats200Response]]:
        """Aggregated connectivity info for this network, grouped by node

        Aggregated connectivity info for this network, grouped by node

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_devices_connection_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetDeviceWirelessConnectionStats200Response]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_devices_connection_stats_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Aggregated connectivity info for this network, grouped by node

        Aggregated connectivity info for this network, grouped by node

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_devices_connection_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetDeviceWirelessConnectionStats200Response]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_devices_connection_stats_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/devices/connectionStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_devices_latency_stats(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Aggregated latency info for this network, grouped by node

        Aggregated latency info for this network, grouped by node

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_devices_latency_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_devices_latency_stats_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Aggregated latency info for this network, grouped by node

        Aggregated latency info for this network, grouped by node

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_devices_latency_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_devices_latency_stats_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Aggregated latency info for this network, grouped by node

        Aggregated latency info for this network, grouped by node

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_devices_latency_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_devices_latency_stats_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/devices/latencyStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_failed_connections(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        serial: Annotated[Optional[StrictStr], Field(description="Filter by AP")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter by client MAC")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetNetworkWirelessFailedConnections200ResponseInner]:
        """List of all failed client connection events on this network in a given time range

        List of all failed client connection events on this network in a given time range

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param serial: Filter by AP
        :type serial: str
        :param client_id: Filter by client MAC
        :type client_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_failed_connections_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            serial=serial,
            client_id=client_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessFailedConnections200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_failed_connections_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        serial: Annotated[Optional[StrictStr], Field(description="Filter by AP")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter by client MAC")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetNetworkWirelessFailedConnections200ResponseInner]]:
        """List of all failed client connection events on this network in a given time range

        List of all failed client connection events on this network in a given time range

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param serial: Filter by AP
        :type serial: str
        :param client_id: Filter by client MAC
        :type client_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_failed_connections_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            serial=serial,
            client_id=client_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessFailedConnections200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_failed_connections_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        serial: Annotated[Optional[StrictStr], Field(description="Filter by AP")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter by client MAC")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List of all failed client connection events on this network in a given time range

        List of all failed client connection events on this network in a given time range

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param serial: Filter by AP
        :type serial: str
        :param client_id: Filter by client MAC
        :type client_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_failed_connections_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            serial=serial,
            client_id=client_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessFailedConnections200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_failed_connections_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        serial,
        client_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if serial is not None:
            
            _query_params.append(('serial', serial))
            
        if client_id is not None:
            
            _query_params.append(('clientId', client_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/failedConnections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_latency_history(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        access_category: Annotated[Optional[StrictStr], Field(description="Filter by access category.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetNetworkWirelessLatencyHistory200ResponseInner]:
        """Return average wireless latency over time for a network, device, or network client

        Return average wireless latency over time for a network, device, or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param access_category: Filter by access category.
        :type access_category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_latency_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            access_category=access_category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessLatencyHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_latency_history_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        access_category: Annotated[Optional[StrictStr], Field(description="Filter by access category.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetNetworkWirelessLatencyHistory200ResponseInner]]:
        """Return average wireless latency over time for a network, device, or network client

        Return average wireless latency over time for a network, device, or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param access_category: Filter by access category.
        :type access_category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_latency_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            access_category=access_category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessLatencyHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_latency_history_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        access_category: Annotated[Optional[StrictStr], Field(description="Filter by access category.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return average wireless latency over time for a network, device, or network client

        Return average wireless latency over time for a network, device, or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param access_category: Filter by access category.
        :type access_category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_latency_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            access_category=access_category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessLatencyHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_latency_history_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        resolution,
        auto_resolution,
        client_id,
        device_serial,
        ap_tag,
        band,
        ssid,
        access_category,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if auto_resolution is not None:
            
            _query_params.append(('autoResolution', auto_resolution))
            
        if client_id is not None:
            
            _query_params.append(('clientId', client_id))
            
        if device_serial is not None:
            
            _query_params.append(('deviceSerial', device_serial))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if access_category is not None:
            
            _query_params.append(('accessCategory', access_category))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/latencyHistory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_latency_stats(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Aggregated latency info for this network

        Aggregated latency info for this network

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_latency_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_latency_stats_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Aggregated latency info for this network

        Aggregated latency info for this network

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_latency_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_latency_stats_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 180 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 7 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID")] = None,
        vlan: Annotated[Optional[StrictInt], Field(description="Filter results by VLAN")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP Tag")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Aggregated latency info for this network

        Aggregated latency info for this network

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 180 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days.
        :type timespan: float
        :param band: Filter results by band (either '2.4', '5' or '6'). Note that data prior to February 2020 will not have band information.
        :type band: str
        :param ssid: Filter results by SSID
        :type ssid: int
        :param vlan: Filter results by VLAN
        :type vlan: int
        :param ap_tag: Filter results by AP Tag
        :type ap_tag: str
        :param fields: Partial selection: If present, this call will return only the selected fields of [\"rawDistribution\", \"avg\"]. All fields will be returned by default. Selected fields must be entered as a comma separated string.
        :type fields: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_latency_stats_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            band=band,
            ssid=ssid,
            vlan=vlan,
            ap_tag=ap_tag,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_latency_stats_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        band,
        ssid,
        vlan,
        ap_tag,
        fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        if vlan is not None:
            
            _query_params.append(('vlan', vlan))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/latencyStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_mesh_statuses(
        self,
        network_id: StrictStr,
        per_page: Annotated[Optional[StrictInt], Field(description="The number of entries per page returned. Acceptable range is 3 - 500. Default is 50.")] = None,
        starting_after: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        ending_before: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """List wireless mesh statuses for repeaters

        List wireless mesh statuses for repeaters

        :param network_id: (required)
        :type network_id: str
        :param per_page: The number of entries per page returned. Acceptable range is 3 - 500. Default is 50.
        :type per_page: int
        :param starting_after: A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type starting_after: str
        :param ending_before: A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type ending_before: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_mesh_statuses_serialize(
            network_id=network_id,
            per_page=per_page,
            starting_after=starting_after,
            ending_before=ending_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_mesh_statuses_with_http_info(
        self,
        network_id: StrictStr,
        per_page: Annotated[Optional[StrictInt], Field(description="The number of entries per page returned. Acceptable range is 3 - 500. Default is 50.")] = None,
        starting_after: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        ending_before: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """List wireless mesh statuses for repeaters

        List wireless mesh statuses for repeaters

        :param network_id: (required)
        :type network_id: str
        :param per_page: The number of entries per page returned. Acceptable range is 3 - 500. Default is 50.
        :type per_page: int
        :param starting_after: A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type starting_after: str
        :param ending_before: A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type ending_before: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_mesh_statuses_serialize(
            network_id=network_id,
            per_page=per_page,
            starting_after=starting_after,
            ending_before=ending_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_mesh_statuses_without_preload_content(
        self,
        network_id: StrictStr,
        per_page: Annotated[Optional[StrictInt], Field(description="The number of entries per page returned. Acceptable range is 3 - 500. Default is 50.")] = None,
        starting_after: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        ending_before: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List wireless mesh statuses for repeaters

        List wireless mesh statuses for repeaters

        :param network_id: (required)
        :type network_id: str
        :param per_page: The number of entries per page returned. Acceptable range is 3 - 500. Default is 50.
        :type per_page: int
        :param starting_after: A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type starting_after: str
        :param ending_before: A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type ending_before: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_mesh_statuses_serialize(
            network_id=network_id,
            per_page=per_page,
            starting_after=starting_after,
            ending_before=ending_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_mesh_statuses_serialize(
        self,
        network_id,
        per_page,
        starting_after,
        ending_before,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if per_page is not None:
            
            _query_params.append(('perPage', per_page))
            
        if starting_after is not None:
            
            _query_params.append(('startingAfter', starting_after))
            
        if ending_before is not None:
            
            _query_params.append(('endingBefore', ending_before))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/meshStatuses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_rf_profile(
        self,
        network_id: StrictStr,
        rf_profile_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Return a RF profile

        Return a RF profile

        :param network_id: (required)
        :type network_id: str
        :param rf_profile_id: (required)
        :type rf_profile_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_rf_profile_serialize(
            network_id=network_id,
            rf_profile_id=rf_profile_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_rf_profile_with_http_info(
        self,
        network_id: StrictStr,
        rf_profile_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Return a RF profile

        Return a RF profile

        :param network_id: (required)
        :type network_id: str
        :param rf_profile_id: (required)
        :type rf_profile_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_rf_profile_serialize(
            network_id=network_id,
            rf_profile_id=rf_profile_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_rf_profile_without_preload_content(
        self,
        network_id: StrictStr,
        rf_profile_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return a RF profile

        Return a RF profile

        :param network_id: (required)
        :type network_id: str
        :param rf_profile_id: (required)
        :type rf_profile_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_rf_profile_serialize(
            network_id=network_id,
            rf_profile_id=rf_profile_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_rf_profile_serialize(
        self,
        network_id,
        rf_profile_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if rf_profile_id is not None:
            _path_params['rfProfileId'] = rf_profile_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/rfProfiles/{rfProfileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_rf_profiles(
        self,
        network_id: StrictStr,
        include_template_profiles: Annotated[Optional[StrictBool], Field(description="If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """List the non-basic RF profiles for this network

        List the non-basic RF profiles for this network

        :param network_id: (required)
        :type network_id: str
        :param include_template_profiles: If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.
        :type include_template_profiles: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_rf_profiles_serialize(
            network_id=network_id,
            include_template_profiles=include_template_profiles,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_rf_profiles_with_http_info(
        self,
        network_id: StrictStr,
        include_template_profiles: Annotated[Optional[StrictBool], Field(description="If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """List the non-basic RF profiles for this network

        List the non-basic RF profiles for this network

        :param network_id: (required)
        :type network_id: str
        :param include_template_profiles: If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.
        :type include_template_profiles: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_rf_profiles_serialize(
            network_id=network_id,
            include_template_profiles=include_template_profiles,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_rf_profiles_without_preload_content(
        self,
        network_id: StrictStr,
        include_template_profiles: Annotated[Optional[StrictBool], Field(description="If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List the non-basic RF profiles for this network

        List the non-basic RF profiles for this network

        :param network_id: (required)
        :type network_id: str
        :param include_template_profiles: If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false.
        :type include_template_profiles: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_rf_profiles_serialize(
            network_id=network_id,
            include_template_profiles=include_template_profiles,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_rf_profiles_serialize(
        self,
        network_id,
        include_template_profiles,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if include_template_profiles is not None:
            
            _query_params.append(('includeTemplateProfiles', include_template_profiles))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/rfProfiles',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_settings(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkWirelessSettings200Response:
        """Return the wireless settings for a network

        Return the wireless settings for a network

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_settings_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_settings_with_http_info(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkWirelessSettings200Response]:
        """Return the wireless settings for a network

        Return the wireless settings for a network

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_settings_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_settings_without_preload_content(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the wireless settings for a network

        Return the wireless settings for a network

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_settings_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_settings_serialize(
        self,
        network_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_signal_quality_history(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetNetworkWirelessSignalQualityHistory200ResponseInner]:
        """Return signal quality (SNR/RSSI) over time for a device or network client

        Return signal quality (SNR/RSSI) over time for a device or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_signal_quality_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessSignalQualityHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_signal_quality_history_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetNetworkWirelessSignalQualityHistory200ResponseInner]]:
        """Return signal quality (SNR/RSSI) over time for a device or network client

        Return signal quality (SNR/RSSI) over time for a device or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_signal_quality_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessSignalQualityHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_signal_quality_history_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return signal quality (SNR/RSSI) over time for a device or network client

        Return signal quality (SNR/RSSI) over time for a device or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client.
        :type client_id: str
        :param device_serial: Filter results by device.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_signal_quality_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessSignalQualityHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_signal_quality_history_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        resolution,
        auto_resolution,
        client_id,
        device_serial,
        ap_tag,
        band,
        ssid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if auto_resolution is not None:
            
            _query_params.append(('autoResolution', auto_resolution))
            
        if client_id is not None:
            
            _query_params.append(('clientId', client_id))
            
        if device_serial is not None:
            
            _query_params.append(('deviceSerial', device_serial))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/signalQualityHistory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Return a single MR SSID

        Return a single MR SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Return a single MR SSID

        Return a single MR SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return a single MR SSID

        Return a single MR SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_bonjour_forwarding(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """List the Bonjour forwarding setting and rules for the SSID

        List the Bonjour forwarding setting and rules for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_bonjour_forwarding_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_bonjour_forwarding_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """List the Bonjour forwarding setting and rules for the SSID

        List the Bonjour forwarding setting and rules for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_bonjour_forwarding_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_bonjour_forwarding_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List the Bonjour forwarding setting and rules for the SSID

        List the Bonjour forwarding setting and rules for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_bonjour_forwarding_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_bonjour_forwarding_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/bonjourForwarding',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_device_type_group_policies(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """List the device type group policies for the SSID

        List the device type group policies for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_device_type_group_policies_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_device_type_group_policies_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """List the device type group policies for the SSID

        List the device type group policies for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_device_type_group_policies_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_device_type_group_policies_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List the device type group policies for the SSID

        List the device type group policies for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_device_type_group_policies_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_device_type_group_policies_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_eap_override(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkWirelessSsidEapOverride200Response:
        """Return the EAP overridden parameters for an SSID

        Return the EAP overridden parameters for an SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_eap_override_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidEapOverride200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_eap_override_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkWirelessSsidEapOverride200Response]:
        """Return the EAP overridden parameters for an SSID

        Return the EAP overridden parameters for an SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_eap_override_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidEapOverride200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_eap_override_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the EAP overridden parameters for an SSID

        Return the EAP overridden parameters for an SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_eap_override_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidEapOverride200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_eap_override_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/eapOverride',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_firewall_l3_firewall_rules(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Return the L3 firewall rules for an SSID on an MR network

        Return the L3 firewall rules for an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_firewall_l3_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_firewall_l3_firewall_rules_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Return the L3 firewall rules for an SSID on an MR network

        Return the L3 firewall rules for an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_firewall_l3_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_firewall_l3_firewall_rules_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the L3 firewall rules for an SSID on an MR network

        Return the L3 firewall rules for an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_firewall_l3_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_firewall_l3_firewall_rules_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_firewall_l7_firewall_rules(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Return the L7 firewall rules for an SSID on an MR network

        Return the L7 firewall rules for an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_firewall_l7_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_firewall_l7_firewall_rules_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Return the L7 firewall rules for an SSID on an MR network

        Return the L7 firewall rules for an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_firewall_l7_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_firewall_l7_firewall_rules_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the L7 firewall rules for an SSID on an MR network

        Return the L7 firewall rules for an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_firewall_l7_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_firewall_l7_firewall_rules_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_hotspot20(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Return the Hotspot 2.0 settings for an SSID

        Return the Hotspot 2.0 settings for an SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_hotspot20_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_hotspot20_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Return the Hotspot 2.0 settings for an SSID

        Return the Hotspot 2.0 settings for an SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_hotspot20_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_hotspot20_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return the Hotspot 2.0 settings for an SSID

        Return the Hotspot 2.0 settings for an SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_hotspot20_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_hotspot20_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/hotspot20',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_identity_psk(
        self,
        network_id: StrictStr,
        number: StrictStr,
        identity_psk_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkWirelessSsidIdentityPsks200ResponseInner:
        """Return an Identity PSK

        Return an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param identity_psk_id: (required)
        :type identity_psk_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            identity_psk_id=identity_psk_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidIdentityPsks200ResponseInner",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_identity_psk_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        identity_psk_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkWirelessSsidIdentityPsks200ResponseInner]:
        """Return an Identity PSK

        Return an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param identity_psk_id: (required)
        :type identity_psk_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            identity_psk_id=identity_psk_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidIdentityPsks200ResponseInner",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_identity_psk_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        identity_psk_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return an Identity PSK

        Return an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param identity_psk_id: (required)
        :type identity_psk_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            identity_psk_id=identity_psk_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidIdentityPsks200ResponseInner",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_identity_psk_serialize(
        self,
        network_id,
        number,
        identity_psk_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        if identity_psk_id is not None:
            _path_params['identityPskId'] = identity_psk_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_identity_psks(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetNetworkWirelessSsidIdentityPsks200ResponseInner]:
        """List all Identity PSKs in a wireless network

        List all Identity PSKs in a wireless network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_identity_psks_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessSsidIdentityPsks200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_identity_psks_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetNetworkWirelessSsidIdentityPsks200ResponseInner]]:
        """List all Identity PSKs in a wireless network

        List all Identity PSKs in a wireless network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_identity_psks_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessSsidIdentityPsks200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_identity_psks_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all Identity PSKs in a wireless network

        List all Identity PSKs in a wireless network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_identity_psks_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessSsidIdentityPsks200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_identity_psks_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/identityPsks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_schedules(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """List the outage schedule for the SSID

        List the outage schedule for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_schedules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_schedules_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """List the outage schedule for the SSID

        List the outage schedule for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_schedules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_schedules_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List the outage schedule for the SSID

        List the outage schedule for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_schedules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_schedules_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/schedules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_splash_settings(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkWirelessSsidSplashSettings200Response:
        """Display the splash page settings for the given SSID

        Display the splash page settings for the given SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_splash_settings_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidSplashSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_splash_settings_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkWirelessSsidSplashSettings200Response]:
        """Display the splash page settings for the given SSID

        Display the splash page settings for the given SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_splash_settings_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidSplashSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_splash_settings_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Display the splash page settings for the given SSID

        Display the splash page settings for the given SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_splash_settings_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidSplashSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_splash_settings_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/splash/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_traffic_shaping_rules(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Display the traffic shaping settings for a SSID on an MR network

        Display the traffic shaping settings for a SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_traffic_shaping_rules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_traffic_shaping_rules_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Display the traffic shaping settings for a SSID on an MR network

        Display the traffic shaping settings for a SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_traffic_shaping_rules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_traffic_shaping_rules_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Display the traffic shaping settings for a SSID on an MR network

        Display the traffic shaping settings for a SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_traffic_shaping_rules_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_traffic_shaping_rules_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssid_vpn(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """List the VPN settings for the SSID.

        List the VPN settings for the SSID.

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_vpn_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssid_vpn_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """List the VPN settings for the SSID.

        List the VPN settings for the SSID.

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_vpn_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssid_vpn_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List the VPN settings for the SSID.

        List the VPN settings for the SSID.

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssid_vpn_serialize(
            network_id=network_id,
            number=number,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssid_vpn_serialize(
        self,
        network_id,
        number,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/vpn',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_ssids(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """List the MR SSIDs in a network

        List the MR SSIDs in a network

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssids_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_ssids_with_http_info(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """List the MR SSIDs in a network

        List the MR SSIDs in a network

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssids_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_ssids_without_preload_content(
        self,
        network_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List the MR SSIDs in a network

        List the MR SSIDs in a network

        :param network_id: (required)
        :type network_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_ssids_serialize(
            network_id=network_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_ssids_serialize(
        self,
        network_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/ssids',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_wireless_usage_history(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client to return per-device AP usage over time inner joined by the queried client's connection history.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device. Requires :band.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetNetworkWirelessUsageHistory200ResponseInner]:
        """Return AP usage over time for a device or network client

        Return AP usage over time for a device or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client to return per-device AP usage over time inner joined by the queried client's connection history.
        :type client_id: str
        :param device_serial: Filter results by device. Requires :band.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_usage_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessUsageHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_wireless_usage_history_with_http_info(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client to return per-device AP usage over time inner joined by the queried client's connection history.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device. Requires :band.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetNetworkWirelessUsageHistory200ResponseInner]]:
        """Return AP usage over time for a device or network client

        Return AP usage over time for a device or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client to return per-device AP usage over time inner joined by the queried client's connection history.
        :type client_id: str
        :param device_serial: Filter results by device. Requires :band.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_usage_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessUsageHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_wireless_usage_history_without_preload_content(
        self,
        network_id: StrictStr,
        t0: Annotated[Optional[StrictStr], Field(description="The beginning of the timespan for the data. The maximum lookback period is 31 days from today.")] = None,
        t1: Annotated[Optional[StrictStr], Field(description="The end of the timespan for the data. t1 can be a maximum of 31 days after t0.")] = None,
        timespan: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.")] = None,
        resolution: Annotated[Optional[StrictInt], Field(description="The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.")] = None,
        auto_resolution: Annotated[Optional[StrictBool], Field(description="Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.")] = None,
        client_id: Annotated[Optional[StrictStr], Field(description="Filter results by network client to return per-device AP usage over time inner joined by the queried client's connection history.")] = None,
        device_serial: Annotated[Optional[StrictStr], Field(description="Filter results by device. Requires :band.")] = None,
        ap_tag: Annotated[Optional[StrictStr], Field(description="Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.")] = None,
        band: Annotated[Optional[StrictStr], Field(description="Filter results by band (either '2.4', '5' or '6').")] = None,
        ssid: Annotated[Optional[StrictInt], Field(description="Filter results by SSID number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return AP usage over time for a device or network client

        Return AP usage over time for a device or network client

        :param network_id: (required)
        :type network_id: str
        :param t0: The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
        :type t0: str
        :param t1: The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
        :type t1: str
        :param timespan: The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
        :type timespan: float
        :param resolution: The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
        :type resolution: int
        :param auto_resolution: Automatically select a data resolution based on the given timespan; this overrides the value specified by the 'resolution' parameter. The default setting is false.
        :type auto_resolution: bool
        :param client_id: Filter results by network client to return per-device AP usage over time inner joined by the queried client's connection history.
        :type client_id: str
        :param device_serial: Filter results by device. Requires :band.
        :type device_serial: str
        :param ap_tag: Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified.
        :type ap_tag: str
        :param band: Filter results by band (either '2.4', '5' or '6').
        :type band: str
        :param ssid: Filter results by SSID number.
        :type ssid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_wireless_usage_history_serialize(
            network_id=network_id,
            t0=t0,
            t1=t1,
            timespan=timespan,
            resolution=resolution,
            auto_resolution=auto_resolution,
            client_id=client_id,
            device_serial=device_serial,
            ap_tag=ap_tag,
            band=band,
            ssid=ssid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetNetworkWirelessUsageHistory200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_wireless_usage_history_serialize(
        self,
        network_id,
        t0,
        t1,
        timespan,
        resolution,
        auto_resolution,
        client_id,
        device_serial,
        ap_tag,
        band,
        ssid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        if t0 is not None:
            
            _query_params.append(('t0', t0))
            
        if t1 is not None:
            
            _query_params.append(('t1', t1))
            
        if timespan is not None:
            
            _query_params.append(('timespan', timespan))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if auto_resolution is not None:
            
            _query_params.append(('autoResolution', auto_resolution))
            
        if client_id is not None:
            
            _query_params.append(('clientId', client_id))
            
        if device_serial is not None:
            
            _query_params.append(('deviceSerial', device_serial))
            
        if ap_tag is not None:
            
            _query_params.append(('apTag', ap_tag))
            
        if band is not None:
            
            _query_params.append(('band', band))
            
        if ssid is not None:
            
            _query_params.append(('ssid', ssid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/networks/{networkId}/wireless/usageHistory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_organization_wireless_devices_ethernet_statuses(
        self,
        organization_id: StrictStr,
        per_page: Annotated[Optional[StrictInt], Field(description="The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.")] = None,
        starting_after: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        ending_before: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        network_ids: Annotated[Optional[List[StrictStr]], Field(description="A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner]:
        """Endpoint to see power status for wireless devices

        Endpoint to see power status for wireless devices

        :param organization_id: (required)
        :type organization_id: str
        :param per_page: The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
        :type per_page: int
        :param starting_after: A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type starting_after: str
        :param ending_before: A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type ending_before: str
        :param network_ids: A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
        :type network_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_organization_wireless_devices_ethernet_statuses_serialize(
            organization_id=organization_id,
            per_page=per_page,
            starting_after=starting_after,
            ending_before=ending_before,
            network_ids=network_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_organization_wireless_devices_ethernet_statuses_with_http_info(
        self,
        organization_id: StrictStr,
        per_page: Annotated[Optional[StrictInt], Field(description="The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.")] = None,
        starting_after: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        ending_before: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        network_ids: Annotated[Optional[List[StrictStr]], Field(description="A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner]]:
        """Endpoint to see power status for wireless devices

        Endpoint to see power status for wireless devices

        :param organization_id: (required)
        :type organization_id: str
        :param per_page: The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
        :type per_page: int
        :param starting_after: A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type starting_after: str
        :param ending_before: A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type ending_before: str
        :param network_ids: A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
        :type network_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_organization_wireless_devices_ethernet_statuses_serialize(
            organization_id=organization_id,
            per_page=per_page,
            starting_after=starting_after,
            ending_before=ending_before,
            network_ids=network_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_organization_wireless_devices_ethernet_statuses_without_preload_content(
        self,
        organization_id: StrictStr,
        per_page: Annotated[Optional[StrictInt], Field(description="The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.")] = None,
        starting_after: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        ending_before: Annotated[Optional[StrictStr], Field(description="A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.")] = None,
        network_ids: Annotated[Optional[List[StrictStr]], Field(description="A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Endpoint to see power status for wireless devices

        Endpoint to see power status for wireless devices

        :param organization_id: (required)
        :type organization_id: str
        :param per_page: The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
        :type per_page: int
        :param starting_after: A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type starting_after: str
        :param ending_before: A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
        :type ending_before: str
        :param network_ids: A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]=N_12345678&networkIds[]=L_3456
        :type network_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_organization_wireless_devices_ethernet_statuses_serialize(
            organization_id=organization_id,
            per_page=per_page,
            starting_after=starting_after,
            ending_before=ending_before,
            network_ids=network_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_organization_wireless_devices_ethernet_statuses_serialize(
        self,
        organization_id,
        per_page,
        starting_after,
        ending_before,
        network_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'networkIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if organization_id is not None:
            _path_params['organizationId'] = organization_id
        # process the query parameters
        if per_page is not None:
            
            _query_params.append(('perPage', per_page))
            
        if starting_after is not None:
            
            _query_params.append(('startingAfter', starting_after))
            
        if ending_before is not None:
            
            _query_params.append(('endingBefore', ending_before))
            
        if network_ids is not None:
            
            _query_params.append(('networkIds', network_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/organizations/{organizationId}/wireless/devices/ethernet/statuses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_device_wireless_bluetooth_settings(
        self,
        serial: StrictStr,
        update_device_wireless_bluetooth_settings_request: Optional[UpdateDeviceWirelessBluetoothSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetDeviceWirelessBluetoothSettings200Response:
        """Update the bluetooth settings for a wireless device

        Update the bluetooth settings for a wireless device

        :param serial: (required)
        :type serial: str
        :param update_device_wireless_bluetooth_settings_request:
        :type update_device_wireless_bluetooth_settings_request: UpdateDeviceWirelessBluetoothSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_device_wireless_bluetooth_settings_serialize(
            serial=serial,
            update_device_wireless_bluetooth_settings_request=update_device_wireless_bluetooth_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_device_wireless_bluetooth_settings_with_http_info(
        self,
        serial: StrictStr,
        update_device_wireless_bluetooth_settings_request: Optional[UpdateDeviceWirelessBluetoothSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetDeviceWirelessBluetoothSettings200Response]:
        """Update the bluetooth settings for a wireless device

        Update the bluetooth settings for a wireless device

        :param serial: (required)
        :type serial: str
        :param update_device_wireless_bluetooth_settings_request:
        :type update_device_wireless_bluetooth_settings_request: UpdateDeviceWirelessBluetoothSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_device_wireless_bluetooth_settings_serialize(
            serial=serial,
            update_device_wireless_bluetooth_settings_request=update_device_wireless_bluetooth_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_device_wireless_bluetooth_settings_without_preload_content(
        self,
        serial: StrictStr,
        update_device_wireless_bluetooth_settings_request: Optional[UpdateDeviceWirelessBluetoothSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the bluetooth settings for a wireless device

        Update the bluetooth settings for a wireless device

        :param serial: (required)
        :type serial: str
        :param update_device_wireless_bluetooth_settings_request:
        :type update_device_wireless_bluetooth_settings_request: UpdateDeviceWirelessBluetoothSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_device_wireless_bluetooth_settings_serialize(
            serial=serial,
            update_device_wireless_bluetooth_settings_request=update_device_wireless_bluetooth_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_device_wireless_bluetooth_settings_serialize(
        self,
        serial,
        update_device_wireless_bluetooth_settings_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if serial is not None:
            _path_params['serial'] = serial
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_device_wireless_bluetooth_settings_request is not None:
            _body_params = update_device_wireless_bluetooth_settings_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/devices/{serial}/wireless/bluetooth/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_device_wireless_radio_settings(
        self,
        serial: StrictStr,
        update_device_wireless_radio_settings_request: Optional[UpdateDeviceWirelessRadioSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the radio settings of a device

        Update the radio settings of a device

        :param serial: (required)
        :type serial: str
        :param update_device_wireless_radio_settings_request:
        :type update_device_wireless_radio_settings_request: UpdateDeviceWirelessRadioSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_device_wireless_radio_settings_serialize(
            serial=serial,
            update_device_wireless_radio_settings_request=update_device_wireless_radio_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_device_wireless_radio_settings_with_http_info(
        self,
        serial: StrictStr,
        update_device_wireless_radio_settings_request: Optional[UpdateDeviceWirelessRadioSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the radio settings of a device

        Update the radio settings of a device

        :param serial: (required)
        :type serial: str
        :param update_device_wireless_radio_settings_request:
        :type update_device_wireless_radio_settings_request: UpdateDeviceWirelessRadioSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_device_wireless_radio_settings_serialize(
            serial=serial,
            update_device_wireless_radio_settings_request=update_device_wireless_radio_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_device_wireless_radio_settings_without_preload_content(
        self,
        serial: StrictStr,
        update_device_wireless_radio_settings_request: Optional[UpdateDeviceWirelessRadioSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the radio settings of a device

        Update the radio settings of a device

        :param serial: (required)
        :type serial: str
        :param update_device_wireless_radio_settings_request:
        :type update_device_wireless_radio_settings_request: UpdateDeviceWirelessRadioSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_device_wireless_radio_settings_serialize(
            serial=serial,
            update_device_wireless_radio_settings_request=update_device_wireless_radio_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_device_wireless_radio_settings_serialize(
        self,
        serial,
        update_device_wireless_radio_settings_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if serial is not None:
            _path_params['serial'] = serial
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_device_wireless_radio_settings_request is not None:
            _body_params = update_device_wireless_radio_settings_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/devices/{serial}/wireless/radio/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_alternate_management_interface(
        self,
        network_id: StrictStr,
        update_network_wireless_alternate_management_interface_request: Optional[UpdateNetworkWirelessAlternateManagementInterfaceRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update alternate management interface and device static IP

        Update alternate management interface and device static IP

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_alternate_management_interface_request:
        :type update_network_wireless_alternate_management_interface_request: UpdateNetworkWirelessAlternateManagementInterfaceRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_alternate_management_interface_serialize(
            network_id=network_id,
            update_network_wireless_alternate_management_interface_request=update_network_wireless_alternate_management_interface_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_alternate_management_interface_with_http_info(
        self,
        network_id: StrictStr,
        update_network_wireless_alternate_management_interface_request: Optional[UpdateNetworkWirelessAlternateManagementInterfaceRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update alternate management interface and device static IP

        Update alternate management interface and device static IP

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_alternate_management_interface_request:
        :type update_network_wireless_alternate_management_interface_request: UpdateNetworkWirelessAlternateManagementInterfaceRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_alternate_management_interface_serialize(
            network_id=network_id,
            update_network_wireless_alternate_management_interface_request=update_network_wireless_alternate_management_interface_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_alternate_management_interface_without_preload_content(
        self,
        network_id: StrictStr,
        update_network_wireless_alternate_management_interface_request: Optional[UpdateNetworkWirelessAlternateManagementInterfaceRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update alternate management interface and device static IP

        Update alternate management interface and device static IP

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_alternate_management_interface_request:
        :type update_network_wireless_alternate_management_interface_request: UpdateNetworkWirelessAlternateManagementInterfaceRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_alternate_management_interface_serialize(
            network_id=network_id,
            update_network_wireless_alternate_management_interface_request=update_network_wireless_alternate_management_interface_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_alternate_management_interface_serialize(
        self,
        network_id,
        update_network_wireless_alternate_management_interface_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_alternate_management_interface_request is not None:
            _body_params = update_network_wireless_alternate_management_interface_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/alternateManagementInterface',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_billing(
        self,
        network_id: StrictStr,
        update_network_wireless_billing_request: Optional[UpdateNetworkWirelessBillingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the billing settings

        Update the billing settings

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_billing_request:
        :type update_network_wireless_billing_request: UpdateNetworkWirelessBillingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_billing_serialize(
            network_id=network_id,
            update_network_wireless_billing_request=update_network_wireless_billing_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_billing_with_http_info(
        self,
        network_id: StrictStr,
        update_network_wireless_billing_request: Optional[UpdateNetworkWirelessBillingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the billing settings

        Update the billing settings

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_billing_request:
        :type update_network_wireless_billing_request: UpdateNetworkWirelessBillingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_billing_serialize(
            network_id=network_id,
            update_network_wireless_billing_request=update_network_wireless_billing_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_billing_without_preload_content(
        self,
        network_id: StrictStr,
        update_network_wireless_billing_request: Optional[UpdateNetworkWirelessBillingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the billing settings

        Update the billing settings

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_billing_request:
        :type update_network_wireless_billing_request: UpdateNetworkWirelessBillingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_billing_serialize(
            network_id=network_id,
            update_network_wireless_billing_request=update_network_wireless_billing_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_billing_serialize(
        self,
        network_id,
        update_network_wireless_billing_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_billing_request is not None:
            _body_params = update_network_wireless_billing_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/billing',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_bluetooth_settings(
        self,
        network_id: StrictStr,
        update_network_wireless_bluetooth_settings_request: Optional[UpdateNetworkWirelessBluetoothSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkWirelessBluetoothSettings200Response:
        """Update the Bluetooth settings for a network

        Update the Bluetooth settings for a network. See the docs page for <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a>.

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_bluetooth_settings_request:
        :type update_network_wireless_bluetooth_settings_request: UpdateNetworkWirelessBluetoothSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_bluetooth_settings_serialize(
            network_id=network_id,
            update_network_wireless_bluetooth_settings_request=update_network_wireless_bluetooth_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_bluetooth_settings_with_http_info(
        self,
        network_id: StrictStr,
        update_network_wireless_bluetooth_settings_request: Optional[UpdateNetworkWirelessBluetoothSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkWirelessBluetoothSettings200Response]:
        """Update the Bluetooth settings for a network

        Update the Bluetooth settings for a network. See the docs page for <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a>.

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_bluetooth_settings_request:
        :type update_network_wireless_bluetooth_settings_request: UpdateNetworkWirelessBluetoothSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_bluetooth_settings_serialize(
            network_id=network_id,
            update_network_wireless_bluetooth_settings_request=update_network_wireless_bluetooth_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_bluetooth_settings_without_preload_content(
        self,
        network_id: StrictStr,
        update_network_wireless_bluetooth_settings_request: Optional[UpdateNetworkWirelessBluetoothSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the Bluetooth settings for a network

        Update the Bluetooth settings for a network. See the docs page for <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a>.

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_bluetooth_settings_request:
        :type update_network_wireless_bluetooth_settings_request: UpdateNetworkWirelessBluetoothSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_bluetooth_settings_serialize(
            network_id=network_id,
            update_network_wireless_bluetooth_settings_request=update_network_wireless_bluetooth_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessBluetoothSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_bluetooth_settings_serialize(
        self,
        network_id,
        update_network_wireless_bluetooth_settings_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_bluetooth_settings_request is not None:
            _body_params = update_network_wireless_bluetooth_settings_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/bluetooth/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_rf_profile(
        self,
        network_id: StrictStr,
        rf_profile_id: StrictStr,
        update_network_wireless_rf_profile_request: Optional[UpdateNetworkWirelessRfProfileRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateNetworkWirelessRfProfile201Response:
        """Updates specified RF profile for this network

        Updates specified RF profile for this network

        :param network_id: (required)
        :type network_id: str
        :param rf_profile_id: (required)
        :type rf_profile_id: str
        :param update_network_wireless_rf_profile_request:
        :type update_network_wireless_rf_profile_request: UpdateNetworkWirelessRfProfileRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_rf_profile_serialize(
            network_id=network_id,
            rf_profile_id=rf_profile_id,
            update_network_wireless_rf_profile_request=update_network_wireless_rf_profile_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateNetworkWirelessRfProfile201Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_rf_profile_with_http_info(
        self,
        network_id: StrictStr,
        rf_profile_id: StrictStr,
        update_network_wireless_rf_profile_request: Optional[UpdateNetworkWirelessRfProfileRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateNetworkWirelessRfProfile201Response]:
        """Updates specified RF profile for this network

        Updates specified RF profile for this network

        :param network_id: (required)
        :type network_id: str
        :param rf_profile_id: (required)
        :type rf_profile_id: str
        :param update_network_wireless_rf_profile_request:
        :type update_network_wireless_rf_profile_request: UpdateNetworkWirelessRfProfileRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_rf_profile_serialize(
            network_id=network_id,
            rf_profile_id=rf_profile_id,
            update_network_wireless_rf_profile_request=update_network_wireless_rf_profile_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateNetworkWirelessRfProfile201Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_rf_profile_without_preload_content(
        self,
        network_id: StrictStr,
        rf_profile_id: StrictStr,
        update_network_wireless_rf_profile_request: Optional[UpdateNetworkWirelessRfProfileRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Updates specified RF profile for this network

        Updates specified RF profile for this network

        :param network_id: (required)
        :type network_id: str
        :param rf_profile_id: (required)
        :type rf_profile_id: str
        :param update_network_wireless_rf_profile_request:
        :type update_network_wireless_rf_profile_request: UpdateNetworkWirelessRfProfileRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_rf_profile_serialize(
            network_id=network_id,
            rf_profile_id=rf_profile_id,
            update_network_wireless_rf_profile_request=update_network_wireless_rf_profile_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateNetworkWirelessRfProfile201Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_rf_profile_serialize(
        self,
        network_id,
        rf_profile_id,
        update_network_wireless_rf_profile_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if rf_profile_id is not None:
            _path_params['rfProfileId'] = rf_profile_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_rf_profile_request is not None:
            _body_params = update_network_wireless_rf_profile_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/rfProfiles/{rfProfileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_settings(
        self,
        network_id: StrictStr,
        update_network_wireless_settings_request: Optional[UpdateNetworkWirelessSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkWirelessSettings200Response:
        """Update the wireless settings for a network

        Update the wireless settings for a network

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_settings_request:
        :type update_network_wireless_settings_request: UpdateNetworkWirelessSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_settings_serialize(
            network_id=network_id,
            update_network_wireless_settings_request=update_network_wireless_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_settings_with_http_info(
        self,
        network_id: StrictStr,
        update_network_wireless_settings_request: Optional[UpdateNetworkWirelessSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkWirelessSettings200Response]:
        """Update the wireless settings for a network

        Update the wireless settings for a network

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_settings_request:
        :type update_network_wireless_settings_request: UpdateNetworkWirelessSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_settings_serialize(
            network_id=network_id,
            update_network_wireless_settings_request=update_network_wireless_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_settings_without_preload_content(
        self,
        network_id: StrictStr,
        update_network_wireless_settings_request: Optional[UpdateNetworkWirelessSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the wireless settings for a network

        Update the wireless settings for a network

        :param network_id: (required)
        :type network_id: str
        :param update_network_wireless_settings_request:
        :type update_network_wireless_settings_request: UpdateNetworkWirelessSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_settings_serialize(
            network_id=network_id,
            update_network_wireless_settings_request=update_network_wireless_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_settings_serialize(
        self,
        network_id,
        update_network_wireless_settings_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_settings_request is not None:
            _body_params = update_network_wireless_settings_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_request: Optional[UpdateNetworkWirelessSsidRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the attributes of an MR SSID

        Update the attributes of an MR SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_request:
        :type update_network_wireless_ssid_request: UpdateNetworkWirelessSsidRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_request=update_network_wireless_ssid_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_request: Optional[UpdateNetworkWirelessSsidRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the attributes of an MR SSID

        Update the attributes of an MR SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_request:
        :type update_network_wireless_ssid_request: UpdateNetworkWirelessSsidRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_request=update_network_wireless_ssid_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_request: Optional[UpdateNetworkWirelessSsidRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the attributes of an MR SSID

        Update the attributes of an MR SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_request:
        :type update_network_wireless_ssid_request: UpdateNetworkWirelessSsidRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_request=update_network_wireless_ssid_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_request is not None:
            _body_params = update_network_wireless_ssid_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_bonjour_forwarding(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_bonjour_forwarding_request: Optional[UpdateNetworkWirelessSsidBonjourForwardingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the bonjour forwarding setting and rules for the SSID

        Update the bonjour forwarding setting and rules for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_bonjour_forwarding_request:
        :type update_network_wireless_ssid_bonjour_forwarding_request: UpdateNetworkWirelessSsidBonjourForwardingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_bonjour_forwarding_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_bonjour_forwarding_request=update_network_wireless_ssid_bonjour_forwarding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_bonjour_forwarding_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_bonjour_forwarding_request: Optional[UpdateNetworkWirelessSsidBonjourForwardingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the bonjour forwarding setting and rules for the SSID

        Update the bonjour forwarding setting and rules for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_bonjour_forwarding_request:
        :type update_network_wireless_ssid_bonjour_forwarding_request: UpdateNetworkWirelessSsidBonjourForwardingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_bonjour_forwarding_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_bonjour_forwarding_request=update_network_wireless_ssid_bonjour_forwarding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_bonjour_forwarding_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_bonjour_forwarding_request: Optional[UpdateNetworkWirelessSsidBonjourForwardingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the bonjour forwarding setting and rules for the SSID

        Update the bonjour forwarding setting and rules for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_bonjour_forwarding_request:
        :type update_network_wireless_ssid_bonjour_forwarding_request: UpdateNetworkWirelessSsidBonjourForwardingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_bonjour_forwarding_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_bonjour_forwarding_request=update_network_wireless_ssid_bonjour_forwarding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_bonjour_forwarding_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_bonjour_forwarding_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_bonjour_forwarding_request is not None:
            _body_params = update_network_wireless_ssid_bonjour_forwarding_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/bonjourForwarding',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_device_type_group_policies(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_device_type_group_policies_request: Optional[UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the device type group policies for the SSID

        Update the device type group policies for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_device_type_group_policies_request:
        :type update_network_wireless_ssid_device_type_group_policies_request: UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_device_type_group_policies_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_device_type_group_policies_request=update_network_wireless_ssid_device_type_group_policies_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_device_type_group_policies_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_device_type_group_policies_request: Optional[UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the device type group policies for the SSID

        Update the device type group policies for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_device_type_group_policies_request:
        :type update_network_wireless_ssid_device_type_group_policies_request: UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_device_type_group_policies_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_device_type_group_policies_request=update_network_wireless_ssid_device_type_group_policies_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_device_type_group_policies_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_device_type_group_policies_request: Optional[UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the device type group policies for the SSID

        Update the device type group policies for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_device_type_group_policies_request:
        :type update_network_wireless_ssid_device_type_group_policies_request: UpdateNetworkWirelessSsidDeviceTypeGroupPoliciesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_device_type_group_policies_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_device_type_group_policies_request=update_network_wireless_ssid_device_type_group_policies_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_device_type_group_policies_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_device_type_group_policies_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_device_type_group_policies_request is not None:
            _body_params = update_network_wireless_ssid_device_type_group_policies_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_eap_override(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_eap_override_request: Optional[UpdateNetworkWirelessSsidEapOverrideRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkWirelessSsidEapOverride200Response:
        """Update the EAP overridden parameters for an SSID.

        Update the EAP overridden parameters for an SSID.

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_eap_override_request:
        :type update_network_wireless_ssid_eap_override_request: UpdateNetworkWirelessSsidEapOverrideRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_eap_override_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_eap_override_request=update_network_wireless_ssid_eap_override_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidEapOverride200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_eap_override_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_eap_override_request: Optional[UpdateNetworkWirelessSsidEapOverrideRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkWirelessSsidEapOverride200Response]:
        """Update the EAP overridden parameters for an SSID.

        Update the EAP overridden parameters for an SSID.

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_eap_override_request:
        :type update_network_wireless_ssid_eap_override_request: UpdateNetworkWirelessSsidEapOverrideRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_eap_override_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_eap_override_request=update_network_wireless_ssid_eap_override_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidEapOverride200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_eap_override_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_eap_override_request: Optional[UpdateNetworkWirelessSsidEapOverrideRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the EAP overridden parameters for an SSID.

        Update the EAP overridden parameters for an SSID.

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_eap_override_request:
        :type update_network_wireless_ssid_eap_override_request: UpdateNetworkWirelessSsidEapOverrideRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_eap_override_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_eap_override_request=update_network_wireless_ssid_eap_override_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidEapOverride200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_eap_override_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_eap_override_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_eap_override_request is not None:
            _body_params = update_network_wireless_ssid_eap_override_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/eapOverride',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_firewall_l3_firewall_rules(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_firewall_l3_firewall_rules_request: Optional[UpdateNetworkWirelessSsidFirewallL3FirewallRulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the L3 firewall rules of an SSID on an MR network

        Update the L3 firewall rules of an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_firewall_l3_firewall_rules_request:
        :type update_network_wireless_ssid_firewall_l3_firewall_rules_request: UpdateNetworkWirelessSsidFirewallL3FirewallRulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_firewall_l3_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_firewall_l3_firewall_rules_request=update_network_wireless_ssid_firewall_l3_firewall_rules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_firewall_l3_firewall_rules_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_firewall_l3_firewall_rules_request: Optional[UpdateNetworkWirelessSsidFirewallL3FirewallRulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the L3 firewall rules of an SSID on an MR network

        Update the L3 firewall rules of an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_firewall_l3_firewall_rules_request:
        :type update_network_wireless_ssid_firewall_l3_firewall_rules_request: UpdateNetworkWirelessSsidFirewallL3FirewallRulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_firewall_l3_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_firewall_l3_firewall_rules_request=update_network_wireless_ssid_firewall_l3_firewall_rules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_firewall_l3_firewall_rules_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_firewall_l3_firewall_rules_request: Optional[UpdateNetworkWirelessSsidFirewallL3FirewallRulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the L3 firewall rules of an SSID on an MR network

        Update the L3 firewall rules of an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_firewall_l3_firewall_rules_request:
        :type update_network_wireless_ssid_firewall_l3_firewall_rules_request: UpdateNetworkWirelessSsidFirewallL3FirewallRulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_firewall_l3_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_firewall_l3_firewall_rules_request=update_network_wireless_ssid_firewall_l3_firewall_rules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_firewall_l3_firewall_rules_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_firewall_l3_firewall_rules_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_firewall_l3_firewall_rules_request is not None:
            _body_params = update_network_wireless_ssid_firewall_l3_firewall_rules_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_firewall_l7_firewall_rules(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_firewall_l7_firewall_rules_request: Optional[UpdateNetworkWirelessSsidFirewallL7FirewallRulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the L7 firewall rules of an SSID on an MR network

        Update the L7 firewall rules of an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_firewall_l7_firewall_rules_request:
        :type update_network_wireless_ssid_firewall_l7_firewall_rules_request: UpdateNetworkWirelessSsidFirewallL7FirewallRulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_firewall_l7_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_firewall_l7_firewall_rules_request=update_network_wireless_ssid_firewall_l7_firewall_rules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_firewall_l7_firewall_rules_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_firewall_l7_firewall_rules_request: Optional[UpdateNetworkWirelessSsidFirewallL7FirewallRulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the L7 firewall rules of an SSID on an MR network

        Update the L7 firewall rules of an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_firewall_l7_firewall_rules_request:
        :type update_network_wireless_ssid_firewall_l7_firewall_rules_request: UpdateNetworkWirelessSsidFirewallL7FirewallRulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_firewall_l7_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_firewall_l7_firewall_rules_request=update_network_wireless_ssid_firewall_l7_firewall_rules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_firewall_l7_firewall_rules_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_firewall_l7_firewall_rules_request: Optional[UpdateNetworkWirelessSsidFirewallL7FirewallRulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the L7 firewall rules of an SSID on an MR network

        Update the L7 firewall rules of an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_firewall_l7_firewall_rules_request:
        :type update_network_wireless_ssid_firewall_l7_firewall_rules_request: UpdateNetworkWirelessSsidFirewallL7FirewallRulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_firewall_l7_firewall_rules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_firewall_l7_firewall_rules_request=update_network_wireless_ssid_firewall_l7_firewall_rules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_firewall_l7_firewall_rules_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_firewall_l7_firewall_rules_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_firewall_l7_firewall_rules_request is not None:
            _body_params = update_network_wireless_ssid_firewall_l7_firewall_rules_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_hotspot20(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_hotspot20_request: Optional[UpdateNetworkWirelessSsidHotspot20Request] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the Hotspot 2.0 settings of an SSID

        Update the Hotspot 2.0 settings of an SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_hotspot20_request:
        :type update_network_wireless_ssid_hotspot20_request: UpdateNetworkWirelessSsidHotspot20Request
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_hotspot20_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_hotspot20_request=update_network_wireless_ssid_hotspot20_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_hotspot20_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_hotspot20_request: Optional[UpdateNetworkWirelessSsidHotspot20Request] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the Hotspot 2.0 settings of an SSID

        Update the Hotspot 2.0 settings of an SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_hotspot20_request:
        :type update_network_wireless_ssid_hotspot20_request: UpdateNetworkWirelessSsidHotspot20Request
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_hotspot20_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_hotspot20_request=update_network_wireless_ssid_hotspot20_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_hotspot20_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_hotspot20_request: Optional[UpdateNetworkWirelessSsidHotspot20Request] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the Hotspot 2.0 settings of an SSID

        Update the Hotspot 2.0 settings of an SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_hotspot20_request:
        :type update_network_wireless_ssid_hotspot20_request: UpdateNetworkWirelessSsidHotspot20Request
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_hotspot20_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_hotspot20_request=update_network_wireless_ssid_hotspot20_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_hotspot20_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_hotspot20_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_hotspot20_request is not None:
            _body_params = update_network_wireless_ssid_hotspot20_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/hotspot20',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_identity_psk(
        self,
        network_id: StrictStr,
        number: StrictStr,
        identity_psk_id: StrictStr,
        update_network_wireless_ssid_identity_psk_request: Optional[UpdateNetworkWirelessSsidIdentityPskRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update an Identity PSK

        Update an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param identity_psk_id: (required)
        :type identity_psk_id: str
        :param update_network_wireless_ssid_identity_psk_request:
        :type update_network_wireless_ssid_identity_psk_request: UpdateNetworkWirelessSsidIdentityPskRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            identity_psk_id=identity_psk_id,
            update_network_wireless_ssid_identity_psk_request=update_network_wireless_ssid_identity_psk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_identity_psk_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        identity_psk_id: StrictStr,
        update_network_wireless_ssid_identity_psk_request: Optional[UpdateNetworkWirelessSsidIdentityPskRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update an Identity PSK

        Update an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param identity_psk_id: (required)
        :type identity_psk_id: str
        :param update_network_wireless_ssid_identity_psk_request:
        :type update_network_wireless_ssid_identity_psk_request: UpdateNetworkWirelessSsidIdentityPskRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            identity_psk_id=identity_psk_id,
            update_network_wireless_ssid_identity_psk_request=update_network_wireless_ssid_identity_psk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_identity_psk_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        identity_psk_id: StrictStr,
        update_network_wireless_ssid_identity_psk_request: Optional[UpdateNetworkWirelessSsidIdentityPskRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update an Identity PSK

        Update an Identity PSK

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param identity_psk_id: (required)
        :type identity_psk_id: str
        :param update_network_wireless_ssid_identity_psk_request:
        :type update_network_wireless_ssid_identity_psk_request: UpdateNetworkWirelessSsidIdentityPskRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_identity_psk_serialize(
            network_id=network_id,
            number=number,
            identity_psk_id=identity_psk_id,
            update_network_wireless_ssid_identity_psk_request=update_network_wireless_ssid_identity_psk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_identity_psk_serialize(
        self,
        network_id,
        number,
        identity_psk_id,
        update_network_wireless_ssid_identity_psk_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        if identity_psk_id is not None:
            _path_params['identityPskId'] = identity_psk_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_identity_psk_request is not None:
            _body_params = update_network_wireless_ssid_identity_psk_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_schedules(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_schedules_request: Optional[UpdateNetworkWirelessSsidSchedulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the outage schedule for the SSID

        Update the outage schedule for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_schedules_request:
        :type update_network_wireless_ssid_schedules_request: UpdateNetworkWirelessSsidSchedulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_schedules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_schedules_request=update_network_wireless_ssid_schedules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_schedules_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_schedules_request: Optional[UpdateNetworkWirelessSsidSchedulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the outage schedule for the SSID

        Update the outage schedule for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_schedules_request:
        :type update_network_wireless_ssid_schedules_request: UpdateNetworkWirelessSsidSchedulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_schedules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_schedules_request=update_network_wireless_ssid_schedules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_schedules_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_schedules_request: Optional[UpdateNetworkWirelessSsidSchedulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the outage schedule for the SSID

        Update the outage schedule for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_schedules_request:
        :type update_network_wireless_ssid_schedules_request: UpdateNetworkWirelessSsidSchedulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_schedules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_schedules_request=update_network_wireless_ssid_schedules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_schedules_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_schedules_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_schedules_request is not None:
            _body_params = update_network_wireless_ssid_schedules_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/schedules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_splash_settings(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_splash_settings_request: Optional[UpdateNetworkWirelessSsidSplashSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkWirelessSsidSplashSettings200Response:
        """Modify the splash page settings for the given SSID

        Modify the splash page settings for the given SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_splash_settings_request:
        :type update_network_wireless_ssid_splash_settings_request: UpdateNetworkWirelessSsidSplashSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_splash_settings_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_splash_settings_request=update_network_wireless_ssid_splash_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidSplashSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_splash_settings_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_splash_settings_request: Optional[UpdateNetworkWirelessSsidSplashSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkWirelessSsidSplashSettings200Response]:
        """Modify the splash page settings for the given SSID

        Modify the splash page settings for the given SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_splash_settings_request:
        :type update_network_wireless_ssid_splash_settings_request: UpdateNetworkWirelessSsidSplashSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_splash_settings_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_splash_settings_request=update_network_wireless_ssid_splash_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidSplashSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_splash_settings_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_splash_settings_request: Optional[UpdateNetworkWirelessSsidSplashSettingsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Modify the splash page settings for the given SSID

        Modify the splash page settings for the given SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_splash_settings_request:
        :type update_network_wireless_ssid_splash_settings_request: UpdateNetworkWirelessSsidSplashSettingsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_splash_settings_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_splash_settings_request=update_network_wireless_ssid_splash_settings_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetNetworkWirelessSsidSplashSettings200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_splash_settings_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_splash_settings_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_splash_settings_request is not None:
            _body_params = update_network_wireless_ssid_splash_settings_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/splash/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_traffic_shaping_rules(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_traffic_shaping_rules_request: Optional[UpdateNetworkWirelessSsidTrafficShapingRulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the traffic shaping settings for an SSID on an MR network

        Update the traffic shaping settings for an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_traffic_shaping_rules_request:
        :type update_network_wireless_ssid_traffic_shaping_rules_request: UpdateNetworkWirelessSsidTrafficShapingRulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_traffic_shaping_rules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_traffic_shaping_rules_request=update_network_wireless_ssid_traffic_shaping_rules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_traffic_shaping_rules_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_traffic_shaping_rules_request: Optional[UpdateNetworkWirelessSsidTrafficShapingRulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the traffic shaping settings for an SSID on an MR network

        Update the traffic shaping settings for an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_traffic_shaping_rules_request:
        :type update_network_wireless_ssid_traffic_shaping_rules_request: UpdateNetworkWirelessSsidTrafficShapingRulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_traffic_shaping_rules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_traffic_shaping_rules_request=update_network_wireless_ssid_traffic_shaping_rules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_traffic_shaping_rules_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_traffic_shaping_rules_request: Optional[UpdateNetworkWirelessSsidTrafficShapingRulesRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the traffic shaping settings for an SSID on an MR network

        Update the traffic shaping settings for an SSID on an MR network

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_traffic_shaping_rules_request:
        :type update_network_wireless_ssid_traffic_shaping_rules_request: UpdateNetworkWirelessSsidTrafficShapingRulesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_traffic_shaping_rules_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_traffic_shaping_rules_request=update_network_wireless_ssid_traffic_shaping_rules_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_traffic_shaping_rules_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_traffic_shaping_rules_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_traffic_shaping_rules_request is not None:
            _body_params = update_network_wireless_ssid_traffic_shaping_rules_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network_wireless_ssid_vpn(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_vpn_request: Optional[UpdateNetworkWirelessSsidVpnRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update the VPN settings for the SSID

        Update the VPN settings for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_vpn_request:
        :type update_network_wireless_ssid_vpn_request: UpdateNetworkWirelessSsidVpnRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_vpn_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_vpn_request=update_network_wireless_ssid_vpn_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_wireless_ssid_vpn_with_http_info(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_vpn_request: Optional[UpdateNetworkWirelessSsidVpnRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update the VPN settings for the SSID

        Update the VPN settings for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_vpn_request:
        :type update_network_wireless_ssid_vpn_request: UpdateNetworkWirelessSsidVpnRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_vpn_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_vpn_request=update_network_wireless_ssid_vpn_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_wireless_ssid_vpn_without_preload_content(
        self,
        network_id: StrictStr,
        number: StrictStr,
        update_network_wireless_ssid_vpn_request: Optional[UpdateNetworkWirelessSsidVpnRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update the VPN settings for the SSID

        Update the VPN settings for the SSID

        :param network_id: (required)
        :type network_id: str
        :param number: (required)
        :type number: str
        :param update_network_wireless_ssid_vpn_request:
        :type update_network_wireless_ssid_vpn_request: UpdateNetworkWirelessSsidVpnRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_wireless_ssid_vpn_serialize(
            network_id=network_id,
            number=number,
            update_network_wireless_ssid_vpn_request=update_network_wireless_ssid_vpn_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_wireless_ssid_vpn_serialize(
        self,
        network_id,
        number,
        update_network_wireless_ssid_vpn_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if network_id is not None:
            _path_params['networkId'] = network_id
        if number is not None:
            _path_params['number'] = number
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_network_wireless_ssid_vpn_request is not None:
            _body_params = update_network_wireless_ssid_vpn_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'meraki_api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/networks/{networkId}/wireless/ssids/{number}/vpn',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


