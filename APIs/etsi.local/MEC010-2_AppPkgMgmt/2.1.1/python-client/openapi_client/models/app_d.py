# coding: utf-8

"""
    ETSI GS MEC 010-2 - Part 2: Application lifecycle, rules and requirements management

    ETSI GS MEC 010-2 - Part 2: Application lifecycle, rules and requirements management described using OpenAPI.

    The version of the OpenAPI document: 2.1.1
    Contact: cti_support@etsi.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.app_external_cpd import AppExternalCpd
from openapi_client.models.dns_rule_descriptor import DNSRuleDescriptor
from openapi_client.models.feature_dependency import FeatureDependency
from openapi_client.models.latency_descriptor import LatencyDescriptor
from openapi_client.models.service_dependency import ServiceDependency
from openapi_client.models.service_descriptor import ServiceDescriptor
from openapi_client.models.traffic_rule_descriptor import TrafficRuleDescriptor
from openapi_client.models.transport_dependency import TransportDependency
from typing import Optional, Set
from typing_extensions import Self

class AppD(BaseModel):
    """
    AppD
    """ # noqa: E501
    app_did: StrictStr = Field(description="Identifier of this MEC application descriptor. This attribute shall be globally unique. See noteÂ 1.", alias="appDId")
    app_dns_rule: Optional[Annotated[List[DNSRuleDescriptor], Field(min_length=0)]] = Field(default=None, description="Describes DNS rules the MEC application requires.", alias="appDNSRule")
    app_d_version: StrictStr = Field(description="Identifies the version of the application descriptor.", alias="appDVersion")
    app_description: StrictStr = Field(description="Human readable description of the MEC application.", alias="appDescription")
    app_ext_cpd: Optional[Annotated[List[AppExternalCpd], Field(min_length=0)]] = Field(default=None, description="Describes external interface(s) exposed by this MEC application.", alias="appExtCpd")
    app_feature_optional: Optional[Annotated[List[FeatureDependency], Field(min_length=0)]] = Field(default=None, description="Describes features a MEC application may use if available.", alias="appFeatureOptional")
    app_feature_required: Optional[Annotated[List[FeatureDependency], Field(min_length=0)]] = Field(default=None, description="Describes features a MEC application requires to run.", alias="appFeatureRequired")
    app_info_name: Optional[StrictStr] = Field(default=None, description="Human readable name for the MEC application.", alias="appInfoName")
    app_latency: Optional[LatencyDescriptor] = Field(default=None, alias="appLatency")
    app_name: StrictStr = Field(description="Name to identify the MEC application.", alias="appName")
    app_provider: StrictStr = Field(description="Provider of the application and of the AppD.", alias="appProvider")
    app_service_optional: Optional[Annotated[List[ServiceDependency], Field(min_length=0)]] = Field(default=None, description="Describes services a MEC application may use if available.", alias="appServiceOptional")
    app_service_produced: Optional[Annotated[List[ServiceDescriptor], Field(min_length=0)]] = Field(default=None, description="Describes services a MEC application is able to produce to the platform or other MEC applications. Only relevant for service-producing apps.", alias="appServiceProduced")
    app_service_required: Optional[Annotated[List[ServiceDependency], Field(min_length=0)]] = Field(default=None, description="Describes services a MEC application requires to run.", alias="appServiceRequired")
    app_soft_version: StrictStr = Field(description="Identifies the version of software of the MEC application.", alias="appSoftVersion")
    app_traffic_rule: Optional[Annotated[List[TrafficRuleDescriptor], Field(min_length=0)]] = Field(default=None, description="Describes traffic rules the MEC application requires.", alias="appTrafficRule")
    change_app_instance_state_op_config: Optional[StrictStr] = Field(default=None, description="NFV", alias="changeAppInstanceStateOpConfig")
    mec_version: Annotated[List[StrictStr], Field(min_length=1)] = Field(description="Identifies version(s) of MEC system compatible with the MEC application described in this version of the AppD.", alias="mecVersion")
    sw_image_descriptor: StrictStr = Field(description="Ref NFV", alias="swImageDescriptor")
    terminate_app_instance_op_config: Optional[StrictStr] = Field(default=None, description="NFV", alias="terminateAppInstanceOpConfig")
    transport_dependencies: Optional[Annotated[List[TransportDependency], Field(min_length=0)]] = Field(default=None, description="Transports, if any, that this application requires to be provided by the platform. These transports will be used by the application to deliver services provided by this application. Only relevant for service-producing apps. See note 2.", alias="transportDependencies")
    virtual_compute_descriptor: StrictStr = Field(description="Ref NFV", alias="virtualComputeDescriptor")
    virtual_storage_descriptor: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="Defines descriptors of virtual storage resources to be used by the MEC application.", alias="virtualStorageDescriptor")
    __properties: ClassVar[List[str]] = ["appDId", "appDNSRule", "appDVersion", "appDescription", "appExtCpd", "appFeatureOptional", "appFeatureRequired", "appInfoName", "appLatency", "appName", "appProvider", "appServiceOptional", "appServiceProduced", "appServiceRequired", "appSoftVersion", "appTrafficRule", "changeAppInstanceStateOpConfig", "mecVersion", "swImageDescriptor", "terminateAppInstanceOpConfig", "transportDependencies", "virtualComputeDescriptor", "virtualStorageDescriptor"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AppD from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in app_dns_rule (list)
        _items = []
        if self.app_dns_rule:
            for _item_app_dns_rule in self.app_dns_rule:
                if _item_app_dns_rule:
                    _items.append(_item_app_dns_rule.to_dict())
            _dict['appDNSRule'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in app_ext_cpd (list)
        _items = []
        if self.app_ext_cpd:
            for _item_app_ext_cpd in self.app_ext_cpd:
                if _item_app_ext_cpd:
                    _items.append(_item_app_ext_cpd.to_dict())
            _dict['appExtCpd'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in app_feature_optional (list)
        _items = []
        if self.app_feature_optional:
            for _item_app_feature_optional in self.app_feature_optional:
                if _item_app_feature_optional:
                    _items.append(_item_app_feature_optional.to_dict())
            _dict['appFeatureOptional'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in app_feature_required (list)
        _items = []
        if self.app_feature_required:
            for _item_app_feature_required in self.app_feature_required:
                if _item_app_feature_required:
                    _items.append(_item_app_feature_required.to_dict())
            _dict['appFeatureRequired'] = _items
        # override the default output from pydantic by calling `to_dict()` of app_latency
        if self.app_latency:
            _dict['appLatency'] = self.app_latency.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in app_service_optional (list)
        _items = []
        if self.app_service_optional:
            for _item_app_service_optional in self.app_service_optional:
                if _item_app_service_optional:
                    _items.append(_item_app_service_optional.to_dict())
            _dict['appServiceOptional'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in app_service_produced (list)
        _items = []
        if self.app_service_produced:
            for _item_app_service_produced in self.app_service_produced:
                if _item_app_service_produced:
                    _items.append(_item_app_service_produced.to_dict())
            _dict['appServiceProduced'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in app_service_required (list)
        _items = []
        if self.app_service_required:
            for _item_app_service_required in self.app_service_required:
                if _item_app_service_required:
                    _items.append(_item_app_service_required.to_dict())
            _dict['appServiceRequired'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in app_traffic_rule (list)
        _items = []
        if self.app_traffic_rule:
            for _item_app_traffic_rule in self.app_traffic_rule:
                if _item_app_traffic_rule:
                    _items.append(_item_app_traffic_rule.to_dict())
            _dict['appTrafficRule'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in transport_dependencies (list)
        _items = []
        if self.transport_dependencies:
            for _item_transport_dependencies in self.transport_dependencies:
                if _item_transport_dependencies:
                    _items.append(_item_transport_dependencies.to_dict())
            _dict['transportDependencies'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AppD from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "appDId": obj.get("appDId"),
            "appDNSRule": [DNSRuleDescriptor.from_dict(_item) for _item in obj["appDNSRule"]] if obj.get("appDNSRule") is not None else None,
            "appDVersion": obj.get("appDVersion"),
            "appDescription": obj.get("appDescription"),
            "appExtCpd": [AppExternalCpd.from_dict(_item) for _item in obj["appExtCpd"]] if obj.get("appExtCpd") is not None else None,
            "appFeatureOptional": [FeatureDependency.from_dict(_item) for _item in obj["appFeatureOptional"]] if obj.get("appFeatureOptional") is not None else None,
            "appFeatureRequired": [FeatureDependency.from_dict(_item) for _item in obj["appFeatureRequired"]] if obj.get("appFeatureRequired") is not None else None,
            "appInfoName": obj.get("appInfoName"),
            "appLatency": LatencyDescriptor.from_dict(obj["appLatency"]) if obj.get("appLatency") is not None else None,
            "appName": obj.get("appName"),
            "appProvider": obj.get("appProvider"),
            "appServiceOptional": [ServiceDependency.from_dict(_item) for _item in obj["appServiceOptional"]] if obj.get("appServiceOptional") is not None else None,
            "appServiceProduced": [ServiceDescriptor.from_dict(_item) for _item in obj["appServiceProduced"]] if obj.get("appServiceProduced") is not None else None,
            "appServiceRequired": [ServiceDependency.from_dict(_item) for _item in obj["appServiceRequired"]] if obj.get("appServiceRequired") is not None else None,
            "appSoftVersion": obj.get("appSoftVersion"),
            "appTrafficRule": [TrafficRuleDescriptor.from_dict(_item) for _item in obj["appTrafficRule"]] if obj.get("appTrafficRule") is not None else None,
            "changeAppInstanceStateOpConfig": obj.get("changeAppInstanceStateOpConfig"),
            "mecVersion": obj.get("mecVersion"),
            "swImageDescriptor": obj.get("swImageDescriptor"),
            "terminateAppInstanceOpConfig": obj.get("terminateAppInstanceOpConfig"),
            "transportDependencies": [TransportDependency.from_dict(_item) for _item in obj["transportDependencies"]] if obj.get("transportDependencies") is not None else None,
            "virtualComputeDescriptor": obj.get("virtualComputeDescriptor"),
            "virtualStorageDescriptor": obj.get("virtualStorageDescriptor")
        })
        return _obj


