# coding: utf-8

"""
    ETSI GS MEC 010-2 - Part 2: Application lifecycle, rules and requirements management

    ETSI GS MEC 010-2 - Part 2: Application lifecycle, rules and requirements management described using OpenAPI.

    The version of the OpenAPI document: 2.1.1
    Contact: cti_support@etsi.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class TrafficFilter(BaseModel):
    """
    TrafficFilter
    """ # noqa: E501
    d_scp: Optional[StrictInt] = Field(default=None, description="Used to match all IPv4 packets that have the same DSCP.", alias="dSCP")
    dst_address: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="A IP address or a range of IP addresses.For IPv4, the IP address could be an IP address plus mask, or an individual IP address, or a range of IP addresses.For IPv6, the IP address could be an IP prefix, or a range of IP prefixes.", alias="dstAddress")
    dst_port: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="A port or a range of ports.", alias="dstPort")
    dst_tunnel_port: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="Used for GTP tunnel based traffic rule.", alias="dstTunnelPort")
    protocol: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="Specify the protocol of the traffic filter.")
    q_ci: Optional[StrictInt] = Field(default=None, description="Used to match all packets that have the same QCI.", alias="qCI")
    src_address: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="An IP address or a range of IP addresses.For IPv4, the IP address could be an IP address plus mask, or an individual IP address, or a range of IP addresses.For IPv6, the IP address could be an IP prefix, or a range of IP prefixes.", alias="srcAddress")
    src_port: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="A port or a range of ports.", alias="srcPort")
    src_tunnel_address: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="Used for GTP tunnel based traffic rule.", alias="srcTunnelAddress")
    src_tunnel_port: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="Used for GTP tunnel based traffic rule.", alias="srcTunnelPort")
    t_c: Optional[StrictInt] = Field(default=None, description="Used to match all IPv6 packets that have the same TC.", alias="tC")
    tag: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="Used for tag based traffic rule.")
    tgt_tunnel_address: Optional[Annotated[List[StrictStr], Field(min_length=0)]] = Field(default=None, description="Used for GTP tunnel based traffic rule.", alias="tgtTunnelAddress")
    __properties: ClassVar[List[str]] = ["dSCP", "dstAddress", "dstPort", "dstTunnelPort", "protocol", "qCI", "srcAddress", "srcPort", "srcTunnelAddress", "srcTunnelPort", "tC", "tag", "tgtTunnelAddress"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TrafficFilter from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TrafficFilter from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "dSCP": obj.get("dSCP"),
            "dstAddress": obj.get("dstAddress"),
            "dstPort": obj.get("dstPort"),
            "dstTunnelPort": obj.get("dstTunnelPort"),
            "protocol": obj.get("protocol"),
            "qCI": obj.get("qCI"),
            "srcAddress": obj.get("srcAddress"),
            "srcPort": obj.get("srcPort"),
            "srcTunnelAddress": obj.get("srcTunnelAddress"),
            "srcTunnelPort": obj.get("srcTunnelPort"),
            "tC": obj.get("tC"),
            "tag": obj.get("tag"),
            "tgtTunnelAddress": obj.get("tgtTunnelAddress")
        })
        return _obj


