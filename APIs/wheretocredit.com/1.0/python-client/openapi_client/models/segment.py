# coding: utf-8

"""
    Where to Credit API

    The Where to Credit API provides mileage earning calculations for frequent flyer programs around the world.

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class Segment(BaseModel):
    """
    Segment
    """ # noqa: E501
    booking_class: StrictStr = Field(description="Single-letter booking class used to determine the earning rate for the flight segment.", alias="bookingClass")
    carrier: StrictStr = Field(description="Two-letter IATA carrier code for the marketing airline.  This is used to determine which earnings chart will be applied for this segment.  NOTE: Frequent flyer programs based on operating carrier, including but not limited to Star Alliance carriers, cannot be reliably mapped to a booking class and will not be accurately reflected in this API.")
    departure: Optional[datetime] = Field(default=None, description="The date on the flight will depart from the origin to go to the destination.  This is used to determine which earnings chart will be in effect at time of departure.")
    destination: StrictStr = Field(description="Three-letter IATA airport code to which the flight is going.")
    distance: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The number of miles for this flight segment.  Otherwise, distance is calculated using the great-circle distance between the origin and destination and may not match other data sources exactly.")
    flight_number: Optional[StrictInt] = Field(default=None, description="The airline identifier for the flight segment, most commonly (but not always) a number and is used for earning charts that are restricted to specific flight numbers.", alias="flightNumber")
    operating_carrier: Optional[StrictStr] = Field(default=None, description="Two-letter IATA carrier code for the operating airline.  This value is only used when earning is based on marketing carrier but restricted to a specific operating carrier.  Leaving this value blank will assume the flight is operated by the marketing carrier.", alias="operatingCarrier")
    origin: StrictStr = Field(description="Three-letter IATA airport code from which the flight will depart.")
    __properties: ClassVar[List[str]] = ["bookingClass", "carrier", "departure", "destination", "distance", "flightNumber", "operatingCarrier", "origin"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Segment from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if departure (nullable) is None
        # and model_fields_set contains the field
        if self.departure is None and "departure" in self.model_fields_set:
            _dict['departure'] = None

        # set to None if distance (nullable) is None
        # and model_fields_set contains the field
        if self.distance is None and "distance" in self.model_fields_set:
            _dict['distance'] = None

        # set to None if flight_number (nullable) is None
        # and model_fields_set contains the field
        if self.flight_number is None and "flight_number" in self.model_fields_set:
            _dict['flightNumber'] = None

        # set to None if operating_carrier (nullable) is None
        # and model_fields_set contains the field
        if self.operating_carrier is None and "operating_carrier" in self.model_fields_set:
            _dict['operatingCarrier'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Segment from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "bookingClass": obj.get("bookingClass"),
            "carrier": obj.get("carrier"),
            "departure": obj.get("departure"),
            "destination": obj.get("destination"),
            "distance": obj.get("distance"),
            "flightNumber": obj.get("flightNumber"),
            "operatingCarrier": obj.get("operatingCarrier"),
            "origin": obj.get("origin")
        })
        return _obj


