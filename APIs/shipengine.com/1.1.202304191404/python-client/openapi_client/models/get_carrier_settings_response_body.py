# coding: utf-8

"""
    ShipEngine API

    ShipEngine's easy-to-use REST API lets you manage all of your shipping needs without worrying about the complexities of different carrier APIs and protocols. We handle all the heavy lifting so you can focus on providing a first-class shipping experience for your customers at the best possible prices.  Each of ShipEngine's features can be used by itself or in conjunction with each other to build powerful shipping functionality into your application or service.  ## Getting Started If you're new to REST APIs then be sure to read our [introduction to REST](https://www.shipengine.com/docs/rest/) to understand the basics.  Learn how to [authenticate yourself to ShipEngine](https://www.shipengine.com/docs/auth/), and then use our [sandbox environment](https://www.shipengine.com/docs/sandbox/) to kick the tires and get familiar with our API. If you run into any problems, then be sure to check the [error handling guide](https://www.shipengine.com/docs/errors/) for tips.  Here are some step-by-step **tutorials** to get you started:    - [Learn how to create your first shipping label](https://www.shipengine.com/docs/labels/create-a-label/)   - [Calculate shipping costs and compare rates across carriers](https://www.shipengine.com/docs/rates/)   - [Track packages on-demand or in real time](https://www.shipengine.com/docs/tracking/)   - [Validate mailing addresses anywhere on Earth](https://www.shipengine.com/docs/addresses/validation/)   ## Shipping Labels for Every Major Carrier ShipEngine makes it easy to [create shipping labels for any carrier](https://www.shipengine.com/docs/labels/create-a-label/) and [download them](https://www.shipengine.com/docs/labels/downloading/) in a [variety of file formats](https://www.shipengine.com/docs/labels/formats/). You can even customize labels with your own [messages](https://www.shipengine.com/docs/labels/messages/) and [images](https://www.shipengine.com/docs/labels/branding/).   ## Real-Time Package Tracking With ShipEngine you can [get the current status of a package](https://www.shipengine.com/docs/tracking/) or [subscribe to real-time tracking updates](https://www.shipengine.com/docs/tracking/webhooks/) via webhooks. You can also create [custimized tracking pages](https://www.shipengine.com/docs/tracking/branded-tracking-page/) with your own branding so your customers will always know where their package is.   ## Compare Shipping Costs Across Carriers Make sure you ship as cost-effectively as possible by [comparing rates across carriers](https://www.shipengine.com/docs/rates/get-shipment-rates/) using the ShipEngine Rates API. Or if you don't know the full shipment details yet, then you can [get rate estimates](https://www.shipengine.com/docs/rates/estimate/) with limited address info.   ## Worldwide Address Validation ShipEngine supports [address validation](https://www.shipengine.com/docs/addresses/validation/) for virtually [every country on Earth](https://www.shipengine.com/docs/addresses/validation/countries/), including the United States, Canada, Great Britain, Australia, Germany, France, Norway, Spain, Sweden, Israel, Italy, and over 160 others. 

    The version of the OpenAPI document: 1.1.202304191404
    Contact: sales@shipengine.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import json
import pprint
from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
from typing import Any, List, Optional
from openapi_client.models.dhl_express_settings_response_body import DhlExpressSettingsResponseBody
from openapi_client.models.fedex_settings_response_body import FedexSettingsResponseBody
from openapi_client.models.ups_settings_response_body import UpsSettingsResponseBody
from pydantic import StrictStr, Field
from typing import Union, List, Set, Optional, Dict
from typing_extensions import Literal, Self

GETCARRIERSETTINGSRESPONSEBODY_ONE_OF_SCHEMAS = ["DhlExpressSettingsResponseBody", "FedexSettingsResponseBody", "UpsSettingsResponseBody"]

class GetCarrierSettingsResponseBody(BaseModel):
    """
    GetCarrierSettingsResponseBody
    """
    # data type: DhlExpressSettingsResponseBody
    oneof_schema_1_validator: Optional[DhlExpressSettingsResponseBody] = None
    # data type: FedexSettingsResponseBody
    oneof_schema_2_validator: Optional[FedexSettingsResponseBody] = None
    # data type: UpsSettingsResponseBody
    oneof_schema_3_validator: Optional[UpsSettingsResponseBody] = None
    actual_instance: Optional[Union[DhlExpressSettingsResponseBody, FedexSettingsResponseBody, UpsSettingsResponseBody]] = None
    one_of_schemas: Set[str] = { "DhlExpressSettingsResponseBody", "FedexSettingsResponseBody", "UpsSettingsResponseBody" }

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
    )


    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = GetCarrierSettingsResponseBody.model_construct()
        error_messages = []
        match = 0
        # validate data type: DhlExpressSettingsResponseBody
        if not isinstance(v, DhlExpressSettingsResponseBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `DhlExpressSettingsResponseBody`")
        else:
            match += 1
        # validate data type: FedexSettingsResponseBody
        if not isinstance(v, FedexSettingsResponseBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `FedexSettingsResponseBody`")
        else:
            match += 1
        # validate data type: UpsSettingsResponseBody
        if not isinstance(v, UpsSettingsResponseBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `UpsSettingsResponseBody`")
        else:
            match += 1
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting `actual_instance` in GetCarrierSettingsResponseBody with oneOf schemas: DhlExpressSettingsResponseBody, FedexSettingsResponseBody, UpsSettingsResponseBody. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting `actual_instance` in GetCarrierSettingsResponseBody with oneOf schemas: DhlExpressSettingsResponseBody, FedexSettingsResponseBody, UpsSettingsResponseBody. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into DhlExpressSettingsResponseBody
        try:
            instance.actual_instance = DhlExpressSettingsResponseBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into FedexSettingsResponseBody
        try:
            instance.actual_instance = FedexSettingsResponseBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into UpsSettingsResponseBody
        try:
            instance.actual_instance = UpsSettingsResponseBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into GetCarrierSettingsResponseBody with oneOf schemas: DhlExpressSettingsResponseBody, FedexSettingsResponseBody, UpsSettingsResponseBody. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into GetCarrierSettingsResponseBody with oneOf schemas: DhlExpressSettingsResponseBody, FedexSettingsResponseBody, UpsSettingsResponseBody. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Optional[Union[Dict[str, Any], DhlExpressSettingsResponseBody, FedexSettingsResponseBody, UpsSettingsResponseBody]]:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())


