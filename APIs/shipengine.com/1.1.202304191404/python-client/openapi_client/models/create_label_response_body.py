# coding: utf-8

"""
    ShipEngine API

    ShipEngine's easy-to-use REST API lets you manage all of your shipping needs without worrying about the complexities of different carrier APIs and protocols. We handle all the heavy lifting so you can focus on providing a first-class shipping experience for your customers at the best possible prices.  Each of ShipEngine's features can be used by itself or in conjunction with each other to build powerful shipping functionality into your application or service.  ## Getting Started If you're new to REST APIs then be sure to read our [introduction to REST](https://www.shipengine.com/docs/rest/) to understand the basics.  Learn how to [authenticate yourself to ShipEngine](https://www.shipengine.com/docs/auth/), and then use our [sandbox environment](https://www.shipengine.com/docs/sandbox/) to kick the tires and get familiar with our API. If you run into any problems, then be sure to check the [error handling guide](https://www.shipengine.com/docs/errors/) for tips.  Here are some step-by-step **tutorials** to get you started:    - [Learn how to create your first shipping label](https://www.shipengine.com/docs/labels/create-a-label/)   - [Calculate shipping costs and compare rates across carriers](https://www.shipengine.com/docs/rates/)   - [Track packages on-demand or in real time](https://www.shipengine.com/docs/tracking/)   - [Validate mailing addresses anywhere on Earth](https://www.shipengine.com/docs/addresses/validation/)   ## Shipping Labels for Every Major Carrier ShipEngine makes it easy to [create shipping labels for any carrier](https://www.shipengine.com/docs/labels/create-a-label/) and [download them](https://www.shipengine.com/docs/labels/downloading/) in a [variety of file formats](https://www.shipengine.com/docs/labels/formats/). You can even customize labels with your own [messages](https://www.shipengine.com/docs/labels/messages/) and [images](https://www.shipengine.com/docs/labels/branding/).   ## Real-Time Package Tracking With ShipEngine you can [get the current status of a package](https://www.shipengine.com/docs/tracking/) or [subscribe to real-time tracking updates](https://www.shipengine.com/docs/tracking/webhooks/) via webhooks. You can also create [custimized tracking pages](https://www.shipengine.com/docs/tracking/branded-tracking-page/) with your own branding so your customers will always know where their package is.   ## Compare Shipping Costs Across Carriers Make sure you ship as cost-effectively as possible by [comparing rates across carriers](https://www.shipengine.com/docs/rates/get-shipment-rates/) using the ShipEngine Rates API. Or if you don't know the full shipment details yet, then you can [get rate estimates](https://www.shipengine.com/docs/rates/estimate/) with limited address info.   ## Worldwide Address Validation ShipEngine supports [address validation](https://www.shipengine.com/docs/addresses/validation/) for virtually [every country on Earth](https://www.shipengine.com/docs/addresses/validation/countries/), including the United States, Canada, Great Britain, Australia, Germany, France, Norway, Spain, Sweden, Israel, Italy, and over 160 others. 

    The version of the OpenAPI document: 1.1.202304191404
    Contact: sales@shipengine.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.alternative_identifier import AlternativeIdentifier
from openapi_client.models.display_scheme import DisplayScheme
from openapi_client.models.label_charge_event import LabelChargeEvent
from openapi_client.models.label_download import LabelDownload
from openapi_client.models.label_download_type import LabelDownloadType
from openapi_client.models.label_format import LabelFormat
from openapi_client.models.label_layout import LabelLayout
from openapi_client.models.label_status import LabelStatus
from openapi_client.models.link import Link
from openapi_client.models.monetary_value import MonetaryValue
from openapi_client.models.package import Package
from openapi_client.models.shipment import Shipment
from openapi_client.models.tracking_status import TrackingStatus
from openapi_client.models.validate_address import ValidateAddress
from typing import Optional, Set
from typing_extensions import Self

class CreateLabelResponseBody(BaseModel):
    """
    A create label response body
    """ # noqa: E501
    alternative_identifiers: Optional[List[AlternativeIdentifier]] = Field(default=None, description="Additional information some carriers may provide by which to identify a given label in their system.  ")
    batch_id: Annotated[str, Field(min_length=1, strict=True, max_length=25)] = Field(description="If this label was created as part of a [batch](https://www.shipengine.com/docs/labels/bulk/), then this is the unique ID of that batch. ")
    carrier_code: Annotated[str, Field(strict=True)] = Field(description="The [shipping carrier](https://www.shipengine.com/docs/carriers/setup/) who will ship the package, such as `fedex`, `dhl_express`, `stamps_com`, etc. ")
    carrier_id: Annotated[str, Field(min_length=1, strict=True, max_length=25)] = Field(description="The unique ID of the [carrier account](https://www.shipengine.com/docs/carriers/setup/) that was used to create this label ")
    charge_event: LabelChargeEvent = Field(description="The label charge event. ")
    created_at: datetime = Field(description="The date and time that the label was created in ShipEngine.")
    display_scheme: DisplayScheme = Field(description="The display format that the label should be shown in.")
    form_download: Optional[Link] = Field(description="The link to download the customs form (a.k.a. commercial invoice) for this shipment, if any.  Forms are in PDF format. This field is null if the shipment does not require a customs form, or if the carrier does not support it. ")
    insurance_claim: Optional[Link] = Field(description="The link to submit an insurance claim for the shipment.  This field is null if the shipment is not insured or if the insurance provider does not support online claim submission. ")
    insurance_cost: MonetaryValue = Field(description="The insurance cost for this package.  Add this to the `shipment_cost` field to get the total cost. ")
    is_international: StrictBool = Field(description="Indicates whether this is an international shipment.  That is, the originating country and destination country are different. ")
    is_return_label: StrictBool = Field(description="Indicates whether this is a return label.  You may also want to set the `rma_number` so you know what is being returned. ")
    label_download: LabelDownload
    label_download_type: Optional[LabelDownloadType] = None
    label_format: LabelFormat = Field(description="The file format that you want the label to be in.  We recommend `pdf` format because it is supported by all carriers, whereas some carriers do not support the `png` or `zpl` formats. ")
    label_id: Annotated[str, Field(min_length=1, strict=True, max_length=25)] = Field(description="A string that uniquely identifies the label. This ID is generated by ShipEngine when the label is created. ")
    label_image_id: Optional[Annotated[str, Field(min_length=4, strict=True)]] = Field(description="The label image resource that was used to create a custom label image.")
    label_layout: LabelLayout = Field(description="The layout (size) that you want the label to be in.  The `label_format` determines which sizes are allowed.  `4x6` is supported for all label formats, whereas `letter` (8.5\" x 11\") is only supported for `pdf` format. ")
    outbound_label_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=25)]] = Field(default=None, description="The `label_id` of the original (outgoing) label that the return label is for. This associates the two labels together, which is required by some carriers. ")
    package_code: Annotated[str, Field(strict=True)] = Field(description="The [package type](https://www.shipengine.com/docs/reference/list-carrier-packages/), such as `thick_envelope`, `small_flat_rate_box`, `large_package`, etc.  The code `package` indicates a custom or unknown package type. ")
    packages: List[Package] = Field(description="The label's package(s).  > **Note:** Some carriers only allow one package per label.  If you attempt to create a multi-package label for a carrier that doesn't allow it, an error will be returned. ")
    rma_number: Optional[StrictStr] = Field(description="An optional Return Merchandise Authorization number.  This field is useful for return labels.  You can set it to any string value. ")
    service_code: Annotated[str, Field(strict=True)] = Field(description="The [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/) used to ship the package, such as `fedex_ground`, `usps_first_class_mail`, `flat_rate_envelope`, etc. ")
    ship_date: datetime = Field(description="The date that the package was (or will be) shippped.  ShipEngine will take the day of week into consideration. For example, if the carrier does not operate on Sundays, then a package that would have shipped on Sunday will ship on Monday instead. ")
    shipment: Optional[Shipment] = Field(default=None, description="The shipment information used to generate the label")
    shipment_cost: MonetaryValue = Field(description="The cost of shipping, delivery confirmation, and other carrier charges.  This amount **does not** include insurance costs. ")
    shipment_id: Annotated[str, Field(min_length=1, strict=True, max_length=25)] = Field(description="The shipment that this label is for.  ShipEngine can create a shipment for you automatically when you [create a label](https://www.shipengine.com/docs/labels/create-a-label/), or you can [create your own shipment](https://www.shipengine.com/docs/shipping/create-a-shipment/) and then [use it to print a label](https://www.shipengine.com/docs/labels/create-from-shipment/) ")
    status: LabelStatus
    test_label: Optional[StrictBool] = Field(default=False, description="Indicate if this label is being used only for testing purposes. If true, then no charge will be added to your account.")
    trackable: StrictBool = Field(description="Indicates whether the shipment is trackable, in which case the `tracking_status` field will reflect the current status and each package will have a `tracking_number`. ")
    tracking_number: Annotated[str, Field(min_length=1, strict=True)] = Field(description="The tracking number for the package. Tracking number formats vary across carriers.")
    tracking_status: TrackingStatus = Field(description="The current status of the package, such as `in_transit` or `delivered`")
    validate_address: Optional[ValidateAddress] = None
    voided: StrictBool = Field(description="Indicates whether the label has been [voided](https://www.shipengine.com/docs/labels/voiding/) ")
    voided_at: Optional[datetime] = Field(description="The date and time that the label was [voided](https://www.shipengine.com/docs/labels/voiding/), or `null` if the label has not been voided ")
    __properties: ClassVar[List[str]] = ["alternative_identifiers", "batch_id", "carrier_code", "carrier_id", "charge_event", "created_at", "display_scheme", "form_download", "insurance_claim", "insurance_cost", "is_international", "is_return_label", "label_download", "label_download_type", "label_format", "label_id", "label_image_id", "label_layout", "outbound_label_id", "package_code", "packages", "rma_number", "service_code", "ship_date", "shipment", "shipment_cost", "shipment_id", "status", "test_label", "trackable", "tracking_number", "tracking_status", "validate_address", "voided", "voided_at"]

    @field_validator('batch_id')
    def batch_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^se(-[a-z0-9]+)+$", value):
            raise ValueError(r"must validate the regular expression /^se(-[a-z0-9]+)+$/")
        return value

    @field_validator('carrier_code')
    def carrier_code_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^[a-z0-9]+(_[a-z0-9]+)*$", value):
            raise ValueError(r"must validate the regular expression /^[a-z0-9]+(_[a-z0-9]+)*$/")
        return value

    @field_validator('carrier_id')
    def carrier_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^se(-[a-z0-9]+)+$", value):
            raise ValueError(r"must validate the regular expression /^se(-[a-z0-9]+)+$/")
        return value

    @field_validator('created_at')
    def created_at_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]\d{2}:\d{2})$", value):
            raise ValueError(r"must validate the regular expression /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]\d{2}:\d{2})$/")
        return value

    @field_validator('label_id')
    def label_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^se(-[a-z0-9]+)+$", value):
            raise ValueError(r"must validate the regular expression /^se(-[a-z0-9]+)+$/")
        return value

    @field_validator('outbound_label_id')
    def outbound_label_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^se(-[a-z0-9]+)+$", value):
            raise ValueError(r"must validate the regular expression /^se(-[a-z0-9]+)+$/")
        return value

    @field_validator('package_code')
    def package_code_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^[a-z0-9]+(_[a-z0-9]+)*$", value):
            raise ValueError(r"must validate the regular expression /^[a-z0-9]+(_[a-z0-9]+)*$/")
        return value

    @field_validator('service_code')
    def service_code_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^[a-z0-9]+(_[a-z0-9-]+)* ?$", value):
            raise ValueError(r"must validate the regular expression /^[a-z0-9]+(_[a-z0-9-]+)* ?$/")
        return value

    @field_validator('ship_date')
    def ship_date_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]\d{2}:\d{2}))?$", value):
            raise ValueError(r"must validate the regular expression /^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]\d{2}:\d{2}))?$/")
        return value

    @field_validator('shipment_id')
    def shipment_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^se(-[a-z0-9]+)+$", value):
            raise ValueError(r"must validate the regular expression /^se(-[a-z0-9]+)+$/")
        return value

    @field_validator('voided_at')
    def voided_at_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]\d{2}:\d{2})$", value):
            raise ValueError(r"must validate the regular expression /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]\d{2}:\d{2})$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateLabelResponseBody from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "alternative_identifiers",
            "batch_id",
            "carrier_code",
            "carrier_id",
            "created_at",
            "form_download",
            "insurance_claim",
            "insurance_cost",
            "is_international",
            "label_download",
            "label_id",
            "package_code",
            "packages",
            "service_code",
            "ship_date",
            "shipment_cost",
            "shipment_id",
            "status",
            "trackable",
            "tracking_number",
            "tracking_status",
            "voided",
            "voided_at",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in alternative_identifiers (list)
        _items = []
        if self.alternative_identifiers:
            for _item_alternative_identifiers in self.alternative_identifiers:
                if _item_alternative_identifiers:
                    _items.append(_item_alternative_identifiers.to_dict())
            _dict['alternative_identifiers'] = _items
        # override the default output from pydantic by calling `to_dict()` of form_download
        if self.form_download:
            _dict['form_download'] = self.form_download.to_dict()
        # override the default output from pydantic by calling `to_dict()` of insurance_claim
        if self.insurance_claim:
            _dict['insurance_claim'] = self.insurance_claim.to_dict()
        # override the default output from pydantic by calling `to_dict()` of insurance_cost
        if self.insurance_cost:
            _dict['insurance_cost'] = self.insurance_cost.to_dict()
        # override the default output from pydantic by calling `to_dict()` of label_download
        if self.label_download:
            _dict['label_download'] = self.label_download.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in packages (list)
        _items = []
        if self.packages:
            for _item_packages in self.packages:
                if _item_packages:
                    _items.append(_item_packages.to_dict())
            _dict['packages'] = _items
        # override the default output from pydantic by calling `to_dict()` of shipment
        if self.shipment:
            _dict['shipment'] = self.shipment.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shipment_cost
        if self.shipment_cost:
            _dict['shipment_cost'] = self.shipment_cost.to_dict()
        # set to None if alternative_identifiers (nullable) is None
        # and model_fields_set contains the field
        if self.alternative_identifiers is None and "alternative_identifiers" in self.model_fields_set:
            _dict['alternative_identifiers'] = None

        # set to None if form_download (nullable) is None
        # and model_fields_set contains the field
        if self.form_download is None and "form_download" in self.model_fields_set:
            _dict['form_download'] = None

        # set to None if insurance_claim (nullable) is None
        # and model_fields_set contains the field
        if self.insurance_claim is None and "insurance_claim" in self.model_fields_set:
            _dict['insurance_claim'] = None

        # set to None if label_image_id (nullable) is None
        # and model_fields_set contains the field
        if self.label_image_id is None and "label_image_id" in self.model_fields_set:
            _dict['label_image_id'] = None

        # set to None if rma_number (nullable) is None
        # and model_fields_set contains the field
        if self.rma_number is None and "rma_number" in self.model_fields_set:
            _dict['rma_number'] = None

        # set to None if voided_at (nullable) is None
        # and model_fields_set contains the field
        if self.voided_at is None and "voided_at" in self.model_fields_set:
            _dict['voided_at'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateLabelResponseBody from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "alternative_identifiers": [AlternativeIdentifier.from_dict(_item) for _item in obj["alternative_identifiers"]] if obj.get("alternative_identifiers") is not None else None,
            "batch_id": obj.get("batch_id"),
            "carrier_code": obj.get("carrier_code"),
            "carrier_id": obj.get("carrier_id"),
            "charge_event": obj.get("charge_event"),
            "created_at": obj.get("created_at"),
            "display_scheme": obj.get("display_scheme"),
            "form_download": Link.from_dict(obj["form_download"]) if obj.get("form_download") is not None else None,
            "insurance_claim": Link.from_dict(obj["insurance_claim"]) if obj.get("insurance_claim") is not None else None,
            "insurance_cost": MonetaryValue.from_dict(obj["insurance_cost"]) if obj.get("insurance_cost") is not None else None,
            "is_international": obj.get("is_international"),
            "is_return_label": obj.get("is_return_label"),
            "label_download": LabelDownload.from_dict(obj["label_download"]) if obj.get("label_download") is not None else None,
            "label_download_type": obj.get("label_download_type"),
            "label_format": obj.get("label_format"),
            "label_id": obj.get("label_id"),
            "label_image_id": obj.get("label_image_id"),
            "label_layout": obj.get("label_layout"),
            "outbound_label_id": obj.get("outbound_label_id"),
            "package_code": obj.get("package_code"),
            "packages": [Package.from_dict(_item) for _item in obj["packages"]] if obj.get("packages") is not None else None,
            "rma_number": obj.get("rma_number"),
            "service_code": obj.get("service_code"),
            "ship_date": obj.get("ship_date"),
            "shipment": Shipment.from_dict(obj["shipment"]) if obj.get("shipment") is not None else None,
            "shipment_cost": MonetaryValue.from_dict(obj["shipment_cost"]) if obj.get("shipment_cost") is not None else None,
            "shipment_id": obj.get("shipment_id"),
            "status": obj.get("status"),
            "test_label": obj.get("test_label") if obj.get("test_label") is not None else False,
            "trackable": obj.get("trackable"),
            "tracking_number": obj.get("tracking_number"),
            "tracking_status": obj.get("tracking_status"),
            "validate_address": obj.get("validate_address"),
            "voided": obj.get("voided"),
            "voided_at": obj.get("voided_at")
        })
        return _obj


