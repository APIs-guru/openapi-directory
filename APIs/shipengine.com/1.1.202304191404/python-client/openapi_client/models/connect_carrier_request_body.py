# coding: utf-8

"""
    ShipEngine API

    ShipEngine's easy-to-use REST API lets you manage all of your shipping needs without worrying about the complexities of different carrier APIs and protocols. We handle all the heavy lifting so you can focus on providing a first-class shipping experience for your customers at the best possible prices.  Each of ShipEngine's features can be used by itself or in conjunction with each other to build powerful shipping functionality into your application or service.  ## Getting Started If you're new to REST APIs then be sure to read our [introduction to REST](https://www.shipengine.com/docs/rest/) to understand the basics.  Learn how to [authenticate yourself to ShipEngine](https://www.shipengine.com/docs/auth/), and then use our [sandbox environment](https://www.shipengine.com/docs/sandbox/) to kick the tires and get familiar with our API. If you run into any problems, then be sure to check the [error handling guide](https://www.shipengine.com/docs/errors/) for tips.  Here are some step-by-step **tutorials** to get you started:    - [Learn how to create your first shipping label](https://www.shipengine.com/docs/labels/create-a-label/)   - [Calculate shipping costs and compare rates across carriers](https://www.shipengine.com/docs/rates/)   - [Track packages on-demand or in real time](https://www.shipengine.com/docs/tracking/)   - [Validate mailing addresses anywhere on Earth](https://www.shipengine.com/docs/addresses/validation/)   ## Shipping Labels for Every Major Carrier ShipEngine makes it easy to [create shipping labels for any carrier](https://www.shipengine.com/docs/labels/create-a-label/) and [download them](https://www.shipengine.com/docs/labels/downloading/) in a [variety of file formats](https://www.shipengine.com/docs/labels/formats/). You can even customize labels with your own [messages](https://www.shipengine.com/docs/labels/messages/) and [images](https://www.shipengine.com/docs/labels/branding/).   ## Real-Time Package Tracking With ShipEngine you can [get the current status of a package](https://www.shipengine.com/docs/tracking/) or [subscribe to real-time tracking updates](https://www.shipengine.com/docs/tracking/webhooks/) via webhooks. You can also create [custimized tracking pages](https://www.shipengine.com/docs/tracking/branded-tracking-page/) with your own branding so your customers will always know where their package is.   ## Compare Shipping Costs Across Carriers Make sure you ship as cost-effectively as possible by [comparing rates across carriers](https://www.shipengine.com/docs/rates/get-shipment-rates/) using the ShipEngine Rates API. Or if you don't know the full shipment details yet, then you can [get rate estimates](https://www.shipengine.com/docs/rates/estimate/) with limited address info.   ## Worldwide Address Validation ShipEngine supports [address validation](https://www.shipengine.com/docs/addresses/validation/) for virtually [every country on Earth](https://www.shipengine.com/docs/addresses/validation/countries/), including the United States, Canada, Great Britain, Australia, Germany, France, Norway, Spain, Sweden, Israel, Italy, and over 160 others. 

    The version of the OpenAPI document: 1.1.202304191404
    Contact: sales@shipengine.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import json
import pprint
from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
from typing import Any, List, Optional
from openapi_client.models.connect_access_worldwide_request_body import ConnectAccessWorldwideRequestBody
from openapi_client.models.connect_amazon_buy_shipping_request_body import ConnectAmazonBuyShippingRequestBody
from openapi_client.models.connect_amazon_shipping_uk import ConnectAmazonShippingUk
from openapi_client.models.connect_apc_request_body import ConnectApcRequestBody
from openapi_client.models.connect_asendia_request_body import ConnectAsendiaRequestBody
from openapi_client.models.connect_australia_post_request_body import ConnectAustraliaPostRequestBody
from openapi_client.models.connect_canada_post_request_body import ConnectCanadaPostRequestBody
from openapi_client.models.connect_dhl_ecommerce_request_body import ConnectDhlEcommerceRequestBody
from openapi_client.models.connect_dhl_express_au_request_body import ConnectDhlExpressAuRequestBody
from openapi_client.models.connect_dhl_express_ca_request_body import ConnectDhlExpressCaRequestBody
from openapi_client.models.connect_dhl_express_request_body import ConnectDhlExpressRequestBody
from openapi_client.models.connect_dhl_express_uk_request_body import ConnectDhlExpressUkRequestBody
from openapi_client.models.connect_dpd_request_body import ConnectDpdRequestBody
from openapi_client.models.connect_endicia_request_body import ConnectEndiciaRequestBody
from openapi_client.models.connect_fedex_request_body import ConnectFedexRequestBody
from openapi_client.models.connect_fedex_uk_request_body import ConnectFedexUkRequestBody
from openapi_client.models.connect_firstmile_request_body import ConnectFirstmileRequestBody
from openapi_client.models.connect_imex_request_body import ConnectImexRequestBody
from openapi_client.models.connect_newgistics_request_body import ConnectNewgisticsRequestBody
from openapi_client.models.connect_ontrac_request_body import ConnectOntracRequestBody
from openapi_client.models.connect_purolator_request_body import ConnectPurolatorRequestBody
from openapi_client.models.connect_royal_mail_request_body import ConnectRoyalMailRequestBody
from openapi_client.models.connect_rr_donnelley_request_body import ConnectRrDonnelleyRequestBody
from openapi_client.models.connect_seko_request_body import ConnectSekoRequestBody
from openapi_client.models.connect_sendle_request_body import ConnectSendleRequestBody
from openapi_client.models.connect_stamps_request_body import ConnectStampsRequestBody
from openapi_client.models.connect_ups_request_body import ConnectUpsRequestBody
from pydantic import StrictStr, Field
from typing import Union, List, Set, Optional, Dict
from typing_extensions import Literal, Self

CONNECTCARRIERREQUESTBODY_ONE_OF_SCHEMAS = ["ConnectAccessWorldwideRequestBody", "ConnectAmazonBuyShippingRequestBody", "ConnectAmazonShippingUk", "ConnectApcRequestBody", "ConnectAsendiaRequestBody", "ConnectAustraliaPostRequestBody", "ConnectCanadaPostRequestBody", "ConnectDhlEcommerceRequestBody", "ConnectDhlExpressAuRequestBody", "ConnectDhlExpressCaRequestBody", "ConnectDhlExpressRequestBody", "ConnectDhlExpressUkRequestBody", "ConnectDpdRequestBody", "ConnectEndiciaRequestBody", "ConnectFedexRequestBody", "ConnectFedexUkRequestBody", "ConnectFirstmileRequestBody", "ConnectImexRequestBody", "ConnectNewgisticsRequestBody", "ConnectOntracRequestBody", "ConnectPurolatorRequestBody", "ConnectRoyalMailRequestBody", "ConnectRrDonnelleyRequestBody", "ConnectSekoRequestBody", "ConnectSendleRequestBody", "ConnectStampsRequestBody", "ConnectUpsRequestBody"]

class ConnectCarrierRequestBody(BaseModel):
    """
    ConnectCarrierRequestBody
    """
    # data type: ConnectAccessWorldwideRequestBody
    oneof_schema_1_validator: Optional[ConnectAccessWorldwideRequestBody] = None
    # data type: ConnectAmazonBuyShippingRequestBody
    oneof_schema_2_validator: Optional[ConnectAmazonBuyShippingRequestBody] = None
    # data type: ConnectAmazonShippingUk
    oneof_schema_3_validator: Optional[ConnectAmazonShippingUk] = None
    # data type: ConnectApcRequestBody
    oneof_schema_4_validator: Optional[ConnectApcRequestBody] = None
    # data type: ConnectAsendiaRequestBody
    oneof_schema_5_validator: Optional[ConnectAsendiaRequestBody] = None
    # data type: ConnectAustraliaPostRequestBody
    oneof_schema_6_validator: Optional[ConnectAustraliaPostRequestBody] = None
    # data type: ConnectCanadaPostRequestBody
    oneof_schema_7_validator: Optional[ConnectCanadaPostRequestBody] = None
    # data type: ConnectDhlEcommerceRequestBody
    oneof_schema_8_validator: Optional[ConnectDhlEcommerceRequestBody] = None
    # data type: ConnectDhlExpressRequestBody
    oneof_schema_9_validator: Optional[ConnectDhlExpressRequestBody] = None
    # data type: ConnectDhlExpressAuRequestBody
    oneof_schema_10_validator: Optional[ConnectDhlExpressAuRequestBody] = None
    # data type: ConnectDhlExpressCaRequestBody
    oneof_schema_11_validator: Optional[ConnectDhlExpressCaRequestBody] = None
    # data type: ConnectDhlExpressUkRequestBody
    oneof_schema_12_validator: Optional[ConnectDhlExpressUkRequestBody] = None
    # data type: ConnectDpdRequestBody
    oneof_schema_13_validator: Optional[ConnectDpdRequestBody] = None
    # data type: ConnectEndiciaRequestBody
    oneof_schema_14_validator: Optional[ConnectEndiciaRequestBody] = None
    # data type: ConnectFedexRequestBody
    oneof_schema_15_validator: Optional[ConnectFedexRequestBody] = None
    # data type: ConnectFedexUkRequestBody
    oneof_schema_16_validator: Optional[ConnectFedexUkRequestBody] = None
    # data type: ConnectFirstmileRequestBody
    oneof_schema_17_validator: Optional[ConnectFirstmileRequestBody] = None
    # data type: ConnectImexRequestBody
    oneof_schema_18_validator: Optional[ConnectImexRequestBody] = None
    # data type: ConnectNewgisticsRequestBody
    oneof_schema_19_validator: Optional[ConnectNewgisticsRequestBody] = None
    # data type: ConnectOntracRequestBody
    oneof_schema_20_validator: Optional[ConnectOntracRequestBody] = None
    # data type: ConnectPurolatorRequestBody
    oneof_schema_21_validator: Optional[ConnectPurolatorRequestBody] = None
    # data type: ConnectRoyalMailRequestBody
    oneof_schema_22_validator: Optional[ConnectRoyalMailRequestBody] = None
    # data type: ConnectRrDonnelleyRequestBody
    oneof_schema_23_validator: Optional[ConnectRrDonnelleyRequestBody] = None
    # data type: ConnectSekoRequestBody
    oneof_schema_24_validator: Optional[ConnectSekoRequestBody] = None
    # data type: ConnectSendleRequestBody
    oneof_schema_25_validator: Optional[ConnectSendleRequestBody] = None
    # data type: ConnectStampsRequestBody
    oneof_schema_26_validator: Optional[ConnectStampsRequestBody] = None
    # data type: ConnectUpsRequestBody
    oneof_schema_27_validator: Optional[ConnectUpsRequestBody] = None
    actual_instance: Optional[Union[ConnectAccessWorldwideRequestBody, ConnectAmazonBuyShippingRequestBody, ConnectAmazonShippingUk, ConnectApcRequestBody, ConnectAsendiaRequestBody, ConnectAustraliaPostRequestBody, ConnectCanadaPostRequestBody, ConnectDhlEcommerceRequestBody, ConnectDhlExpressAuRequestBody, ConnectDhlExpressCaRequestBody, ConnectDhlExpressRequestBody, ConnectDhlExpressUkRequestBody, ConnectDpdRequestBody, ConnectEndiciaRequestBody, ConnectFedexRequestBody, ConnectFedexUkRequestBody, ConnectFirstmileRequestBody, ConnectImexRequestBody, ConnectNewgisticsRequestBody, ConnectOntracRequestBody, ConnectPurolatorRequestBody, ConnectRoyalMailRequestBody, ConnectRrDonnelleyRequestBody, ConnectSekoRequestBody, ConnectSendleRequestBody, ConnectStampsRequestBody, ConnectUpsRequestBody]] = None
    one_of_schemas: Set[str] = { "ConnectAccessWorldwideRequestBody", "ConnectAmazonBuyShippingRequestBody", "ConnectAmazonShippingUk", "ConnectApcRequestBody", "ConnectAsendiaRequestBody", "ConnectAustraliaPostRequestBody", "ConnectCanadaPostRequestBody", "ConnectDhlEcommerceRequestBody", "ConnectDhlExpressAuRequestBody", "ConnectDhlExpressCaRequestBody", "ConnectDhlExpressRequestBody", "ConnectDhlExpressUkRequestBody", "ConnectDpdRequestBody", "ConnectEndiciaRequestBody", "ConnectFedexRequestBody", "ConnectFedexUkRequestBody", "ConnectFirstmileRequestBody", "ConnectImexRequestBody", "ConnectNewgisticsRequestBody", "ConnectOntracRequestBody", "ConnectPurolatorRequestBody", "ConnectRoyalMailRequestBody", "ConnectRrDonnelleyRequestBody", "ConnectSekoRequestBody", "ConnectSendleRequestBody", "ConnectStampsRequestBody", "ConnectUpsRequestBody" }

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
    )


    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = ConnectCarrierRequestBody.model_construct()
        error_messages = []
        match = 0
        # validate data type: ConnectAccessWorldwideRequestBody
        if not isinstance(v, ConnectAccessWorldwideRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectAccessWorldwideRequestBody`")
        else:
            match += 1
        # validate data type: ConnectAmazonBuyShippingRequestBody
        if not isinstance(v, ConnectAmazonBuyShippingRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectAmazonBuyShippingRequestBody`")
        else:
            match += 1
        # validate data type: ConnectAmazonShippingUk
        if not isinstance(v, ConnectAmazonShippingUk):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectAmazonShippingUk`")
        else:
            match += 1
        # validate data type: ConnectApcRequestBody
        if not isinstance(v, ConnectApcRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectApcRequestBody`")
        else:
            match += 1
        # validate data type: ConnectAsendiaRequestBody
        if not isinstance(v, ConnectAsendiaRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectAsendiaRequestBody`")
        else:
            match += 1
        # validate data type: ConnectAustraliaPostRequestBody
        if not isinstance(v, ConnectAustraliaPostRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectAustraliaPostRequestBody`")
        else:
            match += 1
        # validate data type: ConnectCanadaPostRequestBody
        if not isinstance(v, ConnectCanadaPostRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectCanadaPostRequestBody`")
        else:
            match += 1
        # validate data type: ConnectDhlEcommerceRequestBody
        if not isinstance(v, ConnectDhlEcommerceRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectDhlEcommerceRequestBody`")
        else:
            match += 1
        # validate data type: ConnectDhlExpressRequestBody
        if not isinstance(v, ConnectDhlExpressRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectDhlExpressRequestBody`")
        else:
            match += 1
        # validate data type: ConnectDhlExpressAuRequestBody
        if not isinstance(v, ConnectDhlExpressAuRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectDhlExpressAuRequestBody`")
        else:
            match += 1
        # validate data type: ConnectDhlExpressCaRequestBody
        if not isinstance(v, ConnectDhlExpressCaRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectDhlExpressCaRequestBody`")
        else:
            match += 1
        # validate data type: ConnectDhlExpressUkRequestBody
        if not isinstance(v, ConnectDhlExpressUkRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectDhlExpressUkRequestBody`")
        else:
            match += 1
        # validate data type: ConnectDpdRequestBody
        if not isinstance(v, ConnectDpdRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectDpdRequestBody`")
        else:
            match += 1
        # validate data type: ConnectEndiciaRequestBody
        if not isinstance(v, ConnectEndiciaRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectEndiciaRequestBody`")
        else:
            match += 1
        # validate data type: ConnectFedexRequestBody
        if not isinstance(v, ConnectFedexRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectFedexRequestBody`")
        else:
            match += 1
        # validate data type: ConnectFedexUkRequestBody
        if not isinstance(v, ConnectFedexUkRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectFedexUkRequestBody`")
        else:
            match += 1
        # validate data type: ConnectFirstmileRequestBody
        if not isinstance(v, ConnectFirstmileRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectFirstmileRequestBody`")
        else:
            match += 1
        # validate data type: ConnectImexRequestBody
        if not isinstance(v, ConnectImexRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectImexRequestBody`")
        else:
            match += 1
        # validate data type: ConnectNewgisticsRequestBody
        if not isinstance(v, ConnectNewgisticsRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectNewgisticsRequestBody`")
        else:
            match += 1
        # validate data type: ConnectOntracRequestBody
        if not isinstance(v, ConnectOntracRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectOntracRequestBody`")
        else:
            match += 1
        # validate data type: ConnectPurolatorRequestBody
        if not isinstance(v, ConnectPurolatorRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectPurolatorRequestBody`")
        else:
            match += 1
        # validate data type: ConnectRoyalMailRequestBody
        if not isinstance(v, ConnectRoyalMailRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectRoyalMailRequestBody`")
        else:
            match += 1
        # validate data type: ConnectRrDonnelleyRequestBody
        if not isinstance(v, ConnectRrDonnelleyRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectRrDonnelleyRequestBody`")
        else:
            match += 1
        # validate data type: ConnectSekoRequestBody
        if not isinstance(v, ConnectSekoRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectSekoRequestBody`")
        else:
            match += 1
        # validate data type: ConnectSendleRequestBody
        if not isinstance(v, ConnectSendleRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectSendleRequestBody`")
        else:
            match += 1
        # validate data type: ConnectStampsRequestBody
        if not isinstance(v, ConnectStampsRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectStampsRequestBody`")
        else:
            match += 1
        # validate data type: ConnectUpsRequestBody
        if not isinstance(v, ConnectUpsRequestBody):
            error_messages.append(f"Error! Input type `{type(v)}` is not `ConnectUpsRequestBody`")
        else:
            match += 1
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting `actual_instance` in ConnectCarrierRequestBody with oneOf schemas: ConnectAccessWorldwideRequestBody, ConnectAmazonBuyShippingRequestBody, ConnectAmazonShippingUk, ConnectApcRequestBody, ConnectAsendiaRequestBody, ConnectAustraliaPostRequestBody, ConnectCanadaPostRequestBody, ConnectDhlEcommerceRequestBody, ConnectDhlExpressAuRequestBody, ConnectDhlExpressCaRequestBody, ConnectDhlExpressRequestBody, ConnectDhlExpressUkRequestBody, ConnectDpdRequestBody, ConnectEndiciaRequestBody, ConnectFedexRequestBody, ConnectFedexUkRequestBody, ConnectFirstmileRequestBody, ConnectImexRequestBody, ConnectNewgisticsRequestBody, ConnectOntracRequestBody, ConnectPurolatorRequestBody, ConnectRoyalMailRequestBody, ConnectRrDonnelleyRequestBody, ConnectSekoRequestBody, ConnectSendleRequestBody, ConnectStampsRequestBody, ConnectUpsRequestBody. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting `actual_instance` in ConnectCarrierRequestBody with oneOf schemas: ConnectAccessWorldwideRequestBody, ConnectAmazonBuyShippingRequestBody, ConnectAmazonShippingUk, ConnectApcRequestBody, ConnectAsendiaRequestBody, ConnectAustraliaPostRequestBody, ConnectCanadaPostRequestBody, ConnectDhlEcommerceRequestBody, ConnectDhlExpressAuRequestBody, ConnectDhlExpressCaRequestBody, ConnectDhlExpressRequestBody, ConnectDhlExpressUkRequestBody, ConnectDpdRequestBody, ConnectEndiciaRequestBody, ConnectFedexRequestBody, ConnectFedexUkRequestBody, ConnectFirstmileRequestBody, ConnectImexRequestBody, ConnectNewgisticsRequestBody, ConnectOntracRequestBody, ConnectPurolatorRequestBody, ConnectRoyalMailRequestBody, ConnectRrDonnelleyRequestBody, ConnectSekoRequestBody, ConnectSendleRequestBody, ConnectStampsRequestBody, ConnectUpsRequestBody. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into ConnectAccessWorldwideRequestBody
        try:
            instance.actual_instance = ConnectAccessWorldwideRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectAmazonBuyShippingRequestBody
        try:
            instance.actual_instance = ConnectAmazonBuyShippingRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectAmazonShippingUk
        try:
            instance.actual_instance = ConnectAmazonShippingUk.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectApcRequestBody
        try:
            instance.actual_instance = ConnectApcRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectAsendiaRequestBody
        try:
            instance.actual_instance = ConnectAsendiaRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectAustraliaPostRequestBody
        try:
            instance.actual_instance = ConnectAustraliaPostRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectCanadaPostRequestBody
        try:
            instance.actual_instance = ConnectCanadaPostRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectDhlEcommerceRequestBody
        try:
            instance.actual_instance = ConnectDhlEcommerceRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectDhlExpressRequestBody
        try:
            instance.actual_instance = ConnectDhlExpressRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectDhlExpressAuRequestBody
        try:
            instance.actual_instance = ConnectDhlExpressAuRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectDhlExpressCaRequestBody
        try:
            instance.actual_instance = ConnectDhlExpressCaRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectDhlExpressUkRequestBody
        try:
            instance.actual_instance = ConnectDhlExpressUkRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectDpdRequestBody
        try:
            instance.actual_instance = ConnectDpdRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectEndiciaRequestBody
        try:
            instance.actual_instance = ConnectEndiciaRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectFedexRequestBody
        try:
            instance.actual_instance = ConnectFedexRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectFedexUkRequestBody
        try:
            instance.actual_instance = ConnectFedexUkRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectFirstmileRequestBody
        try:
            instance.actual_instance = ConnectFirstmileRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectImexRequestBody
        try:
            instance.actual_instance = ConnectImexRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectNewgisticsRequestBody
        try:
            instance.actual_instance = ConnectNewgisticsRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectOntracRequestBody
        try:
            instance.actual_instance = ConnectOntracRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectPurolatorRequestBody
        try:
            instance.actual_instance = ConnectPurolatorRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectRoyalMailRequestBody
        try:
            instance.actual_instance = ConnectRoyalMailRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectRrDonnelleyRequestBody
        try:
            instance.actual_instance = ConnectRrDonnelleyRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectSekoRequestBody
        try:
            instance.actual_instance = ConnectSekoRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectSendleRequestBody
        try:
            instance.actual_instance = ConnectSendleRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectStampsRequestBody
        try:
            instance.actual_instance = ConnectStampsRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into ConnectUpsRequestBody
        try:
            instance.actual_instance = ConnectUpsRequestBody.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into ConnectCarrierRequestBody with oneOf schemas: ConnectAccessWorldwideRequestBody, ConnectAmazonBuyShippingRequestBody, ConnectAmazonShippingUk, ConnectApcRequestBody, ConnectAsendiaRequestBody, ConnectAustraliaPostRequestBody, ConnectCanadaPostRequestBody, ConnectDhlEcommerceRequestBody, ConnectDhlExpressAuRequestBody, ConnectDhlExpressCaRequestBody, ConnectDhlExpressRequestBody, ConnectDhlExpressUkRequestBody, ConnectDpdRequestBody, ConnectEndiciaRequestBody, ConnectFedexRequestBody, ConnectFedexUkRequestBody, ConnectFirstmileRequestBody, ConnectImexRequestBody, ConnectNewgisticsRequestBody, ConnectOntracRequestBody, ConnectPurolatorRequestBody, ConnectRoyalMailRequestBody, ConnectRrDonnelleyRequestBody, ConnectSekoRequestBody, ConnectSendleRequestBody, ConnectStampsRequestBody, ConnectUpsRequestBody. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into ConnectCarrierRequestBody with oneOf schemas: ConnectAccessWorldwideRequestBody, ConnectAmazonBuyShippingRequestBody, ConnectAmazonShippingUk, ConnectApcRequestBody, ConnectAsendiaRequestBody, ConnectAustraliaPostRequestBody, ConnectCanadaPostRequestBody, ConnectDhlEcommerceRequestBody, ConnectDhlExpressAuRequestBody, ConnectDhlExpressCaRequestBody, ConnectDhlExpressRequestBody, ConnectDhlExpressUkRequestBody, ConnectDpdRequestBody, ConnectEndiciaRequestBody, ConnectFedexRequestBody, ConnectFedexUkRequestBody, ConnectFirstmileRequestBody, ConnectImexRequestBody, ConnectNewgisticsRequestBody, ConnectOntracRequestBody, ConnectPurolatorRequestBody, ConnectRoyalMailRequestBody, ConnectRrDonnelleyRequestBody, ConnectSekoRequestBody, ConnectSendleRequestBody, ConnectStampsRequestBody, ConnectUpsRequestBody. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Optional[Union[Dict[str, Any], ConnectAccessWorldwideRequestBody, ConnectAmazonBuyShippingRequestBody, ConnectAmazonShippingUk, ConnectApcRequestBody, ConnectAsendiaRequestBody, ConnectAustraliaPostRequestBody, ConnectCanadaPostRequestBody, ConnectDhlEcommerceRequestBody, ConnectDhlExpressAuRequestBody, ConnectDhlExpressCaRequestBody, ConnectDhlExpressRequestBody, ConnectDhlExpressUkRequestBody, ConnectDpdRequestBody, ConnectEndiciaRequestBody, ConnectFedexRequestBody, ConnectFedexUkRequestBody, ConnectFirstmileRequestBody, ConnectImexRequestBody, ConnectNewgisticsRequestBody, ConnectOntracRequestBody, ConnectPurolatorRequestBody, ConnectRoyalMailRequestBody, ConnectRrDonnelleyRequestBody, ConnectSekoRequestBody, ConnectSendleRequestBody, ConnectStampsRequestBody, ConnectUpsRequestBody]]:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())


