# coding: utf-8

"""
    1,000,000+ Recipe and Grocery List API (v2)

    #Documentation    This is the documentation for the partner endpoint of the BigOven Recipe and Grocery List API.    The update brings with it Swagger-based documentation. [Swagger](http://swagger.io) is an emerging standard for describing REST-based APIs, and with this Swagger-compliant endpoint (above), you can make ready-to-go interface libraries for your code via [swagger-codegen](https://github.com/swagger-api/swagger-codegen). For instance, it's easy to generate libraries for Node.js, Java, Ruby, ASP.NET MVC, jQuery, php and more!    You can also try out the endpoint calls with your own api_key right here on this page. Be sure to enter your api_key above to use the \"Try it out!\" buttons on this page.    ##Start Here    Developers new to the BigOven API should start with this version, not with the legacy API. We'll be making improvements to this API over time, and doing only bug fixes on the v1 API.        To pretend you're a BigOven user (for instance, to get your recently viewed recipes or your grocery list), you need to pass in Basic Authentication information in the header, just as with the v1 API. We do now require that you make all calls via https. You need to pass your api_key in with every call, though this can now be done on the header (send a request header \"X-BigOven-API-Key\" set to your api_key value, e.g., Request[\"X-BigOven-API-Key\"]=\"your-key-here\".)    ##Migration Notes    For existing partners, we encourage you to [migrate](https://api2.bigoven.com), and while at this writing we have no hard-and-fast termination date for the v1 API, we strongly prefer that you migrate by January 1, 2017. While the changes aren't overly complex, there are several breaking changes, including refactoring of recipe search and results and removal of support for XML. This is not a simply plug-and-play replacement to the v1 API. With respect to an exclusive focus on JSON, the world has spoken, and it prefers JSON for REST-based API's. We've taken numerous steps to refactor the API to make it more REST-compliant. Note that this v2 API will be the preferred API from this point onward, so we encourage developers to migrate to this new format. We have put together some [migration notes](/web/documentation/migration-to-v2) that we encourage you to read carefully.    ##Photos    See our [photos documentation](https://api2.bigoven.com/web/documentation/recipe-images).     For more information on usage of this API, including features, pricing, rate limits, terms and conditions, please visit the [BigOven API website](https://api2.bigoven.com).

    The version of the OpenAPI document: partner
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.api2_models_recipes_feedback_dto import API2ModelsRecipesFeedbackDTO
from openapi_client.models.api2_models_recipes_recipe_response import API2ModelsRecipesRecipeResponse
from openapi_client.models.api2_result import API2Result
from openapi_client.models.big_oven_model_api2_recipe import BigOvenModelAPI2Recipe
from openapi_client.models.big_oven_model_api2_recipe_search_result import BigOvenModelAPI2RecipeSearchResult
from openapi_client.models.big_oven_model_api_recipe import BigOvenModelAPIRecipe
from openapi_client.models.big_oven_model_recipe_category import BigOvenModelRecipeCategory
from openapi_client.models.big_oven_model_recipe_info_date_tuple2 import BigOvenModelRecipeInfoDateTuple2
from openapi_client.models.big_oven_model_recipe_info_review_tuple2 import BigOvenModelRecipeInfoReviewTuple2
from openapi_client.models.big_oven_model_recipe_info_tiny import BigOvenModelRecipeInfoTiny
from openapi_client.models.big_oven_result import BigOvenResult

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class RecipeApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def recipe_auto_complete(
        self,
        query: StrictStr,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[str]:
        """Given a query, return recipe titles starting with query. Query must be at least 3 chars in length.


        :param query:  (required)
        :type query: str
        :param limit: 
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_auto_complete_serialize(
            query=query,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_auto_complete_with_http_info(
        self,
        query: StrictStr,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[str]]:
        """Given a query, return recipe titles starting with query. Query must be at least 3 chars in length.


        :param query:  (required)
        :type query: str
        :param limit: 
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_auto_complete_serialize(
            query=query,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_auto_complete_without_preload_content(
        self,
        query: StrictStr,
        limit: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Given a query, return recipe titles starting with query. Query must be at least 3 chars in length.


        :param query:  (required)
        :type query: str
        :param limit: 
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_auto_complete_serialize(
            query=query,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_auto_complete_serialize(
        self,
        query,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipe/autocomplete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_auto_complete_all_recipes(
        self,
        query: Annotated[StrictStr, Field(description="The query.")],
        limit: Annotated[StrictInt, Field(description="The limit.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[BigOvenModelRecipeInfoTiny]:
        """Automatics the complete all recipes.


        :param query: The query. (required)
        :type query: str
        :param limit: The limit. (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_auto_complete_all_recipes_serialize(
            query=query,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoTiny]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_auto_complete_all_recipes_with_http_info(
        self,
        query: Annotated[StrictStr, Field(description="The query.")],
        limit: Annotated[StrictInt, Field(description="The limit.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[BigOvenModelRecipeInfoTiny]]:
        """Automatics the complete all recipes.


        :param query: The query. (required)
        :type query: str
        :param limit: The limit. (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_auto_complete_all_recipes_serialize(
            query=query,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoTiny]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_auto_complete_all_recipes_without_preload_content(
        self,
        query: Annotated[StrictStr, Field(description="The query.")],
        limit: Annotated[StrictInt, Field(description="The limit.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Automatics the complete all recipes.


        :param query: The query. (required)
        :type query: str
        :param limit: The limit. (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_auto_complete_all_recipes_serialize(
            query=query,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoTiny]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_auto_complete_all_recipes_serialize(
        self,
        query,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipe/autocomplete/all',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_auto_complete_my_recipes(
        self,
        query: Annotated[StrictStr, Field(description="The query.")],
        limit: Annotated[StrictInt, Field(description="The limit.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[BigOvenModelRecipeInfoTiny]:
        """Automatics the complete my recipes.


        :param query: The query. (required)
        :type query: str
        :param limit: The limit. (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_auto_complete_my_recipes_serialize(
            query=query,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoTiny]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_auto_complete_my_recipes_with_http_info(
        self,
        query: Annotated[StrictStr, Field(description="The query.")],
        limit: Annotated[StrictInt, Field(description="The limit.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[BigOvenModelRecipeInfoTiny]]:
        """Automatics the complete my recipes.


        :param query: The query. (required)
        :type query: str
        :param limit: The limit. (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_auto_complete_my_recipes_serialize(
            query=query,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoTiny]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_auto_complete_my_recipes_without_preload_content(
        self,
        query: Annotated[StrictStr, Field(description="The query.")],
        limit: Annotated[StrictInt, Field(description="The limit.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Automatics the complete my recipes.


        :param query: The query. (required)
        :type query: str
        :param limit: The limit. (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_auto_complete_my_recipes_serialize(
            query=query,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoTiny]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_auto_complete_my_recipes_serialize(
        self,
        query,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipe/autocomplete/mine',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_categories(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[BigOvenModelRecipeCategory]:
        """Get a list of recipe categories (the ID field can be used for include_cat in search parameters)


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_categories_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeCategory]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_categories_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[BigOvenModelRecipeCategory]]:
        """Get a list of recipe categories (the ID field can be used for include_cat in search parameters)


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_categories_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeCategory]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_categories_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a list of recipe categories (the ID field can be used for include_cat in search parameters)


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_categories_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeCategory]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_categories_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipe/categories',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_delete(
        self,
        id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Delete a Recipe (you must be authenticated as an owner of the recipe)


        :param id: (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_delete_with_http_info(
        self,
        id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Delete a Recipe (you must be authenticated as an owner of the recipe)


        :param id: (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_delete_without_preload_content(
        self,
        id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a Recipe (you must be authenticated as an owner of the recipe)


        :param id: (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_delete_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_delete_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/recipe/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_feedback(
        self,
        recipe_id: StrictInt,
        api2_models_recipes_feedback_dto: Annotated[API2ModelsRecipesFeedbackDTO, Field(description="The payload for feedback, which includes the field \"feedback\"")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Feedback on a Recipe -- for internal BigOven editors


        :param recipe_id:  (required)
        :type recipe_id: int
        :param api2_models_recipes_feedback_dto: The payload for feedback, which includes the field \"feedback\" (required)
        :type api2_models_recipes_feedback_dto: API2ModelsRecipesFeedbackDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_feedback_serialize(
            recipe_id=recipe_id,
            api2_models_recipes_feedback_dto=api2_models_recipes_feedback_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_feedback_with_http_info(
        self,
        recipe_id: StrictInt,
        api2_models_recipes_feedback_dto: Annotated[API2ModelsRecipesFeedbackDTO, Field(description="The payload for feedback, which includes the field \"feedback\"")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Feedback on a Recipe -- for internal BigOven editors


        :param recipe_id:  (required)
        :type recipe_id: int
        :param api2_models_recipes_feedback_dto: The payload for feedback, which includes the field \"feedback\" (required)
        :type api2_models_recipes_feedback_dto: API2ModelsRecipesFeedbackDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_feedback_serialize(
            recipe_id=recipe_id,
            api2_models_recipes_feedback_dto=api2_models_recipes_feedback_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_feedback_without_preload_content(
        self,
        recipe_id: StrictInt,
        api2_models_recipes_feedback_dto: Annotated[API2ModelsRecipesFeedbackDTO, Field(description="The payload for feedback, which includes the field \"feedback\"")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Feedback on a Recipe -- for internal BigOven editors


        :param recipe_id:  (required)
        :type recipe_id: int
        :param api2_models_recipes_feedback_dto: The payload for feedback, which includes the field \"feedback\" (required)
        :type api2_models_recipes_feedback_dto: API2ModelsRecipesFeedbackDTO
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_feedback_serialize(
            recipe_id=recipe_id,
            api2_models_recipes_feedback_dto=api2_models_recipes_feedback_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_feedback_serialize(
        self,
        recipe_id,
        api2_models_recipes_feedback_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if recipe_id is not None:
            _path_params['recipeId'] = recipe_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if api2_models_recipes_feedback_dto is not None:
            _body_params = api2_models_recipes_feedback_dto


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'application/xml', 
                        'text/json', 
                        'text/xml'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/recipe/{recipeId}/feedback',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_get(
        self,
        id: Annotated[StrictInt, Field(description="The Recipe ID to retrieve")],
        prefetch: Annotated[Optional[StrictBool], Field(description="The prefetch.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BigOvenModelAPI2Recipe:
        """Return full Recipe detail. Returns 403 if the recipe is owned by someone else.


        :param id: The Recipe ID to retrieve (required)
        :type id: int
        :param prefetch: The prefetch.
        :type prefetch: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2Recipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_get_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The Recipe ID to retrieve")],
        prefetch: Annotated[Optional[StrictBool], Field(description="The prefetch.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BigOvenModelAPI2Recipe]:
        """Return full Recipe detail. Returns 403 if the recipe is owned by someone else.


        :param id: The Recipe ID to retrieve (required)
        :type id: int
        :param prefetch: The prefetch.
        :type prefetch: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2Recipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_get_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The Recipe ID to retrieve")],
        prefetch: Annotated[Optional[StrictBool], Field(description="The prefetch.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return full Recipe detail. Returns 403 if the recipe is owned by someone else.


        :param id: The Recipe ID to retrieve (required)
        :type id: int
        :param prefetch: The prefetch.
        :type prefetch: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2Recipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_get_serialize(
        self,
        id,
        prefetch,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if prefetch is not None:
            
            _query_params.append(('prefetch', prefetch))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipe/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_get_active_recipe(
        self,
        user_name: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BigOvenResult:
        """Returns last active recipe for the user


        :param user_name:  (required)
        :type user_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_active_recipe_serialize(
            user_name=user_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_get_active_recipe_with_http_info(
        self,
        user_name: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BigOvenResult]:
        """Returns last active recipe for the user


        :param user_name:  (required)
        :type user_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_active_recipe_serialize(
            user_name=user_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_get_active_recipe_without_preload_content(
        self,
        user_name: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns last active recipe for the user


        :param user_name:  (required)
        :type user_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_active_recipe_serialize(
            user_name=user_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_get_active_recipe_serialize(
        self,
        user_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_name is not None:
            
            _query_params.append(('userName', user_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipe/get/active/recipe',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_get_random_recipe(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BigOvenModelAPIRecipe:
        """Get a random, home-page-quality Recipe.


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_random_recipe_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPIRecipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_get_random_recipe_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BigOvenModelAPIRecipe]:
        """Get a random, home-page-quality Recipe.


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_random_recipe_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPIRecipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_get_random_recipe_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a random, home-page-quality Recipe.


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_random_recipe_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPIRecipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_get_random_recipe_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipes/random',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_get_recipe_with_steps(
        self,
        id: Annotated[StrictInt, Field(description="the Recipe ID to retrieve")],
        prefetch: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BigOvenModelAPI2Recipe:
        """Return full Recipe detail with steps. Returns 403 if the recipe is owned by someone else.


        :param id: the Recipe ID to retrieve (required)
        :type id: int
        :param prefetch:
        :type prefetch: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_recipe_with_steps_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2Recipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_get_recipe_with_steps_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="the Recipe ID to retrieve")],
        prefetch: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BigOvenModelAPI2Recipe]:
        """Return full Recipe detail with steps. Returns 403 if the recipe is owned by someone else.


        :param id: the Recipe ID to retrieve (required)
        :type id: int
        :param prefetch:
        :type prefetch: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_recipe_with_steps_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2Recipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_get_recipe_with_steps_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="the Recipe ID to retrieve")],
        prefetch: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return full Recipe detail with steps. Returns 403 if the recipe is owned by someone else.


        :param id: the Recipe ID to retrieve (required)
        :type id: int
        :param prefetch:
        :type prefetch: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_recipe_with_steps_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2Recipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_get_recipe_with_steps_serialize(
        self,
        id,
        prefetch,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if prefetch is not None:
            
            _query_params.append(('prefetch', prefetch))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipe/steps/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_get_step(
        self,
        user_name: StrictStr,
        recipe_id: StrictInt,
        step_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """Gets recipe single step as text


        :param user_name:  (required)
        :type user_name: str
        :param recipe_id:  (required)
        :type recipe_id: int
        :param step_id:  (required)
        :type step_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_step_serialize(
            user_name=user_name,
            recipe_id=recipe_id,
            step_id=step_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_get_step_with_http_info(
        self,
        user_name: StrictStr,
        recipe_id: StrictInt,
        step_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """Gets recipe single step as text


        :param user_name:  (required)
        :type user_name: str
        :param recipe_id:  (required)
        :type recipe_id: int
        :param step_id:  (required)
        :type step_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_step_serialize(
            user_name=user_name,
            recipe_id=recipe_id,
            step_id=step_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_get_step_without_preload_content(
        self,
        user_name: StrictStr,
        recipe_id: StrictInt,
        step_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets recipe single step as text


        :param user_name:  (required)
        :type user_name: str
        :param recipe_id:  (required)
        :type recipe_id: int
        :param step_id:  (required)
        :type step_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_step_serialize(
            user_name=user_name,
            recipe_id=recipe_id,
            step_id=step_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_get_step_serialize(
        self,
        user_name,
        recipe_id,
        step_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_name is not None:
            
            _query_params.append(('userName', user_name))
            
        if recipe_id is not None:
            
            _query_params.append(('recipeId', recipe_id))
            
        if step_id is not None:
            
            _query_params.append(('stepId', step_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/recipe/get/saved/step',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_get_step_number(
        self,
        user_name: StrictStr,
        recipe_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> API2Result:
        """Returns stored step number and number of steps in recipe


        :param user_name:  (required)
        :type user_name: str
        :param recipe_id:  (required)
        :type recipe_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_step_number_serialize(
            user_name=user_name,
            recipe_id=recipe_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "API2Result",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_get_step_number_with_http_info(
        self,
        user_name: StrictStr,
        recipe_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[API2Result]:
        """Returns stored step number and number of steps in recipe


        :param user_name:  (required)
        :type user_name: str
        :param recipe_id:  (required)
        :type recipe_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_step_number_serialize(
            user_name=user_name,
            recipe_id=recipe_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "API2Result",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_get_step_number_without_preload_content(
        self,
        user_name: StrictStr,
        recipe_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns stored step number and number of steps in recipe


        :param user_name:  (required)
        :type user_name: str
        :param recipe_id:  (required)
        :type recipe_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_step_number_serialize(
            user_name=user_name,
            recipe_id=recipe_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "API2Result",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_get_step_number_serialize(
        self,
        user_name,
        recipe_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_name is not None:
            
            _query_params.append(('userName', user_name))
            
        if recipe_id is not None:
            
            _query_params.append(('recipeId', recipe_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/recipe/get/step/number',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_get_steps(
        self,
        user_name: StrictStr,
        recipe_id: StrictInt,
        step_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BigOvenResult:
        """Stores recipe step number and returns saved step data


        :param user_name:  (required)
        :type user_name: str
        :param recipe_id:  (required)
        :type recipe_id: int
        :param step_id:  (required)
        :type step_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_steps_serialize(
            user_name=user_name,
            recipe_id=recipe_id,
            step_id=step_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_get_steps_with_http_info(
        self,
        user_name: StrictStr,
        recipe_id: StrictInt,
        step_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BigOvenResult]:
        """Stores recipe step number and returns saved step data


        :param user_name:  (required)
        :type user_name: str
        :param recipe_id:  (required)
        :type recipe_id: int
        :param step_id:  (required)
        :type step_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_steps_serialize(
            user_name=user_name,
            recipe_id=recipe_id,
            step_id=step_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_get_steps_without_preload_content(
        self,
        user_name: StrictStr,
        recipe_id: StrictInt,
        step_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Stores recipe step number and returns saved step data


        :param user_name:  (required)
        :type user_name: str
        :param recipe_id:  (required)
        :type recipe_id: int
        :param step_id:  (required)
        :type step_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_steps_serialize(
            user_name=user_name,
            recipe_id=recipe_id,
            step_id=step_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_get_steps_serialize(
        self,
        user_name,
        recipe_id,
        step_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if user_name is not None:
            
            _query_params.append(('userName', user_name))
            
        if recipe_id is not None:
            
            _query_params.append(('recipeId', recipe_id))
            
        if step_id is not None:
            
            _query_params.append(('stepId', step_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/recipe/post/step',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_get_v2(
        self,
        id: Annotated[StrictInt, Field(description="The Recipe ID to retrieve")],
        prefetch: Annotated[Optional[StrictBool], Field(description="The prefetch.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> API2ModelsRecipesRecipeResponse:
        """Same as GET recipe but also includes the recipe videos (if any)


        :param id: The Recipe ID to retrieve (required)
        :type id: int
        :param prefetch: The prefetch.
        :type prefetch: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_v2_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "API2ModelsRecipesRecipeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_get_v2_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The Recipe ID to retrieve")],
        prefetch: Annotated[Optional[StrictBool], Field(description="The prefetch.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[API2ModelsRecipesRecipeResponse]:
        """Same as GET recipe but also includes the recipe videos (if any)


        :param id: The Recipe ID to retrieve (required)
        :type id: int
        :param prefetch: The prefetch.
        :type prefetch: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_v2_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "API2ModelsRecipesRecipeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_get_v2_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The Recipe ID to retrieve")],
        prefetch: Annotated[Optional[StrictBool], Field(description="The prefetch.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Same as GET recipe but also includes the recipe videos (if any)


        :param id: The Recipe ID to retrieve (required)
        :type id: int
        :param prefetch: The prefetch.
        :type prefetch: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_get_v2_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "API2ModelsRecipesRecipeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_get_v2_serialize(
        self,
        id,
        prefetch,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if prefetch is not None:
            
            _query_params.append(('prefetch', prefetch))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipes/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_post(
        self,
        big_oven_model_api_recipe: BigOvenModelAPIRecipe,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BigOvenModelAPIRecipe:
        """Add a new recipe


        :param big_oven_model_api_recipe: (required)
        :type big_oven_model_api_recipe: BigOvenModelAPIRecipe
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_post_serialize(
            big_oven_model_api_recipe=big_oven_model_api_recipe,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPIRecipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_post_with_http_info(
        self,
        big_oven_model_api_recipe: BigOvenModelAPIRecipe,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BigOvenModelAPIRecipe]:
        """Add a new recipe


        :param big_oven_model_api_recipe: (required)
        :type big_oven_model_api_recipe: BigOvenModelAPIRecipe
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_post_serialize(
            big_oven_model_api_recipe=big_oven_model_api_recipe,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPIRecipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_post_without_preload_content(
        self,
        big_oven_model_api_recipe: BigOvenModelAPIRecipe,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add a new recipe


        :param big_oven_model_api_recipe: (required)
        :type big_oven_model_api_recipe: BigOvenModelAPIRecipe
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_post_serialize(
            big_oven_model_api_recipe=big_oven_model_api_recipe,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPIRecipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_post_serialize(
        self,
        big_oven_model_api_recipe,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if big_oven_model_api_recipe is not None:
            _body_params = big_oven_model_api_recipe


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'application/xml', 
                        'text/json', 
                        'text/xml'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/recipe',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_put(
        self,
        big_oven_model_api_recipe: BigOvenModelAPIRecipe,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BigOvenModelAPIRecipe:
        """Update a recipe


        :param big_oven_model_api_recipe: (required)
        :type big_oven_model_api_recipe: BigOvenModelAPIRecipe
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_put_serialize(
            big_oven_model_api_recipe=big_oven_model_api_recipe,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPIRecipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_put_with_http_info(
        self,
        big_oven_model_api_recipe: BigOvenModelAPIRecipe,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BigOvenModelAPIRecipe]:
        """Update a recipe


        :param big_oven_model_api_recipe: (required)
        :type big_oven_model_api_recipe: BigOvenModelAPIRecipe
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_put_serialize(
            big_oven_model_api_recipe=big_oven_model_api_recipe,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPIRecipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_put_without_preload_content(
        self,
        big_oven_model_api_recipe: BigOvenModelAPIRecipe,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a recipe


        :param big_oven_model_api_recipe: (required)
        :type big_oven_model_api_recipe: BigOvenModelAPIRecipe
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_put_serialize(
            big_oven_model_api_recipe=big_oven_model_api_recipe,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPIRecipe",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_put_serialize(
        self,
        big_oven_model_api_recipe,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if big_oven_model_api_recipe is not None:
            _body_params = big_oven_model_api_recipe


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'application/xml', 
                        'text/json', 
                        'text/xml'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/recipe',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_raves(
        self,
        pg: Annotated[Optional[StrictInt], Field(description="page, starting with 1")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="results per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[BigOvenModelRecipeInfoReviewTuple2]:
        """Get the recipe/comment tuples for those recipes with 4 or 5 star ratings


        :param pg: page, starting with 1
        :type pg: int
        :param rpp: results per page
        :type rpp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_raves_serialize(
            pg=pg,
            rpp=rpp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoReviewTuple2]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_raves_with_http_info(
        self,
        pg: Annotated[Optional[StrictInt], Field(description="page, starting with 1")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="results per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[BigOvenModelRecipeInfoReviewTuple2]]:
        """Get the recipe/comment tuples for those recipes with 4 or 5 star ratings


        :param pg: page, starting with 1
        :type pg: int
        :param rpp: results per page
        :type rpp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_raves_serialize(
            pg=pg,
            rpp=rpp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoReviewTuple2]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_raves_without_preload_content(
        self,
        pg: Annotated[Optional[StrictInt], Field(description="page, starting with 1")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="results per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the recipe/comment tuples for those recipes with 4 or 5 star ratings


        :param pg: page, starting with 1
        :type pg: int
        :param rpp: results per page
        :type rpp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_raves_serialize(
            pg=pg,
            rpp=rpp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoReviewTuple2]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_raves_serialize(
        self,
        pg,
        rpp,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if pg is not None:
            
            _query_params.append(('pg', pg))
            
        if rpp is not None:
            
            _query_params.append(('rpp', rpp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipes/raves',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_recent_views(
        self,
        pg: Annotated[Optional[StrictInt], Field(description="Page number starting with 1")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="results per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[BigOvenModelRecipeInfoDateTuple2]:
        """Get a list of recipes that the authenticated user has most recently viewed


        :param pg: Page number starting with 1
        :type pg: int
        :param rpp: results per page
        :type rpp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_recent_views_serialize(
            pg=pg,
            rpp=rpp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoDateTuple2]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_recent_views_with_http_info(
        self,
        pg: Annotated[Optional[StrictInt], Field(description="Page number starting with 1")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="results per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[BigOvenModelRecipeInfoDateTuple2]]:
        """Get a list of recipes that the authenticated user has most recently viewed


        :param pg: Page number starting with 1
        :type pg: int
        :param rpp: results per page
        :type rpp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_recent_views_serialize(
            pg=pg,
            rpp=rpp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoDateTuple2]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_recent_views_without_preload_content(
        self,
        pg: Annotated[Optional[StrictInt], Field(description="Page number starting with 1")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="results per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a list of recipes that the authenticated user has most recently viewed


        :param pg: Page number starting with 1
        :type pg: int
        :param rpp: results per page
        :type rpp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_recent_views_serialize(
            pg=pg,
            rpp=rpp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BigOvenModelRecipeInfoDateTuple2]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_recent_views_serialize(
        self,
        pg,
        rpp,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if pg is not None:
            
            _query_params.append(('pg', pg))
            
        if rpp is not None:
            
            _query_params.append(('rpp', rpp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipes/recentviews',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_recipe_search(
        self,
        any_kw: Annotated[Optional[StrictStr], Field(description="Search anywhere in the recipe for the keyword")] = None,
        folder: Annotated[Optional[StrictStr], Field(description="Search in a specific folder name for the authenticated user")] = None,
        coll: Annotated[Optional[StrictInt], Field(description="Limit to a collection ID number")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set")] = None,
        title_kw: Annotated[Optional[StrictStr], Field(description="Search just in the recipe title for the keyword")] = None,
        user_id: Annotated[Optional[StrictInt], Field(description="Set the target userid to search their public recipes")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set the target username to search their public recipes")] = None,
        token: Optional[StrictStr] = None,
        photos: Annotated[Optional[StrictBool], Field(description="if set to true, limit search results to photos only")] = None,
        boostmine: Annotated[Optional[StrictBool], Field(description="if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)")] = None,
        include_cat: Annotated[Optional[StrictStr], Field(description="integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".")] = None,
        exclude_cat: Annotated[Optional[StrictStr], Field(description="like include_cat, set this to an integer to exclude a specific category")] = None,
        include_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        exclude_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        include_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken")] = None,
        exclude_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)")] = None,
        cuisine: Annotated[Optional[StrictStr], Field(description="Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese")] = None,
        db: Optional[StrictStr] = None,
        userset: Annotated[Optional[StrictStr], Field(description="If set to a given username, it'll force the search to filter to just that username")] = None,
        servings_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"")] = None,
        total_mins: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)")] = None,
        max_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less")] = None,
        min_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that have at least {minIngredients}")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="integer; results per page")] = None,
        pg: Annotated[Optional[StrictInt], Field(description="integer: the page number")] = None,
        vtn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegetarian (Powersearch-capable plan required)")] = None,
        vgn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegan (Powersearch-capable plan required)")] = None,
        chs: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to contains-cheese (Powersearch-capable plan required)")] = None,
        glf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to gluten-free (Powersearch-capable plan required)")] = None,
        ntf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to nut-free (Powersearch-capable plan required)")] = None,
        dyf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to dairy-free (Powersearch-capable plan required)")] = None,
        sff: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to seafood-free (Powersearch-capable plan required)")] = None,
        slf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to shellfish-free (Powersearch-capable plan required)")] = None,
        tnf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to tree-nut free (Powersearch-capable plan required)")] = None,
        wmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to white-meat free (Powersearch-capable plan required)")] = None,
        rmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to red-meat free (Powersearch-capable plan required)")] = None,
        cps: Annotated[Optional[StrictInt], Field(description="when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)")] = None,
        champion: Annotated[Optional[StrictInt], Field(description="optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.")] = None,
        synonyms: Annotated[Optional[StrictBool], Field(description="optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BigOvenModelAPI2RecipeSearchResult:
        """Search for recipes. There are many parameters that you can apply. Starting with the most common, use title_kw to search within a title.              Use any_kw to search across the entire recipe.              If you'd like to limit by course, set the parameter \"include_primarycat\" to one of (appetizers,bread,breakfast,dessert,drinks,maindish,salad,sidedish,soup,marinades,other).              If you'd like to exclude a category, set exclude_cat to one or more (comma-separated) list of those categories to exclude.              If you'd like to include a category, set include_cat to one or more (comma-separated) of those categories to include.              To explicitly include an ingredient in your search, set the parameter \"include_ing\" to a CSV of up to three ingredients, e.g.:include_ing=mustard,chicken,beef%20tips              To explicitly exclude an ingredient in your search, set the parameter \"exclude_ing\" to a CSV of up to three ingredients.              All searches must contain the paging parameters pg and rpp, which are integers, and represent the page number (1-based) and results per page (rpp).              So, to get the third page of a result set paged with 25 recipes per page, you'd pass pg=3&amp;rpp=25              If you'd like to target searches to just a single target user's recipes, set userId=the target userId (number).              Or, you can set username=theirusername              vtn;vgn;chs;glf;ntf;dyf;sff;slf;tnf;wmf;rmf;cps              cuisine              photos              filter=added,try,favorites,myrecipes\\r\\n\\r\\n              folder=FolderNameCaseSensitive              coll=ID of Collection


        :param any_kw: Search anywhere in the recipe for the keyword
        :type any_kw: str
        :param folder: Search in a specific folder name for the authenticated user
        :type folder: str
        :param coll: Limit to a collection ID number
        :type coll: int
        :param filter: optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set
        :type filter: str
        :param title_kw: Search just in the recipe title for the keyword
        :type title_kw: str
        :param user_id: Set the target userid to search their public recipes
        :type user_id: int
        :param username: Set the target username to search their public recipes
        :type username: str
        :param token: 
        :type token: str
        :param photos: if set to true, limit search results to photos only
        :type photos: bool
        :param boostmine: if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)
        :type boostmine: bool
        :param include_cat: integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".
        :type include_cat: str
        :param exclude_cat: like include_cat, set this to an integer to exclude a specific category
        :type exclude_cat: str
        :param include_primarycat: csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type include_primarycat: str
        :param exclude_primarycat: csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type exclude_primarycat: str
        :param include_ing: A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken
        :type include_ing: str
        :param exclude_ing: A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)
        :type exclude_ing: str
        :param cuisine: Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese
        :type cuisine: str
        :param db: 
        :type db: str
        :param userset: If set to a given username, it'll force the search to filter to just that username
        :type userset: str
        :param servings_min: Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"
        :type servings_min: float
        :param total_mins: Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)
        :type total_mins: int
        :param max_ingredients: Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less
        :type max_ingredients: int
        :param min_ingredients: Optional. If supplied, will restrict results to recipes that have at least {minIngredients}
        :type min_ingredients: int
        :param rpp: integer; results per page
        :type rpp: int
        :param pg: integer: the page number
        :type pg: int
        :param vtn: when set to 1, limit to vegetarian (Powersearch-capable plan required)
        :type vtn: int
        :param vgn: when set to 1, limit to vegan (Powersearch-capable plan required)
        :type vgn: int
        :param chs: when set to 1, limit to contains-cheese (Powersearch-capable plan required)
        :type chs: int
        :param glf: when set to 1, limit to gluten-free (Powersearch-capable plan required)
        :type glf: int
        :param ntf: when set to 1, limit to nut-free (Powersearch-capable plan required)
        :type ntf: int
        :param dyf: when set to 1, limit to dairy-free (Powersearch-capable plan required)
        :type dyf: int
        :param sff: when set to 1, limit to seafood-free (Powersearch-capable plan required)
        :type sff: int
        :param slf: when set to 1, limit to shellfish-free (Powersearch-capable plan required)
        :type slf: int
        :param tnf: when set to 1, limit to tree-nut free (Powersearch-capable plan required)
        :type tnf: int
        :param wmf: when set to 1, limit to white-meat free (Powersearch-capable plan required)
        :type wmf: int
        :param rmf: when set to 1, limit to red-meat free (Powersearch-capable plan required)
        :type rmf: int
        :param cps: when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)
        :type cps: int
        :param champion: optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.
        :type champion: int
        :param synonyms: optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)
        :type synonyms: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_recipe_search_serialize(
            any_kw=any_kw,
            folder=folder,
            coll=coll,
            filter=filter,
            title_kw=title_kw,
            user_id=user_id,
            username=username,
            token=token,
            photos=photos,
            boostmine=boostmine,
            include_cat=include_cat,
            exclude_cat=exclude_cat,
            include_primarycat=include_primarycat,
            exclude_primarycat=exclude_primarycat,
            include_ing=include_ing,
            exclude_ing=exclude_ing,
            cuisine=cuisine,
            db=db,
            userset=userset,
            servings_min=servings_min,
            total_mins=total_mins,
            max_ingredients=max_ingredients,
            min_ingredients=min_ingredients,
            rpp=rpp,
            pg=pg,
            vtn=vtn,
            vgn=vgn,
            chs=chs,
            glf=glf,
            ntf=ntf,
            dyf=dyf,
            sff=sff,
            slf=slf,
            tnf=tnf,
            wmf=wmf,
            rmf=rmf,
            cps=cps,
            champion=champion,
            synonyms=synonyms,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2RecipeSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_recipe_search_with_http_info(
        self,
        any_kw: Annotated[Optional[StrictStr], Field(description="Search anywhere in the recipe for the keyword")] = None,
        folder: Annotated[Optional[StrictStr], Field(description="Search in a specific folder name for the authenticated user")] = None,
        coll: Annotated[Optional[StrictInt], Field(description="Limit to a collection ID number")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set")] = None,
        title_kw: Annotated[Optional[StrictStr], Field(description="Search just in the recipe title for the keyword")] = None,
        user_id: Annotated[Optional[StrictInt], Field(description="Set the target userid to search their public recipes")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set the target username to search their public recipes")] = None,
        token: Optional[StrictStr] = None,
        photos: Annotated[Optional[StrictBool], Field(description="if set to true, limit search results to photos only")] = None,
        boostmine: Annotated[Optional[StrictBool], Field(description="if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)")] = None,
        include_cat: Annotated[Optional[StrictStr], Field(description="integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".")] = None,
        exclude_cat: Annotated[Optional[StrictStr], Field(description="like include_cat, set this to an integer to exclude a specific category")] = None,
        include_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        exclude_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        include_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken")] = None,
        exclude_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)")] = None,
        cuisine: Annotated[Optional[StrictStr], Field(description="Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese")] = None,
        db: Optional[StrictStr] = None,
        userset: Annotated[Optional[StrictStr], Field(description="If set to a given username, it'll force the search to filter to just that username")] = None,
        servings_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"")] = None,
        total_mins: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)")] = None,
        max_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less")] = None,
        min_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that have at least {minIngredients}")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="integer; results per page")] = None,
        pg: Annotated[Optional[StrictInt], Field(description="integer: the page number")] = None,
        vtn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegetarian (Powersearch-capable plan required)")] = None,
        vgn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegan (Powersearch-capable plan required)")] = None,
        chs: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to contains-cheese (Powersearch-capable plan required)")] = None,
        glf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to gluten-free (Powersearch-capable plan required)")] = None,
        ntf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to nut-free (Powersearch-capable plan required)")] = None,
        dyf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to dairy-free (Powersearch-capable plan required)")] = None,
        sff: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to seafood-free (Powersearch-capable plan required)")] = None,
        slf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to shellfish-free (Powersearch-capable plan required)")] = None,
        tnf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to tree-nut free (Powersearch-capable plan required)")] = None,
        wmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to white-meat free (Powersearch-capable plan required)")] = None,
        rmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to red-meat free (Powersearch-capable plan required)")] = None,
        cps: Annotated[Optional[StrictInt], Field(description="when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)")] = None,
        champion: Annotated[Optional[StrictInt], Field(description="optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.")] = None,
        synonyms: Annotated[Optional[StrictBool], Field(description="optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BigOvenModelAPI2RecipeSearchResult]:
        """Search for recipes. There are many parameters that you can apply. Starting with the most common, use title_kw to search within a title.              Use any_kw to search across the entire recipe.              If you'd like to limit by course, set the parameter \"include_primarycat\" to one of (appetizers,bread,breakfast,dessert,drinks,maindish,salad,sidedish,soup,marinades,other).              If you'd like to exclude a category, set exclude_cat to one or more (comma-separated) list of those categories to exclude.              If you'd like to include a category, set include_cat to one or more (comma-separated) of those categories to include.              To explicitly include an ingredient in your search, set the parameter \"include_ing\" to a CSV of up to three ingredients, e.g.:include_ing=mustard,chicken,beef%20tips              To explicitly exclude an ingredient in your search, set the parameter \"exclude_ing\" to a CSV of up to three ingredients.              All searches must contain the paging parameters pg and rpp, which are integers, and represent the page number (1-based) and results per page (rpp).              So, to get the third page of a result set paged with 25 recipes per page, you'd pass pg=3&amp;rpp=25              If you'd like to target searches to just a single target user's recipes, set userId=the target userId (number).              Or, you can set username=theirusername              vtn;vgn;chs;glf;ntf;dyf;sff;slf;tnf;wmf;rmf;cps              cuisine              photos              filter=added,try,favorites,myrecipes\\r\\n\\r\\n              folder=FolderNameCaseSensitive              coll=ID of Collection


        :param any_kw: Search anywhere in the recipe for the keyword
        :type any_kw: str
        :param folder: Search in a specific folder name for the authenticated user
        :type folder: str
        :param coll: Limit to a collection ID number
        :type coll: int
        :param filter: optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set
        :type filter: str
        :param title_kw: Search just in the recipe title for the keyword
        :type title_kw: str
        :param user_id: Set the target userid to search their public recipes
        :type user_id: int
        :param username: Set the target username to search their public recipes
        :type username: str
        :param token: 
        :type token: str
        :param photos: if set to true, limit search results to photos only
        :type photos: bool
        :param boostmine: if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)
        :type boostmine: bool
        :param include_cat: integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".
        :type include_cat: str
        :param exclude_cat: like include_cat, set this to an integer to exclude a specific category
        :type exclude_cat: str
        :param include_primarycat: csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type include_primarycat: str
        :param exclude_primarycat: csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type exclude_primarycat: str
        :param include_ing: A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken
        :type include_ing: str
        :param exclude_ing: A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)
        :type exclude_ing: str
        :param cuisine: Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese
        :type cuisine: str
        :param db: 
        :type db: str
        :param userset: If set to a given username, it'll force the search to filter to just that username
        :type userset: str
        :param servings_min: Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"
        :type servings_min: float
        :param total_mins: Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)
        :type total_mins: int
        :param max_ingredients: Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less
        :type max_ingredients: int
        :param min_ingredients: Optional. If supplied, will restrict results to recipes that have at least {minIngredients}
        :type min_ingredients: int
        :param rpp: integer; results per page
        :type rpp: int
        :param pg: integer: the page number
        :type pg: int
        :param vtn: when set to 1, limit to vegetarian (Powersearch-capable plan required)
        :type vtn: int
        :param vgn: when set to 1, limit to vegan (Powersearch-capable plan required)
        :type vgn: int
        :param chs: when set to 1, limit to contains-cheese (Powersearch-capable plan required)
        :type chs: int
        :param glf: when set to 1, limit to gluten-free (Powersearch-capable plan required)
        :type glf: int
        :param ntf: when set to 1, limit to nut-free (Powersearch-capable plan required)
        :type ntf: int
        :param dyf: when set to 1, limit to dairy-free (Powersearch-capable plan required)
        :type dyf: int
        :param sff: when set to 1, limit to seafood-free (Powersearch-capable plan required)
        :type sff: int
        :param slf: when set to 1, limit to shellfish-free (Powersearch-capable plan required)
        :type slf: int
        :param tnf: when set to 1, limit to tree-nut free (Powersearch-capable plan required)
        :type tnf: int
        :param wmf: when set to 1, limit to white-meat free (Powersearch-capable plan required)
        :type wmf: int
        :param rmf: when set to 1, limit to red-meat free (Powersearch-capable plan required)
        :type rmf: int
        :param cps: when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)
        :type cps: int
        :param champion: optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.
        :type champion: int
        :param synonyms: optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)
        :type synonyms: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_recipe_search_serialize(
            any_kw=any_kw,
            folder=folder,
            coll=coll,
            filter=filter,
            title_kw=title_kw,
            user_id=user_id,
            username=username,
            token=token,
            photos=photos,
            boostmine=boostmine,
            include_cat=include_cat,
            exclude_cat=exclude_cat,
            include_primarycat=include_primarycat,
            exclude_primarycat=exclude_primarycat,
            include_ing=include_ing,
            exclude_ing=exclude_ing,
            cuisine=cuisine,
            db=db,
            userset=userset,
            servings_min=servings_min,
            total_mins=total_mins,
            max_ingredients=max_ingredients,
            min_ingredients=min_ingredients,
            rpp=rpp,
            pg=pg,
            vtn=vtn,
            vgn=vgn,
            chs=chs,
            glf=glf,
            ntf=ntf,
            dyf=dyf,
            sff=sff,
            slf=slf,
            tnf=tnf,
            wmf=wmf,
            rmf=rmf,
            cps=cps,
            champion=champion,
            synonyms=synonyms,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2RecipeSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_recipe_search_without_preload_content(
        self,
        any_kw: Annotated[Optional[StrictStr], Field(description="Search anywhere in the recipe for the keyword")] = None,
        folder: Annotated[Optional[StrictStr], Field(description="Search in a specific folder name for the authenticated user")] = None,
        coll: Annotated[Optional[StrictInt], Field(description="Limit to a collection ID number")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set")] = None,
        title_kw: Annotated[Optional[StrictStr], Field(description="Search just in the recipe title for the keyword")] = None,
        user_id: Annotated[Optional[StrictInt], Field(description="Set the target userid to search their public recipes")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set the target username to search their public recipes")] = None,
        token: Optional[StrictStr] = None,
        photos: Annotated[Optional[StrictBool], Field(description="if set to true, limit search results to photos only")] = None,
        boostmine: Annotated[Optional[StrictBool], Field(description="if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)")] = None,
        include_cat: Annotated[Optional[StrictStr], Field(description="integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".")] = None,
        exclude_cat: Annotated[Optional[StrictStr], Field(description="like include_cat, set this to an integer to exclude a specific category")] = None,
        include_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        exclude_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        include_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken")] = None,
        exclude_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)")] = None,
        cuisine: Annotated[Optional[StrictStr], Field(description="Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese")] = None,
        db: Optional[StrictStr] = None,
        userset: Annotated[Optional[StrictStr], Field(description="If set to a given username, it'll force the search to filter to just that username")] = None,
        servings_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"")] = None,
        total_mins: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)")] = None,
        max_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less")] = None,
        min_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that have at least {minIngredients}")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="integer; results per page")] = None,
        pg: Annotated[Optional[StrictInt], Field(description="integer: the page number")] = None,
        vtn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegetarian (Powersearch-capable plan required)")] = None,
        vgn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegan (Powersearch-capable plan required)")] = None,
        chs: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to contains-cheese (Powersearch-capable plan required)")] = None,
        glf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to gluten-free (Powersearch-capable plan required)")] = None,
        ntf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to nut-free (Powersearch-capable plan required)")] = None,
        dyf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to dairy-free (Powersearch-capable plan required)")] = None,
        sff: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to seafood-free (Powersearch-capable plan required)")] = None,
        slf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to shellfish-free (Powersearch-capable plan required)")] = None,
        tnf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to tree-nut free (Powersearch-capable plan required)")] = None,
        wmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to white-meat free (Powersearch-capable plan required)")] = None,
        rmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to red-meat free (Powersearch-capable plan required)")] = None,
        cps: Annotated[Optional[StrictInt], Field(description="when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)")] = None,
        champion: Annotated[Optional[StrictInt], Field(description="optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.")] = None,
        synonyms: Annotated[Optional[StrictBool], Field(description="optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for recipes. There are many parameters that you can apply. Starting with the most common, use title_kw to search within a title.              Use any_kw to search across the entire recipe.              If you'd like to limit by course, set the parameter \"include_primarycat\" to one of (appetizers,bread,breakfast,dessert,drinks,maindish,salad,sidedish,soup,marinades,other).              If you'd like to exclude a category, set exclude_cat to one or more (comma-separated) list of those categories to exclude.              If you'd like to include a category, set include_cat to one or more (comma-separated) of those categories to include.              To explicitly include an ingredient in your search, set the parameter \"include_ing\" to a CSV of up to three ingredients, e.g.:include_ing=mustard,chicken,beef%20tips              To explicitly exclude an ingredient in your search, set the parameter \"exclude_ing\" to a CSV of up to three ingredients.              All searches must contain the paging parameters pg and rpp, which are integers, and represent the page number (1-based) and results per page (rpp).              So, to get the third page of a result set paged with 25 recipes per page, you'd pass pg=3&amp;rpp=25              If you'd like to target searches to just a single target user's recipes, set userId=the target userId (number).              Or, you can set username=theirusername              vtn;vgn;chs;glf;ntf;dyf;sff;slf;tnf;wmf;rmf;cps              cuisine              photos              filter=added,try,favorites,myrecipes\\r\\n\\r\\n              folder=FolderNameCaseSensitive              coll=ID of Collection


        :param any_kw: Search anywhere in the recipe for the keyword
        :type any_kw: str
        :param folder: Search in a specific folder name for the authenticated user
        :type folder: str
        :param coll: Limit to a collection ID number
        :type coll: int
        :param filter: optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set
        :type filter: str
        :param title_kw: Search just in the recipe title for the keyword
        :type title_kw: str
        :param user_id: Set the target userid to search their public recipes
        :type user_id: int
        :param username: Set the target username to search their public recipes
        :type username: str
        :param token: 
        :type token: str
        :param photos: if set to true, limit search results to photos only
        :type photos: bool
        :param boostmine: if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)
        :type boostmine: bool
        :param include_cat: integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".
        :type include_cat: str
        :param exclude_cat: like include_cat, set this to an integer to exclude a specific category
        :type exclude_cat: str
        :param include_primarycat: csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type include_primarycat: str
        :param exclude_primarycat: csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type exclude_primarycat: str
        :param include_ing: A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken
        :type include_ing: str
        :param exclude_ing: A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)
        :type exclude_ing: str
        :param cuisine: Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese
        :type cuisine: str
        :param db: 
        :type db: str
        :param userset: If set to a given username, it'll force the search to filter to just that username
        :type userset: str
        :param servings_min: Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"
        :type servings_min: float
        :param total_mins: Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)
        :type total_mins: int
        :param max_ingredients: Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less
        :type max_ingredients: int
        :param min_ingredients: Optional. If supplied, will restrict results to recipes that have at least {minIngredients}
        :type min_ingredients: int
        :param rpp: integer; results per page
        :type rpp: int
        :param pg: integer: the page number
        :type pg: int
        :param vtn: when set to 1, limit to vegetarian (Powersearch-capable plan required)
        :type vtn: int
        :param vgn: when set to 1, limit to vegan (Powersearch-capable plan required)
        :type vgn: int
        :param chs: when set to 1, limit to contains-cheese (Powersearch-capable plan required)
        :type chs: int
        :param glf: when set to 1, limit to gluten-free (Powersearch-capable plan required)
        :type glf: int
        :param ntf: when set to 1, limit to nut-free (Powersearch-capable plan required)
        :type ntf: int
        :param dyf: when set to 1, limit to dairy-free (Powersearch-capable plan required)
        :type dyf: int
        :param sff: when set to 1, limit to seafood-free (Powersearch-capable plan required)
        :type sff: int
        :param slf: when set to 1, limit to shellfish-free (Powersearch-capable plan required)
        :type slf: int
        :param tnf: when set to 1, limit to tree-nut free (Powersearch-capable plan required)
        :type tnf: int
        :param wmf: when set to 1, limit to white-meat free (Powersearch-capable plan required)
        :type wmf: int
        :param rmf: when set to 1, limit to red-meat free (Powersearch-capable plan required)
        :type rmf: int
        :param cps: when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)
        :type cps: int
        :param champion: optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.
        :type champion: int
        :param synonyms: optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)
        :type synonyms: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_recipe_search_serialize(
            any_kw=any_kw,
            folder=folder,
            coll=coll,
            filter=filter,
            title_kw=title_kw,
            user_id=user_id,
            username=username,
            token=token,
            photos=photos,
            boostmine=boostmine,
            include_cat=include_cat,
            exclude_cat=exclude_cat,
            include_primarycat=include_primarycat,
            exclude_primarycat=exclude_primarycat,
            include_ing=include_ing,
            exclude_ing=exclude_ing,
            cuisine=cuisine,
            db=db,
            userset=userset,
            servings_min=servings_min,
            total_mins=total_mins,
            max_ingredients=max_ingredients,
            min_ingredients=min_ingredients,
            rpp=rpp,
            pg=pg,
            vtn=vtn,
            vgn=vgn,
            chs=chs,
            glf=glf,
            ntf=ntf,
            dyf=dyf,
            sff=sff,
            slf=slf,
            tnf=tnf,
            wmf=wmf,
            rmf=rmf,
            cps=cps,
            champion=champion,
            synonyms=synonyms,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2RecipeSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_recipe_search_serialize(
        self,
        any_kw,
        folder,
        coll,
        filter,
        title_kw,
        user_id,
        username,
        token,
        photos,
        boostmine,
        include_cat,
        exclude_cat,
        include_primarycat,
        exclude_primarycat,
        include_ing,
        exclude_ing,
        cuisine,
        db,
        userset,
        servings_min,
        total_mins,
        max_ingredients,
        min_ingredients,
        rpp,
        pg,
        vtn,
        vgn,
        chs,
        glf,
        ntf,
        dyf,
        sff,
        slf,
        tnf,
        wmf,
        rmf,
        cps,
        champion,
        synonyms,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if any_kw is not None:
            
            _query_params.append(('any_kw', any_kw))
            
        if folder is not None:
            
            _query_params.append(('folder', folder))
            
        if coll is not None:
            
            _query_params.append(('coll', coll))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if title_kw is not None:
            
            _query_params.append(('title_kw', title_kw))
            
        if user_id is not None:
            
            _query_params.append(('userId', user_id))
            
        if username is not None:
            
            _query_params.append(('username', username))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        if photos is not None:
            
            _query_params.append(('photos', photos))
            
        if boostmine is not None:
            
            _query_params.append(('boostmine', boostmine))
            
        if include_cat is not None:
            
            _query_params.append(('include_cat', include_cat))
            
        if exclude_cat is not None:
            
            _query_params.append(('exclude_cat', exclude_cat))
            
        if include_primarycat is not None:
            
            _query_params.append(('include_primarycat', include_primarycat))
            
        if exclude_primarycat is not None:
            
            _query_params.append(('exclude_primarycat', exclude_primarycat))
            
        if include_ing is not None:
            
            _query_params.append(('include_ing', include_ing))
            
        if exclude_ing is not None:
            
            _query_params.append(('exclude_ing', exclude_ing))
            
        if cuisine is not None:
            
            _query_params.append(('cuisine', cuisine))
            
        if db is not None:
            
            _query_params.append(('db', db))
            
        if userset is not None:
            
            _query_params.append(('userset', userset))
            
        if servings_min is not None:
            
            _query_params.append(('servingsMin', servings_min))
            
        if total_mins is not None:
            
            _query_params.append(('totalMins', total_mins))
            
        if max_ingredients is not None:
            
            _query_params.append(('maxIngredients', max_ingredients))
            
        if min_ingredients is not None:
            
            _query_params.append(('minIngredients', min_ingredients))
            
        if rpp is not None:
            
            _query_params.append(('rpp', rpp))
            
        if pg is not None:
            
            _query_params.append(('pg', pg))
            
        if vtn is not None:
            
            _query_params.append(('vtn', vtn))
            
        if vgn is not None:
            
            _query_params.append(('vgn', vgn))
            
        if chs is not None:
            
            _query_params.append(('chs', chs))
            
        if glf is not None:
            
            _query_params.append(('glf', glf))
            
        if ntf is not None:
            
            _query_params.append(('ntf', ntf))
            
        if dyf is not None:
            
            _query_params.append(('dyf', dyf))
            
        if sff is not None:
            
            _query_params.append(('sff', sff))
            
        if slf is not None:
            
            _query_params.append(('slf', slf))
            
        if tnf is not None:
            
            _query_params.append(('tnf', tnf))
            
        if wmf is not None:
            
            _query_params.append(('wmf', wmf))
            
        if rmf is not None:
            
            _query_params.append(('rmf', rmf))
            
        if cps is not None:
            
            _query_params.append(('cps', cps))
            
        if champion is not None:
            
            _query_params.append(('champion', champion))
            
        if synonyms is not None:
            
            _query_params.append(('synonyms', synonyms))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_recipe_search_random(
        self,
        any_kw: Annotated[Optional[StrictStr], Field(description="Search anywhere in the recipe for the keyword")] = None,
        folder: Annotated[Optional[StrictStr], Field(description="Search in a specific folder name for the authenticated user")] = None,
        coll: Annotated[Optional[StrictInt], Field(description="Limit to a collection ID number")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set")] = None,
        title_kw: Annotated[Optional[StrictStr], Field(description="Search just in the recipe title for the keyword")] = None,
        user_id: Annotated[Optional[StrictInt], Field(description="Set the target userid to search their public recipes")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set the target username to search their public recipes")] = None,
        token: Optional[StrictStr] = None,
        photos: Annotated[Optional[StrictBool], Field(description="if set to true, limit search results to photos only")] = None,
        boostmine: Annotated[Optional[StrictBool], Field(description="if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)")] = None,
        include_cat: Annotated[Optional[StrictStr], Field(description="integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".")] = None,
        exclude_cat: Annotated[Optional[StrictStr], Field(description="like include_cat, set this to an integer to exclude a specific category")] = None,
        include_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        exclude_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        include_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken")] = None,
        exclude_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)")] = None,
        cuisine: Annotated[Optional[StrictStr], Field(description="Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese")] = None,
        db: Optional[StrictStr] = None,
        userset: Annotated[Optional[StrictStr], Field(description="If set to a given username, it'll force the search to filter to just that username")] = None,
        servings_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"")] = None,
        total_mins: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)")] = None,
        max_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less")] = None,
        min_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that have at least {minIngredients}")] = None,
        vtn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegetarian (Powersearch-capable plan required)")] = None,
        vgn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegan (Powersearch-capable plan required)")] = None,
        chs: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to contains-cheese (Powersearch-capable plan required)")] = None,
        glf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to gluten-free (Powersearch-capable plan required)")] = None,
        ntf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to nut-free (Powersearch-capable plan required)")] = None,
        dyf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to dairy-free (Powersearch-capable plan required)")] = None,
        sff: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to seafood-free (Powersearch-capable plan required)")] = None,
        slf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to shellfish-free (Powersearch-capable plan required)")] = None,
        tnf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to tree-nut free (Powersearch-capable plan required)")] = None,
        wmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to white-meat free (Powersearch-capable plan required)")] = None,
        rmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to red-meat free (Powersearch-capable plan required)")] = None,
        cps: Annotated[Optional[StrictInt], Field(description="when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)")] = None,
        champion: Annotated[Optional[StrictInt], Field(description="optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.")] = None,
        synonyms: Annotated[Optional[StrictBool], Field(description="optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BigOvenModelAPI2RecipeSearchResult:
        """Search for recipes. There are many parameters that you can apply. Starting with the most common, use title_kw to search within a title.              Use any_kw to search across the entire recipe.              If you'd like to limit by course, set the parameter \"include_primarycat\" to one of (appetizers,bread,breakfast,dessert,drinks,maindish,salad,sidedish,soup,marinades,other).              If you'd like to exclude a category, set exclude_cat to one or more (comma-separated) list of those categories to exclude.              If you'd like to include a category, set include_cat to one or more (comma-separated) of those categories to include.              To explicitly include an ingredient in your search, set the parameter \"include_ing\" to a CSV of up to three ingredients, e.g.:include_ing=mustard,chicken,beef%20tips              To explicitly exclude an ingredient in your search, set the parameter \"exclude_ing\" to a CSV of up to three ingredients.              All searches must contain the paging parameters pg and rpp, which are integers, and represent the page number (1-based) and results per page (rpp).              So, to get the third page of a result set paged with 25 recipes per page, you'd pass pg=3&amp;rpp=25              If you'd like to target searches to just a single target user's recipes, set userId=the target userId (number).              Or, you can set username=theirusername              vtn;vgn;chs;glf;ntf;dyf;sff;slf;tnf;wmf;rmf;cps              cuisine              photos              filter=added,try,favorites,myrecipes\\r\\n\\r\\n              folder=FolderNameCaseSensitive              coll=ID of Collection


        :param any_kw: Search anywhere in the recipe for the keyword
        :type any_kw: str
        :param folder: Search in a specific folder name for the authenticated user
        :type folder: str
        :param coll: Limit to a collection ID number
        :type coll: int
        :param filter: optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set
        :type filter: str
        :param title_kw: Search just in the recipe title for the keyword
        :type title_kw: str
        :param user_id: Set the target userid to search their public recipes
        :type user_id: int
        :param username: Set the target username to search their public recipes
        :type username: str
        :param token: 
        :type token: str
        :param photos: if set to true, limit search results to photos only
        :type photos: bool
        :param boostmine: if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)
        :type boostmine: bool
        :param include_cat: integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".
        :type include_cat: str
        :param exclude_cat: like include_cat, set this to an integer to exclude a specific category
        :type exclude_cat: str
        :param include_primarycat: csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type include_primarycat: str
        :param exclude_primarycat: csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type exclude_primarycat: str
        :param include_ing: A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken
        :type include_ing: str
        :param exclude_ing: A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)
        :type exclude_ing: str
        :param cuisine: Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese
        :type cuisine: str
        :param db: 
        :type db: str
        :param userset: If set to a given username, it'll force the search to filter to just that username
        :type userset: str
        :param servings_min: Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"
        :type servings_min: float
        :param total_mins: Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)
        :type total_mins: int
        :param max_ingredients: Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less
        :type max_ingredients: int
        :param min_ingredients: Optional. If supplied, will restrict results to recipes that have at least {minIngredients}
        :type min_ingredients: int
        :param vtn: when set to 1, limit to vegetarian (Powersearch-capable plan required)
        :type vtn: int
        :param vgn: when set to 1, limit to vegan (Powersearch-capable plan required)
        :type vgn: int
        :param chs: when set to 1, limit to contains-cheese (Powersearch-capable plan required)
        :type chs: int
        :param glf: when set to 1, limit to gluten-free (Powersearch-capable plan required)
        :type glf: int
        :param ntf: when set to 1, limit to nut-free (Powersearch-capable plan required)
        :type ntf: int
        :param dyf: when set to 1, limit to dairy-free (Powersearch-capable plan required)
        :type dyf: int
        :param sff: when set to 1, limit to seafood-free (Powersearch-capable plan required)
        :type sff: int
        :param slf: when set to 1, limit to shellfish-free (Powersearch-capable plan required)
        :type slf: int
        :param tnf: when set to 1, limit to tree-nut free (Powersearch-capable plan required)
        :type tnf: int
        :param wmf: when set to 1, limit to white-meat free (Powersearch-capable plan required)
        :type wmf: int
        :param rmf: when set to 1, limit to red-meat free (Powersearch-capable plan required)
        :type rmf: int
        :param cps: when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)
        :type cps: int
        :param champion: optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.
        :type champion: int
        :param synonyms: optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)
        :type synonyms: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_recipe_search_random_serialize(
            any_kw=any_kw,
            folder=folder,
            coll=coll,
            filter=filter,
            title_kw=title_kw,
            user_id=user_id,
            username=username,
            token=token,
            photos=photos,
            boostmine=boostmine,
            include_cat=include_cat,
            exclude_cat=exclude_cat,
            include_primarycat=include_primarycat,
            exclude_primarycat=exclude_primarycat,
            include_ing=include_ing,
            exclude_ing=exclude_ing,
            cuisine=cuisine,
            db=db,
            userset=userset,
            servings_min=servings_min,
            total_mins=total_mins,
            max_ingredients=max_ingredients,
            min_ingredients=min_ingredients,
            vtn=vtn,
            vgn=vgn,
            chs=chs,
            glf=glf,
            ntf=ntf,
            dyf=dyf,
            sff=sff,
            slf=slf,
            tnf=tnf,
            wmf=wmf,
            rmf=rmf,
            cps=cps,
            champion=champion,
            synonyms=synonyms,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2RecipeSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_recipe_search_random_with_http_info(
        self,
        any_kw: Annotated[Optional[StrictStr], Field(description="Search anywhere in the recipe for the keyword")] = None,
        folder: Annotated[Optional[StrictStr], Field(description="Search in a specific folder name for the authenticated user")] = None,
        coll: Annotated[Optional[StrictInt], Field(description="Limit to a collection ID number")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set")] = None,
        title_kw: Annotated[Optional[StrictStr], Field(description="Search just in the recipe title for the keyword")] = None,
        user_id: Annotated[Optional[StrictInt], Field(description="Set the target userid to search their public recipes")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set the target username to search their public recipes")] = None,
        token: Optional[StrictStr] = None,
        photos: Annotated[Optional[StrictBool], Field(description="if set to true, limit search results to photos only")] = None,
        boostmine: Annotated[Optional[StrictBool], Field(description="if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)")] = None,
        include_cat: Annotated[Optional[StrictStr], Field(description="integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".")] = None,
        exclude_cat: Annotated[Optional[StrictStr], Field(description="like include_cat, set this to an integer to exclude a specific category")] = None,
        include_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        exclude_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        include_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken")] = None,
        exclude_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)")] = None,
        cuisine: Annotated[Optional[StrictStr], Field(description="Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese")] = None,
        db: Optional[StrictStr] = None,
        userset: Annotated[Optional[StrictStr], Field(description="If set to a given username, it'll force the search to filter to just that username")] = None,
        servings_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"")] = None,
        total_mins: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)")] = None,
        max_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less")] = None,
        min_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that have at least {minIngredients}")] = None,
        vtn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegetarian (Powersearch-capable plan required)")] = None,
        vgn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegan (Powersearch-capable plan required)")] = None,
        chs: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to contains-cheese (Powersearch-capable plan required)")] = None,
        glf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to gluten-free (Powersearch-capable plan required)")] = None,
        ntf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to nut-free (Powersearch-capable plan required)")] = None,
        dyf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to dairy-free (Powersearch-capable plan required)")] = None,
        sff: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to seafood-free (Powersearch-capable plan required)")] = None,
        slf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to shellfish-free (Powersearch-capable plan required)")] = None,
        tnf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to tree-nut free (Powersearch-capable plan required)")] = None,
        wmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to white-meat free (Powersearch-capable plan required)")] = None,
        rmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to red-meat free (Powersearch-capable plan required)")] = None,
        cps: Annotated[Optional[StrictInt], Field(description="when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)")] = None,
        champion: Annotated[Optional[StrictInt], Field(description="optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.")] = None,
        synonyms: Annotated[Optional[StrictBool], Field(description="optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BigOvenModelAPI2RecipeSearchResult]:
        """Search for recipes. There are many parameters that you can apply. Starting with the most common, use title_kw to search within a title.              Use any_kw to search across the entire recipe.              If you'd like to limit by course, set the parameter \"include_primarycat\" to one of (appetizers,bread,breakfast,dessert,drinks,maindish,salad,sidedish,soup,marinades,other).              If you'd like to exclude a category, set exclude_cat to one or more (comma-separated) list of those categories to exclude.              If you'd like to include a category, set include_cat to one or more (comma-separated) of those categories to include.              To explicitly include an ingredient in your search, set the parameter \"include_ing\" to a CSV of up to three ingredients, e.g.:include_ing=mustard,chicken,beef%20tips              To explicitly exclude an ingredient in your search, set the parameter \"exclude_ing\" to a CSV of up to three ingredients.              All searches must contain the paging parameters pg and rpp, which are integers, and represent the page number (1-based) and results per page (rpp).              So, to get the third page of a result set paged with 25 recipes per page, you'd pass pg=3&amp;rpp=25              If you'd like to target searches to just a single target user's recipes, set userId=the target userId (number).              Or, you can set username=theirusername              vtn;vgn;chs;glf;ntf;dyf;sff;slf;tnf;wmf;rmf;cps              cuisine              photos              filter=added,try,favorites,myrecipes\\r\\n\\r\\n              folder=FolderNameCaseSensitive              coll=ID of Collection


        :param any_kw: Search anywhere in the recipe for the keyword
        :type any_kw: str
        :param folder: Search in a specific folder name for the authenticated user
        :type folder: str
        :param coll: Limit to a collection ID number
        :type coll: int
        :param filter: optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set
        :type filter: str
        :param title_kw: Search just in the recipe title for the keyword
        :type title_kw: str
        :param user_id: Set the target userid to search their public recipes
        :type user_id: int
        :param username: Set the target username to search their public recipes
        :type username: str
        :param token: 
        :type token: str
        :param photos: if set to true, limit search results to photos only
        :type photos: bool
        :param boostmine: if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)
        :type boostmine: bool
        :param include_cat: integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".
        :type include_cat: str
        :param exclude_cat: like include_cat, set this to an integer to exclude a specific category
        :type exclude_cat: str
        :param include_primarycat: csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type include_primarycat: str
        :param exclude_primarycat: csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type exclude_primarycat: str
        :param include_ing: A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken
        :type include_ing: str
        :param exclude_ing: A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)
        :type exclude_ing: str
        :param cuisine: Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese
        :type cuisine: str
        :param db: 
        :type db: str
        :param userset: If set to a given username, it'll force the search to filter to just that username
        :type userset: str
        :param servings_min: Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"
        :type servings_min: float
        :param total_mins: Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)
        :type total_mins: int
        :param max_ingredients: Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less
        :type max_ingredients: int
        :param min_ingredients: Optional. If supplied, will restrict results to recipes that have at least {minIngredients}
        :type min_ingredients: int
        :param vtn: when set to 1, limit to vegetarian (Powersearch-capable plan required)
        :type vtn: int
        :param vgn: when set to 1, limit to vegan (Powersearch-capable plan required)
        :type vgn: int
        :param chs: when set to 1, limit to contains-cheese (Powersearch-capable plan required)
        :type chs: int
        :param glf: when set to 1, limit to gluten-free (Powersearch-capable plan required)
        :type glf: int
        :param ntf: when set to 1, limit to nut-free (Powersearch-capable plan required)
        :type ntf: int
        :param dyf: when set to 1, limit to dairy-free (Powersearch-capable plan required)
        :type dyf: int
        :param sff: when set to 1, limit to seafood-free (Powersearch-capable plan required)
        :type sff: int
        :param slf: when set to 1, limit to shellfish-free (Powersearch-capable plan required)
        :type slf: int
        :param tnf: when set to 1, limit to tree-nut free (Powersearch-capable plan required)
        :type tnf: int
        :param wmf: when set to 1, limit to white-meat free (Powersearch-capable plan required)
        :type wmf: int
        :param rmf: when set to 1, limit to red-meat free (Powersearch-capable plan required)
        :type rmf: int
        :param cps: when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)
        :type cps: int
        :param champion: optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.
        :type champion: int
        :param synonyms: optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)
        :type synonyms: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_recipe_search_random_serialize(
            any_kw=any_kw,
            folder=folder,
            coll=coll,
            filter=filter,
            title_kw=title_kw,
            user_id=user_id,
            username=username,
            token=token,
            photos=photos,
            boostmine=boostmine,
            include_cat=include_cat,
            exclude_cat=exclude_cat,
            include_primarycat=include_primarycat,
            exclude_primarycat=exclude_primarycat,
            include_ing=include_ing,
            exclude_ing=exclude_ing,
            cuisine=cuisine,
            db=db,
            userset=userset,
            servings_min=servings_min,
            total_mins=total_mins,
            max_ingredients=max_ingredients,
            min_ingredients=min_ingredients,
            vtn=vtn,
            vgn=vgn,
            chs=chs,
            glf=glf,
            ntf=ntf,
            dyf=dyf,
            sff=sff,
            slf=slf,
            tnf=tnf,
            wmf=wmf,
            rmf=rmf,
            cps=cps,
            champion=champion,
            synonyms=synonyms,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2RecipeSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_recipe_search_random_without_preload_content(
        self,
        any_kw: Annotated[Optional[StrictStr], Field(description="Search anywhere in the recipe for the keyword")] = None,
        folder: Annotated[Optional[StrictStr], Field(description="Search in a specific folder name for the authenticated user")] = None,
        coll: Annotated[Optional[StrictInt], Field(description="Limit to a collection ID number")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set")] = None,
        title_kw: Annotated[Optional[StrictStr], Field(description="Search just in the recipe title for the keyword")] = None,
        user_id: Annotated[Optional[StrictInt], Field(description="Set the target userid to search their public recipes")] = None,
        username: Annotated[Optional[StrictStr], Field(description="Set the target username to search their public recipes")] = None,
        token: Optional[StrictStr] = None,
        photos: Annotated[Optional[StrictBool], Field(description="if set to true, limit search results to photos only")] = None,
        boostmine: Annotated[Optional[StrictBool], Field(description="if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)")] = None,
        include_cat: Annotated[Optional[StrictStr], Field(description="integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".")] = None,
        exclude_cat: Annotated[Optional[StrictStr], Field(description="like include_cat, set this to an integer to exclude a specific category")] = None,
        include_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        exclude_primarycat: Annotated[Optional[StrictStr], Field(description="csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]")] = None,
        include_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken")] = None,
        exclude_ing: Annotated[Optional[StrictStr], Field(description="A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)")] = None,
        cuisine: Annotated[Optional[StrictStr], Field(description="Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese")] = None,
        db: Optional[StrictStr] = None,
        userset: Annotated[Optional[StrictStr], Field(description="If set to a given username, it'll force the search to filter to just that username")] = None,
        servings_min: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"")] = None,
        total_mins: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)")] = None,
        max_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less")] = None,
        min_ingredients: Annotated[Optional[StrictInt], Field(description="Optional. If supplied, will restrict results to recipes that have at least {minIngredients}")] = None,
        vtn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegetarian (Powersearch-capable plan required)")] = None,
        vgn: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to vegan (Powersearch-capable plan required)")] = None,
        chs: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to contains-cheese (Powersearch-capable plan required)")] = None,
        glf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to gluten-free (Powersearch-capable plan required)")] = None,
        ntf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to nut-free (Powersearch-capable plan required)")] = None,
        dyf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to dairy-free (Powersearch-capable plan required)")] = None,
        sff: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to seafood-free (Powersearch-capable plan required)")] = None,
        slf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to shellfish-free (Powersearch-capable plan required)")] = None,
        tnf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to tree-nut free (Powersearch-capable plan required)")] = None,
        wmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to white-meat free (Powersearch-capable plan required)")] = None,
        rmf: Annotated[Optional[StrictInt], Field(description="when set to 1, limit to red-meat free (Powersearch-capable plan required)")] = None,
        cps: Annotated[Optional[StrictInt], Field(description="when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)")] = None,
        champion: Annotated[Optional[StrictInt], Field(description="optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.")] = None,
        synonyms: Annotated[Optional[StrictBool], Field(description="optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for recipes. There are many parameters that you can apply. Starting with the most common, use title_kw to search within a title.              Use any_kw to search across the entire recipe.              If you'd like to limit by course, set the parameter \"include_primarycat\" to one of (appetizers,bread,breakfast,dessert,drinks,maindish,salad,sidedish,soup,marinades,other).              If you'd like to exclude a category, set exclude_cat to one or more (comma-separated) list of those categories to exclude.              If you'd like to include a category, set include_cat to one or more (comma-separated) of those categories to include.              To explicitly include an ingredient in your search, set the parameter \"include_ing\" to a CSV of up to three ingredients, e.g.:include_ing=mustard,chicken,beef%20tips              To explicitly exclude an ingredient in your search, set the parameter \"exclude_ing\" to a CSV of up to three ingredients.              All searches must contain the paging parameters pg and rpp, which are integers, and represent the page number (1-based) and results per page (rpp).              So, to get the third page of a result set paged with 25 recipes per page, you'd pass pg=3&amp;rpp=25              If you'd like to target searches to just a single target user's recipes, set userId=the target userId (number).              Or, you can set username=theirusername              vtn;vgn;chs;glf;ntf;dyf;sff;slf;tnf;wmf;rmf;cps              cuisine              photos              filter=added,try,favorites,myrecipes\\r\\n\\r\\n              folder=FolderNameCaseSensitive              coll=ID of Collection


        :param any_kw: Search anywhere in the recipe for the keyword
        :type any_kw: str
        :param folder: Search in a specific folder name for the authenticated user
        :type folder: str
        :param coll: Limit to a collection ID number
        :type coll: int
        :param filter: optionally set to either \"myrecipes\", \"try\", \"favorites\",\"added\" to filter to just the authenticated user's recipe set
        :type filter: str
        :param title_kw: Search just in the recipe title for the keyword
        :type title_kw: str
        :param user_id: Set the target userid to search their public recipes
        :type user_id: int
        :param username: Set the target username to search their public recipes
        :type username: str
        :param token: 
        :type token: str
        :param photos: if set to true, limit search results to photos only
        :type photos: bool
        :param boostmine: if set to true, boost my own recipes in my folders so they show up high in the list (at the expense of other sort orders)
        :type boostmine: bool
        :param include_cat: integer of the subcategory you'd like to limit searches to (see the /recipe/categories endpoint for available id numbers). For instance, 58 is \"Main Dish &gt; Casseroles\".
        :type include_cat: str
        :param exclude_cat: like include_cat, set this to an integer to exclude a specific category
        :type exclude_cat: str
        :param include_primarycat: csv indicating up to three top-level categories -- valid values are [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type include_primarycat: str
        :param exclude_primarycat: csv indicating integer values for up to 3 top-level categories -- valid values are 1...11 [appetizers,bread,breakfast,desserts,drinks,maindish,salads,sidedish,soups,marinades,other]
        :type exclude_primarycat: str
        :param include_ing: A CSV representing up to 3 ingredients to include, e.g., tomatoes,corn%20%starch,chicken
        :type include_ing: str
        :param exclude_ing: A CSV representing up to 3 ingredients to exclude  (Powersearch-capable plan required)
        :type exclude_ing: str
        :param cuisine: Limit to a specific cuisine. Cooks can enter anything free-form, but the few dozen preconfigured values are Afghan,African,American,American-South,Asian,Australian,Brazilian,Cajun,Canadian,Caribbean,Chinese,Croatian,Cuban,Dessert,Eastern European,English,French,German,Greek,Hawaiian,Hungarian,India,Indian,Irish,Italian,Japanese,Jewish,Korean,Latin,Mediterranean,Mexican,Middle Eastern,Moroccan,Polish,Russian,Scandanavian,Seafood,Southern,Southwestern,Spanish,Tex-Mex,Thai,Vegan,Vegetarian,Vietnamese
        :type cuisine: str
        :param db: 
        :type db: str
        :param userset: If set to a given username, it'll force the search to filter to just that username
        :type userset: str
        :param servings_min: Limit to yield of a given number size or greater. Note that cooks usually enter recipes by Servings, but sometimes they are posted by \"dozen\", etc. This parameter simply specifies the minimum number for that value entered in \"yield.\"
        :type servings_min: float
        :param total_mins: Optional. If supplied, will restrict results to recipes that can be made in {totalMins} or less. (Convert \"1 hour, 15 minutes\" to 75 before passing in.)
        :type total_mins: int
        :param max_ingredients: Optional. If supplied, will restrict results to recipes that can be made with {maxIngredients} ingredients or less
        :type max_ingredients: int
        :param min_ingredients: Optional. If supplied, will restrict results to recipes that have at least {minIngredients}
        :type min_ingredients: int
        :param vtn: when set to 1, limit to vegetarian (Powersearch-capable plan required)
        :type vtn: int
        :param vgn: when set to 1, limit to vegan (Powersearch-capable plan required)
        :type vgn: int
        :param chs: when set to 1, limit to contains-cheese (Powersearch-capable plan required)
        :type chs: int
        :param glf: when set to 1, limit to gluten-free (Powersearch-capable plan required)
        :type glf: int
        :param ntf: when set to 1, limit to nut-free (Powersearch-capable plan required)
        :type ntf: int
        :param dyf: when set to 1, limit to dairy-free (Powersearch-capable plan required)
        :type dyf: int
        :param sff: when set to 1, limit to seafood-free (Powersearch-capable plan required)
        :type sff: int
        :param slf: when set to 1, limit to shellfish-free (Powersearch-capable plan required)
        :type slf: int
        :param tnf: when set to 1, limit to tree-nut free (Powersearch-capable plan required)
        :type tnf: int
        :param wmf: when set to 1, limit to white-meat free (Powersearch-capable plan required)
        :type wmf: int
        :param rmf: when set to 1, limit to red-meat free (Powersearch-capable plan required)
        :type rmf: int
        :param cps: when set to 1, recipe contains pasta, set to 0 means contains no pasta (Powersearch-capable plan required)
        :type cps: int
        :param champion: optional. When set to 1, this will limit search results to \"best of\" recipes as determined by various internal editorial and programmatic algorithms. For the most comprehensive results, don't include this parameter.
        :type champion: int
        :param synonyms: optional, default is false. When set to true, BigOven will attempt to apply synonyms in search (e.g., excluding pork will also exclude bacon)
        :type synonyms: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_recipe_search_random_serialize(
            any_kw=any_kw,
            folder=folder,
            coll=coll,
            filter=filter,
            title_kw=title_kw,
            user_id=user_id,
            username=username,
            token=token,
            photos=photos,
            boostmine=boostmine,
            include_cat=include_cat,
            exclude_cat=exclude_cat,
            include_primarycat=include_primarycat,
            exclude_primarycat=exclude_primarycat,
            include_ing=include_ing,
            exclude_ing=exclude_ing,
            cuisine=cuisine,
            db=db,
            userset=userset,
            servings_min=servings_min,
            total_mins=total_mins,
            max_ingredients=max_ingredients,
            min_ingredients=min_ingredients,
            vtn=vtn,
            vgn=vgn,
            chs=chs,
            glf=glf,
            ntf=ntf,
            dyf=dyf,
            sff=sff,
            slf=slf,
            tnf=tnf,
            wmf=wmf,
            rmf=rmf,
            cps=cps,
            champion=champion,
            synonyms=synonyms,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2RecipeSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_recipe_search_random_serialize(
        self,
        any_kw,
        folder,
        coll,
        filter,
        title_kw,
        user_id,
        username,
        token,
        photos,
        boostmine,
        include_cat,
        exclude_cat,
        include_primarycat,
        exclude_primarycat,
        include_ing,
        exclude_ing,
        cuisine,
        db,
        userset,
        servings_min,
        total_mins,
        max_ingredients,
        min_ingredients,
        vtn,
        vgn,
        chs,
        glf,
        ntf,
        dyf,
        sff,
        slf,
        tnf,
        wmf,
        rmf,
        cps,
        champion,
        synonyms,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if any_kw is not None:
            
            _query_params.append(('any_kw', any_kw))
            
        if folder is not None:
            
            _query_params.append(('folder', folder))
            
        if coll is not None:
            
            _query_params.append(('coll', coll))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if title_kw is not None:
            
            _query_params.append(('title_kw', title_kw))
            
        if user_id is not None:
            
            _query_params.append(('userId', user_id))
            
        if username is not None:
            
            _query_params.append(('username', username))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        if photos is not None:
            
            _query_params.append(('photos', photos))
            
        if boostmine is not None:
            
            _query_params.append(('boostmine', boostmine))
            
        if include_cat is not None:
            
            _query_params.append(('include_cat', include_cat))
            
        if exclude_cat is not None:
            
            _query_params.append(('exclude_cat', exclude_cat))
            
        if include_primarycat is not None:
            
            _query_params.append(('include_primarycat', include_primarycat))
            
        if exclude_primarycat is not None:
            
            _query_params.append(('exclude_primarycat', exclude_primarycat))
            
        if include_ing is not None:
            
            _query_params.append(('include_ing', include_ing))
            
        if exclude_ing is not None:
            
            _query_params.append(('exclude_ing', exclude_ing))
            
        if cuisine is not None:
            
            _query_params.append(('cuisine', cuisine))
            
        if db is not None:
            
            _query_params.append(('db', db))
            
        if userset is not None:
            
            _query_params.append(('userset', userset))
            
        if servings_min is not None:
            
            _query_params.append(('servingsMin', servings_min))
            
        if total_mins is not None:
            
            _query_params.append(('totalMins', total_mins))
            
        if max_ingredients is not None:
            
            _query_params.append(('maxIngredients', max_ingredients))
            
        if min_ingredients is not None:
            
            _query_params.append(('minIngredients', min_ingredients))
            
        if vtn is not None:
            
            _query_params.append(('vtn', vtn))
            
        if vgn is not None:
            
            _query_params.append(('vgn', vgn))
            
        if chs is not None:
            
            _query_params.append(('chs', chs))
            
        if glf is not None:
            
            _query_params.append(('glf', glf))
            
        if ntf is not None:
            
            _query_params.append(('ntf', ntf))
            
        if dyf is not None:
            
            _query_params.append(('dyf', dyf))
            
        if sff is not None:
            
            _query_params.append(('sff', sff))
            
        if slf is not None:
            
            _query_params.append(('slf', slf))
            
        if tnf is not None:
            
            _query_params.append(('tnf', tnf))
            
        if wmf is not None:
            
            _query_params.append(('wmf', wmf))
            
        if rmf is not None:
            
            _query_params.append(('rmf', rmf))
            
        if cps is not None:
            
            _query_params.append(('cps', cps))
            
        if champion is not None:
            
            _query_params.append(('champion', champion))
            
        if synonyms is not None:
            
            _query_params.append(('synonyms', synonyms))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipes/top25random',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_related(
        self,
        recipe_id: Annotated[StrictInt, Field(description="The recipe id")],
        pg: Annotated[Optional[StrictInt], Field(description="The page")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="The results per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BigOvenModelAPI2RecipeSearchResult:
        """Get recipes related to the given recipeId


        :param recipe_id: The recipe id (required)
        :type recipe_id: int
        :param pg: The page
        :type pg: int
        :param rpp: The results per page
        :type rpp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_related_serialize(
            recipe_id=recipe_id,
            pg=pg,
            rpp=rpp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2RecipeSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_related_with_http_info(
        self,
        recipe_id: Annotated[StrictInt, Field(description="The recipe id")],
        pg: Annotated[Optional[StrictInt], Field(description="The page")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="The results per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BigOvenModelAPI2RecipeSearchResult]:
        """Get recipes related to the given recipeId


        :param recipe_id: The recipe id (required)
        :type recipe_id: int
        :param pg: The page
        :type pg: int
        :param rpp: The results per page
        :type rpp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_related_serialize(
            recipe_id=recipe_id,
            pg=pg,
            rpp=rpp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2RecipeSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_related_without_preload_content(
        self,
        recipe_id: Annotated[StrictInt, Field(description="The recipe id")],
        pg: Annotated[Optional[StrictInt], Field(description="The page")] = None,
        rpp: Annotated[Optional[StrictInt], Field(description="The results per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get recipes related to the given recipeId


        :param recipe_id: The recipe id (required)
        :type recipe_id: int
        :param pg: The page
        :type pg: int
        :param rpp: The results per page
        :type rpp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_related_serialize(
            recipe_id=recipe_id,
            pg=pg,
            rpp=rpp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BigOvenModelAPI2RecipeSearchResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_related_serialize(
        self,
        recipe_id,
        pg,
        rpp,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if recipe_id is not None:
            _path_params['recipeId'] = recipe_id
        # process the query parameters
        if pg is not None:
            
            _query_params.append(('pg', pg))
            
        if rpp is not None:
            
            _query_params.append(('rpp', rpp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipe/{recipeId}/related',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_scan(
        self,
        test: Optional[StrictBool] = None,
        devicetype: Optional[StrictStr] = None,
        lat: Optional[Union[StrictFloat, StrictInt]] = None,
        lng: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """POST an image as a new RecipeScan request                  1)  Fetch the filename -- DONE                  2)  Copy it to the pics/scan folder - ENSURE NO NAMING COLLISIONS -- DONE                  3)  Create 120 thumbnail size  in pics/scan/120 -- DONE                  4)  Insert the CloudTasks record                  5)  Create the HIT                  6)  Update the CloudTasks record with the HIT ID                  7)  Email the requesing user                  8)  Call out to www.bigoven.com to fetch the image and re-create the thumbnail


        :param test:
        :type test: bool
        :param devicetype:
        :type devicetype: str
        :param lat:
        :type lat: float
        :param lng:
        :type lng: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_scan_serialize(
            test=test,
            devicetype=devicetype,
            lat=lat,
            lng=lng,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': None,
            '402': None,
            '415': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_scan_with_http_info(
        self,
        test: Optional[StrictBool] = None,
        devicetype: Optional[StrictStr] = None,
        lat: Optional[Union[StrictFloat, StrictInt]] = None,
        lng: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """POST an image as a new RecipeScan request                  1)  Fetch the filename -- DONE                  2)  Copy it to the pics/scan folder - ENSURE NO NAMING COLLISIONS -- DONE                  3)  Create 120 thumbnail size  in pics/scan/120 -- DONE                  4)  Insert the CloudTasks record                  5)  Create the HIT                  6)  Update the CloudTasks record with the HIT ID                  7)  Email the requesing user                  8)  Call out to www.bigoven.com to fetch the image and re-create the thumbnail


        :param test:
        :type test: bool
        :param devicetype:
        :type devicetype: str
        :param lat:
        :type lat: float
        :param lng:
        :type lng: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_scan_serialize(
            test=test,
            devicetype=devicetype,
            lat=lat,
            lng=lng,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': None,
            '402': None,
            '415': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_scan_without_preload_content(
        self,
        test: Optional[StrictBool] = None,
        devicetype: Optional[StrictStr] = None,
        lat: Optional[Union[StrictFloat, StrictInt]] = None,
        lng: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """POST an image as a new RecipeScan request                  1)  Fetch the filename -- DONE                  2)  Copy it to the pics/scan folder - ENSURE NO NAMING COLLISIONS -- DONE                  3)  Create 120 thumbnail size  in pics/scan/120 -- DONE                  4)  Insert the CloudTasks record                  5)  Create the HIT                  6)  Update the CloudTasks record with the HIT ID                  7)  Email the requesing user                  8)  Call out to www.bigoven.com to fetch the image and re-create the thumbnail


        :param test:
        :type test: bool
        :param devicetype:
        :type devicetype: str
        :param lat:
        :type lat: float
        :param lng:
        :type lng: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_scan_serialize(
            test=test,
            devicetype=devicetype,
            lat=lat,
            lng=lng,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': None,
            '402': None,
            '415': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_scan_serialize(
        self,
        test,
        devicetype,
        lat,
        lng,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if test is not None:
            
            _query_params.append(('test', test))
            
        if devicetype is not None:
            
            _query_params.append(('devicetype', devicetype))
            
        if lat is not None:
            
            _query_params.append(('lat', lat))
            
        if lng is not None:
            
            _query_params.append(('lng', lng))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/recipe/scan',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def recipe_zap_recipe(
        self,
        id: Annotated[StrictInt, Field(description="The identifier.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Zaps the recipe.


        :param id: The identifier. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_zap_recipe_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def recipe_zap_recipe_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The identifier.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Zaps the recipe.


        :param id: The identifier. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_zap_recipe_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def recipe_zap_recipe_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The identifier.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Zaps the recipe.


        :param id: The identifier. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recipe_zap_recipe_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recipe_zap_recipe_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'application/xml', 
                    'text/json', 
                    'text/xml'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/recipe/{id}/zap',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


