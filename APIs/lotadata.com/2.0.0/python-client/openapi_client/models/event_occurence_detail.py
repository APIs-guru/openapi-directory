# coding: utf-8

"""
    LotaData

    Access the most exhaustive, accurate and up-to-date collection of global and hyper-local geocoded events and activities across a wide range of categories and genres

    The version of the OpenAPI document: 2.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.contact_detail import ContactDetail
from openapi_client.models.feature_reference import FeatureReference
from openapi_client.models.image_meta import ImageMeta
from openapi_client.models.occurrence_reference import OccurrenceReference
from openapi_client.models.place_reference import PlaceReference
from openapi_client.models.ticket_offer import TicketOffer
from typing import Optional, Set
from typing_extensions import Self

class EventOccurenceDetail(BaseModel):
    """
    Event Occurrence Detail limited to requested fieldset.
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="Unique event id", alias="@id")
    type: Optional[StrictStr] = Field(default=None, description="Type of occurrence. You will usually see Organized as the type for most events. While Virtual events will get their own Virtual type.", alias="@type")
    activity: Optional[List[FeatureReference]] = Field(default=None, description="Associated ActivityType entries")
    ambience: Optional[List[FeatureReference]] = Field(default=None, description="expected mood and feel of the event")
    at: Optional[PlaceReference] = None
    away_team: Optional[FeatureReference] = Field(default=None, alias="awayTeam")
    category: Optional[List[FeatureReference]] = Field(default=None, description="Associated EventCategory. May be multiple, such as Charity Music event")
    contact_point: Optional[ContactDetail] = Field(default=None, alias="contactPoint")
    description: Optional[StrictStr] = Field(default=None, description="Full description in plain text")
    door_time: Optional[datetime] = Field(default=None, description="Time when the admission starts", alias="doorTime")
    duration: Optional[StrictStr] = Field(default=None, description="Duration of the event in ISO-8601 format (PT45M) - 45 minutes")
    end_approx: Optional[StrictBool] = Field(default=None, description="endDate is approximated based on historical data", alias="endApprox")
    end_date: Optional[datetime] = Field(default=None, description="Time when the event ends, if known", alias="endDate")
    ext_taxonomy: Optional[List[FeatureReference]] = Field(default=None, description="extended taxonomy such as IAB and Google AdWords", alias="extTaxonomy")
    genre: Optional[List[FeatureReference]] = Field(default=None, description="applicable Genres. (Tier 2 taxonomy). May include related genres from categories, not deemed as primary")
    headline: Optional[StrictStr] = Field(default=None, description="Optional short description in plain text")
    home_team: Optional[FeatureReference] = Field(default=None, alias="homeTeam")
    html_description: Optional[StrictStr] = Field(default=None, description="Full description with HTML formatting, where available", alias="htmlDescription")
    image: Optional[ImageMeta] = None
    in_language: Optional[FeatureReference] = Field(default=None, alias="inLanguage")
    name: Optional[StrictStr] = Field(default=None, description="Name of the event in plain text")
    no_time: Optional[StrictBool] = Field(default=None, description="Specific time of the event is unknown. (shown only when true)", alias="noTime")
    offers: Optional[List[TicketOffer]] = Field(default=None, description="Ticketing options")
    on_demand: Optional[StrictBool] = Field(default=None, description="This event can start at any time during specified window", alias="onDemand")
    performer: Optional[List[FeatureReference]] = Field(default=None, description="List of Personas significant for this event")
    photo: Optional[List[ImageMeta]] = Field(default=None, description="Primary image")
    start_date: Optional[datetime] = Field(default=None, description="Time when the event starts", alias="startDate")
    super_event: Optional[OccurrenceReference] = Field(default=None, alias="superEvent")
    updated: Optional[datetime] = Field(default=None, description="Timestamp of last modification (UTC)")
    url: Optional[StrictStr] = Field(default=None, description="Primary url for published event")
    work_performed: Optional[List[FeatureReference]] = Field(default=None, description="Subject matter of the event", alias="workPerformed")
    __properties: ClassVar[List[str]] = ["@id", "@type", "activity", "ambience", "at", "awayTeam", "category", "contactPoint", "description", "doorTime", "duration", "endApprox", "endDate", "extTaxonomy", "genre", "headline", "homeTeam", "htmlDescription", "image", "inLanguage", "name", "noTime", "offers", "onDemand", "performer", "photo", "startDate", "superEvent", "updated", "url", "workPerformed"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Organized', 'Screening', 'Environmental', 'Virtual']):
            raise ValueError("must be one of enum values ('Organized', 'Screening', 'Environmental', 'Virtual')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of EventOccurenceDetail from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in activity (list)
        _items = []
        if self.activity:
            for _item_activity in self.activity:
                if _item_activity:
                    _items.append(_item_activity.to_dict())
            _dict['activity'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in ambience (list)
        _items = []
        if self.ambience:
            for _item_ambience in self.ambience:
                if _item_ambience:
                    _items.append(_item_ambience.to_dict())
            _dict['ambience'] = _items
        # override the default output from pydantic by calling `to_dict()` of at
        if self.at:
            _dict['at'] = self.at.to_dict()
        # override the default output from pydantic by calling `to_dict()` of away_team
        if self.away_team:
            _dict['awayTeam'] = self.away_team.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in category (list)
        _items = []
        if self.category:
            for _item_category in self.category:
                if _item_category:
                    _items.append(_item_category.to_dict())
            _dict['category'] = _items
        # override the default output from pydantic by calling `to_dict()` of contact_point
        if self.contact_point:
            _dict['contactPoint'] = self.contact_point.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in ext_taxonomy (list)
        _items = []
        if self.ext_taxonomy:
            for _item_ext_taxonomy in self.ext_taxonomy:
                if _item_ext_taxonomy:
                    _items.append(_item_ext_taxonomy.to_dict())
            _dict['extTaxonomy'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in genre (list)
        _items = []
        if self.genre:
            for _item_genre in self.genre:
                if _item_genre:
                    _items.append(_item_genre.to_dict())
            _dict['genre'] = _items
        # override the default output from pydantic by calling `to_dict()` of home_team
        if self.home_team:
            _dict['homeTeam'] = self.home_team.to_dict()
        # override the default output from pydantic by calling `to_dict()` of image
        if self.image:
            _dict['image'] = self.image.to_dict()
        # override the default output from pydantic by calling `to_dict()` of in_language
        if self.in_language:
            _dict['inLanguage'] = self.in_language.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in offers (list)
        _items = []
        if self.offers:
            for _item_offers in self.offers:
                if _item_offers:
                    _items.append(_item_offers.to_dict())
            _dict['offers'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in performer (list)
        _items = []
        if self.performer:
            for _item_performer in self.performer:
                if _item_performer:
                    _items.append(_item_performer.to_dict())
            _dict['performer'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in photo (list)
        _items = []
        if self.photo:
            for _item_photo in self.photo:
                if _item_photo:
                    _items.append(_item_photo.to_dict())
            _dict['photo'] = _items
        # override the default output from pydantic by calling `to_dict()` of super_event
        if self.super_event:
            _dict['superEvent'] = self.super_event.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in work_performed (list)
        _items = []
        if self.work_performed:
            for _item_work_performed in self.work_performed:
                if _item_work_performed:
                    _items.append(_item_work_performed.to_dict())
            _dict['workPerformed'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of EventOccurenceDetail from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "@id": obj.get("@id"),
            "@type": obj.get("@type"),
            "activity": [FeatureReference.from_dict(_item) for _item in obj["activity"]] if obj.get("activity") is not None else None,
            "ambience": [FeatureReference.from_dict(_item) for _item in obj["ambience"]] if obj.get("ambience") is not None else None,
            "at": PlaceReference.from_dict(obj["at"]) if obj.get("at") is not None else None,
            "awayTeam": FeatureReference.from_dict(obj["awayTeam"]) if obj.get("awayTeam") is not None else None,
            "category": [FeatureReference.from_dict(_item) for _item in obj["category"]] if obj.get("category") is not None else None,
            "contactPoint": ContactDetail.from_dict(obj["contactPoint"]) if obj.get("contactPoint") is not None else None,
            "description": obj.get("description"),
            "doorTime": obj.get("doorTime"),
            "duration": obj.get("duration"),
            "endApprox": obj.get("endApprox"),
            "endDate": obj.get("endDate"),
            "extTaxonomy": [FeatureReference.from_dict(_item) for _item in obj["extTaxonomy"]] if obj.get("extTaxonomy") is not None else None,
            "genre": [FeatureReference.from_dict(_item) for _item in obj["genre"]] if obj.get("genre") is not None else None,
            "headline": obj.get("headline"),
            "homeTeam": FeatureReference.from_dict(obj["homeTeam"]) if obj.get("homeTeam") is not None else None,
            "htmlDescription": obj.get("htmlDescription"),
            "image": ImageMeta.from_dict(obj["image"]) if obj.get("image") is not None else None,
            "inLanguage": FeatureReference.from_dict(obj["inLanguage"]) if obj.get("inLanguage") is not None else None,
            "name": obj.get("name"),
            "noTime": obj.get("noTime"),
            "offers": [TicketOffer.from_dict(_item) for _item in obj["offers"]] if obj.get("offers") is not None else None,
            "onDemand": obj.get("onDemand"),
            "performer": [FeatureReference.from_dict(_item) for _item in obj["performer"]] if obj.get("performer") is not None else None,
            "photo": [ImageMeta.from_dict(_item) for _item in obj["photo"]] if obj.get("photo") is not None else None,
            "startDate": obj.get("startDate"),
            "superEvent": OccurrenceReference.from_dict(obj["superEvent"]) if obj.get("superEvent") is not None else None,
            "updated": obj.get("updated"),
            "url": obj.get("url"),
            "workPerformed": [FeatureReference.from_dict(_item) for _item in obj["workPerformed"]] if obj.get("workPerformed") is not None else None
        })
        return _obj


