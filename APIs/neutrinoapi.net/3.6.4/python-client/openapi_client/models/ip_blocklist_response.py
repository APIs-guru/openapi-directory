# coding: utf-8

"""
    Neutrino API

    The general-purpose API

    The version of the OpenAPI document: 3.6.4
    Contact: ops@neutrinoapi.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from openapi_client.models.blocklist_sensor import BlocklistSensor
from typing import Optional, Set
from typing_extensions import Self

class IPBlocklistResponse(BaseModel):
    """
    IPBlocklistResponse
    """ # noqa: E501
    blocklists: List[StrictStr] = Field(description="An array of strings indicating which blocklist categories this IP is listed on")
    cidr: StrictStr = Field(description="The CIDR address for this listing (only set if the IP is listed)")
    ip: StrictStr = Field(description="The IP address")
    is_bot: StrictBool = Field(description="IP is hosting a malicious bot or is part of a botnet. This is a broad category which includes brute-force crackers", alias="is-bot")
    is_dshield: StrictBool = Field(description="IP has been flagged as a significant attack source by DShield (dshield.org)", alias="is-dshield")
    is_exploit_bot: StrictBool = Field(description="IP is hosting an exploit finding bot or is running exploit scanning software", alias="is-exploit-bot")
    is_hijacked: StrictBool = Field(description="IP is part of a hijacked netblock or a netblock controlled by a criminal organization", alias="is-hijacked")
    is_listed: StrictBool = Field(description="Is this IP on a blocklist", alias="is-listed")
    is_malware: StrictBool = Field(description="IP is involved in distributing or is running malware", alias="is-malware")
    is_proxy: StrictBool = Field(description="IP has been detected as an anonymous web proxy or anonymous HTTP proxy", alias="is-proxy")
    is_spam_bot: StrictBool = Field(description="IP address is hosting a spam bot, comment spamming or any other spamming type software", alias="is-spam-bot")
    is_spider: StrictBool = Field(description="IP is running a hostile web spider / web crawler", alias="is-spider")
    is_spyware: StrictBool = Field(description="IP is involved in distributing or is running spyware", alias="is-spyware")
    is_tor: StrictBool = Field(description="IP is a Tor node or running a Tor related service", alias="is-tor")
    is_vpn: StrictBool = Field(description="IP belongs to a public VPN provider (only set if the 'vpn-lookup' option is enabled)", alias="is-vpn")
    last_seen: StrictInt = Field(description="The unix time when this IP was last seen on any blocklist. IPs are automatically removed after 7 days therefor this value will never be older than 7 days", alias="last-seen")
    list_count: StrictInt = Field(description="The number of blocklists the IP is listed on", alias="list-count")
    sensors: List[BlocklistSensor] = Field(description="An array of objects containing details on which specific sensors detected the IP")
    __properties: ClassVar[List[str]] = ["blocklists", "cidr", "ip", "is-bot", "is-dshield", "is-exploit-bot", "is-hijacked", "is-listed", "is-malware", "is-proxy", "is-spam-bot", "is-spider", "is-spyware", "is-tor", "is-vpn", "last-seen", "list-count", "sensors"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of IPBlocklistResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in sensors (list)
        _items = []
        if self.sensors:
            for _item_sensors in self.sensors:
                if _item_sensors:
                    _items.append(_item_sensors.to_dict())
            _dict['sensors'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of IPBlocklistResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "blocklists": obj.get("blocklists"),
            "cidr": obj.get("cidr"),
            "ip": obj.get("ip"),
            "is-bot": obj.get("is-bot"),
            "is-dshield": obj.get("is-dshield"),
            "is-exploit-bot": obj.get("is-exploit-bot"),
            "is-hijacked": obj.get("is-hijacked"),
            "is-listed": obj.get("is-listed"),
            "is-malware": obj.get("is-malware"),
            "is-proxy": obj.get("is-proxy"),
            "is-spam-bot": obj.get("is-spam-bot"),
            "is-spider": obj.get("is-spider"),
            "is-spyware": obj.get("is-spyware"),
            "is-tor": obj.get("is-tor"),
            "is-vpn": obj.get("is-vpn"),
            "last-seen": obj.get("last-seen"),
            "list-count": obj.get("list-count"),
            "sensors": [BlocklistSensor.from_dict(_item) for _item in obj["sensors"]] if obj.get("sensors") is not None else None
        })
        return _obj


