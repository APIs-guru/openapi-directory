# coding: utf-8

"""
    Neutrino API

    The general-purpose API

    The version of the OpenAPI document: 3.6.4
    Contact: ops@neutrinoapi.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from openapi_client.models.blocklist_sensor import BlocklistSensor
from typing import Optional, Set
from typing_extensions import Self

class DomainLookupResponse(BaseModel):
    """
    DomainLookupResponse
    """ # noqa: E501
    age: StrictInt = Field(description="The number of days since the domain was registered. A domain age of under 90 days is generally considered to be potentially risky. A value of 0 indicates no registration date was found for this domain")
    blocklists: List[StrictStr] = Field(description="An array of strings indicating which blocklist categories this domain is listed on. Current categories are: phishing, malware, spam, anonymizer, nefarious")
    dns_provider: StrictStr = Field(description="The primary domain of the DNS provider for this domain", alias="dns-provider")
    domain: StrictStr = Field(description="The primary domain name excluding any subdomains. This is also referred to as the second-level domain (SLD)")
    fqdn: StrictStr = Field(description="The fully qualified domain name (FQDN)")
    is_adult: StrictBool = Field(description="This domain is hosting adult content such as porn, webcams, escorts, etc", alias="is-adult")
    is_gov: StrictBool = Field(description="Is this domain under a government or military TLD", alias="is-gov")
    is_malicious: StrictBool = Field(description="Consider this domain malicious as it is currently listed on at least 1 blocklist", alias="is-malicious")
    is_opennic: StrictBool = Field(description="Is this domain under an OpenNIC TLD", alias="is-opennic")
    is_pending: StrictBool = Field(description="True if this domain is unseen and is currently being processed in the background. This field only matters when the 'live' lookup setting has been explicitly disabled and indicates that not all domain data my be present yet", alias="is-pending")
    is_subdomain: StrictBool = Field(description="Is the FQDN a subdomain of the primary domain", alias="is-subdomain")
    mail_provider: StrictStr = Field(description="The primary domain of the email provider for this domain. An empty value indicates the domain has no valid MX records", alias="mail-provider")
    rank: StrictInt = Field(description="The domains estimated global traffic rank with the highest rank being 1. A value of 0 indicates the domain is currently ranked outside of the top 1M of domains")
    registered_date: StrictStr = Field(description="The ISO date this domain was registered or first seen on the internet. An empty value indicates we could not reliably determine the date", alias="registered-date")
    registrar_id: StrictInt = Field(description="The IANA registrar ID (0 if no registrar ID was found)", alias="registrar-id")
    registrar_name: StrictStr = Field(description="The name of the domain registrar owning this domain", alias="registrar-name")
    sensors: List[BlocklistSensor] = Field(description="An array of objects containing details on which specific blocklist sensors have detected this domain")
    tld: StrictStr = Field(description="The top-level domain (TLD)")
    tld_cc: StrictStr = Field(description="For a country code top-level domain (ccTLD) this will contain the associated ISO 2-letter country code", alias="tld-cc")
    valid: StrictBool = Field(description="True if a valid domain was found. For a domain to be considered valid it must be registered and have valid DNS NS records")
    __properties: ClassVar[List[str]] = ["age", "blocklists", "dns-provider", "domain", "fqdn", "is-adult", "is-gov", "is-malicious", "is-opennic", "is-pending", "is-subdomain", "mail-provider", "rank", "registered-date", "registrar-id", "registrar-name", "sensors", "tld", "tld-cc", "valid"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DomainLookupResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in sensors (list)
        _items = []
        if self.sensors:
            for _item_sensors in self.sensors:
                if _item_sensors:
                    _items.append(_item_sensors.to_dict())
            _dict['sensors'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DomainLookupResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "age": obj.get("age"),
            "blocklists": obj.get("blocklists"),
            "dns-provider": obj.get("dns-provider"),
            "domain": obj.get("domain"),
            "fqdn": obj.get("fqdn"),
            "is-adult": obj.get("is-adult"),
            "is-gov": obj.get("is-gov"),
            "is-malicious": obj.get("is-malicious"),
            "is-opennic": obj.get("is-opennic"),
            "is-pending": obj.get("is-pending"),
            "is-subdomain": obj.get("is-subdomain"),
            "mail-provider": obj.get("mail-provider"),
            "rank": obj.get("rank"),
            "registered-date": obj.get("registered-date"),
            "registrar-id": obj.get("registrar-id"),
            "registrar-name": obj.get("registrar-name"),
            "sensors": [BlocklistSensor.from_dict(_item) for _item in obj["sensors"]] if obj.get("sensors") is not None else None,
            "tld": obj.get("tld"),
            "tld-cc": obj.get("tld-cc"),
            "valid": obj.get("valid")
        })
        return _obj


