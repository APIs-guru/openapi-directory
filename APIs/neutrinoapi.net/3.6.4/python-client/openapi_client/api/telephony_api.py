# coding: utf-8

"""
    Neutrino API

    The general-purpose API

    The version of the OpenAPI document: 3.6.4
    Contact: ops@neutrinoapi.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.hlr_lookup_response import HLRLookupResponse
from openapi_client.models.phone_playback_response import PhonePlaybackResponse
from openapi_client.models.phone_verify_response import PhoneVerifyResponse
from openapi_client.models.sms_verify_response import SMSVerifyResponse
from openapi_client.models.verify_security_code_response import VerifySecurityCodeResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class TelephonyApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def h_lr_lookup(
        self,
        number: Annotated[StrictStr, Field(description="A phone number")],
        country_code: Annotated[Optional[StrictStr], Field(description="ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HLRLookupResponse:
        """HLR Lookup

        Connect to the global mobile cellular network and retrieve the status of a mobile device

        :param number: A phone number (required)
        :type number: str
        :param country_code: ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)
        :type country_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._h_lr_lookup_serialize(
            number=number,
            country_code=country_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HLRLookupResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def h_lr_lookup_with_http_info(
        self,
        number: Annotated[StrictStr, Field(description="A phone number")],
        country_code: Annotated[Optional[StrictStr], Field(description="ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HLRLookupResponse]:
        """HLR Lookup

        Connect to the global mobile cellular network and retrieve the status of a mobile device

        :param number: A phone number (required)
        :type number: str
        :param country_code: ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)
        :type country_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._h_lr_lookup_serialize(
            number=number,
            country_code=country_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HLRLookupResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def h_lr_lookup_without_preload_content(
        self,
        number: Annotated[StrictStr, Field(description="A phone number")],
        country_code: Annotated[Optional[StrictStr], Field(description="ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """HLR Lookup

        Connect to the global mobile cellular network and retrieve the status of a mobile device

        :param number: A phone number (required)
        :type number: str
        :param country_code: ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)
        :type country_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._h_lr_lookup_serialize(
            number=number,
            country_code=country_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HLRLookupResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _h_lr_lookup_serialize(
        self,
        number,
        country_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if number is not None:
            
            _query_params.append(('number', number))
            
        if country_code is not None:
            
            _query_params.append(('country-code', country_code))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/hlr-lookup',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def phone_playback(
        self,
        audio_url: Annotated[StrictStr, Field(description="A URL to a valid audio file. Accepted audio formats are: <ul> <li>MP3</li> <li>WAV</li> <li>OGG</li> </ul>You can use the following MP3 URL for testing: <br>https://www.neutrinoapi.com/test-files/test1.mp3")],
        number: Annotated[StrictStr, Field(description="The phone number to call. Must be in valid international format")],
        limit: Annotated[Optional[StrictInt], Field(description="Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned")] = None,
        limit_ttl: Annotated[Optional[StrictInt], Field(description="Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PhonePlaybackResponse:
        """Phone Playback

        Make an automated call to any valid phone number and playback an audio message

        :param audio_url: A URL to a valid audio file. Accepted audio formats are: <ul> <li>MP3</li> <li>WAV</li> <li>OGG</li> </ul>You can use the following MP3 URL for testing: <br>https://www.neutrinoapi.com/test-files/test1.mp3 (required)
        :type audio_url: str
        :param number: The phone number to call. Must be in valid international format (required)
        :type number: str
        :param limit: Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned
        :type limit: int
        :param limit_ttl: Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)
        :type limit_ttl: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._phone_playback_serialize(
            audio_url=audio_url,
            number=number,
            limit=limit,
            limit_ttl=limit_ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PhonePlaybackResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def phone_playback_with_http_info(
        self,
        audio_url: Annotated[StrictStr, Field(description="A URL to a valid audio file. Accepted audio formats are: <ul> <li>MP3</li> <li>WAV</li> <li>OGG</li> </ul>You can use the following MP3 URL for testing: <br>https://www.neutrinoapi.com/test-files/test1.mp3")],
        number: Annotated[StrictStr, Field(description="The phone number to call. Must be in valid international format")],
        limit: Annotated[Optional[StrictInt], Field(description="Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned")] = None,
        limit_ttl: Annotated[Optional[StrictInt], Field(description="Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PhonePlaybackResponse]:
        """Phone Playback

        Make an automated call to any valid phone number and playback an audio message

        :param audio_url: A URL to a valid audio file. Accepted audio formats are: <ul> <li>MP3</li> <li>WAV</li> <li>OGG</li> </ul>You can use the following MP3 URL for testing: <br>https://www.neutrinoapi.com/test-files/test1.mp3 (required)
        :type audio_url: str
        :param number: The phone number to call. Must be in valid international format (required)
        :type number: str
        :param limit: Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned
        :type limit: int
        :param limit_ttl: Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)
        :type limit_ttl: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._phone_playback_serialize(
            audio_url=audio_url,
            number=number,
            limit=limit,
            limit_ttl=limit_ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PhonePlaybackResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def phone_playback_without_preload_content(
        self,
        audio_url: Annotated[StrictStr, Field(description="A URL to a valid audio file. Accepted audio formats are: <ul> <li>MP3</li> <li>WAV</li> <li>OGG</li> </ul>You can use the following MP3 URL for testing: <br>https://www.neutrinoapi.com/test-files/test1.mp3")],
        number: Annotated[StrictStr, Field(description="The phone number to call. Must be in valid international format")],
        limit: Annotated[Optional[StrictInt], Field(description="Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned")] = None,
        limit_ttl: Annotated[Optional[StrictInt], Field(description="Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Phone Playback

        Make an automated call to any valid phone number and playback an audio message

        :param audio_url: A URL to a valid audio file. Accepted audio formats are: <ul> <li>MP3</li> <li>WAV</li> <li>OGG</li> </ul>You can use the following MP3 URL for testing: <br>https://www.neutrinoapi.com/test-files/test1.mp3 (required)
        :type audio_url: str
        :param number: The phone number to call. Must be in valid international format (required)
        :type number: str
        :param limit: Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned
        :type limit: int
        :param limit_ttl: Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)
        :type limit_ttl: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._phone_playback_serialize(
            audio_url=audio_url,
            number=number,
            limit=limit,
            limit_ttl=limit_ttl,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PhonePlaybackResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _phone_playback_serialize(
        self,
        audio_url,
        number,
        limit,
        limit_ttl,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if audio_url is not None:
            _form_params.append(('audio-url', audio_url))
        if limit is not None:
            _form_params.append(('limit', limit))
        if limit_ttl is not None:
            _form_params.append(('limit-ttl', limit_ttl))
        if number is not None:
            _form_params.append(('number', number))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/phone-playback',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def phone_verify(
        self,
        number: Annotated[StrictStr, Field(description="The phone number to send the verification code to")],
        code_length: Annotated[Optional[StrictInt], Field(description="The number of digits to use in the security code (between 4 and 12)")] = None,
        country_code: Annotated[Optional[StrictStr], Field(description="ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)")] = None,
        language_code: Annotated[Optional[StrictStr], Field(description="The language to playback the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned")] = None,
        limit_ttl: Annotated[Optional[StrictInt], Field(description="Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)")] = None,
        playback_delay: Annotated[Optional[StrictInt], Field(description="The delay in milliseconds between the playback of each security code")] = None,
        security_code: Annotated[Optional[StrictInt], Field(description="Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PhoneVerifyResponse:
        """Phone Verify

        Make an automated call to any valid phone number and playback a unique security code

        :param number: The phone number to send the verification code to (required)
        :type number: str
        :param code_length: The number of digits to use in the security code (between 4 and 12)
        :type code_length: int
        :param country_code: ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)
        :type country_code: str
        :param language_code: The language to playback the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>
        :type language_code: str
        :param limit: Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned
        :type limit: int
        :param limit_ttl: Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)
        :type limit_ttl: int
        :param playback_delay: The delay in milliseconds between the playback of each security code
        :type playback_delay: int
        :param security_code: Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code
        :type security_code: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._phone_verify_serialize(
            number=number,
            code_length=code_length,
            country_code=country_code,
            language_code=language_code,
            limit=limit,
            limit_ttl=limit_ttl,
            playback_delay=playback_delay,
            security_code=security_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PhoneVerifyResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def phone_verify_with_http_info(
        self,
        number: Annotated[StrictStr, Field(description="The phone number to send the verification code to")],
        code_length: Annotated[Optional[StrictInt], Field(description="The number of digits to use in the security code (between 4 and 12)")] = None,
        country_code: Annotated[Optional[StrictStr], Field(description="ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)")] = None,
        language_code: Annotated[Optional[StrictStr], Field(description="The language to playback the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned")] = None,
        limit_ttl: Annotated[Optional[StrictInt], Field(description="Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)")] = None,
        playback_delay: Annotated[Optional[StrictInt], Field(description="The delay in milliseconds between the playback of each security code")] = None,
        security_code: Annotated[Optional[StrictInt], Field(description="Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PhoneVerifyResponse]:
        """Phone Verify

        Make an automated call to any valid phone number and playback a unique security code

        :param number: The phone number to send the verification code to (required)
        :type number: str
        :param code_length: The number of digits to use in the security code (between 4 and 12)
        :type code_length: int
        :param country_code: ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)
        :type country_code: str
        :param language_code: The language to playback the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>
        :type language_code: str
        :param limit: Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned
        :type limit: int
        :param limit_ttl: Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)
        :type limit_ttl: int
        :param playback_delay: The delay in milliseconds between the playback of each security code
        :type playback_delay: int
        :param security_code: Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code
        :type security_code: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._phone_verify_serialize(
            number=number,
            code_length=code_length,
            country_code=country_code,
            language_code=language_code,
            limit=limit,
            limit_ttl=limit_ttl,
            playback_delay=playback_delay,
            security_code=security_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PhoneVerifyResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def phone_verify_without_preload_content(
        self,
        number: Annotated[StrictStr, Field(description="The phone number to send the verification code to")],
        code_length: Annotated[Optional[StrictInt], Field(description="The number of digits to use in the security code (between 4 and 12)")] = None,
        country_code: Annotated[Optional[StrictStr], Field(description="ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)")] = None,
        language_code: Annotated[Optional[StrictStr], Field(description="The language to playback the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned")] = None,
        limit_ttl: Annotated[Optional[StrictInt], Field(description="Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)")] = None,
        playback_delay: Annotated[Optional[StrictInt], Field(description="The delay in milliseconds between the playback of each security code")] = None,
        security_code: Annotated[Optional[StrictInt], Field(description="Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Phone Verify

        Make an automated call to any valid phone number and playback a unique security code

        :param number: The phone number to send the verification code to (required)
        :type number: str
        :param code_length: The number of digits to use in the security code (between 4 and 12)
        :type code_length: int
        :param country_code: ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)
        :type country_code: str
        :param language_code: The language to playback the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>
        :type language_code: str
        :param limit: Limit the total number of calls allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned
        :type limit: int
        :param limit_ttl: Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)
        :type limit_ttl: int
        :param playback_delay: The delay in milliseconds between the playback of each security code
        :type playback_delay: int
        :param security_code: Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code
        :type security_code: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._phone_verify_serialize(
            number=number,
            code_length=code_length,
            country_code=country_code,
            language_code=language_code,
            limit=limit,
            limit_ttl=limit_ttl,
            playback_delay=playback_delay,
            security_code=security_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PhoneVerifyResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _phone_verify_serialize(
        self,
        number,
        code_length,
        country_code,
        language_code,
        limit,
        limit_ttl,
        playback_delay,
        security_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if code_length is not None:
            _form_params.append(('code-length', code_length))
        if country_code is not None:
            _form_params.append(('country-code', country_code))
        if language_code is not None:
            _form_params.append(('language-code', language_code))
        if limit is not None:
            _form_params.append(('limit', limit))
        if limit_ttl is not None:
            _form_params.append(('limit-ttl', limit_ttl))
        if number is not None:
            _form_params.append(('number', number))
        if playback_delay is not None:
            _form_params.append(('playback-delay', playback_delay))
        if security_code is not None:
            _form_params.append(('security-code', security_code))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/phone-verify',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def s_ms_verify(
        self,
        number: Annotated[StrictStr, Field(description="The phone number to send a verification code to")],
        code_length: Annotated[Optional[StrictInt], Field(description="The number of digits to use in the security code (must be between 4 and 12)")] = None,
        country_code: Annotated[Optional[StrictStr], Field(description="ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)")] = None,
        language_code: Annotated[Optional[StrictStr], Field(description="The language to send the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the total number of SMS allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned")] = None,
        limit_ttl: Annotated[Optional[StrictInt], Field(description="Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)")] = None,
        security_code: Annotated[Optional[StrictInt], Field(description="Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SMSVerifyResponse:
        """SMS Verify

        Send a unique security code to any mobile device via SMS

        :param number: The phone number to send a verification code to (required)
        :type number: str
        :param code_length: The number of digits to use in the security code (must be between 4 and 12)
        :type code_length: int
        :param country_code: ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)
        :type country_code: str
        :param language_code: The language to send the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>
        :type language_code: str
        :param limit: Limit the total number of SMS allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned
        :type limit: int
        :param limit_ttl: Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)
        :type limit_ttl: int
        :param security_code: Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code
        :type security_code: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._s_ms_verify_serialize(
            number=number,
            code_length=code_length,
            country_code=country_code,
            language_code=language_code,
            limit=limit,
            limit_ttl=limit_ttl,
            security_code=security_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SMSVerifyResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def s_ms_verify_with_http_info(
        self,
        number: Annotated[StrictStr, Field(description="The phone number to send a verification code to")],
        code_length: Annotated[Optional[StrictInt], Field(description="The number of digits to use in the security code (must be between 4 and 12)")] = None,
        country_code: Annotated[Optional[StrictStr], Field(description="ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)")] = None,
        language_code: Annotated[Optional[StrictStr], Field(description="The language to send the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the total number of SMS allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned")] = None,
        limit_ttl: Annotated[Optional[StrictInt], Field(description="Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)")] = None,
        security_code: Annotated[Optional[StrictInt], Field(description="Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SMSVerifyResponse]:
        """SMS Verify

        Send a unique security code to any mobile device via SMS

        :param number: The phone number to send a verification code to (required)
        :type number: str
        :param code_length: The number of digits to use in the security code (must be between 4 and 12)
        :type code_length: int
        :param country_code: ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)
        :type country_code: str
        :param language_code: The language to send the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>
        :type language_code: str
        :param limit: Limit the total number of SMS allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned
        :type limit: int
        :param limit_ttl: Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)
        :type limit_ttl: int
        :param security_code: Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code
        :type security_code: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._s_ms_verify_serialize(
            number=number,
            code_length=code_length,
            country_code=country_code,
            language_code=language_code,
            limit=limit,
            limit_ttl=limit_ttl,
            security_code=security_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SMSVerifyResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def s_ms_verify_without_preload_content(
        self,
        number: Annotated[StrictStr, Field(description="The phone number to send a verification code to")],
        code_length: Annotated[Optional[StrictInt], Field(description="The number of digits to use in the security code (must be between 4 and 12)")] = None,
        country_code: Annotated[Optional[StrictStr], Field(description="ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)")] = None,
        language_code: Annotated[Optional[StrictStr], Field(description="The language to send the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the total number of SMS allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned")] = None,
        limit_ttl: Annotated[Optional[StrictInt], Field(description="Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)")] = None,
        security_code: Annotated[Optional[StrictInt], Field(description="Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """SMS Verify

        Send a unique security code to any mobile device via SMS

        :param number: The phone number to send a verification code to (required)
        :type number: str
        :param code_length: The number of digits to use in the security code (must be between 4 and 12)
        :type code_length: int
        :param country_code: ISO 2-letter country code, assume numbers are based in this country. <br>If not set numbers are assumed to be in international format (with or without the leading + sign)
        :type country_code: str
        :param language_code: The language to send the verification code in, available languages are: <ul> <li>de - German</li> <li>en - English</li> <li>es - Spanish</li> <li>fr - French</li> <li>it - Italian</li> <li>pt - Portuguese</li> <li>ru - Russian</li> </ul>
        :type language_code: str
        :param limit: Limit the total number of SMS allowed to the supplied phone number, if the limit is reached within the TTL then error code 14 will be returned
        :type limit: int
        :param limit_ttl: Set the TTL in number of days that the 'limit' option will remember a phone number (the default is 1 day and the maximum is 365 days)
        :type limit_ttl: int
        :param security_code: Pass in your own security code. This is useful if you have implemented TOTP or similar 2FA methods. If not set then we will generate a secure random code
        :type security_code: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._s_ms_verify_serialize(
            number=number,
            code_length=code_length,
            country_code=country_code,
            language_code=language_code,
            limit=limit,
            limit_ttl=limit_ttl,
            security_code=security_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SMSVerifyResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _s_ms_verify_serialize(
        self,
        number,
        code_length,
        country_code,
        language_code,
        limit,
        limit_ttl,
        security_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if code_length is not None:
            _form_params.append(('code-length', code_length))
        if country_code is not None:
            _form_params.append(('country-code', country_code))
        if language_code is not None:
            _form_params.append(('language-code', language_code))
        if limit is not None:
            _form_params.append(('limit', limit))
        if limit_ttl is not None:
            _form_params.append(('limit-ttl', limit_ttl))
        if number is not None:
            _form_params.append(('number', number))
        if security_code is not None:
            _form_params.append(('security-code', security_code))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/sms-verify',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def verify_security_code(
        self,
        security_code: Annotated[StrictStr, Field(description="The security code to verify")],
        limit_by: Annotated[Optional[StrictStr], Field(description="If set then enable additional brute-force protection by limiting the number of attempts by the supplied value. This can be set to any unique identifier you would like to limit by, for example a hash of the users email, phone number or IP address. Requests to this API will be ignored after approximately 10 failed verification attempts")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VerifySecurityCodeResponse:
        """Verify Security Code

        Check if a security code sent via SMS Verify or Phone Verify is valid

        :param security_code: The security code to verify (required)
        :type security_code: str
        :param limit_by: If set then enable additional brute-force protection by limiting the number of attempts by the supplied value. This can be set to any unique identifier you would like to limit by, for example a hash of the users email, phone number or IP address. Requests to this API will be ignored after approximately 10 failed verification attempts
        :type limit_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_security_code_serialize(
            security_code=security_code,
            limit_by=limit_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VerifySecurityCodeResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def verify_security_code_with_http_info(
        self,
        security_code: Annotated[StrictStr, Field(description="The security code to verify")],
        limit_by: Annotated[Optional[StrictStr], Field(description="If set then enable additional brute-force protection by limiting the number of attempts by the supplied value. This can be set to any unique identifier you would like to limit by, for example a hash of the users email, phone number or IP address. Requests to this API will be ignored after approximately 10 failed verification attempts")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VerifySecurityCodeResponse]:
        """Verify Security Code

        Check if a security code sent via SMS Verify or Phone Verify is valid

        :param security_code: The security code to verify (required)
        :type security_code: str
        :param limit_by: If set then enable additional brute-force protection by limiting the number of attempts by the supplied value. This can be set to any unique identifier you would like to limit by, for example a hash of the users email, phone number or IP address. Requests to this API will be ignored after approximately 10 failed verification attempts
        :type limit_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_security_code_serialize(
            security_code=security_code,
            limit_by=limit_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VerifySecurityCodeResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def verify_security_code_without_preload_content(
        self,
        security_code: Annotated[StrictStr, Field(description="The security code to verify")],
        limit_by: Annotated[Optional[StrictStr], Field(description="If set then enable additional brute-force protection by limiting the number of attempts by the supplied value. This can be set to any unique identifier you would like to limit by, for example a hash of the users email, phone number or IP address. Requests to this API will be ignored after approximately 10 failed verification attempts")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Verify Security Code

        Check if a security code sent via SMS Verify or Phone Verify is valid

        :param security_code: The security code to verify (required)
        :type security_code: str
        :param limit_by: If set then enable additional brute-force protection by limiting the number of attempts by the supplied value. This can be set to any unique identifier you would like to limit by, for example a hash of the users email, phone number or IP address. Requests to this API will be ignored after approximately 10 failed verification attempts
        :type limit_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_security_code_serialize(
            security_code=security_code,
            limit_by=limit_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VerifySecurityCodeResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _verify_security_code_serialize(
        self,
        security_code,
        limit_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if security_code is not None:
            
            _query_params.append(('security-code', security_code))
            
        if limit_by is not None:
            
            _query_params.append(('limit-by', limit_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/verify-security-code',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


