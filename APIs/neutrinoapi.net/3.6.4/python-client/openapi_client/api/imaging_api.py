# coding: utf-8

"""
    Neutrino API

    The general-purpose API

    The version of the OpenAPI document: 3.6.4
    Contact: ops@neutrinoapi.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr
from typing import Optional, Tuple, Union
from typing_extensions import Annotated

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ImagingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def h_tml_render(
        self,
        content: Annotated[StrictStr, Field(description="The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string")],
        css: Annotated[Optional[StrictStr], Field(description="Inject custom CSS into the HTML. e.g. 'body { background-color: red;}'")] = None,
        delay: Annotated[Optional[StrictInt], Field(description="Number of seconds to wait before rendering the page (can be useful for pages with animations etc)")] = None,
        footer: Annotated[Optional[StrictStr], Field(description="The footer HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Which format to output, available options are: PDF, PNG, JPG")] = None,
        grayscale: Annotated[Optional[StrictBool], Field(description="Render the final document in grayscale")] = None,
        header: Annotated[Optional[StrictStr], Field(description="The header HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}")] = None,
        ignore_certificate_errors: Annotated[Optional[StrictBool], Field(description="Ignore any TLS/SSL certificate errors")] = None,
        image_height: Annotated[Optional[StrictInt], Field(description="If rendering to an image format (PNG or JPG) use this image height (in pixels). The default is automatic which dynamically sets the image height based on the content")] = None,
        image_width: Annotated[Optional[StrictInt], Field(description="If rendering to an image format (PNG or JPG) use this image width (in pixels)")] = None,
        landscape: Annotated[Optional[StrictBool], Field(description="Set the document to landscape orientation")] = None,
        margin: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document margin (in mm)")] = None,
        margin_bottom: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document bottom margin (in mm)")] = None,
        margin_left: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document left margin (in mm)")] = None,
        margin_right: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document right margin (in mm)")] = None,
        margin_top: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document top margin (in mm)")] = None,
        page_height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Set the PDF page height explicitly (in mm)")] = None,
        page_size: Annotated[Optional[StrictStr], Field(description="Set the document page size, can be one of: A0 - A9, B0 - B10, Comm10E, DLE or Letter")] = None,
        page_width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Set the PDF page width explicitly (in mm)")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout in seconds. Give up if still trying to load the HTML content after this number of seconds")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The document title")] = None,
        zoom: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Set the zoom factor when rendering the page (2.0 for double size, 0.5 for half size)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """HTML Render

        Render HTML content to PDF, JPG or PNG

        :param content: The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string (required)
        :type content: str
        :param css: Inject custom CSS into the HTML. e.g. 'body { background-color: red;}'
        :type css: str
        :param delay: Number of seconds to wait before rendering the page (can be useful for pages with animations etc)
        :type delay: int
        :param footer: The footer HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}
        :type footer: str
        :param format: Which format to output, available options are: PDF, PNG, JPG
        :type format: str
        :param grayscale: Render the final document in grayscale
        :type grayscale: bool
        :param header: The header HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}
        :type header: str
        :param ignore_certificate_errors: Ignore any TLS/SSL certificate errors
        :type ignore_certificate_errors: bool
        :param image_height: If rendering to an image format (PNG or JPG) use this image height (in pixels). The default is automatic which dynamically sets the image height based on the content
        :type image_height: int
        :param image_width: If rendering to an image format (PNG or JPG) use this image width (in pixels)
        :type image_width: int
        :param landscape: Set the document to landscape orientation
        :type landscape: bool
        :param margin: The document margin (in mm)
        :type margin: float
        :param margin_bottom: The document bottom margin (in mm)
        :type margin_bottom: float
        :param margin_left: The document left margin (in mm)
        :type margin_left: float
        :param margin_right: The document right margin (in mm)
        :type margin_right: float
        :param margin_top: The document top margin (in mm)
        :type margin_top: float
        :param page_height: Set the PDF page height explicitly (in mm)
        :type page_height: float
        :param page_size: Set the document page size, can be one of: A0 - A9, B0 - B10, Comm10E, DLE or Letter
        :type page_size: str
        :param page_width: Set the PDF page width explicitly (in mm)
        :type page_width: float
        :param timeout: Timeout in seconds. Give up if still trying to load the HTML content after this number of seconds
        :type timeout: int
        :param title: The document title
        :type title: str
        :param zoom: Set the zoom factor when rendering the page (2.0 for double size, 0.5 for half size)
        :type zoom: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._h_tml_render_serialize(
            content=content,
            css=css,
            delay=delay,
            footer=footer,
            format=format,
            grayscale=grayscale,
            header=header,
            ignore_certificate_errors=ignore_certificate_errors,
            image_height=image_height,
            image_width=image_width,
            landscape=landscape,
            margin=margin,
            margin_bottom=margin_bottom,
            margin_left=margin_left,
            margin_right=margin_right,
            margin_top=margin_top,
            page_height=page_height,
            page_size=page_size,
            page_width=page_width,
            timeout=timeout,
            title=title,
            zoom=zoom,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def h_tml_render_with_http_info(
        self,
        content: Annotated[StrictStr, Field(description="The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string")],
        css: Annotated[Optional[StrictStr], Field(description="Inject custom CSS into the HTML. e.g. 'body { background-color: red;}'")] = None,
        delay: Annotated[Optional[StrictInt], Field(description="Number of seconds to wait before rendering the page (can be useful for pages with animations etc)")] = None,
        footer: Annotated[Optional[StrictStr], Field(description="The footer HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Which format to output, available options are: PDF, PNG, JPG")] = None,
        grayscale: Annotated[Optional[StrictBool], Field(description="Render the final document in grayscale")] = None,
        header: Annotated[Optional[StrictStr], Field(description="The header HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}")] = None,
        ignore_certificate_errors: Annotated[Optional[StrictBool], Field(description="Ignore any TLS/SSL certificate errors")] = None,
        image_height: Annotated[Optional[StrictInt], Field(description="If rendering to an image format (PNG or JPG) use this image height (in pixels). The default is automatic which dynamically sets the image height based on the content")] = None,
        image_width: Annotated[Optional[StrictInt], Field(description="If rendering to an image format (PNG or JPG) use this image width (in pixels)")] = None,
        landscape: Annotated[Optional[StrictBool], Field(description="Set the document to landscape orientation")] = None,
        margin: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document margin (in mm)")] = None,
        margin_bottom: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document bottom margin (in mm)")] = None,
        margin_left: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document left margin (in mm)")] = None,
        margin_right: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document right margin (in mm)")] = None,
        margin_top: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document top margin (in mm)")] = None,
        page_height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Set the PDF page height explicitly (in mm)")] = None,
        page_size: Annotated[Optional[StrictStr], Field(description="Set the document page size, can be one of: A0 - A9, B0 - B10, Comm10E, DLE or Letter")] = None,
        page_width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Set the PDF page width explicitly (in mm)")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout in seconds. Give up if still trying to load the HTML content after this number of seconds")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The document title")] = None,
        zoom: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Set the zoom factor when rendering the page (2.0 for double size, 0.5 for half size)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """HTML Render

        Render HTML content to PDF, JPG or PNG

        :param content: The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string (required)
        :type content: str
        :param css: Inject custom CSS into the HTML. e.g. 'body { background-color: red;}'
        :type css: str
        :param delay: Number of seconds to wait before rendering the page (can be useful for pages with animations etc)
        :type delay: int
        :param footer: The footer HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}
        :type footer: str
        :param format: Which format to output, available options are: PDF, PNG, JPG
        :type format: str
        :param grayscale: Render the final document in grayscale
        :type grayscale: bool
        :param header: The header HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}
        :type header: str
        :param ignore_certificate_errors: Ignore any TLS/SSL certificate errors
        :type ignore_certificate_errors: bool
        :param image_height: If rendering to an image format (PNG or JPG) use this image height (in pixels). The default is automatic which dynamically sets the image height based on the content
        :type image_height: int
        :param image_width: If rendering to an image format (PNG or JPG) use this image width (in pixels)
        :type image_width: int
        :param landscape: Set the document to landscape orientation
        :type landscape: bool
        :param margin: The document margin (in mm)
        :type margin: float
        :param margin_bottom: The document bottom margin (in mm)
        :type margin_bottom: float
        :param margin_left: The document left margin (in mm)
        :type margin_left: float
        :param margin_right: The document right margin (in mm)
        :type margin_right: float
        :param margin_top: The document top margin (in mm)
        :type margin_top: float
        :param page_height: Set the PDF page height explicitly (in mm)
        :type page_height: float
        :param page_size: Set the document page size, can be one of: A0 - A9, B0 - B10, Comm10E, DLE or Letter
        :type page_size: str
        :param page_width: Set the PDF page width explicitly (in mm)
        :type page_width: float
        :param timeout: Timeout in seconds. Give up if still trying to load the HTML content after this number of seconds
        :type timeout: int
        :param title: The document title
        :type title: str
        :param zoom: Set the zoom factor when rendering the page (2.0 for double size, 0.5 for half size)
        :type zoom: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._h_tml_render_serialize(
            content=content,
            css=css,
            delay=delay,
            footer=footer,
            format=format,
            grayscale=grayscale,
            header=header,
            ignore_certificate_errors=ignore_certificate_errors,
            image_height=image_height,
            image_width=image_width,
            landscape=landscape,
            margin=margin,
            margin_bottom=margin_bottom,
            margin_left=margin_left,
            margin_right=margin_right,
            margin_top=margin_top,
            page_height=page_height,
            page_size=page_size,
            page_width=page_width,
            timeout=timeout,
            title=title,
            zoom=zoom,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def h_tml_render_without_preload_content(
        self,
        content: Annotated[StrictStr, Field(description="The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string")],
        css: Annotated[Optional[StrictStr], Field(description="Inject custom CSS into the HTML. e.g. 'body { background-color: red;}'")] = None,
        delay: Annotated[Optional[StrictInt], Field(description="Number of seconds to wait before rendering the page (can be useful for pages with animations etc)")] = None,
        footer: Annotated[Optional[StrictStr], Field(description="The footer HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Which format to output, available options are: PDF, PNG, JPG")] = None,
        grayscale: Annotated[Optional[StrictBool], Field(description="Render the final document in grayscale")] = None,
        header: Annotated[Optional[StrictStr], Field(description="The header HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}")] = None,
        ignore_certificate_errors: Annotated[Optional[StrictBool], Field(description="Ignore any TLS/SSL certificate errors")] = None,
        image_height: Annotated[Optional[StrictInt], Field(description="If rendering to an image format (PNG or JPG) use this image height (in pixels). The default is automatic which dynamically sets the image height based on the content")] = None,
        image_width: Annotated[Optional[StrictInt], Field(description="If rendering to an image format (PNG or JPG) use this image width (in pixels)")] = None,
        landscape: Annotated[Optional[StrictBool], Field(description="Set the document to landscape orientation")] = None,
        margin: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document margin (in mm)")] = None,
        margin_bottom: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document bottom margin (in mm)")] = None,
        margin_left: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document left margin (in mm)")] = None,
        margin_right: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document right margin (in mm)")] = None,
        margin_top: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The document top margin (in mm)")] = None,
        page_height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Set the PDF page height explicitly (in mm)")] = None,
        page_size: Annotated[Optional[StrictStr], Field(description="Set the document page size, can be one of: A0 - A9, B0 - B10, Comm10E, DLE or Letter")] = None,
        page_width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Set the PDF page width explicitly (in mm)")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout in seconds. Give up if still trying to load the HTML content after this number of seconds")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The document title")] = None,
        zoom: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Set the zoom factor when rendering the page (2.0 for double size, 0.5 for half size)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """HTML Render

        Render HTML content to PDF, JPG or PNG

        :param content: The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string (required)
        :type content: str
        :param css: Inject custom CSS into the HTML. e.g. 'body { background-color: red;}'
        :type css: str
        :param delay: Number of seconds to wait before rendering the page (can be useful for pages with animations etc)
        :type delay: int
        :param footer: The footer HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}
        :type footer: str
        :param format: Which format to output, available options are: PDF, PNG, JPG
        :type format: str
        :param grayscale: Render the final document in grayscale
        :type grayscale: bool
        :param header: The header HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}
        :type header: str
        :param ignore_certificate_errors: Ignore any TLS/SSL certificate errors
        :type ignore_certificate_errors: bool
        :param image_height: If rendering to an image format (PNG or JPG) use this image height (in pixels). The default is automatic which dynamically sets the image height based on the content
        :type image_height: int
        :param image_width: If rendering to an image format (PNG or JPG) use this image width (in pixels)
        :type image_width: int
        :param landscape: Set the document to landscape orientation
        :type landscape: bool
        :param margin: The document margin (in mm)
        :type margin: float
        :param margin_bottom: The document bottom margin (in mm)
        :type margin_bottom: float
        :param margin_left: The document left margin (in mm)
        :type margin_left: float
        :param margin_right: The document right margin (in mm)
        :type margin_right: float
        :param margin_top: The document top margin (in mm)
        :type margin_top: float
        :param page_height: Set the PDF page height explicitly (in mm)
        :type page_height: float
        :param page_size: Set the document page size, can be one of: A0 - A9, B0 - B10, Comm10E, DLE or Letter
        :type page_size: str
        :param page_width: Set the PDF page width explicitly (in mm)
        :type page_width: float
        :param timeout: Timeout in seconds. Give up if still trying to load the HTML content after this number of seconds
        :type timeout: int
        :param title: The document title
        :type title: str
        :param zoom: Set the zoom factor when rendering the page (2.0 for double size, 0.5 for half size)
        :type zoom: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._h_tml_render_serialize(
            content=content,
            css=css,
            delay=delay,
            footer=footer,
            format=format,
            grayscale=grayscale,
            header=header,
            ignore_certificate_errors=ignore_certificate_errors,
            image_height=image_height,
            image_width=image_width,
            landscape=landscape,
            margin=margin,
            margin_bottom=margin_bottom,
            margin_left=margin_left,
            margin_right=margin_right,
            margin_top=margin_top,
            page_height=page_height,
            page_size=page_size,
            page_width=page_width,
            timeout=timeout,
            title=title,
            zoom=zoom,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _h_tml_render_serialize(
        self,
        content,
        css,
        delay,
        footer,
        format,
        grayscale,
        header,
        ignore_certificate_errors,
        image_height,
        image_width,
        landscape,
        margin,
        margin_bottom,
        margin_left,
        margin_right,
        margin_top,
        page_height,
        page_size,
        page_width,
        timeout,
        title,
        zoom,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if content is not None:
            _form_params.append(('content', content))
        if css is not None:
            _form_params.append(('css', css))
        if delay is not None:
            _form_params.append(('delay', delay))
        if footer is not None:
            _form_params.append(('footer', footer))
        if format is not None:
            _form_params.append(('format', format))
        if grayscale is not None:
            _form_params.append(('grayscale', grayscale))
        if header is not None:
            _form_params.append(('header', header))
        if ignore_certificate_errors is not None:
            _form_params.append(('ignore-certificate-errors', ignore_certificate_errors))
        if image_height is not None:
            _form_params.append(('image-height', image_height))
        if image_width is not None:
            _form_params.append(('image-width', image_width))
        if landscape is not None:
            _form_params.append(('landscape', landscape))
        if margin is not None:
            _form_params.append(('margin', margin))
        if margin_bottom is not None:
            _form_params.append(('margin-bottom', margin_bottom))
        if margin_left is not None:
            _form_params.append(('margin-left', margin_left))
        if margin_right is not None:
            _form_params.append(('margin-right', margin_right))
        if margin_top is not None:
            _form_params.append(('margin-top', margin_top))
        if page_height is not None:
            _form_params.append(('page-height', page_height))
        if page_size is not None:
            _form_params.append(('page-size', page_size))
        if page_width is not None:
            _form_params.append(('page-width', page_width))
        if timeout is not None:
            _form_params.append(('timeout', timeout))
        if title is not None:
            _form_params.append(('title', title))
        if zoom is not None:
            _form_params.append(('zoom', zoom))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/html-render',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def image_resize(
        self,
        image_url: Annotated[StrictStr, Field(description="The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data")],
        width: Annotated[StrictInt, Field(description="The width to resize to (in px)")],
        bg_color: Annotated[Optional[StrictStr], Field(description="The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)")] = None,
        format: Annotated[Optional[StrictStr], Field(description="The output image format, can be either png or jpg")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height to resize to (in px). If you don't set this field then the height will be automatic based on the requested width and image aspect ratio")] = None,
        resize_mode: Annotated[Optional[StrictStr], Field(description="The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Image Resize

        Resize an image and output as either JPEG or PNG

        :param image_url: The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data (required)
        :type image_url: str
        :param width: The width to resize to (in px) (required)
        :type width: int
        :param bg_color: The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)
        :type bg_color: str
        :param format: The output image format, can be either png or jpg
        :type format: str
        :param height: The height to resize to (in px). If you don't set this field then the height will be automatic based on the requested width and image aspect ratio
        :type height: int
        :param resize_mode: The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>
        :type resize_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._image_resize_serialize(
            image_url=image_url,
            width=width,
            bg_color=bg_color,
            format=format,
            height=height,
            resize_mode=resize_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def image_resize_with_http_info(
        self,
        image_url: Annotated[StrictStr, Field(description="The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data")],
        width: Annotated[StrictInt, Field(description="The width to resize to (in px)")],
        bg_color: Annotated[Optional[StrictStr], Field(description="The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)")] = None,
        format: Annotated[Optional[StrictStr], Field(description="The output image format, can be either png or jpg")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height to resize to (in px). If you don't set this field then the height will be automatic based on the requested width and image aspect ratio")] = None,
        resize_mode: Annotated[Optional[StrictStr], Field(description="The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Image Resize

        Resize an image and output as either JPEG or PNG

        :param image_url: The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data (required)
        :type image_url: str
        :param width: The width to resize to (in px) (required)
        :type width: int
        :param bg_color: The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)
        :type bg_color: str
        :param format: The output image format, can be either png or jpg
        :type format: str
        :param height: The height to resize to (in px). If you don't set this field then the height will be automatic based on the requested width and image aspect ratio
        :type height: int
        :param resize_mode: The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>
        :type resize_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._image_resize_serialize(
            image_url=image_url,
            width=width,
            bg_color=bg_color,
            format=format,
            height=height,
            resize_mode=resize_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def image_resize_without_preload_content(
        self,
        image_url: Annotated[StrictStr, Field(description="The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data")],
        width: Annotated[StrictInt, Field(description="The width to resize to (in px)")],
        bg_color: Annotated[Optional[StrictStr], Field(description="The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)")] = None,
        format: Annotated[Optional[StrictStr], Field(description="The output image format, can be either png or jpg")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height to resize to (in px). If you don't set this field then the height will be automatic based on the requested width and image aspect ratio")] = None,
        resize_mode: Annotated[Optional[StrictStr], Field(description="The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Image Resize

        Resize an image and output as either JPEG or PNG

        :param image_url: The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data (required)
        :type image_url: str
        :param width: The width to resize to (in px) (required)
        :type width: int
        :param bg_color: The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)
        :type bg_color: str
        :param format: The output image format, can be either png or jpg
        :type format: str
        :param height: The height to resize to (in px). If you don't set this field then the height will be automatic based on the requested width and image aspect ratio
        :type height: int
        :param resize_mode: The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>
        :type resize_mode: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._image_resize_serialize(
            image_url=image_url,
            width=width,
            bg_color=bg_color,
            format=format,
            height=height,
            resize_mode=resize_mode,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _image_resize_serialize(
        self,
        image_url,
        width,
        bg_color,
        format,
        height,
        resize_mode,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if bg_color is not None:
            _form_params.append(('bg-color', bg_color))
        if format is not None:
            _form_params.append(('format', format))
        if height is not None:
            _form_params.append(('height', height))
        if image_url is not None:
            _form_params.append(('image-url', image_url))
        if resize_mode is not None:
            _form_params.append(('resize-mode', resize_mode))
        if width is not None:
            _form_params.append(('width', width))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/image-resize',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def image_watermark(
        self,
        image_url: Annotated[StrictStr, Field(description="The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data")],
        watermark_url: Annotated[StrictStr, Field(description="The URL or Base64 encoded Data URL for the watermark image. You can also upload an image file directly using multipart/form-data")],
        bg_color: Annotated[Optional[StrictStr], Field(description="The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)")] = None,
        format: Annotated[Optional[StrictStr], Field(description="The output image format, can be either png or jpg")] = None,
        height: Annotated[Optional[StrictInt], Field(description="If set resize the resulting image to this height (in px)")] = None,
        opacity: Annotated[Optional[StrictInt], Field(description="The opacity of the watermark (0 to 100)")] = None,
        position: Annotated[Optional[StrictStr], Field(description="The position of the watermark image, possible values are: <br>center, top-left, top-center, top-right, bottom-left, bottom-center, bottom-right")] = None,
        resize_mode: Annotated[Optional[StrictStr], Field(description="The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>")] = None,
        width: Annotated[Optional[StrictInt], Field(description="If set resize the resulting image to this width (in px)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Image Watermark

        Watermark one image with another image

        :param image_url: The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data (required)
        :type image_url: str
        :param watermark_url: The URL or Base64 encoded Data URL for the watermark image. You can also upload an image file directly using multipart/form-data (required)
        :type watermark_url: str
        :param bg_color: The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)
        :type bg_color: str
        :param format: The output image format, can be either png or jpg
        :type format: str
        :param height: If set resize the resulting image to this height (in px)
        :type height: int
        :param opacity: The opacity of the watermark (0 to 100)
        :type opacity: int
        :param position: The position of the watermark image, possible values are: <br>center, top-left, top-center, top-right, bottom-left, bottom-center, bottom-right
        :type position: str
        :param resize_mode: The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>
        :type resize_mode: str
        :param width: If set resize the resulting image to this width (in px)
        :type width: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._image_watermark_serialize(
            image_url=image_url,
            watermark_url=watermark_url,
            bg_color=bg_color,
            format=format,
            height=height,
            opacity=opacity,
            position=position,
            resize_mode=resize_mode,
            width=width,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def image_watermark_with_http_info(
        self,
        image_url: Annotated[StrictStr, Field(description="The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data")],
        watermark_url: Annotated[StrictStr, Field(description="The URL or Base64 encoded Data URL for the watermark image. You can also upload an image file directly using multipart/form-data")],
        bg_color: Annotated[Optional[StrictStr], Field(description="The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)")] = None,
        format: Annotated[Optional[StrictStr], Field(description="The output image format, can be either png or jpg")] = None,
        height: Annotated[Optional[StrictInt], Field(description="If set resize the resulting image to this height (in px)")] = None,
        opacity: Annotated[Optional[StrictInt], Field(description="The opacity of the watermark (0 to 100)")] = None,
        position: Annotated[Optional[StrictStr], Field(description="The position of the watermark image, possible values are: <br>center, top-left, top-center, top-right, bottom-left, bottom-center, bottom-right")] = None,
        resize_mode: Annotated[Optional[StrictStr], Field(description="The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>")] = None,
        width: Annotated[Optional[StrictInt], Field(description="If set resize the resulting image to this width (in px)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Image Watermark

        Watermark one image with another image

        :param image_url: The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data (required)
        :type image_url: str
        :param watermark_url: The URL or Base64 encoded Data URL for the watermark image. You can also upload an image file directly using multipart/form-data (required)
        :type watermark_url: str
        :param bg_color: The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)
        :type bg_color: str
        :param format: The output image format, can be either png or jpg
        :type format: str
        :param height: If set resize the resulting image to this height (in px)
        :type height: int
        :param opacity: The opacity of the watermark (0 to 100)
        :type opacity: int
        :param position: The position of the watermark image, possible values are: <br>center, top-left, top-center, top-right, bottom-left, bottom-center, bottom-right
        :type position: str
        :param resize_mode: The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>
        :type resize_mode: str
        :param width: If set resize the resulting image to this width (in px)
        :type width: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._image_watermark_serialize(
            image_url=image_url,
            watermark_url=watermark_url,
            bg_color=bg_color,
            format=format,
            height=height,
            opacity=opacity,
            position=position,
            resize_mode=resize_mode,
            width=width,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def image_watermark_without_preload_content(
        self,
        image_url: Annotated[StrictStr, Field(description="The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data")],
        watermark_url: Annotated[StrictStr, Field(description="The URL or Base64 encoded Data URL for the watermark image. You can also upload an image file directly using multipart/form-data")],
        bg_color: Annotated[Optional[StrictStr], Field(description="The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)")] = None,
        format: Annotated[Optional[StrictStr], Field(description="The output image format, can be either png or jpg")] = None,
        height: Annotated[Optional[StrictInt], Field(description="If set resize the resulting image to this height (in px)")] = None,
        opacity: Annotated[Optional[StrictInt], Field(description="The opacity of the watermark (0 to 100)")] = None,
        position: Annotated[Optional[StrictStr], Field(description="The position of the watermark image, possible values are: <br>center, top-left, top-center, top-right, bottom-left, bottom-center, bottom-right")] = None,
        resize_mode: Annotated[Optional[StrictStr], Field(description="The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>")] = None,
        width: Annotated[Optional[StrictInt], Field(description="If set resize the resulting image to this width (in px)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Image Watermark

        Watermark one image with another image

        :param image_url: The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data (required)
        :type image_url: str
        :param watermark_url: The URL or Base64 encoded Data URL for the watermark image. You can also upload an image file directly using multipart/form-data (required)
        :type watermark_url: str
        :param bg_color: The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)
        :type bg_color: str
        :param format: The output image format, can be either png or jpg
        :type format: str
        :param height: If set resize the resulting image to this height (in px)
        :type height: int
        :param opacity: The opacity of the watermark (0 to 100)
        :type opacity: int
        :param position: The position of the watermark image, possible values are: <br>center, top-left, top-center, top-right, bottom-left, bottom-center, bottom-right
        :type position: str
        :param resize_mode: The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>
        :type resize_mode: str
        :param width: If set resize the resulting image to this width (in px)
        :type width: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._image_watermark_serialize(
            image_url=image_url,
            watermark_url=watermark_url,
            bg_color=bg_color,
            format=format,
            height=height,
            opacity=opacity,
            position=position,
            resize_mode=resize_mode,
            width=width,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _image_watermark_serialize(
        self,
        image_url,
        watermark_url,
        bg_color,
        format,
        height,
        opacity,
        position,
        resize_mode,
        width,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if bg_color is not None:
            _form_params.append(('bg-color', bg_color))
        if format is not None:
            _form_params.append(('format', format))
        if height is not None:
            _form_params.append(('height', height))
        if image_url is not None:
            _form_params.append(('image-url', image_url))
        if opacity is not None:
            _form_params.append(('opacity', opacity))
        if position is not None:
            _form_params.append(('position', position))
        if resize_mode is not None:
            _form_params.append(('resize-mode', resize_mode))
        if watermark_url is not None:
            _form_params.append(('watermark-url', watermark_url))
        if width is not None:
            _form_params.append(('width', width))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/image-watermark',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def q_r_code(
        self,
        content: Annotated[StrictStr, Field(description="The content to encode into the QR code (e.g. a URL or a phone number)")],
        bg_color: Annotated[Optional[StrictStr], Field(description="The QR code background color")] = None,
        fg_color: Annotated[Optional[StrictStr], Field(description="The QR code foreground color")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of the QR code (in px)")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of the QR code (in px)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """QR Code

        Generate a QR code as a PNG image

        :param content: The content to encode into the QR code (e.g. a URL or a phone number) (required)
        :type content: str
        :param bg_color: The QR code background color
        :type bg_color: str
        :param fg_color: The QR code foreground color
        :type fg_color: str
        :param height: The height of the QR code (in px)
        :type height: int
        :param width: The width of the QR code (in px)
        :type width: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._q_r_code_serialize(
            content=content,
            bg_color=bg_color,
            fg_color=fg_color,
            height=height,
            width=width,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def q_r_code_with_http_info(
        self,
        content: Annotated[StrictStr, Field(description="The content to encode into the QR code (e.g. a URL or a phone number)")],
        bg_color: Annotated[Optional[StrictStr], Field(description="The QR code background color")] = None,
        fg_color: Annotated[Optional[StrictStr], Field(description="The QR code foreground color")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of the QR code (in px)")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of the QR code (in px)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """QR Code

        Generate a QR code as a PNG image

        :param content: The content to encode into the QR code (e.g. a URL or a phone number) (required)
        :type content: str
        :param bg_color: The QR code background color
        :type bg_color: str
        :param fg_color: The QR code foreground color
        :type fg_color: str
        :param height: The height of the QR code (in px)
        :type height: int
        :param width: The width of the QR code (in px)
        :type width: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._q_r_code_serialize(
            content=content,
            bg_color=bg_color,
            fg_color=fg_color,
            height=height,
            width=width,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def q_r_code_without_preload_content(
        self,
        content: Annotated[StrictStr, Field(description="The content to encode into the QR code (e.g. a URL or a phone number)")],
        bg_color: Annotated[Optional[StrictStr], Field(description="The QR code background color")] = None,
        fg_color: Annotated[Optional[StrictStr], Field(description="The QR code foreground color")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of the QR code (in px)")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of the QR code (in px)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """QR Code

        Generate a QR code as a PNG image

        :param content: The content to encode into the QR code (e.g. a URL or a phone number) (required)
        :type content: str
        :param bg_color: The QR code background color
        :type bg_color: str
        :param fg_color: The QR code foreground color
        :type fg_color: str
        :param height: The height of the QR code (in px)
        :type height: int
        :param width: The width of the QR code (in px)
        :type width: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._q_r_code_serialize(
            content=content,
            bg_color=bg_color,
            fg_color=fg_color,
            height=height,
            width=width,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _q_r_code_serialize(
        self,
        content,
        bg_color,
        fg_color,
        height,
        width,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if bg_color is not None:
            _form_params.append(('bg-color', bg_color))
        if content is not None:
            _form_params.append(('content', content))
        if fg_color is not None:
            _form_params.append(('fg-color', fg_color))
        if height is not None:
            _form_params.append(('height', height))
        if width is not None:
            _form_params.append(('width', width))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/qr-code',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


