# coding: utf-8

"""
    Neutrino API

    The general-purpose API

    The version of the OpenAPI document: 3.6.4
    Contact: ops@neutrinoapi.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.browser_bot_response import BrowserBotResponse
from openapi_client.models.url_info_response import URLInfoResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class WWWApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def browser_bot(
        self,
        url: Annotated[StrictStr, Field(description="The URL to load")],
        delay: Annotated[Optional[StrictInt], Field(description="Delay in seconds to wait before capturing any page data, executing selectors or JavaScript")] = None,
        var_exec: Annotated[Optional[List[StrictStr]], Field(description="Execute JavaScript on the website. This parameter accepts JavaScript as either a string containing JavaScript or for sending multiple separate statements a JSON array or POST array can also be used. If a statement returns any value it will be returned in the 'exec-results' response. You can also use the following specially defined user interaction functions: <br> <br> <div> sleep(seconds); Just wait/sleep for the specified number of seconds. <br>click('selector'); Click on the first element matching the given selector. <br>focus('selector'); Focus on the first element matching the given selector. <br>keys('characters'); Send the specified keyboard characters. Use click() or focus() first to send keys to a specific element. <br>enter(); Send the Enter key. <br>tab(); Send the Tab key. <br> </div>")] = None,
        ignore_certificate_errors: Annotated[Optional[StrictBool], Field(description="Ignore any TLS/SSL certificate errors and load the page anyway")] = None,
        selector: Annotated[Optional[StrictStr], Field(description="Extract content from the page DOM using this selector. Commonly known as a CSS selector, you can find a good reference <a href=\\\"https://www.w3schools.com/cssref/css_selectors.asp\\\">here</a>")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout in seconds. Give up if still trying to load the page after this number of seconds")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="Override the browsers default user-agent string with this one")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BrowserBotResponse:
        """Browser Bot

        Browser bot can extract content, interact with keyboard and mouse events, and execute JavaScript on a website

        :param url: The URL to load (required)
        :type url: str
        :param delay: Delay in seconds to wait before capturing any page data, executing selectors or JavaScript
        :type delay: int
        :param var_exec: Execute JavaScript on the website. This parameter accepts JavaScript as either a string containing JavaScript or for sending multiple separate statements a JSON array or POST array can also be used. If a statement returns any value it will be returned in the 'exec-results' response. You can also use the following specially defined user interaction functions: <br> <br> <div> sleep(seconds); Just wait/sleep for the specified number of seconds. <br>click('selector'); Click on the first element matching the given selector. <br>focus('selector'); Focus on the first element matching the given selector. <br>keys('characters'); Send the specified keyboard characters. Use click() or focus() first to send keys to a specific element. <br>enter(); Send the Enter key. <br>tab(); Send the Tab key. <br> </div>
        :type var_exec: List[str]
        :param ignore_certificate_errors: Ignore any TLS/SSL certificate errors and load the page anyway
        :type ignore_certificate_errors: bool
        :param selector: Extract content from the page DOM using this selector. Commonly known as a CSS selector, you can find a good reference <a href=\\\"https://www.w3schools.com/cssref/css_selectors.asp\\\">here</a>
        :type selector: str
        :param timeout: Timeout in seconds. Give up if still trying to load the page after this number of seconds
        :type timeout: int
        :param user_agent: Override the browsers default user-agent string with this one
        :type user_agent: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._browser_bot_serialize(
            url=url,
            delay=delay,
            var_exec=var_exec,
            ignore_certificate_errors=ignore_certificate_errors,
            selector=selector,
            timeout=timeout,
            user_agent=user_agent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BrowserBotResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def browser_bot_with_http_info(
        self,
        url: Annotated[StrictStr, Field(description="The URL to load")],
        delay: Annotated[Optional[StrictInt], Field(description="Delay in seconds to wait before capturing any page data, executing selectors or JavaScript")] = None,
        var_exec: Annotated[Optional[List[StrictStr]], Field(description="Execute JavaScript on the website. This parameter accepts JavaScript as either a string containing JavaScript or for sending multiple separate statements a JSON array or POST array can also be used. If a statement returns any value it will be returned in the 'exec-results' response. You can also use the following specially defined user interaction functions: <br> <br> <div> sleep(seconds); Just wait/sleep for the specified number of seconds. <br>click('selector'); Click on the first element matching the given selector. <br>focus('selector'); Focus on the first element matching the given selector. <br>keys('characters'); Send the specified keyboard characters. Use click() or focus() first to send keys to a specific element. <br>enter(); Send the Enter key. <br>tab(); Send the Tab key. <br> </div>")] = None,
        ignore_certificate_errors: Annotated[Optional[StrictBool], Field(description="Ignore any TLS/SSL certificate errors and load the page anyway")] = None,
        selector: Annotated[Optional[StrictStr], Field(description="Extract content from the page DOM using this selector. Commonly known as a CSS selector, you can find a good reference <a href=\\\"https://www.w3schools.com/cssref/css_selectors.asp\\\">here</a>")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout in seconds. Give up if still trying to load the page after this number of seconds")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="Override the browsers default user-agent string with this one")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BrowserBotResponse]:
        """Browser Bot

        Browser bot can extract content, interact with keyboard and mouse events, and execute JavaScript on a website

        :param url: The URL to load (required)
        :type url: str
        :param delay: Delay in seconds to wait before capturing any page data, executing selectors or JavaScript
        :type delay: int
        :param var_exec: Execute JavaScript on the website. This parameter accepts JavaScript as either a string containing JavaScript or for sending multiple separate statements a JSON array or POST array can also be used. If a statement returns any value it will be returned in the 'exec-results' response. You can also use the following specially defined user interaction functions: <br> <br> <div> sleep(seconds); Just wait/sleep for the specified number of seconds. <br>click('selector'); Click on the first element matching the given selector. <br>focus('selector'); Focus on the first element matching the given selector. <br>keys('characters'); Send the specified keyboard characters. Use click() or focus() first to send keys to a specific element. <br>enter(); Send the Enter key. <br>tab(); Send the Tab key. <br> </div>
        :type var_exec: List[str]
        :param ignore_certificate_errors: Ignore any TLS/SSL certificate errors and load the page anyway
        :type ignore_certificate_errors: bool
        :param selector: Extract content from the page DOM using this selector. Commonly known as a CSS selector, you can find a good reference <a href=\\\"https://www.w3schools.com/cssref/css_selectors.asp\\\">here</a>
        :type selector: str
        :param timeout: Timeout in seconds. Give up if still trying to load the page after this number of seconds
        :type timeout: int
        :param user_agent: Override the browsers default user-agent string with this one
        :type user_agent: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._browser_bot_serialize(
            url=url,
            delay=delay,
            var_exec=var_exec,
            ignore_certificate_errors=ignore_certificate_errors,
            selector=selector,
            timeout=timeout,
            user_agent=user_agent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BrowserBotResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def browser_bot_without_preload_content(
        self,
        url: Annotated[StrictStr, Field(description="The URL to load")],
        delay: Annotated[Optional[StrictInt], Field(description="Delay in seconds to wait before capturing any page data, executing selectors or JavaScript")] = None,
        var_exec: Annotated[Optional[List[StrictStr]], Field(description="Execute JavaScript on the website. This parameter accepts JavaScript as either a string containing JavaScript or for sending multiple separate statements a JSON array or POST array can also be used. If a statement returns any value it will be returned in the 'exec-results' response. You can also use the following specially defined user interaction functions: <br> <br> <div> sleep(seconds); Just wait/sleep for the specified number of seconds. <br>click('selector'); Click on the first element matching the given selector. <br>focus('selector'); Focus on the first element matching the given selector. <br>keys('characters'); Send the specified keyboard characters. Use click() or focus() first to send keys to a specific element. <br>enter(); Send the Enter key. <br>tab(); Send the Tab key. <br> </div>")] = None,
        ignore_certificate_errors: Annotated[Optional[StrictBool], Field(description="Ignore any TLS/SSL certificate errors and load the page anyway")] = None,
        selector: Annotated[Optional[StrictStr], Field(description="Extract content from the page DOM using this selector. Commonly known as a CSS selector, you can find a good reference <a href=\\\"https://www.w3schools.com/cssref/css_selectors.asp\\\">here</a>")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout in seconds. Give up if still trying to load the page after this number of seconds")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="Override the browsers default user-agent string with this one")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Browser Bot

        Browser bot can extract content, interact with keyboard and mouse events, and execute JavaScript on a website

        :param url: The URL to load (required)
        :type url: str
        :param delay: Delay in seconds to wait before capturing any page data, executing selectors or JavaScript
        :type delay: int
        :param var_exec: Execute JavaScript on the website. This parameter accepts JavaScript as either a string containing JavaScript or for sending multiple separate statements a JSON array or POST array can also be used. If a statement returns any value it will be returned in the 'exec-results' response. You can also use the following specially defined user interaction functions: <br> <br> <div> sleep(seconds); Just wait/sleep for the specified number of seconds. <br>click('selector'); Click on the first element matching the given selector. <br>focus('selector'); Focus on the first element matching the given selector. <br>keys('characters'); Send the specified keyboard characters. Use click() or focus() first to send keys to a specific element. <br>enter(); Send the Enter key. <br>tab(); Send the Tab key. <br> </div>
        :type var_exec: List[str]
        :param ignore_certificate_errors: Ignore any TLS/SSL certificate errors and load the page anyway
        :type ignore_certificate_errors: bool
        :param selector: Extract content from the page DOM using this selector. Commonly known as a CSS selector, you can find a good reference <a href=\\\"https://www.w3schools.com/cssref/css_selectors.asp\\\">here</a>
        :type selector: str
        :param timeout: Timeout in seconds. Give up if still trying to load the page after this number of seconds
        :type timeout: int
        :param user_agent: Override the browsers default user-agent string with this one
        :type user_agent: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._browser_bot_serialize(
            url=url,
            delay=delay,
            var_exec=var_exec,
            ignore_certificate_errors=ignore_certificate_errors,
            selector=selector,
            timeout=timeout,
            user_agent=user_agent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BrowserBotResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _browser_bot_serialize(
        self,
        url,
        delay,
        var_exec,
        ignore_certificate_errors,
        selector,
        timeout,
        user_agent,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'exec': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if delay is not None:
            _form_params.append(('delay', delay))
        if var_exec is not None:
            _form_params.append(('exec', var_exec))
        if ignore_certificate_errors is not None:
            _form_params.append(('ignore-certificate-errors', ignore_certificate_errors))
        if selector is not None:
            _form_params.append(('selector', selector))
        if timeout is not None:
            _form_params.append(('timeout', timeout))
        if url is not None:
            _form_params.append(('url', url))
        if user_agent is not None:
            _form_params.append(('user-agent', user_agent))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/browser-bot',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def h_tml_clean(
        self,
        content: Annotated[StrictStr, Field(description="The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string")],
        output_type: Annotated[StrictStr, Field(description="The level of sanitization, possible values are: <br><b>plain-text</b>: reduce the content to plain text only (no HTML tags at all) <br><b>simple-text</b>: allow only very basic text formatting tags like b, em, i, strong, u <br><b>basic-html</b>: allow advanced text formatting and hyper links <br><b>basic-html-with-images</b>: same as basic html but also allows image tags <br><b>advanced-html</b>: same as basic html with images but also allows many more common HTML tags like table, ul, dl, pre <br>")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """HTML Clean

        Clean and sanitize untrusted HTML

        :param content: The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string (required)
        :type content: str
        :param output_type: The level of sanitization, possible values are: <br><b>plain-text</b>: reduce the content to plain text only (no HTML tags at all) <br><b>simple-text</b>: allow only very basic text formatting tags like b, em, i, strong, u <br><b>basic-html</b>: allow advanced text formatting and hyper links <br><b>basic-html-with-images</b>: same as basic html but also allows image tags <br><b>advanced-html</b>: same as basic html with images but also allows many more common HTML tags like table, ul, dl, pre <br> (required)
        :type output_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._h_tml_clean_serialize(
            content=content,
            output_type=output_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def h_tml_clean_with_http_info(
        self,
        content: Annotated[StrictStr, Field(description="The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string")],
        output_type: Annotated[StrictStr, Field(description="The level of sanitization, possible values are: <br><b>plain-text</b>: reduce the content to plain text only (no HTML tags at all) <br><b>simple-text</b>: allow only very basic text formatting tags like b, em, i, strong, u <br><b>basic-html</b>: allow advanced text formatting and hyper links <br><b>basic-html-with-images</b>: same as basic html but also allows image tags <br><b>advanced-html</b>: same as basic html with images but also allows many more common HTML tags like table, ul, dl, pre <br>")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """HTML Clean

        Clean and sanitize untrusted HTML

        :param content: The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string (required)
        :type content: str
        :param output_type: The level of sanitization, possible values are: <br><b>plain-text</b>: reduce the content to plain text only (no HTML tags at all) <br><b>simple-text</b>: allow only very basic text formatting tags like b, em, i, strong, u <br><b>basic-html</b>: allow advanced text formatting and hyper links <br><b>basic-html-with-images</b>: same as basic html but also allows image tags <br><b>advanced-html</b>: same as basic html with images but also allows many more common HTML tags like table, ul, dl, pre <br> (required)
        :type output_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._h_tml_clean_serialize(
            content=content,
            output_type=output_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def h_tml_clean_without_preload_content(
        self,
        content: Annotated[StrictStr, Field(description="The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string")],
        output_type: Annotated[StrictStr, Field(description="The level of sanitization, possible values are: <br><b>plain-text</b>: reduce the content to plain text only (no HTML tags at all) <br><b>simple-text</b>: allow only very basic text formatting tags like b, em, i, strong, u <br><b>basic-html</b>: allow advanced text formatting and hyper links <br><b>basic-html-with-images</b>: same as basic html but also allows image tags <br><b>advanced-html</b>: same as basic html with images but also allows many more common HTML tags like table, ul, dl, pre <br>")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """HTML Clean

        Clean and sanitize untrusted HTML

        :param content: The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string (required)
        :type content: str
        :param output_type: The level of sanitization, possible values are: <br><b>plain-text</b>: reduce the content to plain text only (no HTML tags at all) <br><b>simple-text</b>: allow only very basic text formatting tags like b, em, i, strong, u <br><b>basic-html</b>: allow advanced text formatting and hyper links <br><b>basic-html-with-images</b>: same as basic html but also allows image tags <br><b>advanced-html</b>: same as basic html with images but also allows many more common HTML tags like table, ul, dl, pre <br> (required)
        :type output_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._h_tml_clean_serialize(
            content=content,
            output_type=output_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _h_tml_clean_serialize(
        self,
        content,
        output_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if content is not None:
            _form_params.append(('content', content))
        if output_type is not None:
            _form_params.append(('output-type', output_type))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/html-clean',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def u_rl_info(
        self,
        url: Annotated[StrictStr, Field(description="The URL to probe")],
        fetch_content: Annotated[Optional[StrictBool], Field(description="If this URL responds with html, text, json or xml then return the response. This option is useful if you want to perform further processing on the URL content (e.g. with the HTML Extract or HTML Clean APIs)")] = None,
        ignore_certificate_errors: Annotated[Optional[StrictBool], Field(description="Ignore any TLS/SSL certificate errors and load the URL anyway")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout in seconds. Give up if still trying to load the URL after this number of seconds")] = None,
        retry: Annotated[Optional[StrictInt], Field(description="If the request fails for any reason try again this many times")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> URLInfoResponse:
        """URL Info

        Parse, analyze and retrieve content from the supplied URL

        :param url: The URL to probe (required)
        :type url: str
        :param fetch_content: If this URL responds with html, text, json or xml then return the response. This option is useful if you want to perform further processing on the URL content (e.g. with the HTML Extract or HTML Clean APIs)
        :type fetch_content: bool
        :param ignore_certificate_errors: Ignore any TLS/SSL certificate errors and load the URL anyway
        :type ignore_certificate_errors: bool
        :param timeout: Timeout in seconds. Give up if still trying to load the URL after this number of seconds
        :type timeout: int
        :param retry: If the request fails for any reason try again this many times
        :type retry: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._u_rl_info_serialize(
            url=url,
            fetch_content=fetch_content,
            ignore_certificate_errors=ignore_certificate_errors,
            timeout=timeout,
            retry=retry,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "URLInfoResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def u_rl_info_with_http_info(
        self,
        url: Annotated[StrictStr, Field(description="The URL to probe")],
        fetch_content: Annotated[Optional[StrictBool], Field(description="If this URL responds with html, text, json or xml then return the response. This option is useful if you want to perform further processing on the URL content (e.g. with the HTML Extract or HTML Clean APIs)")] = None,
        ignore_certificate_errors: Annotated[Optional[StrictBool], Field(description="Ignore any TLS/SSL certificate errors and load the URL anyway")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout in seconds. Give up if still trying to load the URL after this number of seconds")] = None,
        retry: Annotated[Optional[StrictInt], Field(description="If the request fails for any reason try again this many times")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[URLInfoResponse]:
        """URL Info

        Parse, analyze and retrieve content from the supplied URL

        :param url: The URL to probe (required)
        :type url: str
        :param fetch_content: If this URL responds with html, text, json or xml then return the response. This option is useful if you want to perform further processing on the URL content (e.g. with the HTML Extract or HTML Clean APIs)
        :type fetch_content: bool
        :param ignore_certificate_errors: Ignore any TLS/SSL certificate errors and load the URL anyway
        :type ignore_certificate_errors: bool
        :param timeout: Timeout in seconds. Give up if still trying to load the URL after this number of seconds
        :type timeout: int
        :param retry: If the request fails for any reason try again this many times
        :type retry: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._u_rl_info_serialize(
            url=url,
            fetch_content=fetch_content,
            ignore_certificate_errors=ignore_certificate_errors,
            timeout=timeout,
            retry=retry,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "URLInfoResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def u_rl_info_without_preload_content(
        self,
        url: Annotated[StrictStr, Field(description="The URL to probe")],
        fetch_content: Annotated[Optional[StrictBool], Field(description="If this URL responds with html, text, json or xml then return the response. This option is useful if you want to perform further processing on the URL content (e.g. with the HTML Extract or HTML Clean APIs)")] = None,
        ignore_certificate_errors: Annotated[Optional[StrictBool], Field(description="Ignore any TLS/SSL certificate errors and load the URL anyway")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout in seconds. Give up if still trying to load the URL after this number of seconds")] = None,
        retry: Annotated[Optional[StrictInt], Field(description="If the request fails for any reason try again this many times")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """URL Info

        Parse, analyze and retrieve content from the supplied URL

        :param url: The URL to probe (required)
        :type url: str
        :param fetch_content: If this URL responds with html, text, json or xml then return the response. This option is useful if you want to perform further processing on the URL content (e.g. with the HTML Extract or HTML Clean APIs)
        :type fetch_content: bool
        :param ignore_certificate_errors: Ignore any TLS/SSL certificate errors and load the URL anyway
        :type ignore_certificate_errors: bool
        :param timeout: Timeout in seconds. Give up if still trying to load the URL after this number of seconds
        :type timeout: int
        :param retry: If the request fails for any reason try again this many times
        :type retry: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._u_rl_info_serialize(
            url=url,
            fetch_content=fetch_content,
            ignore_certificate_errors=ignore_certificate_errors,
            timeout=timeout,
            retry=retry,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "URLInfoResponse",
            '400': "APIError",
            '403': "APIError",
            '500': "APIError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _u_rl_info_serialize(
        self,
        url,
        fetch_content,
        ignore_certificate_errors,
        timeout,
        retry,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if url is not None:
            
            _query_params.append(('url', url))
            
        if fetch_content is not None:
            
            _query_params.append(('fetch-content', fetch_content))
            
        if ignore_certificate_errors is not None:
            
            _query_params.append(('ignore-certificate-errors', ignore_certificate_errors))
            
        if timeout is not None:
            
            _query_params.append(('timeout', timeout))
            
        if retry is not None:
            
            _query_params.append(('retry', retry))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api-key', 
            'user-id'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/url-info',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


