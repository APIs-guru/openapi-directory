# coding: utf-8

"""
    Real-time Bidding API

    Allows external bidders to manage their RTB integration with Google. This includes managing bidder endpoints, QPS quotas, configuring what ad inventory to receive via pretargeting, submitting creatives for verification, and accessing creative metadata such as approval status.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.ad_technology_providers import AdTechnologyProviders
from openapi_client.models.advertiser_and_brand import AdvertiserAndBrand
from openapi_client.models.policy_compliance import PolicyCompliance
from typing import Optional, Set
from typing_extensions import Self

class CreativeServingDecision(BaseModel):
    """
    Top level status and detected attributes of a creative.
    """ # noqa: E501
    ad_technology_providers: Optional[AdTechnologyProviders] = Field(default=None, alias="adTechnologyProviders")
    china_policy_compliance: Optional[PolicyCompliance] = Field(default=None, alias="chinaPolicyCompliance")
    deals_policy_compliance: Optional[PolicyCompliance] = Field(default=None, alias="dealsPolicyCompliance")
    detected_advertisers: Optional[List[AdvertiserAndBrand]] = Field(default=None, description="Detected advertisers and brands.", alias="detectedAdvertisers")
    detected_attributes: Optional[List[StrictStr]] = Field(default=None, description="Publisher-excludable attributes that were detected for this creative. Can be used to filter the response of the creatives.list method. If the `excluded_attribute` field of a [bid request](https://developers.google.com/authorized-buyers/rtb/downloads/realtime-bidding-proto) contains one of the attributes that were declared or detected for a given creative, and a bid is submitted with that creative, the bid will be filtered before the auction.", alias="detectedAttributes")
    detected_click_through_urls: Optional[List[StrictStr]] = Field(default=None, description="The set of detected destination URLs for the creative. Can be used to filter the response of the creatives.list method.", alias="detectedClickThroughUrls")
    detected_domains: Optional[List[StrictStr]] = Field(default=None, description="The detected domains for this creative.", alias="detectedDomains")
    detected_languages: Optional[List[StrictStr]] = Field(default=None, description="The detected languages for this creative. The order is arbitrary. The codes are 2 or 5 characters and are documented at https://developers.google.com/adwords/api/docs/appendix/languagecodes. Can be used to filter the response of the creatives.list method.", alias="detectedLanguages")
    detected_product_categories: Optional[List[StrictInt]] = Field(default=None, description="Detected product categories, if any. See the ad-product-categories.txt file in the technical documentation for a list of IDs. Can be used to filter the response of the creatives.list method.", alias="detectedProductCategories")
    detected_sensitive_categories: Optional[List[StrictInt]] = Field(default=None, description="Detected sensitive categories, if any. Can be used to filter the response of the creatives.list method. See the ad-sensitive-categories.txt file in the technical documentation for a list of IDs. You should use these IDs along with the excluded-sensitive-category field in the bid request to filter your bids.", alias="detectedSensitiveCategories")
    detected_vendor_ids: Optional[List[StrictInt]] = Field(default=None, description="IDs of the ad technology vendors that were detected to be used by this creative. See https://storage.googleapis.com/adx-rtb-dictionaries/vendors.txt for possible values. Can be used to filter the response of the creatives.list method. If the `allowed_vendor_type` field of a [bid request](https://developers.google.com/authorized-buyers/rtb/downloads/realtime-bidding-proto) does not contain one of the vendor type IDs that were declared or detected for a given creative, and a bid is submitted with that creative, the bid will be filtered before the auction.", alias="detectedVendorIds")
    last_status_update: Optional[StrictStr] = Field(default=None, description="The last time the creative status was updated. Can be used to filter the response of the creatives.list method.", alias="lastStatusUpdate")
    network_policy_compliance: Optional[PolicyCompliance] = Field(default=None, alias="networkPolicyCompliance")
    platform_policy_compliance: Optional[PolicyCompliance] = Field(default=None, alias="platformPolicyCompliance")
    russia_policy_compliance: Optional[PolicyCompliance] = Field(default=None, alias="russiaPolicyCompliance")
    __properties: ClassVar[List[str]] = ["adTechnologyProviders", "chinaPolicyCompliance", "dealsPolicyCompliance", "detectedAdvertisers", "detectedAttributes", "detectedClickThroughUrls", "detectedDomains", "detectedLanguages", "detectedProductCategories", "detectedSensitiveCategories", "detectedVendorIds", "lastStatusUpdate", "networkPolicyCompliance", "platformPolicyCompliance", "russiaPolicyCompliance"]

    @field_validator('detected_attributes')
    def detected_attributes_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['ATTRIBUTE_UNSPECIFIED', 'IMAGE_RICH_MEDIA', 'ADOBE_FLASH_FLV', 'IS_TAGGED', 'IS_COOKIE_TARGETED', 'IS_USER_INTEREST_TARGETED', 'EXPANDING_DIRECTION_NONE', 'EXPANDING_DIRECTION_UP', 'EXPANDING_DIRECTION_DOWN', 'EXPANDING_DIRECTION_LEFT', 'EXPANDING_DIRECTION_RIGHT', 'EXPANDING_DIRECTION_UP_LEFT', 'EXPANDING_DIRECTION_UP_RIGHT', 'EXPANDING_DIRECTION_DOWN_LEFT', 'EXPANDING_DIRECTION_DOWN_RIGHT', 'CREATIVE_TYPE_HTML', 'CREATIVE_TYPE_VAST_VIDEO', 'EXPANDING_DIRECTION_UP_OR_DOWN', 'EXPANDING_DIRECTION_LEFT_OR_RIGHT', 'EXPANDING_DIRECTION_ANY_DIAGONAL', 'EXPANDING_ACTION_ROLLOVER_TO_EXPAND', 'INSTREAM_VAST_VIDEO_TYPE_VPAID_FLASH', 'RICH_MEDIA_CAPABILITY_TYPE_MRAID', 'RICH_MEDIA_CAPABILITY_TYPE_FLASH', 'RICH_MEDIA_CAPABILITY_TYPE_HTML5', 'SKIPPABLE_INSTREAM_VIDEO', 'RICH_MEDIA_CAPABILITY_TYPE_SSL', 'RICH_MEDIA_CAPABILITY_TYPE_NON_SSL', 'RICH_MEDIA_CAPABILITY_TYPE_INTERSTITIAL', 'NON_SKIPPABLE_INSTREAM_VIDEO', 'NATIVE_ELIGIBILITY_ELIGIBLE', 'NON_VPAID', 'NATIVE_ELIGIBILITY_NOT_ELIGIBLE', 'ANY_INTERSTITIAL', 'NON_INTERSTITIAL', 'IN_BANNER_VIDEO', 'RENDERING_SIZELESS_ADX', 'OMSDK_1_0', 'RENDERING_PLAYABLE']):
                raise ValueError("each list item must be one of ('ATTRIBUTE_UNSPECIFIED', 'IMAGE_RICH_MEDIA', 'ADOBE_FLASH_FLV', 'IS_TAGGED', 'IS_COOKIE_TARGETED', 'IS_USER_INTEREST_TARGETED', 'EXPANDING_DIRECTION_NONE', 'EXPANDING_DIRECTION_UP', 'EXPANDING_DIRECTION_DOWN', 'EXPANDING_DIRECTION_LEFT', 'EXPANDING_DIRECTION_RIGHT', 'EXPANDING_DIRECTION_UP_LEFT', 'EXPANDING_DIRECTION_UP_RIGHT', 'EXPANDING_DIRECTION_DOWN_LEFT', 'EXPANDING_DIRECTION_DOWN_RIGHT', 'CREATIVE_TYPE_HTML', 'CREATIVE_TYPE_VAST_VIDEO', 'EXPANDING_DIRECTION_UP_OR_DOWN', 'EXPANDING_DIRECTION_LEFT_OR_RIGHT', 'EXPANDING_DIRECTION_ANY_DIAGONAL', 'EXPANDING_ACTION_ROLLOVER_TO_EXPAND', 'INSTREAM_VAST_VIDEO_TYPE_VPAID_FLASH', 'RICH_MEDIA_CAPABILITY_TYPE_MRAID', 'RICH_MEDIA_CAPABILITY_TYPE_FLASH', 'RICH_MEDIA_CAPABILITY_TYPE_HTML5', 'SKIPPABLE_INSTREAM_VIDEO', 'RICH_MEDIA_CAPABILITY_TYPE_SSL', 'RICH_MEDIA_CAPABILITY_TYPE_NON_SSL', 'RICH_MEDIA_CAPABILITY_TYPE_INTERSTITIAL', 'NON_SKIPPABLE_INSTREAM_VIDEO', 'NATIVE_ELIGIBILITY_ELIGIBLE', 'NON_VPAID', 'NATIVE_ELIGIBILITY_NOT_ELIGIBLE', 'ANY_INTERSTITIAL', 'NON_INTERSTITIAL', 'IN_BANNER_VIDEO', 'RENDERING_SIZELESS_ADX', 'OMSDK_1_0', 'RENDERING_PLAYABLE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreativeServingDecision from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of ad_technology_providers
        if self.ad_technology_providers:
            _dict['adTechnologyProviders'] = self.ad_technology_providers.to_dict()
        # override the default output from pydantic by calling `to_dict()` of china_policy_compliance
        if self.china_policy_compliance:
            _dict['chinaPolicyCompliance'] = self.china_policy_compliance.to_dict()
        # override the default output from pydantic by calling `to_dict()` of deals_policy_compliance
        if self.deals_policy_compliance:
            _dict['dealsPolicyCompliance'] = self.deals_policy_compliance.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in detected_advertisers (list)
        _items = []
        if self.detected_advertisers:
            for _item_detected_advertisers in self.detected_advertisers:
                if _item_detected_advertisers:
                    _items.append(_item_detected_advertisers.to_dict())
            _dict['detectedAdvertisers'] = _items
        # override the default output from pydantic by calling `to_dict()` of network_policy_compliance
        if self.network_policy_compliance:
            _dict['networkPolicyCompliance'] = self.network_policy_compliance.to_dict()
        # override the default output from pydantic by calling `to_dict()` of platform_policy_compliance
        if self.platform_policy_compliance:
            _dict['platformPolicyCompliance'] = self.platform_policy_compliance.to_dict()
        # override the default output from pydantic by calling `to_dict()` of russia_policy_compliance
        if self.russia_policy_compliance:
            _dict['russiaPolicyCompliance'] = self.russia_policy_compliance.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreativeServingDecision from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "adTechnologyProviders": AdTechnologyProviders.from_dict(obj["adTechnologyProviders"]) if obj.get("adTechnologyProviders") is not None else None,
            "chinaPolicyCompliance": PolicyCompliance.from_dict(obj["chinaPolicyCompliance"]) if obj.get("chinaPolicyCompliance") is not None else None,
            "dealsPolicyCompliance": PolicyCompliance.from_dict(obj["dealsPolicyCompliance"]) if obj.get("dealsPolicyCompliance") is not None else None,
            "detectedAdvertisers": [AdvertiserAndBrand.from_dict(_item) for _item in obj["detectedAdvertisers"]] if obj.get("detectedAdvertisers") is not None else None,
            "detectedAttributes": obj.get("detectedAttributes"),
            "detectedClickThroughUrls": obj.get("detectedClickThroughUrls"),
            "detectedDomains": obj.get("detectedDomains"),
            "detectedLanguages": obj.get("detectedLanguages"),
            "detectedProductCategories": obj.get("detectedProductCategories"),
            "detectedSensitiveCategories": obj.get("detectedSensitiveCategories"),
            "detectedVendorIds": obj.get("detectedVendorIds"),
            "lastStatusUpdate": obj.get("lastStatusUpdate"),
            "networkPolicyCompliance": PolicyCompliance.from_dict(obj["networkPolicyCompliance"]) if obj.get("networkPolicyCompliance") is not None else None,
            "platformPolicyCompliance": PolicyCompliance.from_dict(obj["platformPolicyCompliance"]) if obj.get("platformPolicyCompliance") is not None else None,
            "russiaPolicyCompliance": PolicyCompliance.from_dict(obj["russiaPolicyCompliance"]) if obj.get("russiaPolicyCompliance") is not None else None
        })
        return _obj


