# coding: utf-8

"""
    OS Config API

    OS management tools that can be used for patch management, patch compliance, and configuration management on VM instances.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.os_policy_assignment_instance_filter_inventory import OSPolicyAssignmentInstanceFilterInventory
from openapi_client.models.os_policy_assignment_label_set import OSPolicyAssignmentLabelSet
from typing import Optional, Set
from typing_extensions import Self

class OSPolicyAssignmentInstanceFilter(BaseModel):
    """
    Filters to select target VMs for an assignment. If more than one filter criteria is specified below, a VM will be selected if and only if it satisfies all of them.
    """ # noqa: E501
    all: Optional[StrictBool] = Field(default=None, description="Target all VMs in the project. If true, no other criteria is permitted.")
    exclusion_labels: Optional[List[OSPolicyAssignmentLabelSet]] = Field(default=None, description="List of label sets used for VM exclusion. If the list has more than one label set, the VM is excluded if any of the label sets are applicable for the VM.", alias="exclusionLabels")
    inclusion_labels: Optional[List[OSPolicyAssignmentLabelSet]] = Field(default=None, description="List of label sets used for VM inclusion. If the list has more than one `LabelSet`, the VM is included if any of the label sets are applicable for the VM.", alias="inclusionLabels")
    inventories: Optional[List[OSPolicyAssignmentInstanceFilterInventory]] = Field(default=None, description="List of inventories to select VMs. A VM is selected if its inventory data matches at least one of the following inventories.")
    __properties: ClassVar[List[str]] = ["all", "exclusionLabels", "inclusionLabels", "inventories"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OSPolicyAssignmentInstanceFilter from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in exclusion_labels (list)
        _items = []
        if self.exclusion_labels:
            for _item_exclusion_labels in self.exclusion_labels:
                if _item_exclusion_labels:
                    _items.append(_item_exclusion_labels.to_dict())
            _dict['exclusionLabels'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in inclusion_labels (list)
        _items = []
        if self.inclusion_labels:
            for _item_inclusion_labels in self.inclusion_labels:
                if _item_inclusion_labels:
                    _items.append(_item_inclusion_labels.to_dict())
            _dict['inclusionLabels'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in inventories (list)
        _items = []
        if self.inventories:
            for _item_inventories in self.inventories:
                if _item_inventories:
                    _items.append(_item_inventories.to_dict())
            _dict['inventories'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OSPolicyAssignmentInstanceFilter from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "all": obj.get("all"),
            "exclusionLabels": [OSPolicyAssignmentLabelSet.from_dict(_item) for _item in obj["exclusionLabels"]] if obj.get("exclusionLabels") is not None else None,
            "inclusionLabels": [OSPolicyAssignmentLabelSet.from_dict(_item) for _item in obj["inclusionLabels"]] if obj.get("inclusionLabels") is not None else None,
            "inventories": [OSPolicyAssignmentInstanceFilterInventory.from_dict(_item) for _item in obj["inventories"]] if obj.get("inventories") is not None else None
        })
        return _obj


