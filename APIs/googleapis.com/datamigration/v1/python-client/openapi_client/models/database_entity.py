# coding: utf-8

"""
    Database Migration API

    Manage Cloud Database Migration Service resources on Google Cloud Platform.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.database_instance_entity import DatabaseInstanceEntity
from openapi_client.models.entity_ddl import EntityDdl
from openapi_client.models.entity_issue import EntityIssue
from openapi_client.models.entity_mapping import EntityMapping
from openapi_client.models.function_entity import FunctionEntity
from openapi_client.models.materialized_view_entity import MaterializedViewEntity
from openapi_client.models.package_entity import PackageEntity
from openapi_client.models.schema_entity import SchemaEntity
from openapi_client.models.sequence_entity import SequenceEntity
from openapi_client.models.stored_procedure_entity import StoredProcedureEntity
from openapi_client.models.synonym_entity import SynonymEntity
from openapi_client.models.table_entity import TableEntity
from openapi_client.models.udt_entity import UDTEntity
from openapi_client.models.view_entity import ViewEntity
from typing import Optional, Set
from typing_extensions import Self

class DatabaseEntity(BaseModel):
    """
    The base entity type for all the database related entities. The message contains the entity name, the name of its parent, the entity type, and the specific details per entity type.
    """ # noqa: E501
    database: Optional[DatabaseInstanceEntity] = None
    database_function: Optional[FunctionEntity] = Field(default=None, alias="databaseFunction")
    database_package: Optional[PackageEntity] = Field(default=None, alias="databasePackage")
    entity_ddl: Optional[List[EntityDdl]] = Field(default=None, description="Details about the entity DDL script. Multiple DDL scripts are provided for child entities such as a table entity will have one DDL for the table with additional DDLs for each index, constraint and such.", alias="entityDdl")
    entity_type: Optional[StrictStr] = Field(default=None, description="The type of the database entity (table, view, index, ...).", alias="entityType")
    issues: Optional[List[EntityIssue]] = Field(default=None, description="Details about the various issues found for the entity.")
    mappings: Optional[List[EntityMapping]] = Field(default=None, description="Details about entity mappings. For source tree entities, this holds the draft entities which were generated by the mapping rules. For draft tree entities, this holds the source entities which were converted to form the draft entity. Destination entities will have no mapping details.")
    materialized_view: Optional[MaterializedViewEntity] = Field(default=None, alias="materializedView")
    parent_entity: Optional[StrictStr] = Field(default=None, description="The full name of the parent entity (e.g. schema name).", alias="parentEntity")
    var_schema: Optional[SchemaEntity] = Field(default=None, alias="schema")
    sequence: Optional[SequenceEntity] = None
    short_name: Optional[StrictStr] = Field(default=None, description="The short name (e.g. table name) of the entity.", alias="shortName")
    stored_procedure: Optional[StoredProcedureEntity] = Field(default=None, alias="storedProcedure")
    synonym: Optional[SynonymEntity] = None
    table: Optional[TableEntity] = None
    tree: Optional[StrictStr] = Field(default=None, description="The type of tree the entity belongs to.")
    udt: Optional[UDTEntity] = None
    view: Optional[ViewEntity] = None
    __properties: ClassVar[List[str]] = ["database", "databaseFunction", "databasePackage", "entityDdl", "entityType", "issues", "mappings", "materializedView", "parentEntity", "schema", "sequence", "shortName", "storedProcedure", "synonym", "table", "tree", "udt", "view"]

    @field_validator('entity_type')
    def entity_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DATABASE_ENTITY_TYPE_UNSPECIFIED', 'DATABASE_ENTITY_TYPE_SCHEMA', 'DATABASE_ENTITY_TYPE_TABLE', 'DATABASE_ENTITY_TYPE_COLUMN', 'DATABASE_ENTITY_TYPE_CONSTRAINT', 'DATABASE_ENTITY_TYPE_INDEX', 'DATABASE_ENTITY_TYPE_TRIGGER', 'DATABASE_ENTITY_TYPE_VIEW', 'DATABASE_ENTITY_TYPE_SEQUENCE', 'DATABASE_ENTITY_TYPE_STORED_PROCEDURE', 'DATABASE_ENTITY_TYPE_FUNCTION', 'DATABASE_ENTITY_TYPE_SYNONYM', 'DATABASE_ENTITY_TYPE_DATABASE_PACKAGE', 'DATABASE_ENTITY_TYPE_UDT', 'DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW', 'DATABASE_ENTITY_TYPE_DATABASE']):
            raise ValueError("must be one of enum values ('DATABASE_ENTITY_TYPE_UNSPECIFIED', 'DATABASE_ENTITY_TYPE_SCHEMA', 'DATABASE_ENTITY_TYPE_TABLE', 'DATABASE_ENTITY_TYPE_COLUMN', 'DATABASE_ENTITY_TYPE_CONSTRAINT', 'DATABASE_ENTITY_TYPE_INDEX', 'DATABASE_ENTITY_TYPE_TRIGGER', 'DATABASE_ENTITY_TYPE_VIEW', 'DATABASE_ENTITY_TYPE_SEQUENCE', 'DATABASE_ENTITY_TYPE_STORED_PROCEDURE', 'DATABASE_ENTITY_TYPE_FUNCTION', 'DATABASE_ENTITY_TYPE_SYNONYM', 'DATABASE_ENTITY_TYPE_DATABASE_PACKAGE', 'DATABASE_ENTITY_TYPE_UDT', 'DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW', 'DATABASE_ENTITY_TYPE_DATABASE')")
        return value

    @field_validator('tree')
    def tree_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['TREE_TYPE_UNSPECIFIED', 'SOURCE', 'DRAFT', 'DESTINATION']):
            raise ValueError("must be one of enum values ('TREE_TYPE_UNSPECIFIED', 'SOURCE', 'DRAFT', 'DESTINATION')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DatabaseEntity from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of database
        if self.database:
            _dict['database'] = self.database.to_dict()
        # override the default output from pydantic by calling `to_dict()` of database_function
        if self.database_function:
            _dict['databaseFunction'] = self.database_function.to_dict()
        # override the default output from pydantic by calling `to_dict()` of database_package
        if self.database_package:
            _dict['databasePackage'] = self.database_package.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in entity_ddl (list)
        _items = []
        if self.entity_ddl:
            for _item_entity_ddl in self.entity_ddl:
                if _item_entity_ddl:
                    _items.append(_item_entity_ddl.to_dict())
            _dict['entityDdl'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in issues (list)
        _items = []
        if self.issues:
            for _item_issues in self.issues:
                if _item_issues:
                    _items.append(_item_issues.to_dict())
            _dict['issues'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mappings (list)
        _items = []
        if self.mappings:
            for _item_mappings in self.mappings:
                if _item_mappings:
                    _items.append(_item_mappings.to_dict())
            _dict['mappings'] = _items
        # override the default output from pydantic by calling `to_dict()` of materialized_view
        if self.materialized_view:
            _dict['materializedView'] = self.materialized_view.to_dict()
        # override the default output from pydantic by calling `to_dict()` of var_schema
        if self.var_schema:
            _dict['schema'] = self.var_schema.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sequence
        if self.sequence:
            _dict['sequence'] = self.sequence.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stored_procedure
        if self.stored_procedure:
            _dict['storedProcedure'] = self.stored_procedure.to_dict()
        # override the default output from pydantic by calling `to_dict()` of synonym
        if self.synonym:
            _dict['synonym'] = self.synonym.to_dict()
        # override the default output from pydantic by calling `to_dict()` of table
        if self.table:
            _dict['table'] = self.table.to_dict()
        # override the default output from pydantic by calling `to_dict()` of udt
        if self.udt:
            _dict['udt'] = self.udt.to_dict()
        # override the default output from pydantic by calling `to_dict()` of view
        if self.view:
            _dict['view'] = self.view.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DatabaseEntity from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "database": DatabaseInstanceEntity.from_dict(obj["database"]) if obj.get("database") is not None else None,
            "databaseFunction": FunctionEntity.from_dict(obj["databaseFunction"]) if obj.get("databaseFunction") is not None else None,
            "databasePackage": PackageEntity.from_dict(obj["databasePackage"]) if obj.get("databasePackage") is not None else None,
            "entityDdl": [EntityDdl.from_dict(_item) for _item in obj["entityDdl"]] if obj.get("entityDdl") is not None else None,
            "entityType": obj.get("entityType"),
            "issues": [EntityIssue.from_dict(_item) for _item in obj["issues"]] if obj.get("issues") is not None else None,
            "mappings": [EntityMapping.from_dict(_item) for _item in obj["mappings"]] if obj.get("mappings") is not None else None,
            "materializedView": MaterializedViewEntity.from_dict(obj["materializedView"]) if obj.get("materializedView") is not None else None,
            "parentEntity": obj.get("parentEntity"),
            "schema": SchemaEntity.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
            "sequence": SequenceEntity.from_dict(obj["sequence"]) if obj.get("sequence") is not None else None,
            "shortName": obj.get("shortName"),
            "storedProcedure": StoredProcedureEntity.from_dict(obj["storedProcedure"]) if obj.get("storedProcedure") is not None else None,
            "synonym": SynonymEntity.from_dict(obj["synonym"]) if obj.get("synonym") is not None else None,
            "table": TableEntity.from_dict(obj["table"]) if obj.get("table") is not None else None,
            "tree": obj.get("tree"),
            "udt": UDTEntity.from_dict(obj["udt"]) if obj.get("udt") is not None else None,
            "view": ViewEntity.from_dict(obj["view"]) if obj.get("view") is not None else None
        })
        return _obj


