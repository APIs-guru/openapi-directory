# coding: utf-8

"""
    Cloud Tasks API

    Manages the execution of large numbers of distributed requests.

    The version of the OpenAPI document: v2beta3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.path_override import PathOverride
from openapi_client.models.query_override import QueryOverride
from typing import Optional, Set
from typing_extensions import Self

class UriOverride(BaseModel):
    """
    URI Override. When specified, all the HTTP tasks inside the queue will be partially or fully overridden depending on the configured values.
    """ # noqa: E501
    host: Optional[StrictStr] = Field(default=None, description="Host override. When specified, replaces the host part of the task URL. For example, if the task URL is \"https://www.google.com,\" and host value is set to \"example.net\", the overridden URI will be changed to \"https://example.net.\" Host value cannot be an empty string (INVALID_ARGUMENT).")
    path_override: Optional[PathOverride] = Field(default=None, alias="pathOverride")
    port: Optional[StrictStr] = Field(default=None, description="Port override. When specified, replaces the port part of the task URI. For instance, for a URI http://www.google.com/foo and port=123, the overridden URI becomes http://www.google.com:123/foo. Note that the port value must be a positive integer. Setting the port to 0 (Zero) clears the URI port.")
    query_override: Optional[QueryOverride] = Field(default=None, alias="queryOverride")
    scheme: Optional[StrictStr] = Field(default=None, description="Scheme override. When specified, the task URI scheme is replaced by the provided value (HTTP or HTTPS).")
    uri_override_enforce_mode: Optional[StrictStr] = Field(default=None, description="URI Override Enforce Mode When specified, determines the Target UriOverride mode. If not specified, it defaults to ALWAYS.", alias="uriOverrideEnforceMode")
    __properties: ClassVar[List[str]] = ["host", "pathOverride", "port", "queryOverride", "scheme", "uriOverrideEnforceMode"]

    @field_validator('scheme')
    def scheme_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SCHEME_UNSPECIFIED', 'HTTP', 'HTTPS']):
            raise ValueError("must be one of enum values ('SCHEME_UNSPECIFIED', 'HTTP', 'HTTPS')")
        return value

    @field_validator('uri_override_enforce_mode')
    def uri_override_enforce_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['URI_OVERRIDE_ENFORCE_MODE_UNSPECIFIED', 'IF_NOT_EXISTS', 'ALWAYS']):
            raise ValueError("must be one of enum values ('URI_OVERRIDE_ENFORCE_MODE_UNSPECIFIED', 'IF_NOT_EXISTS', 'ALWAYS')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UriOverride from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of path_override
        if self.path_override:
            _dict['pathOverride'] = self.path_override.to_dict()
        # override the default output from pydantic by calling `to_dict()` of query_override
        if self.query_override:
            _dict['queryOverride'] = self.query_override.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UriOverride from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "host": obj.get("host"),
            "pathOverride": PathOverride.from_dict(obj["pathOverride"]) if obj.get("pathOverride") is not None else None,
            "port": obj.get("port"),
            "queryOverride": QueryOverride.from_dict(obj["queryOverride"]) if obj.get("queryOverride") is not None else None,
            "scheme": obj.get("scheme"),
            "uriOverrideEnforceMode": obj.get("uriOverrideEnforceMode")
        })
        return _obj


