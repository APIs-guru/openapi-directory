# coding: utf-8

"""
    Google Play EMM API

    Manages the deployment of apps to Android Enterprise devices.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.web_app_icon import WebAppIcon
from typing import Optional, Set
from typing_extensions import Self

class WebApp(BaseModel):
    """
    A WebApps resource represents a web app created for an enterprise. Web apps are published to managed Google Play and can be distributed like other Android apps. On a user's device, a web app opens its specified URL.
    """ # noqa: E501
    display_mode: Optional[StrictStr] = Field(default=None, description="The display mode of the web app. Possible values include: - \"minimalUi\", the device's status bar, navigation bar, the app's URL, and a refresh button are visible when the app is open. For HTTP URLs, you can only select this option. - \"standalone\", the device's status bar and navigation bar are visible when the app is open. - \"fullScreen\", the app opens in full screen mode, hiding the device's status and navigation bars. All browser UI elements, page URL, system status bar and back button are not visible, and the web app takes up the entirety of the available display area. ", alias="displayMode")
    icons: Optional[List[WebAppIcon]] = Field(default=None, description="A list of icons representing this website. If absent, a default icon (for create) or the current icon (for update) will be used.")
    is_published: Optional[StrictBool] = Field(default=None, description="A flag whether the app has been published to the Play store yet.", alias="isPublished")
    start_url: Optional[StrictStr] = Field(default=None, description="The start URL, i.e. the URL that should load when the user opens the application.", alias="startUrl")
    title: Optional[StrictStr] = Field(default=None, description="The title of the web app as displayed to the user (e.g., amongst a list of other applications, or as a label for an icon).")
    version_code: Optional[StrictStr] = Field(default=None, description="The current version of the app. Note that the version can automatically increase during the lifetime of the web app, while Google does internal housekeeping to keep the web app up-to-date.", alias="versionCode")
    web_app_id: Optional[StrictStr] = Field(default=None, description="The ID of the application. A string of the form \"app:<package name>\" where the package name always starts with the prefix \"com.google.enterprise.webapp.\" followed by a random id.", alias="webAppId")
    __properties: ClassVar[List[str]] = ["displayMode", "icons", "isPublished", "startUrl", "title", "versionCode", "webAppId"]

    @field_validator('display_mode')
    def display_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['displayModeUnspecified', 'minimalUi', 'standalone', 'fullScreen']):
            raise ValueError("must be one of enum values ('displayModeUnspecified', 'minimalUi', 'standalone', 'fullScreen')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of WebApp from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in icons (list)
        _items = []
        if self.icons:
            for _item_icons in self.icons:
                if _item_icons:
                    _items.append(_item_icons.to_dict())
            _dict['icons'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of WebApp from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "displayMode": obj.get("displayMode"),
            "icons": [WebAppIcon.from_dict(_item) for _item in obj["icons"]] if obj.get("icons") is not None else None,
            "isPublished": obj.get("isPublished"),
            "startUrl": obj.get("startUrl"),
            "title": obj.get("title"),
            "versionCode": obj.get("versionCode"),
            "webAppId": obj.get("webAppId")
        })
        return _obj


