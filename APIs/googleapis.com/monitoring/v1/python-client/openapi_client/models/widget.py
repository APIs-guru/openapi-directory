# coding: utf-8

"""
    Cloud Monitoring API

    Manages your Cloud Monitoring data and configurations.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.alert_chart import AlertChart
from openapi_client.models.collapsible_group import CollapsibleGroup
from openapi_client.models.error_reporting_panel import ErrorReportingPanel
from openapi_client.models.incident_list import IncidentList
from openapi_client.models.logs_panel import LogsPanel
from openapi_client.models.pie_chart import PieChart
from openapi_client.models.scorecard import Scorecard
from openapi_client.models.section_header import SectionHeader
from openapi_client.models.text import Text
from openapi_client.models.time_series_table import TimeSeriesTable
from openapi_client.models.xy_chart import XyChart
from typing import Optional, Set
from typing_extensions import Self

class Widget(BaseModel):
    """
    Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
    """ # noqa: E501
    alert_chart: Optional[AlertChart] = Field(default=None, alias="alertChart")
    blank: Optional[Dict[str, Any]] = Field(default=None, description="A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } ")
    collapsible_group: Optional[CollapsibleGroup] = Field(default=None, alias="collapsibleGroup")
    error_reporting_panel: Optional[ErrorReportingPanel] = Field(default=None, alias="errorReportingPanel")
    id: Optional[StrictStr] = Field(default=None, description="Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.")
    incident_list: Optional[IncidentList] = Field(default=None, alias="incidentList")
    logs_panel: Optional[LogsPanel] = Field(default=None, alias="logsPanel")
    pie_chart: Optional[PieChart] = Field(default=None, alias="pieChart")
    scorecard: Optional[Scorecard] = None
    section_header: Optional[SectionHeader] = Field(default=None, alias="sectionHeader")
    single_view_group: Optional[Dict[str, Any]] = Field(default=None, description="A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets.", alias="singleViewGroup")
    text: Optional[Text] = None
    time_series_table: Optional[TimeSeriesTable] = Field(default=None, alias="timeSeriesTable")
    title: Optional[StrictStr] = Field(default=None, description="Optional. The title of the widget.")
    xy_chart: Optional[XyChart] = Field(default=None, alias="xyChart")
    __properties: ClassVar[List[str]] = ["alertChart", "blank", "collapsibleGroup", "errorReportingPanel", "id", "incidentList", "logsPanel", "pieChart", "scorecard", "sectionHeader", "singleViewGroup", "text", "timeSeriesTable", "title", "xyChart"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Widget from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of alert_chart
        if self.alert_chart:
            _dict['alertChart'] = self.alert_chart.to_dict()
        # override the default output from pydantic by calling `to_dict()` of collapsible_group
        if self.collapsible_group:
            _dict['collapsibleGroup'] = self.collapsible_group.to_dict()
        # override the default output from pydantic by calling `to_dict()` of error_reporting_panel
        if self.error_reporting_panel:
            _dict['errorReportingPanel'] = self.error_reporting_panel.to_dict()
        # override the default output from pydantic by calling `to_dict()` of incident_list
        if self.incident_list:
            _dict['incidentList'] = self.incident_list.to_dict()
        # override the default output from pydantic by calling `to_dict()` of logs_panel
        if self.logs_panel:
            _dict['logsPanel'] = self.logs_panel.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pie_chart
        if self.pie_chart:
            _dict['pieChart'] = self.pie_chart.to_dict()
        # override the default output from pydantic by calling `to_dict()` of scorecard
        if self.scorecard:
            _dict['scorecard'] = self.scorecard.to_dict()
        # override the default output from pydantic by calling `to_dict()` of section_header
        if self.section_header:
            _dict['sectionHeader'] = self.section_header.to_dict()
        # override the default output from pydantic by calling `to_dict()` of text
        if self.text:
            _dict['text'] = self.text.to_dict()
        # override the default output from pydantic by calling `to_dict()` of time_series_table
        if self.time_series_table:
            _dict['timeSeriesTable'] = self.time_series_table.to_dict()
        # override the default output from pydantic by calling `to_dict()` of xy_chart
        if self.xy_chart:
            _dict['xyChart'] = self.xy_chart.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Widget from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "alertChart": AlertChart.from_dict(obj["alertChart"]) if obj.get("alertChart") is not None else None,
            "blank": obj.get("blank"),
            "collapsibleGroup": CollapsibleGroup.from_dict(obj["collapsibleGroup"]) if obj.get("collapsibleGroup") is not None else None,
            "errorReportingPanel": ErrorReportingPanel.from_dict(obj["errorReportingPanel"]) if obj.get("errorReportingPanel") is not None else None,
            "id": obj.get("id"),
            "incidentList": IncidentList.from_dict(obj["incidentList"]) if obj.get("incidentList") is not None else None,
            "logsPanel": LogsPanel.from_dict(obj["logsPanel"]) if obj.get("logsPanel") is not None else None,
            "pieChart": PieChart.from_dict(obj["pieChart"]) if obj.get("pieChart") is not None else None,
            "scorecard": Scorecard.from_dict(obj["scorecard"]) if obj.get("scorecard") is not None else None,
            "sectionHeader": SectionHeader.from_dict(obj["sectionHeader"]) if obj.get("sectionHeader") is not None else None,
            "singleViewGroup": obj.get("singleViewGroup"),
            "text": Text.from_dict(obj["text"]) if obj.get("text") is not None else None,
            "timeSeriesTable": TimeSeriesTable.from_dict(obj["timeSeriesTable"]) if obj.get("timeSeriesTable") is not None else None,
            "title": obj.get("title"),
            "xyChart": XyChart.from_dict(obj["xyChart"]) if obj.get("xyChart") is not None else None
        })
        return _obj


