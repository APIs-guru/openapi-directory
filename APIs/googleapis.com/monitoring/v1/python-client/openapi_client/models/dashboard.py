# coding: utf-8

"""
    Cloud Monitoring API

    Manages your Cloud Monitoring data and configurations.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.column_layout import ColumnLayout
from openapi_client.models.dashboard_filter import DashboardFilter
from openapi_client.models.grid_layout import GridLayout
from openapi_client.models.mosaic_layout import MosaicLayout
from openapi_client.models.row_layout import RowLayout
from typing import Optional, Set
from typing_extensions import Self

class Dashboard(BaseModel):
    """
    A Google Stackdriver dashboard. Dashboards define the content and layout of pages in the Stackdriver web application.
    """ # noqa: E501
    column_layout: Optional[ColumnLayout] = Field(default=None, alias="columnLayout")
    dashboard_filters: Optional[List[DashboardFilter]] = Field(default=None, description="Filters to reduce the amount of data charted based on the filter criteria.", alias="dashboardFilters")
    display_name: Optional[StrictStr] = Field(default=None, description="Required. The mutable, human-readable name.", alias="displayName")
    etag: Optional[StrictStr] = Field(default=None, description="etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An etag is returned in the response to GetDashboard, and users are expected to put that etag in the request to UpdateDashboard to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation.")
    grid_layout: Optional[GridLayout] = Field(default=None, alias="gridLayout")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Labels applied to the dashboard")
    mosaic_layout: Optional[MosaicLayout] = Field(default=None, alias="mosaicLayout")
    name: Optional[StrictStr] = Field(default=None, description="Identifier. The resource name of the dashboard.")
    row_layout: Optional[RowLayout] = Field(default=None, alias="rowLayout")
    __properties: ClassVar[List[str]] = ["columnLayout", "dashboardFilters", "displayName", "etag", "gridLayout", "labels", "mosaicLayout", "name", "rowLayout"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Dashboard from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of column_layout
        if self.column_layout:
            _dict['columnLayout'] = self.column_layout.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in dashboard_filters (list)
        _items = []
        if self.dashboard_filters:
            for _item_dashboard_filters in self.dashboard_filters:
                if _item_dashboard_filters:
                    _items.append(_item_dashboard_filters.to_dict())
            _dict['dashboardFilters'] = _items
        # override the default output from pydantic by calling `to_dict()` of grid_layout
        if self.grid_layout:
            _dict['gridLayout'] = self.grid_layout.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mosaic_layout
        if self.mosaic_layout:
            _dict['mosaicLayout'] = self.mosaic_layout.to_dict()
        # override the default output from pydantic by calling `to_dict()` of row_layout
        if self.row_layout:
            _dict['rowLayout'] = self.row_layout.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Dashboard from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "columnLayout": ColumnLayout.from_dict(obj["columnLayout"]) if obj.get("columnLayout") is not None else None,
            "dashboardFilters": [DashboardFilter.from_dict(_item) for _item in obj["dashboardFilters"]] if obj.get("dashboardFilters") is not None else None,
            "displayName": obj.get("displayName"),
            "etag": obj.get("etag"),
            "gridLayout": GridLayout.from_dict(obj["gridLayout"]) if obj.get("gridLayout") is not None else None,
            "labels": obj.get("labels"),
            "mosaicLayout": MosaicLayout.from_dict(obj["mosaicLayout"]) if obj.get("mosaicLayout") is not None else None,
            "name": obj.get("name"),
            "rowLayout": RowLayout.from_dict(obj["rowLayout"]) if obj.get("rowLayout") is not None else None
        })
        return _obj


