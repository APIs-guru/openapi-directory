# coding: utf-8

"""
    Cloud Monitoring API

    Manages your Cloud Monitoring data and configurations.

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.content_matcher import ContentMatcher
from openapi_client.models.http_check import HttpCheck
from openapi_client.models.internal_checker import InternalChecker
from openapi_client.models.monitored_resource import MonitoredResource
from openapi_client.models.resource_group import ResourceGroup
from openapi_client.models.synthetic_monitor_target import SyntheticMonitorTarget
from openapi_client.models.tcp_check import TcpCheck
from typing import Optional, Set
from typing_extensions import Self

class UptimeCheckConfig(BaseModel):
    """
    This message configures which resources and services to monitor for availability.
    """ # noqa: E501
    checker_type: Optional[StrictStr] = Field(default=None, description="The type of checkers to use to execute the Uptime check.", alias="checkerType")
    content_matchers: Optional[List[ContentMatcher]] = Field(default=None, description="The content that is expected to appear in the data returned by the target server against which the check is run. Currently, only the first entry in the content_matchers list is supported, and additional entries will be ignored. This field is optional and should only be specified if a content match is required as part of the/ Uptime check.", alias="contentMatchers")
    display_name: Optional[StrictStr] = Field(default=None, description="A human-friendly name for the Uptime check configuration. The display name should be unique within a Cloud Monitoring Workspace in order to make it easier to identify; however, uniqueness is not enforced. Required.", alias="displayName")
    http_check: Optional[HttpCheck] = Field(default=None, alias="httpCheck")
    internal_checkers: Optional[List[InternalChecker]] = Field(default=None, description="The internal checkers that this check will egress from. If is_internal is true and this list is empty, the check will egress from all the InternalCheckers configured for the project that owns this UptimeCheckConfig.", alias="internalCheckers")
    is_internal: Optional[StrictBool] = Field(default=None, description="If this is true, then checks are made only from the 'internal_checkers'. If it is false, then checks are made only from the 'selected_regions'. It is an error to provide 'selected_regions' when is_internal is true, or to provide 'internal_checkers' when is_internal is false.", alias="isInternal")
    monitored_resource: Optional[MonitoredResource] = Field(default=None, alias="monitoredResource")
    name: Optional[StrictStr] = Field(default=None, description="Identifier. A unique resource name for this Uptime check configuration. The format is: projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID] [PROJECT_ID_OR_NUMBER] is the Workspace host project associated with the Uptime check.This field should be omitted when creating the Uptime check configuration; on create, the resource name is assigned by the server and included in the response.")
    period: Optional[StrictStr] = Field(default=None, description="How often, in seconds, the Uptime check is performed. Currently, the only supported values are 60s (1 minute), 300s (5 minutes), 600s (10 minutes), and 900s (15 minutes). Optional, defaults to 60s.")
    resource_group: Optional[ResourceGroup] = Field(default=None, alias="resourceGroup")
    selected_regions: Optional[List[StrictStr]] = Field(default=None, description="The list of regions from which the check will be run. Some regions contain one location, and others contain more than one. If this field is specified, enough regions must be provided to include a minimum of 3 locations. Not specifying this field will result in Uptime checks running from all available regions.", alias="selectedRegions")
    synthetic_monitor: Optional[SyntheticMonitorTarget] = Field(default=None, alias="syntheticMonitor")
    tcp_check: Optional[TcpCheck] = Field(default=None, alias="tcpCheck")
    timeout: Optional[StrictStr] = Field(default=None, description="The maximum amount of time to wait for the request to complete (must be between 1 and 60 seconds). Required.")
    user_labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="User-supplied key/value data to be used for organizing and identifying the UptimeCheckConfig objects.The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.", alias="userLabels")
    __properties: ClassVar[List[str]] = ["checkerType", "contentMatchers", "displayName", "httpCheck", "internalCheckers", "isInternal", "monitoredResource", "name", "period", "resourceGroup", "selectedRegions", "syntheticMonitor", "tcpCheck", "timeout", "userLabels"]

    @field_validator('checker_type')
    def checker_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CHECKER_TYPE_UNSPECIFIED', 'STATIC_IP_CHECKERS', 'VPC_CHECKERS']):
            raise ValueError("must be one of enum values ('CHECKER_TYPE_UNSPECIFIED', 'STATIC_IP_CHECKERS', 'VPC_CHECKERS')")
        return value

    @field_validator('selected_regions')
    def selected_regions_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['REGION_UNSPECIFIED', 'USA', 'EUROPE', 'SOUTH_AMERICA', 'ASIA_PACIFIC', 'USA_OREGON', 'USA_IOWA', 'USA_VIRGINIA']):
                raise ValueError("each list item must be one of ('REGION_UNSPECIFIED', 'USA', 'EUROPE', 'SOUTH_AMERICA', 'ASIA_PACIFIC', 'USA_OREGON', 'USA_IOWA', 'USA_VIRGINIA')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UptimeCheckConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in content_matchers (list)
        _items = []
        if self.content_matchers:
            for _item_content_matchers in self.content_matchers:
                if _item_content_matchers:
                    _items.append(_item_content_matchers.to_dict())
            _dict['contentMatchers'] = _items
        # override the default output from pydantic by calling `to_dict()` of http_check
        if self.http_check:
            _dict['httpCheck'] = self.http_check.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in internal_checkers (list)
        _items = []
        if self.internal_checkers:
            for _item_internal_checkers in self.internal_checkers:
                if _item_internal_checkers:
                    _items.append(_item_internal_checkers.to_dict())
            _dict['internalCheckers'] = _items
        # override the default output from pydantic by calling `to_dict()` of monitored_resource
        if self.monitored_resource:
            _dict['monitoredResource'] = self.monitored_resource.to_dict()
        # override the default output from pydantic by calling `to_dict()` of resource_group
        if self.resource_group:
            _dict['resourceGroup'] = self.resource_group.to_dict()
        # override the default output from pydantic by calling `to_dict()` of synthetic_monitor
        if self.synthetic_monitor:
            _dict['syntheticMonitor'] = self.synthetic_monitor.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tcp_check
        if self.tcp_check:
            _dict['tcpCheck'] = self.tcp_check.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UptimeCheckConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "checkerType": obj.get("checkerType"),
            "contentMatchers": [ContentMatcher.from_dict(_item) for _item in obj["contentMatchers"]] if obj.get("contentMatchers") is not None else None,
            "displayName": obj.get("displayName"),
            "httpCheck": HttpCheck.from_dict(obj["httpCheck"]) if obj.get("httpCheck") is not None else None,
            "internalCheckers": [InternalChecker.from_dict(_item) for _item in obj["internalCheckers"]] if obj.get("internalCheckers") is not None else None,
            "isInternal": obj.get("isInternal"),
            "monitoredResource": MonitoredResource.from_dict(obj["monitoredResource"]) if obj.get("monitoredResource") is not None else None,
            "name": obj.get("name"),
            "period": obj.get("period"),
            "resourceGroup": ResourceGroup.from_dict(obj["resourceGroup"]) if obj.get("resourceGroup") is not None else None,
            "selectedRegions": obj.get("selectedRegions"),
            "syntheticMonitor": SyntheticMonitorTarget.from_dict(obj["syntheticMonitor"]) if obj.get("syntheticMonitor") is not None else None,
            "tcpCheck": TcpCheck.from_dict(obj["tcpCheck"]) if obj.get("tcpCheck") is not None else None,
            "timeout": obj.get("timeout"),
            "userLabels": obj.get("userLabels")
        })
        return _obj


