# coding: utf-8

"""
    Cloud DNS API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1beta2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.managed_zone_cloud_logging_config import ManagedZoneCloudLoggingConfig
from openapi_client.models.managed_zone_dns_sec_config import ManagedZoneDnsSecConfig
from openapi_client.models.managed_zone_forwarding_config import ManagedZoneForwardingConfig
from openapi_client.models.managed_zone_peering_config import ManagedZonePeeringConfig
from openapi_client.models.managed_zone_private_visibility_config import ManagedZonePrivateVisibilityConfig
from openapi_client.models.managed_zone_reverse_lookup_config import ManagedZoneReverseLookupConfig
from openapi_client.models.managed_zone_service_directory_config import ManagedZoneServiceDirectoryConfig
from typing import Optional, Set
from typing_extensions import Self

class ManagedZone(BaseModel):
    """
    A zone is a subtree of the DNS namespace under one administrative responsibility. A ManagedZone is a resource that represents a DNS zone hosted by the Cloud DNS service.
    """ # noqa: E501
    cloud_logging_config: Optional[ManagedZoneCloudLoggingConfig] = Field(default=None, alias="cloudLoggingConfig")
    creation_time: Optional[StrictStr] = Field(default=None, description="The time that this resource was created on the server. This is in RFC3339 text format. Output only.", alias="creationTime")
    description: Optional[StrictStr] = Field(default=None, description="A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.")
    dns_name: Optional[StrictStr] = Field(default=None, description="The DNS name of this managed zone, for instance \"example.com.\".", alias="dnsName")
    dnssec_config: Optional[ManagedZoneDnsSecConfig] = Field(default=None, alias="dnssecConfig")
    forwarding_config: Optional[ManagedZoneForwardingConfig] = Field(default=None, alias="forwardingConfig")
    id: Optional[StrictStr] = Field(default=None, description="Unique identifier for the resource; defined by the server (output only)")
    kind: Optional[StrictStr] = 'dns#managedZone'
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="User labels.")
    name: Optional[StrictStr] = Field(default=None, description="User assigned name for this resource. Must be unique within the project. The name must be 1-63 characters long, must begin with a letter, end with a letter or digit, and only contain lowercase letters, digits or dashes.")
    name_server_set: Optional[StrictStr] = Field(default=None, description="Optionally specifies the NameServerSet for this ManagedZone. A NameServerSet is a set of DNS name servers that all host the same ManagedZones. Most users leave this field unset. If you need to use this field, contact your account team.", alias="nameServerSet")
    name_servers: Optional[List[StrictStr]] = Field(default=None, description="Delegate your managed_zone to these virtual name servers; defined by the server (output only)", alias="nameServers")
    peering_config: Optional[ManagedZonePeeringConfig] = Field(default=None, alias="peeringConfig")
    private_visibility_config: Optional[ManagedZonePrivateVisibilityConfig] = Field(default=None, alias="privateVisibilityConfig")
    reverse_lookup_config: Optional[ManagedZoneReverseLookupConfig] = Field(default=None, alias="reverseLookupConfig")
    service_directory_config: Optional[ManagedZoneServiceDirectoryConfig] = Field(default=None, alias="serviceDirectoryConfig")
    visibility: Optional[StrictStr] = Field(default=None, description="The zone's visibility: public zones are exposed to the Internet, while private zones are visible only to Virtual Private Cloud resources.")
    __properties: ClassVar[List[str]] = ["cloudLoggingConfig", "creationTime", "description", "dnsName", "dnssecConfig", "forwardingConfig", "id", "kind", "labels", "name", "nameServerSet", "nameServers", "peeringConfig", "privateVisibilityConfig", "reverseLookupConfig", "serviceDirectoryConfig", "visibility"]

    @field_validator('visibility')
    def visibility_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['public', 'private']):
            raise ValueError("must be one of enum values ('public', 'private')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ManagedZone from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of cloud_logging_config
        if self.cloud_logging_config:
            _dict['cloudLoggingConfig'] = self.cloud_logging_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dnssec_config
        if self.dnssec_config:
            _dict['dnssecConfig'] = self.dnssec_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of forwarding_config
        if self.forwarding_config:
            _dict['forwardingConfig'] = self.forwarding_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of peering_config
        if self.peering_config:
            _dict['peeringConfig'] = self.peering_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of private_visibility_config
        if self.private_visibility_config:
            _dict['privateVisibilityConfig'] = self.private_visibility_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of reverse_lookup_config
        if self.reverse_lookup_config:
            _dict['reverseLookupConfig'] = self.reverse_lookup_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of service_directory_config
        if self.service_directory_config:
            _dict['serviceDirectoryConfig'] = self.service_directory_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ManagedZone from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "cloudLoggingConfig": ManagedZoneCloudLoggingConfig.from_dict(obj["cloudLoggingConfig"]) if obj.get("cloudLoggingConfig") is not None else None,
            "creationTime": obj.get("creationTime"),
            "description": obj.get("description"),
            "dnsName": obj.get("dnsName"),
            "dnssecConfig": ManagedZoneDnsSecConfig.from_dict(obj["dnssecConfig"]) if obj.get("dnssecConfig") is not None else None,
            "forwardingConfig": ManagedZoneForwardingConfig.from_dict(obj["forwardingConfig"]) if obj.get("forwardingConfig") is not None else None,
            "id": obj.get("id"),
            "kind": obj.get("kind") if obj.get("kind") is not None else 'dns#managedZone',
            "labels": obj.get("labels"),
            "name": obj.get("name"),
            "nameServerSet": obj.get("nameServerSet"),
            "nameServers": obj.get("nameServers"),
            "peeringConfig": ManagedZonePeeringConfig.from_dict(obj["peeringConfig"]) if obj.get("peeringConfig") is not None else None,
            "privateVisibilityConfig": ManagedZonePrivateVisibilityConfig.from_dict(obj["privateVisibilityConfig"]) if obj.get("privateVisibilityConfig") is not None else None,
            "reverseLookupConfig": ManagedZoneReverseLookupConfig.from_dict(obj["reverseLookupConfig"]) if obj.get("reverseLookupConfig") is not None else None,
            "serviceDirectoryConfig": ManagedZoneServiceDirectoryConfig.from_dict(obj["serviceDirectoryConfig"]) if obj.get("serviceDirectoryConfig") is not None else None,
            "visibility": obj.get("visibility")
        })
        return _obj


