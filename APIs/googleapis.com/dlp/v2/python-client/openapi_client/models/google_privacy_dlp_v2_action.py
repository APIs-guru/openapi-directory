# coding: utf-8

"""
    Sensitive Data Protection (DLP)

    Discover and protect your sensitive data. A fully managed service designed to help you discover, classify, and protect your valuable data assets with ease.

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_privacy_dlp_v2_deidentify import GooglePrivacyDlpV2Deidentify
from openapi_client.models.google_privacy_dlp_v2_publish_to_pub_sub import GooglePrivacyDlpV2PublishToPubSub
from openapi_client.models.google_privacy_dlp_v2_save_findings import GooglePrivacyDlpV2SaveFindings
from typing import Optional, Set
from typing_extensions import Self

class GooglePrivacyDlpV2Action(BaseModel):
    """
    A task to execute on the completion of a job. See https://cloud.google.com/sensitive-data-protection/docs/concepts-actions to learn more.
    """ # noqa: E501
    deidentify: Optional[GooglePrivacyDlpV2Deidentify] = None
    job_notification_emails: Optional[Dict[str, Any]] = Field(default=None, description="Sends an email when the job completes. The email goes to IAM project owners and technical [Essential Contacts](https://cloud.google.com/resource-manager/docs/managing-notification-contacts).", alias="jobNotificationEmails")
    pub_sub: Optional[GooglePrivacyDlpV2PublishToPubSub] = Field(default=None, alias="pubSub")
    publish_findings_to_cloud_data_catalog: Optional[Dict[str, Any]] = Field(default=None, description="Publish findings of a DlpJob to Data Catalog. In Data Catalog, tag templates are applied to the resource that Cloud DLP scanned. Data Catalog tag templates are stored in the same project and region where the BigQuery table exists. For Cloud DLP to create and apply the tag template, the Cloud DLP service agent must have the `roles/datacatalog.tagTemplateOwner` permission on the project. The tag template contains fields summarizing the results of the DlpJob. Any field values previously written by another DlpJob are deleted. InfoType naming patterns are strictly enforced when using this feature. Findings are persisted in Data Catalog storage and are governed by service-specific policies for Data Catalog. For more information, see [Service Specific Terms](https://cloud.google.com/terms/service-terms). Only a single instance of this action can be specified. This action is allowed only if all resources being scanned are BigQuery tables. Compatible with: Inspect", alias="publishFindingsToCloudDataCatalog")
    publish_summary_to_cscc: Optional[Dict[str, Any]] = Field(default=None, description="Publish the result summary of a DlpJob to [Security Command Center](https://cloud.google.com/security-command-center). This action is available for only projects that belong to an organization. This action publishes the count of finding instances and their infoTypes. The summary of findings are persisted in Security Command Center and are governed by [service-specific policies for Security Command Center](https://cloud.google.com/terms/service-terms). Only a single instance of this action can be specified. Compatible with: Inspect", alias="publishSummaryToCscc")
    publish_to_stackdriver: Optional[Dict[str, Any]] = Field(default=None, description="Enable Stackdriver metric dlp.googleapis.com/finding_count. This will publish a metric to stack driver on each infotype requested and how many findings were found for it. CustomDetectors will be bucketed as 'Custom' under the Stackdriver label 'info_type'.", alias="publishToStackdriver")
    save_findings: Optional[GooglePrivacyDlpV2SaveFindings] = Field(default=None, alias="saveFindings")
    __properties: ClassVar[List[str]] = ["deidentify", "jobNotificationEmails", "pubSub", "publishFindingsToCloudDataCatalog", "publishSummaryToCscc", "publishToStackdriver", "saveFindings"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GooglePrivacyDlpV2Action from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of deidentify
        if self.deidentify:
            _dict['deidentify'] = self.deidentify.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pub_sub
        if self.pub_sub:
            _dict['pubSub'] = self.pub_sub.to_dict()
        # override the default output from pydantic by calling `to_dict()` of save_findings
        if self.save_findings:
            _dict['saveFindings'] = self.save_findings.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GooglePrivacyDlpV2Action from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "deidentify": GooglePrivacyDlpV2Deidentify.from_dict(obj["deidentify"]) if obj.get("deidentify") is not None else None,
            "jobNotificationEmails": obj.get("jobNotificationEmails"),
            "pubSub": GooglePrivacyDlpV2PublishToPubSub.from_dict(obj["pubSub"]) if obj.get("pubSub") is not None else None,
            "publishFindingsToCloudDataCatalog": obj.get("publishFindingsToCloudDataCatalog"),
            "publishSummaryToCscc": obj.get("publishSummaryToCscc"),
            "publishToStackdriver": obj.get("publishToStackdriver"),
            "saveFindings": GooglePrivacyDlpV2SaveFindings.from_dict(obj["saveFindings"]) if obj.get("saveFindings") is not None else None
        })
        return _obj


