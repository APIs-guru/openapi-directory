# coding: utf-8

"""
    API Discovery Service

    Provides information about other Google APIs, such as what APIs are available, the resource, and method details for each API.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.directory_list_items_inner_icons import DirectoryListItemsInnerIcons
from openapi_client.models.json_schema import JsonSchema
from openapi_client.models.rest_description_auth import RestDescriptionAuth
from openapi_client.models.rest_description_endpoints_inner import RestDescriptionEndpointsInner
from openapi_client.models.rest_method import RestMethod
from openapi_client.models.rest_resource import RestResource
from typing import Optional, Set
from typing_extensions import Self

class RestDescription(BaseModel):
    """
    RestDescription
    """ # noqa: E501
    auth: Optional[RestDescriptionAuth] = None
    base_path: Optional[StrictStr] = Field(default=None, description="[DEPRECATED] The base path for REST requests.", alias="basePath")
    base_url: Optional[StrictStr] = Field(default=None, description="[DEPRECATED] The base URL for REST requests.", alias="baseUrl")
    batch_path: Optional[StrictStr] = Field(default=None, description="The path for REST batch requests.", alias="batchPath")
    canonical_name: Optional[StrictStr] = Field(default=None, description="Indicates how the API name should be capitalized and split into various parts. Useful for generating pretty class names.", alias="canonicalName")
    description: Optional[StrictStr] = Field(default=None, description="The description of this API.")
    discovery_version: Optional[StrictStr] = Field(default='v1', description="Indicate the version of the Discovery API used to generate this doc.", alias="discoveryVersion")
    documentation_link: Optional[StrictStr] = Field(default=None, description="A link to human readable documentation for the API.", alias="documentationLink")
    endpoints: Optional[List[RestDescriptionEndpointsInner]] = Field(default=None, description="A list of location-based endpoint objects for this API. Each object contains the endpoint URL, location, description and deprecation status.")
    etag: Optional[StrictStr] = Field(default=None, description="The ETag for this response.")
    exponential_backoff_default: Optional[StrictBool] = Field(default=None, description="Enable exponential backoff for suitable methods in the generated clients.", alias="exponentialBackoffDefault")
    features: Optional[List[StrictStr]] = Field(default=None, description="A list of supported features for this API.")
    icons: Optional[DirectoryListItemsInnerIcons] = None
    id: Optional[StrictStr] = Field(default=None, description="The ID of this API.")
    kind: Optional[StrictStr] = Field(default='discovery#restDescription', description="The kind for this response.")
    labels: Optional[List[StrictStr]] = Field(default=None, description="Labels for the status of this API, such as labs or deprecated.")
    methods: Optional[Dict[str, RestMethod]] = Field(default=None, description="API-level methods for this API.")
    name: Optional[StrictStr] = Field(default=None, description="The name of this API.")
    owner_domain: Optional[StrictStr] = Field(default=None, description="The domain of the owner of this API. Together with the ownerName and a packagePath values, this can be used to generate a library for this API which would have a unique fully qualified name.", alias="ownerDomain")
    owner_name: Optional[StrictStr] = Field(default=None, description="The name of the owner of this API. See ownerDomain.", alias="ownerName")
    package_path: Optional[StrictStr] = Field(default=None, description="The package of the owner of this API. See ownerDomain.", alias="packagePath")
    parameters: Optional[Dict[str, JsonSchema]] = Field(default=None, description="Common parameters that apply across all apis.")
    protocol: Optional[StrictStr] = Field(default='rest', description="The protocol described by this document.")
    resources: Optional[Dict[str, RestResource]] = Field(default=None, description="The resources in this API.")
    revision: Optional[StrictStr] = Field(default=None, description="The version of this API.")
    root_url: Optional[StrictStr] = Field(default=None, description="The root URL under which all API services live.", alias="rootUrl")
    schemas: Optional[Dict[str, JsonSchema]] = Field(default=None, description="The schemas for this API.")
    service_path: Optional[StrictStr] = Field(default=None, description="The base path for all REST requests.", alias="servicePath")
    title: Optional[StrictStr] = Field(default=None, description="The title of this API.")
    version: Optional[StrictStr] = Field(default=None, description="The version of this API.")
    version_module: Optional[StrictBool] = None
    __properties: ClassVar[List[str]] = ["auth", "basePath", "baseUrl", "batchPath", "canonicalName", "description", "discoveryVersion", "documentationLink", "endpoints", "etag", "exponentialBackoffDefault", "features", "icons", "id", "kind", "labels", "methods", "name", "ownerDomain", "ownerName", "packagePath", "parameters", "protocol", "resources", "revision", "rootUrl", "schemas", "servicePath", "title", "version", "version_module"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RestDescription from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "etag",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of auth
        if self.auth:
            _dict['auth'] = self.auth.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in endpoints (list)
        _items = []
        if self.endpoints:
            for _item_endpoints in self.endpoints:
                if _item_endpoints:
                    _items.append(_item_endpoints.to_dict())
            _dict['endpoints'] = _items
        # override the default output from pydantic by calling `to_dict()` of icons
        if self.icons:
            _dict['icons'] = self.icons.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in methods (dict)
        _field_dict = {}
        if self.methods:
            for _key_methods in self.methods:
                if self.methods[_key_methods]:
                    _field_dict[_key_methods] = self.methods[_key_methods].to_dict()
            _dict['methods'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in parameters (dict)
        _field_dict = {}
        if self.parameters:
            for _key_parameters in self.parameters:
                if self.parameters[_key_parameters]:
                    _field_dict[_key_parameters] = self.parameters[_key_parameters].to_dict()
            _dict['parameters'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in resources (dict)
        _field_dict = {}
        if self.resources:
            for _key_resources in self.resources:
                if self.resources[_key_resources]:
                    _field_dict[_key_resources] = self.resources[_key_resources].to_dict()
            _dict['resources'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in schemas (dict)
        _field_dict = {}
        if self.schemas:
            for _key_schemas in self.schemas:
                if self.schemas[_key_schemas]:
                    _field_dict[_key_schemas] = self.schemas[_key_schemas].to_dict()
            _dict['schemas'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RestDescription from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": RestDescriptionAuth.from_dict(obj["auth"]) if obj.get("auth") is not None else None,
            "basePath": obj.get("basePath"),
            "baseUrl": obj.get("baseUrl"),
            "batchPath": obj.get("batchPath"),
            "canonicalName": obj.get("canonicalName"),
            "description": obj.get("description"),
            "discoveryVersion": obj.get("discoveryVersion") if obj.get("discoveryVersion") is not None else 'v1',
            "documentationLink": obj.get("documentationLink"),
            "endpoints": [RestDescriptionEndpointsInner.from_dict(_item) for _item in obj["endpoints"]] if obj.get("endpoints") is not None else None,
            "etag": obj.get("etag"),
            "exponentialBackoffDefault": obj.get("exponentialBackoffDefault"),
            "features": obj.get("features"),
            "icons": DirectoryListItemsInnerIcons.from_dict(obj["icons"]) if obj.get("icons") is not None else None,
            "id": obj.get("id"),
            "kind": obj.get("kind") if obj.get("kind") is not None else 'discovery#restDescription',
            "labels": obj.get("labels"),
            "methods": dict(
                (_k, RestMethod.from_dict(_v))
                for _k, _v in obj["methods"].items()
            )
            if obj.get("methods") is not None
            else None,
            "name": obj.get("name"),
            "ownerDomain": obj.get("ownerDomain"),
            "ownerName": obj.get("ownerName"),
            "packagePath": obj.get("packagePath"),
            "parameters": dict(
                (_k, JsonSchema.from_dict(_v))
                for _k, _v in obj["parameters"].items()
            )
            if obj.get("parameters") is not None
            else None,
            "protocol": obj.get("protocol") if obj.get("protocol") is not None else 'rest',
            "resources": dict(
                (_k, RestResource.from_dict(_v))
                for _k, _v in obj["resources"].items()
            )
            if obj.get("resources") is not None
            else None,
            "revision": obj.get("revision"),
            "rootUrl": obj.get("rootUrl"),
            "schemas": dict(
                (_k, JsonSchema.from_dict(_v))
                for _k, _v in obj["schemas"].items()
            )
            if obj.get("schemas") is not None
            else None,
            "servicePath": obj.get("servicePath"),
            "title": obj.get("title"),
            "version": obj.get("version"),
            "version_module": obj.get("version_module")
        })
        return _obj


