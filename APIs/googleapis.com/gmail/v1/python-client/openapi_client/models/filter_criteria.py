# coding: utf-8

"""
    Gmail API

    The Gmail API lets you view and manage Gmail mailbox data like threads, messages, and labels.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class FilterCriteria(BaseModel):
    """
    Message matching criteria.
    """ # noqa: E501
    exclude_chats: Optional[StrictBool] = Field(default=None, description="Whether the response should exclude chats.", alias="excludeChats")
    var_from: Optional[StrictStr] = Field(default=None, description="The sender's display name or email address.", alias="from")
    has_attachment: Optional[StrictBool] = Field(default=None, description="Whether the message has any attachment.", alias="hasAttachment")
    negated_query: Optional[StrictStr] = Field(default=None, description="Only return messages not matching the specified query. Supports the same query format as the Gmail search box. For example, `\"from:someuser@example.com rfc822msgid: is:unread\"`.", alias="negatedQuery")
    query: Optional[StrictStr] = Field(default=None, description="Only return messages matching the specified query. Supports the same query format as the Gmail search box. For example, `\"from:someuser@example.com rfc822msgid: is:unread\"`.")
    size: Optional[StrictInt] = Field(default=None, description="The size of the entire RFC822 message in bytes, including all headers and attachments.")
    size_comparison: Optional[StrictStr] = Field(default=None, description="How the message size in bytes should be in relation to the size field.", alias="sizeComparison")
    subject: Optional[StrictStr] = Field(default=None, description="Case-insensitive phrase found in the message's subject. Trailing and leading whitespace are be trimmed and adjacent spaces are collapsed.")
    to: Optional[StrictStr] = Field(default=None, description="The recipient's display name or email address. Includes recipients in the \"to\", \"cc\", and \"bcc\" header fields. You can use simply the local part of the email address. For example, \"example\" and \"example@\" both match \"example@gmail.com\". This field is case-insensitive.")
    __properties: ClassVar[List[str]] = ["excludeChats", "from", "hasAttachment", "negatedQuery", "query", "size", "sizeComparison", "subject", "to"]

    @field_validator('size_comparison')
    def size_comparison_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['unspecified', 'smaller', 'larger']):
            raise ValueError("must be one of enum values ('unspecified', 'smaller', 'larger')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FilterCriteria from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FilterCriteria from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "excludeChats": obj.get("excludeChats"),
            "from": obj.get("from"),
            "hasAttachment": obj.get("hasAttachment"),
            "negatedQuery": obj.get("negatedQuery"),
            "query": obj.get("query"),
            "size": obj.get("size"),
            "sizeComparison": obj.get("sizeComparison"),
            "subject": obj.get("subject"),
            "to": obj.get("to")
        })
        return _obj


