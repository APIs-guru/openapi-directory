# coding: utf-8

"""
    My Business Verifications API

    The My Business Verifications API provides an interface for taking verifications related actions for locations.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.service_business_context import ServiceBusinessContext
from openapi_client.models.verification_token import VerificationToken
from typing import Optional, Set
from typing_extensions import Self

class VerifyLocationRequest(BaseModel):
    """
    Request message for Verifications.VerifyLocation.
    """ # noqa: E501
    context: Optional[ServiceBusinessContext] = None
    email_address: Optional[StrictStr] = Field(default=None, description="Optional. The input for EMAIL method. Email address where the PIN should be sent to. An email address is accepted only if it is one of the addresses provided by FetchVerificationOptions. If the EmailVerificationData has is_user_name_editable set to true, the client may specify a different user name (local-part) but must match the domain name.", alias="emailAddress")
    language_code: Optional[StrictStr] = Field(default=None, description="Optional. The BCP 47 language code representing the language that is to be used for the verification process.", alias="languageCode")
    mailer_contact: Optional[StrictStr] = Field(default=None, description="Optional. The input for ADDRESS method. Contact name the mail should be sent to.", alias="mailerContact")
    method: Optional[StrictStr] = Field(default=None, description="Required. Verification method.")
    phone_number: Optional[StrictStr] = Field(default=None, description="Optional. The input for PHONE_CALL/SMS method The phone number that should be called or be sent SMS to. It must be one of the phone numbers in the eligible options.", alias="phoneNumber")
    token: Optional[VerificationToken] = None
    __properties: ClassVar[List[str]] = ["context", "emailAddress", "languageCode", "mailerContact", "method", "phoneNumber", "token"]

    @field_validator('method')
    def method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['VERIFICATION_METHOD_UNSPECIFIED', 'ADDRESS', 'EMAIL', 'PHONE_CALL', 'SMS', 'AUTO', 'VETTED_PARTNER']):
            raise ValueError("must be one of enum values ('VERIFICATION_METHOD_UNSPECIFIED', 'ADDRESS', 'EMAIL', 'PHONE_CALL', 'SMS', 'AUTO', 'VETTED_PARTNER')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VerifyLocationRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of context
        if self.context:
            _dict['context'] = self.context.to_dict()
        # override the default output from pydantic by calling `to_dict()` of token
        if self.token:
            _dict['token'] = self.token.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VerifyLocationRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "context": ServiceBusinessContext.from_dict(obj["context"]) if obj.get("context") is not None else None,
            "emailAddress": obj.get("emailAddress"),
            "languageCode": obj.get("languageCode"),
            "mailerContact": obj.get("mailerContact"),
            "method": obj.get("method"),
            "phoneNumber": obj.get("phoneNumber"),
            "token": VerificationToken.from_dict(obj["token"]) if obj.get("token") is not None else None
        })
        return _obj


