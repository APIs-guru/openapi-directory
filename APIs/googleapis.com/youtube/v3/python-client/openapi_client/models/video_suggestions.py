# coding: utf-8

"""
    YouTube Data API v3

    The YouTube Data API v3 is an API that provides access to YouTube data, such as videos, playlists, and channels.

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.video_suggestions_tag_suggestion import VideoSuggestionsTagSuggestion
from typing import Optional, Set
from typing_extensions import Self

class VideoSuggestions(BaseModel):
    """
    Specifies suggestions on how to improve video content, including encoding hints, tag suggestions, and editor suggestions.
    """ # noqa: E501
    editor_suggestions: Optional[List[StrictStr]] = Field(default=None, description="A list of video editing operations that might improve the video quality or playback experience of the uploaded video.", alias="editorSuggestions")
    processing_errors: Optional[List[StrictStr]] = Field(default=None, description="A list of errors that will prevent YouTube from successfully processing the uploaded video video. These errors indicate that, regardless of the video's current processing status, eventually, that status will almost certainly be failed.", alias="processingErrors")
    processing_hints: Optional[List[StrictStr]] = Field(default=None, description="A list of suggestions that may improve YouTube's ability to process the video.", alias="processingHints")
    processing_warnings: Optional[List[StrictStr]] = Field(default=None, description="A list of reasons why YouTube may have difficulty transcoding the uploaded video or that might result in an erroneous transcoding. These warnings are generated before YouTube actually processes the uploaded video file. In addition, they identify issues that are unlikely to cause the video processing to fail but that might cause problems such as sync issues, video artifacts, or a missing audio track.", alias="processingWarnings")
    tag_suggestions: Optional[List[VideoSuggestionsTagSuggestion]] = Field(default=None, description="A list of keyword tags that could be added to the video's metadata to increase the likelihood that users will locate your video when searching or browsing on YouTube.", alias="tagSuggestions")
    __properties: ClassVar[List[str]] = ["editorSuggestions", "processingErrors", "processingHints", "processingWarnings", "tagSuggestions"]

    @field_validator('editor_suggestions')
    def editor_suggestions_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['videoAutoLevels', 'videoStabilize', 'videoCrop', 'audioQuietAudioSwap']):
                raise ValueError("each list item must be one of ('videoAutoLevels', 'videoStabilize', 'videoCrop', 'audioQuietAudioSwap')")
        return value

    @field_validator('processing_errors')
    def processing_errors_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['audioFile', 'imageFile', 'projectFile', 'notAVideoFile', 'docFile', 'archiveFile', 'unsupportedSpatialAudioLayout']):
                raise ValueError("each list item must be one of ('audioFile', 'imageFile', 'projectFile', 'notAVideoFile', 'docFile', 'archiveFile', 'unsupportedSpatialAudioLayout')")
        return value

    @field_validator('processing_hints')
    def processing_hints_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['nonStreamableMov', 'sendBestQualityVideo', 'sphericalVideo', 'spatialAudio', 'vrVideo', 'hdrVideo']):
                raise ValueError("each list item must be one of ('nonStreamableMov', 'sendBestQualityVideo', 'sphericalVideo', 'spatialAudio', 'vrVideo', 'hdrVideo')")
        return value

    @field_validator('processing_warnings')
    def processing_warnings_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['unknownContainer', 'unknownVideoCodec', 'unknownAudioCodec', 'inconsistentResolution', 'hasEditlist', 'problematicVideoCodec', 'problematicAudioCodec', 'unsupportedVrStereoMode', 'unsupportedSphericalProjectionType', 'unsupportedHdrPixelFormat', 'unsupportedHdrColorMetadata', 'problematicHdrLookupTable']):
                raise ValueError("each list item must be one of ('unknownContainer', 'unknownVideoCodec', 'unknownAudioCodec', 'inconsistentResolution', 'hasEditlist', 'problematicVideoCodec', 'problematicAudioCodec', 'unsupportedVrStereoMode', 'unsupportedSphericalProjectionType', 'unsupportedHdrPixelFormat', 'unsupportedHdrColorMetadata', 'problematicHdrLookupTable')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VideoSuggestions from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in tag_suggestions (list)
        _items = []
        if self.tag_suggestions:
            for _item_tag_suggestions in self.tag_suggestions:
                if _item_tag_suggestions:
                    _items.append(_item_tag_suggestions.to_dict())
            _dict['tagSuggestions'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VideoSuggestions from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "editorSuggestions": obj.get("editorSuggestions"),
            "processingErrors": obj.get("processingErrors"),
            "processingHints": obj.get("processingHints"),
            "processingWarnings": obj.get("processingWarnings"),
            "tagSuggestions": [VideoSuggestionsTagSuggestion.from_dict(_item) for _item in obj["tagSuggestions"]] if obj.get("tagSuggestions") is not None else None
        })
        return _obj


