# coding: utf-8

"""
    YouTube Data API v3

    The YouTube Data API v3 is an API that provides access to YouTube data, such as videos, playlists, and channels.

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class VideoLiveStreamingDetails(BaseModel):
    """
    Details about the live streaming metadata.
    """ # noqa: E501
    active_live_chat_id: Optional[StrictStr] = Field(default=None, description="The ID of the currently active live chat attached to this video. This field is filled only if the video is a currently live broadcast that has live chat. Once the broadcast transitions to complete this field will be removed and the live chat closed down. For persistent broadcasts that live chat id will no longer be tied to this video but rather to the new video being displayed at the persistent page.", alias="activeLiveChatId")
    actual_end_time: Optional[datetime] = Field(default=None, description="The time that the broadcast actually ended. This value will not be available until the broadcast is over.", alias="actualEndTime")
    actual_start_time: Optional[datetime] = Field(default=None, description="The time that the broadcast actually started. This value will not be available until the broadcast begins.", alias="actualStartTime")
    concurrent_viewers: Optional[StrictStr] = Field(default=None, description="The number of viewers currently watching the broadcast. The property and its value will be present if the broadcast has current viewers and the broadcast owner has not hidden the viewcount for the video. Note that YouTube stops tracking the number of concurrent viewers for a broadcast when the broadcast ends. So, this property would not identify the number of viewers watching an archived video of a live broadcast that already ended.", alias="concurrentViewers")
    scheduled_end_time: Optional[datetime] = Field(default=None, description="The time that the broadcast is scheduled to end. If the value is empty or the property is not present, then the broadcast is scheduled to contiue indefinitely.", alias="scheduledEndTime")
    scheduled_start_time: Optional[datetime] = Field(default=None, description="The time that the broadcast is scheduled to begin.", alias="scheduledStartTime")
    __properties: ClassVar[List[str]] = ["activeLiveChatId", "actualEndTime", "actualStartTime", "concurrentViewers", "scheduledEndTime", "scheduledStartTime"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VideoLiveStreamingDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VideoLiveStreamingDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "activeLiveChatId": obj.get("activeLiveChatId"),
            "actualEndTime": obj.get("actualEndTime"),
            "actualStartTime": obj.get("actualStartTime"),
            "concurrentViewers": obj.get("concurrentViewers"),
            "scheduledEndTime": obj.get("scheduledEndTime"),
            "scheduledStartTime": obj.get("scheduledStartTime")
        })
        return _obj


