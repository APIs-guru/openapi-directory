# coding: utf-8

"""
    YouTube Data API v3

    The YouTube Data API v3 is an API that provides access to YouTube data, such as videos, playlists, and channels.

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.video_processing_details_processing_progress import VideoProcessingDetailsProcessingProgress
from typing import Optional, Set
from typing_extensions import Self

class VideoProcessingDetails(BaseModel):
    """
    Describes processing status and progress and availability of some other Video resource parts.
    """ # noqa: E501
    editor_suggestions_availability: Optional[StrictStr] = Field(default=None, description="This value indicates whether video editing suggestions, which might improve video quality or the playback experience, are available for the video. You can retrieve these suggestions by requesting the suggestions part in your videos.list() request.", alias="editorSuggestionsAvailability")
    file_details_availability: Optional[StrictStr] = Field(default=None, description="This value indicates whether file details are available for the uploaded video. You can retrieve a video's file details by requesting the fileDetails part in your videos.list() request.", alias="fileDetailsAvailability")
    processing_failure_reason: Optional[StrictStr] = Field(default=None, description="The reason that YouTube failed to process the video. This property will only have a value if the processingStatus property's value is failed.", alias="processingFailureReason")
    processing_issues_availability: Optional[StrictStr] = Field(default=None, description="This value indicates whether the video processing engine has generated suggestions that might improve YouTube's ability to process the the video, warnings that explain video processing problems, or errors that cause video processing problems. You can retrieve these suggestions by requesting the suggestions part in your videos.list() request.", alias="processingIssuesAvailability")
    processing_progress: Optional[VideoProcessingDetailsProcessingProgress] = Field(default=None, alias="processingProgress")
    processing_status: Optional[StrictStr] = Field(default=None, description="The video's processing status. This value indicates whether YouTube was able to process the video or if the video is still being processed.", alias="processingStatus")
    tag_suggestions_availability: Optional[StrictStr] = Field(default=None, description="This value indicates whether keyword (tag) suggestions are available for the video. Tags can be added to a video's metadata to make it easier for other users to find the video. You can retrieve these suggestions by requesting the suggestions part in your videos.list() request.", alias="tagSuggestionsAvailability")
    thumbnails_availability: Optional[StrictStr] = Field(default=None, description="This value indicates whether thumbnail images have been generated for the video.", alias="thumbnailsAvailability")
    __properties: ClassVar[List[str]] = ["editorSuggestionsAvailability", "fileDetailsAvailability", "processingFailureReason", "processingIssuesAvailability", "processingProgress", "processingStatus", "tagSuggestionsAvailability", "thumbnailsAvailability"]

    @field_validator('processing_failure_reason')
    def processing_failure_reason_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['uploadFailed', 'transcodeFailed', 'streamingFailed', 'other']):
            raise ValueError("must be one of enum values ('uploadFailed', 'transcodeFailed', 'streamingFailed', 'other')")
        return value

    @field_validator('processing_status')
    def processing_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['processing', 'succeeded', 'failed', 'terminated']):
            raise ValueError("must be one of enum values ('processing', 'succeeded', 'failed', 'terminated')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VideoProcessingDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of processing_progress
        if self.processing_progress:
            _dict['processingProgress'] = self.processing_progress.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VideoProcessingDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "editorSuggestionsAvailability": obj.get("editorSuggestionsAvailability"),
            "fileDetailsAvailability": obj.get("fileDetailsAvailability"),
            "processingFailureReason": obj.get("processingFailureReason"),
            "processingIssuesAvailability": obj.get("processingIssuesAvailability"),
            "processingProgress": VideoProcessingDetailsProcessingProgress.from_dict(obj["processingProgress"]) if obj.get("processingProgress") is not None else None,
            "processingStatus": obj.get("processingStatus"),
            "tagSuggestionsAvailability": obj.get("tagSuggestionsAvailability"),
            "thumbnailsAvailability": obj.get("thumbnailsAvailability")
        })
        return _obj


