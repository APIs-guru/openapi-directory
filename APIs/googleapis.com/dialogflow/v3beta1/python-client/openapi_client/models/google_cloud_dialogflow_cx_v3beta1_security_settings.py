# coding: utf-8

"""
    Dialogflow API

    Builds conversational interfaces (for example, chatbots, and voice-powered apps and devices).

    The version of the OpenAPI document: v3beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_dialogflow_cx_v3beta1_security_settings_audio_export_settings import GoogleCloudDialogflowCxV3beta1SecuritySettingsAudioExportSettings
from openapi_client.models.google_cloud_dialogflow_cx_v3beta1_security_settings_insights_export_settings import GoogleCloudDialogflowCxV3beta1SecuritySettingsInsightsExportSettings
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudDialogflowCxV3beta1SecuritySettings(BaseModel):
    """
    Represents the settings related to security issues, such as data redaction and data retention. It may take hours for updates on the settings to propagate to all the related components and take effect.
    """ # noqa: E501
    audio_export_settings: Optional[GoogleCloudDialogflowCxV3beta1SecuritySettingsAudioExportSettings] = Field(default=None, alias="audioExportSettings")
    deidentify_template: Optional[StrictStr] = Field(default=None, description="[DLP](https://cloud.google.com/dlp/docs) deidentify template name. Use this template to define de-identification configuration for the content. The `DLP De-identify Templates Reader` role is needed on the Dialogflow service identity service account (has the form `service-PROJECT_NUMBER@gcp-sa-dialogflow.iam.gserviceaccount.com`) for your agent's project. If empty, Dialogflow replaces sensitive info with `[redacted]` text. The template name will have one of the following formats: `projects//locations//deidentifyTemplates/` OR `organizations//locations//deidentifyTemplates/` Note: `deidentify_template` must be located in the same region as the `SecuritySettings`.", alias="deidentifyTemplate")
    display_name: Optional[StrictStr] = Field(default=None, description="Required. The human-readable name of the security settings, unique within the location.", alias="displayName")
    insights_export_settings: Optional[GoogleCloudDialogflowCxV3beta1SecuritySettingsInsightsExportSettings] = Field(default=None, alias="insightsExportSettings")
    inspect_template: Optional[StrictStr] = Field(default=None, description="[DLP](https://cloud.google.com/dlp/docs) inspect template name. Use this template to define inspect base settings. The `DLP Inspect Templates Reader` role is needed on the Dialogflow service identity service account (has the form `service-PROJECT_NUMBER@gcp-sa-dialogflow.iam.gserviceaccount.com`) for your agent's project. If empty, we use the default DLP inspect config. The template name will have one of the following formats: `projects//locations//inspectTemplates/` OR `organizations//locations//inspectTemplates/` Note: `inspect_template` must be located in the same region as the `SecuritySettings`.", alias="inspectTemplate")
    name: Optional[StrictStr] = Field(default=None, description="Resource name of the settings. Required for the SecuritySettingsService.UpdateSecuritySettings method. SecuritySettingsService.CreateSecuritySettings populates the name automatically. Format: `projects//locations//securitySettings/`.")
    purge_data_types: Optional[List[StrictStr]] = Field(default=None, description="List of types of data to remove when retention settings triggers purge.", alias="purgeDataTypes")
    redaction_scope: Optional[StrictStr] = Field(default=None, description="Defines the data for which Dialogflow applies redaction. Dialogflow does not redact data that it does not have access to â€“ for example, Cloud logging.", alias="redactionScope")
    redaction_strategy: Optional[StrictStr] = Field(default=None, description="Strategy that defines how we do redaction.", alias="redactionStrategy")
    retention_strategy: Optional[StrictStr] = Field(default=None, description="Specifies the retention behavior defined by SecuritySettings.RetentionStrategy.", alias="retentionStrategy")
    retention_window_days: Optional[StrictInt] = Field(default=None, description="Retains data in interaction logging for the specified number of days. This does not apply to Cloud logging, which is owned by the user - not Dialogflow. User must set a value lower than Dialogflow's default 365d TTL (30 days for Agent Assist traffic), higher value will be ignored and use default. Setting a value higher than that has no effect. A missing value or setting to 0 also means we use default TTL.", alias="retentionWindowDays")
    __properties: ClassVar[List[str]] = ["audioExportSettings", "deidentifyTemplate", "displayName", "insightsExportSettings", "inspectTemplate", "name", "purgeDataTypes", "redactionScope", "redactionStrategy", "retentionStrategy", "retentionWindowDays"]

    @field_validator('purge_data_types')
    def purge_data_types_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['PURGE_DATA_TYPE_UNSPECIFIED', 'DIALOGFLOW_HISTORY']):
                raise ValueError("each list item must be one of ('PURGE_DATA_TYPE_UNSPECIFIED', 'DIALOGFLOW_HISTORY')")
        return value

    @field_validator('redaction_scope')
    def redaction_scope_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['REDACTION_SCOPE_UNSPECIFIED', 'REDACT_DISK_STORAGE']):
            raise ValueError("must be one of enum values ('REDACTION_SCOPE_UNSPECIFIED', 'REDACT_DISK_STORAGE')")
        return value

    @field_validator('redaction_strategy')
    def redaction_strategy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['REDACTION_STRATEGY_UNSPECIFIED', 'REDACT_WITH_SERVICE']):
            raise ValueError("must be one of enum values ('REDACTION_STRATEGY_UNSPECIFIED', 'REDACT_WITH_SERVICE')")
        return value

    @field_validator('retention_strategy')
    def retention_strategy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['RETENTION_STRATEGY_UNSPECIFIED', 'REMOVE_AFTER_CONVERSATION']):
            raise ValueError("must be one of enum values ('RETENTION_STRATEGY_UNSPECIFIED', 'REMOVE_AFTER_CONVERSATION')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudDialogflowCxV3beta1SecuritySettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of audio_export_settings
        if self.audio_export_settings:
            _dict['audioExportSettings'] = self.audio_export_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of insights_export_settings
        if self.insights_export_settings:
            _dict['insightsExportSettings'] = self.insights_export_settings.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudDialogflowCxV3beta1SecuritySettings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "audioExportSettings": GoogleCloudDialogflowCxV3beta1SecuritySettingsAudioExportSettings.from_dict(obj["audioExportSettings"]) if obj.get("audioExportSettings") is not None else None,
            "deidentifyTemplate": obj.get("deidentifyTemplate"),
            "displayName": obj.get("displayName"),
            "insightsExportSettings": GoogleCloudDialogflowCxV3beta1SecuritySettingsInsightsExportSettings.from_dict(obj["insightsExportSettings"]) if obj.get("insightsExportSettings") is not None else None,
            "inspectTemplate": obj.get("inspectTemplate"),
            "name": obj.get("name"),
            "purgeDataTypes": obj.get("purgeDataTypes"),
            "redactionScope": obj.get("redactionScope"),
            "redactionStrategy": obj.get("redactionStrategy"),
            "retentionStrategy": obj.get("retentionStrategy"),
            "retentionWindowDays": obj.get("retentionWindowDays")
        })
        return _obj


