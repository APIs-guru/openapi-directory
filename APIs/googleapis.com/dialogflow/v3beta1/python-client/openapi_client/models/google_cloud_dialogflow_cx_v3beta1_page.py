# coding: utf-8

"""
    Dialogflow API

    Builds conversational interfaces (for example, chatbots, and voice-powered apps and devices).

    The version of the OpenAPI document: v3beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_dialogflow_cx_v3beta1_advanced_settings import GoogleCloudDialogflowCxV3beta1AdvancedSettings
from openapi_client.models.google_cloud_dialogflow_cx_v3beta1_event_handler import GoogleCloudDialogflowCxV3beta1EventHandler
from openapi_client.models.google_cloud_dialogflow_cx_v3beta1_form import GoogleCloudDialogflowCxV3beta1Form
from openapi_client.models.google_cloud_dialogflow_cx_v3beta1_fulfillment import GoogleCloudDialogflowCxV3beta1Fulfillment
from openapi_client.models.google_cloud_dialogflow_cx_v3beta1_knowledge_connector_settings import GoogleCloudDialogflowCxV3beta1KnowledgeConnectorSettings
from openapi_client.models.google_cloud_dialogflow_cx_v3beta1_transition_route import GoogleCloudDialogflowCxV3beta1TransitionRoute
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudDialogflowCxV3beta1Page(BaseModel):
    """
    A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page).
    """ # noqa: E501
    advanced_settings: Optional[GoogleCloudDialogflowCxV3beta1AdvancedSettings] = Field(default=None, alias="advancedSettings")
    description: Optional[StrictStr] = Field(default=None, description="The description of the page. The maximum length is 500 characters.")
    display_name: Optional[StrictStr] = Field(default=None, description="Required. The human-readable name of the page, unique within the flow.", alias="displayName")
    entry_fulfillment: Optional[GoogleCloudDialogflowCxV3beta1Fulfillment] = Field(default=None, alias="entryFulfillment")
    event_handlers: Optional[List[GoogleCloudDialogflowCxV3beta1EventHandler]] = Field(default=None, description="Handlers associated with the page to handle events such as webhook errors, no match or no input.", alias="eventHandlers")
    form: Optional[GoogleCloudDialogflowCxV3beta1Form] = None
    knowledge_connector_settings: Optional[GoogleCloudDialogflowCxV3beta1KnowledgeConnectorSettings] = Field(default=None, alias="knowledgeConnectorSettings")
    name: Optional[StrictStr] = Field(default=None, description="The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.")
    transition_route_groups: Optional[List[StrictStr]] = Field(default=None, description="Ordered list of `TransitionRouteGroups` added to the page. Transition route groups must be unique within a page. If the page links both flow-level transition route groups and agent-level transition route groups, the flow-level ones will have higher priority and will be put before the agent-level ones. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page's transition route -> page's transition route group -> flow's transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/` or `projects//locations//agents//transitionRouteGroups/` for agent-level groups.", alias="transitionRouteGroups")
    transition_routes: Optional[List[GoogleCloudDialogflowCxV3beta1TransitionRoute]] = Field(default=None, description="A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.", alias="transitionRoutes")
    __properties: ClassVar[List[str]] = ["advancedSettings", "description", "displayName", "entryFulfillment", "eventHandlers", "form", "knowledgeConnectorSettings", "name", "transitionRouteGroups", "transitionRoutes"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudDialogflowCxV3beta1Page from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of advanced_settings
        if self.advanced_settings:
            _dict['advancedSettings'] = self.advanced_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of entry_fulfillment
        if self.entry_fulfillment:
            _dict['entryFulfillment'] = self.entry_fulfillment.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in event_handlers (list)
        _items = []
        if self.event_handlers:
            for _item_event_handlers in self.event_handlers:
                if _item_event_handlers:
                    _items.append(_item_event_handlers.to_dict())
            _dict['eventHandlers'] = _items
        # override the default output from pydantic by calling `to_dict()` of form
        if self.form:
            _dict['form'] = self.form.to_dict()
        # override the default output from pydantic by calling `to_dict()` of knowledge_connector_settings
        if self.knowledge_connector_settings:
            _dict['knowledgeConnectorSettings'] = self.knowledge_connector_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in transition_routes (list)
        _items = []
        if self.transition_routes:
            for _item_transition_routes in self.transition_routes:
                if _item_transition_routes:
                    _items.append(_item_transition_routes.to_dict())
            _dict['transitionRoutes'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudDialogflowCxV3beta1Page from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "advancedSettings": GoogleCloudDialogflowCxV3beta1AdvancedSettings.from_dict(obj["advancedSettings"]) if obj.get("advancedSettings") is not None else None,
            "description": obj.get("description"),
            "displayName": obj.get("displayName"),
            "entryFulfillment": GoogleCloudDialogflowCxV3beta1Fulfillment.from_dict(obj["entryFulfillment"]) if obj.get("entryFulfillment") is not None else None,
            "eventHandlers": [GoogleCloudDialogflowCxV3beta1EventHandler.from_dict(_item) for _item in obj["eventHandlers"]] if obj.get("eventHandlers") is not None else None,
            "form": GoogleCloudDialogflowCxV3beta1Form.from_dict(obj["form"]) if obj.get("form") is not None else None,
            "knowledgeConnectorSettings": GoogleCloudDialogflowCxV3beta1KnowledgeConnectorSettings.from_dict(obj["knowledgeConnectorSettings"]) if obj.get("knowledgeConnectorSettings") is not None else None,
            "name": obj.get("name"),
            "transitionRouteGroups": obj.get("transitionRouteGroups"),
            "transitionRoutes": [GoogleCloudDialogflowCxV3beta1TransitionRoute.from_dict(_item) for _item in obj["transitionRoutes"]] if obj.get("transitionRoutes") is not None else None
        })
        return _obj


