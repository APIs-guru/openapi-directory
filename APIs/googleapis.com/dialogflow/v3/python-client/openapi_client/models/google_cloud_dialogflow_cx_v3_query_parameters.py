# coding: utf-8

"""
    Dialogflow API

    Builds conversational interfaces (for example, chatbots, and voice-powered apps and devices).

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_dialogflow_cx_v3_search_config import GoogleCloudDialogflowCxV3SearchConfig
from openapi_client.models.google_cloud_dialogflow_cx_v3_session_entity_type import GoogleCloudDialogflowCxV3SessionEntityType
from openapi_client.models.google_type_lat_lng import GoogleTypeLatLng
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudDialogflowCxV3QueryParameters(BaseModel):
    """
    Represents the parameters of a conversational query.
    """ # noqa: E501
    analyze_query_text_sentiment: Optional[StrictBool] = Field(default=None, description="Configures whether sentiment analysis should be performed. If not provided, sentiment analysis is not performed.", alias="analyzeQueryTextSentiment")
    channel: Optional[StrictStr] = Field(default=None, description="The channel which this query is for. If specified, only the ResponseMessage associated with the channel will be returned. If no ResponseMessage is associated with the channel, it falls back to the ResponseMessage with unspecified channel. If unspecified, the ResponseMessage with unspecified channel will be returned.")
    current_page: Optional[StrictStr] = Field(default=None, description="The unique identifier of the page to override the current page in the session. Format: `projects//locations//agents//flows//pages/`. If `current_page` is specified, the previous state of the session will be ignored by Dialogflow, including the previous page and the previous session parameters. In most cases, current_page and parameters should be configured together to direct a session to a specific state.", alias="currentPage")
    disable_webhook: Optional[StrictBool] = Field(default=None, description="Whether to disable webhook calls for this request.", alias="disableWebhook")
    end_user_metadata: Optional[Dict[str, Any]] = Field(default=None, description="Optional. Information about the end-user to improve the relevance and accuracy of generative answers. This will be interpreted and used by a language model, so, for good results, the data should be self-descriptive, and in a simple structure. Example: ```json { \"subscription plan\": \"Business Premium Plus\", \"devices owned\": [ {\"model\": \"Google Pixel 7\"}, {\"model\": \"Google Pixel Tablet\"} ] } ```", alias="endUserMetadata")
    flow_versions: Optional[List[StrictStr]] = Field(default=None, description="A list of flow versions to override for the request. Format: `projects//locations//agents//flows//versions/`. If version 1 of flow X is included in this list, the traffic of flow X will go through version 1 regardless of the version configuration in the environment. Each flow can have at most one version specified in this list.", alias="flowVersions")
    geo_location: Optional[GoogleTypeLatLng] = Field(default=None, alias="geoLocation")
    parameters: Optional[Dict[str, Any]] = Field(default=None, description="Additional parameters to be put into session parameters. To remove a parameter from the session, clients should explicitly set the parameter value to null. You can reference the session parameters in the agent with the following format: $session.params.parameter-id. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter's entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter's entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.")
    payload: Optional[Dict[str, Any]] = Field(default=None, description="This field can be used to pass custom data into the webhook associated with the agent. Arbitrary JSON objects are supported. Some integrations that query a Dialogflow agent may provide additional information in the payload. In particular, for the Dialogflow Phone Gateway integration, this field has the form: ``` { \"telephony\": { \"caller_id\": \"+18558363987\" } } ```")
    search_config: Optional[GoogleCloudDialogflowCxV3SearchConfig] = Field(default=None, alias="searchConfig")
    session_entity_types: Optional[List[GoogleCloudDialogflowCxV3SessionEntityType]] = Field(default=None, description="Additional session entity types to replace or extend developer entity types with. The entity synonyms apply to all languages and persist for the session of this query.", alias="sessionEntityTypes")
    session_ttl: Optional[StrictStr] = Field(default=None, description="Optional. Configure lifetime of the Dialogflow session. By default, a Dialogflow session remains active and its data is stored for 30 minutes after the last request is sent for the session. This value should be no longer than 1 day.", alias="sessionTtl")
    time_zone: Optional[StrictStr] = Field(default=None, description="The time zone of this conversational query from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris. If not provided, the time zone specified in the agent is used.", alias="timeZone")
    webhook_headers: Optional[Dict[str, StrictStr]] = Field(default=None, description="This field can be used to pass HTTP headers for a webhook call. These headers will be sent to webhook along with the headers that have been configured through Dialogflow web console. The headers defined within this field will overwrite the headers configured through Dialogflow console if there is a conflict. Header names are case-insensitive. Google's specified headers are not allowed. Including: \"Host\", \"Content-Length\", \"Connection\", \"From\", \"User-Agent\", \"Accept-Encoding\", \"If-Modified-Since\", \"If-None-Match\", \"X-Forwarded-For\", etc.", alias="webhookHeaders")
    __properties: ClassVar[List[str]] = ["analyzeQueryTextSentiment", "channel", "currentPage", "disableWebhook", "endUserMetadata", "flowVersions", "geoLocation", "parameters", "payload", "searchConfig", "sessionEntityTypes", "sessionTtl", "timeZone", "webhookHeaders"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudDialogflowCxV3QueryParameters from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of geo_location
        if self.geo_location:
            _dict['geoLocation'] = self.geo_location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of search_config
        if self.search_config:
            _dict['searchConfig'] = self.search_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in session_entity_types (list)
        _items = []
        if self.session_entity_types:
            for _item_session_entity_types in self.session_entity_types:
                if _item_session_entity_types:
                    _items.append(_item_session_entity_types.to_dict())
            _dict['sessionEntityTypes'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudDialogflowCxV3QueryParameters from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "analyzeQueryTextSentiment": obj.get("analyzeQueryTextSentiment"),
            "channel": obj.get("channel"),
            "currentPage": obj.get("currentPage"),
            "disableWebhook": obj.get("disableWebhook"),
            "endUserMetadata": obj.get("endUserMetadata"),
            "flowVersions": obj.get("flowVersions"),
            "geoLocation": GoogleTypeLatLng.from_dict(obj["geoLocation"]) if obj.get("geoLocation") is not None else None,
            "parameters": obj.get("parameters"),
            "payload": obj.get("payload"),
            "searchConfig": GoogleCloudDialogflowCxV3SearchConfig.from_dict(obj["searchConfig"]) if obj.get("searchConfig") is not None else None,
            "sessionEntityTypes": [GoogleCloudDialogflowCxV3SessionEntityType.from_dict(_item) for _item in obj["sessionEntityTypes"]] if obj.get("sessionEntityTypes") is not None else None,
            "sessionTtl": obj.get("sessionTtl"),
            "timeZone": obj.get("timeZone"),
            "webhookHeaders": obj.get("webhookHeaders")
        })
        return _obj


