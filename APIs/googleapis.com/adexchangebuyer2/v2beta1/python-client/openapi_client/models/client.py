# coding: utf-8

"""
    Ad Exchange Buyer API II

    Accesses the latest features for managing Authorized Buyers accounts, Real-Time Bidding configurations and auction metrics, and Marketplace programmatic deals.

    The version of the OpenAPI document: v2beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class Client(BaseModel):
    """
    A client resource represents a client buyerâ€”an agency, a brand, or an advertiser customer of the sponsor buyer. Users associated with the client buyer have restricted access to the Marketplace and certain other sections of the Authorized Buyers UI based on the role granted to the client buyer. All fields are required unless otherwise specified.
    """ # noqa: E501
    client_account_id: Optional[StrictStr] = Field(default=None, description="The globally-unique numerical ID of the client. The value of this field is ignored in create and update operations.", alias="clientAccountId")
    client_name: Optional[StrictStr] = Field(default=None, description="Name used to represent this client to publishers. You may have multiple clients that map to the same entity, but for each client the combination of `clientName` and entity must be unique. You can specify this field as empty. Maximum length of 255 characters is allowed.", alias="clientName")
    entity_id: Optional[StrictStr] = Field(default=None, description="Numerical identifier of the client entity. The entity can be an advertiser, a brand, or an agency. This identifier is unique among all the entities with the same type. The value of this field is ignored if the entity type is not provided. A list of all known advertisers with their identifiers is available in the [advertisers.txt](https://storage.googleapis.com/adx-rtb-dictionaries/advertisers.txt) file. A list of all known brands with their identifiers is available in the [brands.txt](https://storage.googleapis.com/adx-rtb-dictionaries/brands.txt) file. A list of all known agencies with their identifiers is available in the [agencies.txt](https://storage.googleapis.com/adx-rtb-dictionaries/agencies.txt) file.", alias="entityId")
    entity_name: Optional[StrictStr] = Field(default=None, description="The name of the entity. This field is automatically fetched based on the type and ID. The value of this field is ignored in create and update operations.", alias="entityName")
    entity_type: Optional[StrictStr] = Field(default=None, description="An optional field for specifying the type of the client entity: `ADVERTISER`, `BRAND`, or `AGENCY`.", alias="entityType")
    partner_client_id: Optional[StrictStr] = Field(default=None, description="Optional arbitrary unique identifier of this client buyer from the standpoint of its Ad Exchange sponsor buyer. This field can be used to associate a client buyer with the identifier in the namespace of its sponsor buyer, lookup client buyers by that identifier and verify whether an Ad Exchange counterpart of a given client buyer already exists. If present, must be unique among all the client buyers for its Ad Exchange sponsor buyer.", alias="partnerClientId")
    role: Optional[StrictStr] = Field(default=None, description="The role which is assigned to the client buyer. Each role implies a set of permissions granted to the client. Must be one of `CLIENT_DEAL_VIEWER`, `CLIENT_DEAL_NEGOTIATOR` or `CLIENT_DEAL_APPROVER`.")
    status: Optional[StrictStr] = Field(default=None, description="The status of the client buyer.")
    visible_to_seller: Optional[StrictBool] = Field(default=None, description="Whether the client buyer will be visible to sellers.", alias="visibleToSeller")
    __properties: ClassVar[List[str]] = ["clientAccountId", "clientName", "entityId", "entityName", "entityType", "partnerClientId", "role", "status", "visibleToSeller"]

    @field_validator('entity_type')
    def entity_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ENTITY_TYPE_UNSPECIFIED', 'ADVERTISER', 'BRAND', 'AGENCY', 'ENTITY_TYPE_UNCLASSIFIED']):
            raise ValueError("must be one of enum values ('ENTITY_TYPE_UNSPECIFIED', 'ADVERTISER', 'BRAND', 'AGENCY', 'ENTITY_TYPE_UNCLASSIFIED')")
        return value

    @field_validator('role')
    def role_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CLIENT_ROLE_UNSPECIFIED', 'CLIENT_DEAL_VIEWER', 'CLIENT_DEAL_NEGOTIATOR', 'CLIENT_DEAL_APPROVER']):
            raise ValueError("must be one of enum values ('CLIENT_ROLE_UNSPECIFIED', 'CLIENT_DEAL_VIEWER', 'CLIENT_DEAL_NEGOTIATOR', 'CLIENT_DEAL_APPROVER')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CLIENT_STATUS_UNSPECIFIED', 'DISABLED', 'ACTIVE']):
            raise ValueError("must be one of enum values ('CLIENT_STATUS_UNSPECIFIED', 'DISABLED', 'ACTIVE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Client from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Client from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "clientAccountId": obj.get("clientAccountId"),
            "clientName": obj.get("clientName"),
            "entityId": obj.get("entityId"),
            "entityName": obj.get("entityName"),
            "entityType": obj.get("entityType"),
            "partnerClientId": obj.get("partnerClientId"),
            "role": obj.get("role"),
            "status": obj.get("status"),
            "visibleToSeller": obj.get("visibleToSeller")
        })
        return _obj


