# coding: utf-8

"""
    Cloud Tool Results API

    API to publish and access results from developer tools.

    The version of the OpenAPI document: v1beta3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.outcome import Outcome
from openapi_client.models.test_suite_overview import TestSuiteOverview
from typing import Optional, Set
from typing_extensions import Self

class MergedResult(BaseModel):
    """
    Merged test result for environment. If the environment has only one step (no reruns or shards), then the merged result is the same as the step result. If the environment has multiple shards and/or reruns, then the results of shards and reruns that belong to the same environment are merged into one environment result.
    """ # noqa: E501
    outcome: Optional[Outcome] = None
    state: Optional[StrictStr] = Field(default=None, description="State of the resource")
    test_suite_overviews: Optional[List[TestSuiteOverview]] = Field(default=None, description="The combined and rolled-up result of each test suite that was run as part of this environment. Combining: When the test cases from a suite are run in different steps (sharding), the results are added back together in one overview. (e.g., if shard1 has 2 failures and shard2 has 1 failure than the overview failure_count = 3). Rollup: When test cases from the same suite are run multiple times (flaky), the results are combined (e.g., if testcase1.run1 fails, testcase1.run2 passes, and both testcase2.run1 and testcase2.run2 fail then the overview flaky_count = 1 and failure_count = 1).", alias="testSuiteOverviews")
    __properties: ClassVar[List[str]] = ["outcome", "state", "testSuiteOverviews"]

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['unknownState', 'pending', 'inProgress', 'complete']):
            raise ValueError("must be one of enum values ('unknownState', 'pending', 'inProgress', 'complete')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MergedResult from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of outcome
        if self.outcome:
            _dict['outcome'] = self.outcome.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in test_suite_overviews (list)
        _items = []
        if self.test_suite_overviews:
            for _item_test_suite_overviews in self.test_suite_overviews:
                if _item_test_suite_overviews:
                    _items.append(_item_test_suite_overviews.to_dict())
            _dict['testSuiteOverviews'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MergedResult from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "outcome": Outcome.from_dict(obj["outcome"]) if obj.get("outcome") is not None else None,
            "state": obj.get("state"),
            "testSuiteOverviews": [TestSuiteOverview.from_dict(_item) for _item in obj["testSuiteOverviews"]] if obj.get("testSuiteOverviews") is not None else None
        })
        return _obj


