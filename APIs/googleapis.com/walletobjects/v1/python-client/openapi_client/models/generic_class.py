# coding: utf-8

"""
    Google Wallet API

    API for issuers to save and manage Google Wallet Objects.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.callback_options import CallbackOptions
from openapi_client.models.class_template_info import ClassTemplateInfo
from openapi_client.models.image_module_data import ImageModuleData
from openapi_client.models.links_module_data import LinksModuleData
from openapi_client.models.message import Message
from openapi_client.models.security_animation import SecurityAnimation
from openapi_client.models.text_module_data import TextModuleData
from typing import Optional, Set
from typing_extensions import Self

class GenericClass(BaseModel):
    """
    Generic Class
    """ # noqa: E501
    callback_options: Optional[CallbackOptions] = Field(default=None, alias="callbackOptions")
    class_template_info: Optional[ClassTemplateInfo] = Field(default=None, alias="classTemplateInfo")
    enable_smart_tap: Optional[StrictBool] = Field(default=None, description="Available only to Smart Tap enabled partners. Contact support for additional guidance.", alias="enableSmartTap")
    id: Optional[StrictStr] = Field(default=None, description="Required. The unique identifier for the class. This ID must be unique across all from an issuer. This value needs to follow the format `issuerID.identifier` where `issuerID` is issued by Google and `identifier` is chosen by you. The unique identifier can only include alphanumeric characters, `.`, `_`, or `-`.")
    image_modules_data: Optional[List[ImageModuleData]] = Field(default=None, description="Image module data. If `imageModulesData` is also defined on the object, both will be displayed. Only one of the image from class and one from object level will be rendered when both set.", alias="imageModulesData")
    links_module_data: Optional[LinksModuleData] = Field(default=None, alias="linksModuleData")
    messages: Optional[List[Message]] = Field(default=None, description="An array of messages displayed in the app. All users of this object will receive its associated messages. The maximum number of these fields is 10.")
    multiple_devices_and_holders_allowed_status: Optional[StrictStr] = Field(default=None, description="Identifies whether multiple users and devices will save the same object referencing this class.", alias="multipleDevicesAndHoldersAllowedStatus")
    redemption_issuers: Optional[List[StrictStr]] = Field(default=None, description="Identifies which redemption issuers can redeem the pass over Smart Tap. Redemption issuers are identified by their issuer ID. Redemption issuers must have at least one Smart Tap key configured. The `enableSmartTap` and object level `smartTapRedemptionLevel` fields must also be set up correctly in order for a pass to support Smart Tap.", alias="redemptionIssuers")
    security_animation: Optional[SecurityAnimation] = Field(default=None, alias="securityAnimation")
    text_modules_data: Optional[List[TextModuleData]] = Field(default=None, description="Text module data. If `textModulesData` is also defined on the object, both will be displayed. The maximum number of these fields displayed is 10 from class and 10 from object.", alias="textModulesData")
    view_unlock_requirement: Optional[StrictStr] = Field(default=None, description="View Unlock Requirement options for the generic pass.", alias="viewUnlockRequirement")
    __properties: ClassVar[List[str]] = ["callbackOptions", "classTemplateInfo", "enableSmartTap", "id", "imageModulesData", "linksModuleData", "messages", "multipleDevicesAndHoldersAllowedStatus", "redemptionIssuers", "securityAnimation", "textModulesData", "viewUnlockRequirement"]

    @field_validator('multiple_devices_and_holders_allowed_status')
    def multiple_devices_and_holders_allowed_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATUS_UNSPECIFIED', 'MULTIPLE_HOLDERS', 'ONE_USER_ALL_DEVICES', 'ONE_USER_ONE_DEVICE', 'multipleHolders', 'oneUserAllDevices', 'oneUserOneDevice']):
            raise ValueError("must be one of enum values ('STATUS_UNSPECIFIED', 'MULTIPLE_HOLDERS', 'ONE_USER_ALL_DEVICES', 'ONE_USER_ONE_DEVICE', 'multipleHolders', 'oneUserAllDevices', 'oneUserOneDevice')")
        return value

    @field_validator('view_unlock_requirement')
    def view_unlock_requirement_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['VIEW_UNLOCK_REQUIREMENT_UNSPECIFIED', 'UNLOCK_NOT_REQUIRED', 'UNLOCK_REQUIRED_TO_VIEW']):
            raise ValueError("must be one of enum values ('VIEW_UNLOCK_REQUIREMENT_UNSPECIFIED', 'UNLOCK_NOT_REQUIRED', 'UNLOCK_REQUIRED_TO_VIEW')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GenericClass from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of callback_options
        if self.callback_options:
            _dict['callbackOptions'] = self.callback_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of class_template_info
        if self.class_template_info:
            _dict['classTemplateInfo'] = self.class_template_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in image_modules_data (list)
        _items = []
        if self.image_modules_data:
            for _item_image_modules_data in self.image_modules_data:
                if _item_image_modules_data:
                    _items.append(_item_image_modules_data.to_dict())
            _dict['imageModulesData'] = _items
        # override the default output from pydantic by calling `to_dict()` of links_module_data
        if self.links_module_data:
            _dict['linksModuleData'] = self.links_module_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in messages (list)
        _items = []
        if self.messages:
            for _item_messages in self.messages:
                if _item_messages:
                    _items.append(_item_messages.to_dict())
            _dict['messages'] = _items
        # override the default output from pydantic by calling `to_dict()` of security_animation
        if self.security_animation:
            _dict['securityAnimation'] = self.security_animation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in text_modules_data (list)
        _items = []
        if self.text_modules_data:
            for _item_text_modules_data in self.text_modules_data:
                if _item_text_modules_data:
                    _items.append(_item_text_modules_data.to_dict())
            _dict['textModulesData'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GenericClass from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "callbackOptions": CallbackOptions.from_dict(obj["callbackOptions"]) if obj.get("callbackOptions") is not None else None,
            "classTemplateInfo": ClassTemplateInfo.from_dict(obj["classTemplateInfo"]) if obj.get("classTemplateInfo") is not None else None,
            "enableSmartTap": obj.get("enableSmartTap"),
            "id": obj.get("id"),
            "imageModulesData": [ImageModuleData.from_dict(_item) for _item in obj["imageModulesData"]] if obj.get("imageModulesData") is not None else None,
            "linksModuleData": LinksModuleData.from_dict(obj["linksModuleData"]) if obj.get("linksModuleData") is not None else None,
            "messages": [Message.from_dict(_item) for _item in obj["messages"]] if obj.get("messages") is not None else None,
            "multipleDevicesAndHoldersAllowedStatus": obj.get("multipleDevicesAndHoldersAllowedStatus"),
            "redemptionIssuers": obj.get("redemptionIssuers"),
            "securityAnimation": SecurityAnimation.from_dict(obj["securityAnimation"]) if obj.get("securityAnimation") is not None else None,
            "textModulesData": [TextModuleData.from_dict(_item) for _item in obj["textModulesData"]] if obj.get("textModulesData") is not None else None,
            "viewUnlockRequirement": obj.get("viewUnlockRequirement")
        })
        return _obj


