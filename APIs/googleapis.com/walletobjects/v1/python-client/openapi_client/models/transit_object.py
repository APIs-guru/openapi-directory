# coding: utf-8

"""
    Google Wallet API

    API for issuers to save and manage Google Wallet Objects.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.activation_status import ActivationStatus
from openapi_client.models.app_link_data import AppLinkData
from openapi_client.models.barcode import Barcode
from openapi_client.models.device_context import DeviceContext
from openapi_client.models.grouping_info import GroupingInfo
from openapi_client.models.image import Image
from openapi_client.models.image_module_data import ImageModuleData
from openapi_client.models.info_module_data import InfoModuleData
from openapi_client.models.lat_long_point import LatLongPoint
from openapi_client.models.links_module_data import LinksModuleData
from openapi_client.models.localized_string import LocalizedString
from openapi_client.models.message import Message
from openapi_client.models.pass_constraints import PassConstraints
from openapi_client.models.purchase_details import PurchaseDetails
from openapi_client.models.rotating_barcode import RotatingBarcode
from openapi_client.models.text_module_data import TextModuleData
from openapi_client.models.ticket_leg import TicketLeg
from openapi_client.models.ticket_restrictions import TicketRestrictions
from openapi_client.models.time_interval import TimeInterval
from openapi_client.models.transit_class import TransitClass
from typing import Optional, Set
from typing_extensions import Self

class TransitObject(BaseModel):
    """
    TransitObject
    """ # noqa: E501
    activation_status: Optional[ActivationStatus] = Field(default=None, alias="activationStatus")
    app_link_data: Optional[AppLinkData] = Field(default=None, alias="appLinkData")
    barcode: Optional[Barcode] = None
    class_id: Optional[StrictStr] = Field(default=None, description="Required. The class associated with this object. The class must be of the same type as this object, must already exist, and must be approved. Class IDs should follow the format issuer ID.identifier where the former is issued by Google and latter is chosen by you.", alias="classId")
    class_reference: Optional[TransitClass] = Field(default=None, alias="classReference")
    concession_category: Optional[StrictStr] = Field(default=None, description="The concession category for the ticket.", alias="concessionCategory")
    custom_concession_category: Optional[LocalizedString] = Field(default=None, alias="customConcessionCategory")
    custom_ticket_status: Optional[LocalizedString] = Field(default=None, alias="customTicketStatus")
    device_context: Optional[DeviceContext] = Field(default=None, alias="deviceContext")
    disable_expiration_notification: Optional[StrictBool] = Field(default=None, description="Indicates if notifications should explicitly be suppressed. If this field is set to true, regardless of the `messages` field, expiration notifications to the user will be suppressed. By default, this field is set to false. Currently, this can only be set for offers.", alias="disableExpirationNotification")
    grouping_info: Optional[GroupingInfo] = Field(default=None, alias="groupingInfo")
    has_linked_device: Optional[StrictBool] = Field(default=None, description="Whether this object is currently linked to a single device. This field is set by the platform when a user saves the object, linking it to their device. Intended for use by select partners. Contact support for additional information.", alias="hasLinkedDevice")
    has_users: Optional[StrictBool] = Field(default=None, description="Indicates if the object has users. This field is set by the platform.", alias="hasUsers")
    hero_image: Optional[Image] = Field(default=None, alias="heroImage")
    hex_background_color: Optional[StrictStr] = Field(default=None, description="The background color for the card. If not set the dominant color of the hero image is used, and if no hero image is set, the dominant color of the logo is used. The format is #rrggbb where rrggbb is a hex RGB triplet, such as `#ffcc00`. You can also use the shorthand version of the RGB triplet which is #rgb, such as `#fc0`.", alias="hexBackgroundColor")
    id: Optional[StrictStr] = Field(default=None, description="Required. The unique identifier for an object. This ID must be unique across all objects from an issuer. This value should follow the format issuer ID.identifier where the former is issued by Google and latter is chosen by you. The unique identifier should only include alphanumeric characters, '.', '_', or '-'.")
    image_modules_data: Optional[List[ImageModuleData]] = Field(default=None, description="Image module data. The maximum number of these fields displayed is 1 from object level and 1 for class object level.", alias="imageModulesData")
    info_module_data: Optional[InfoModuleData] = Field(default=None, alias="infoModuleData")
    links_module_data: Optional[LinksModuleData] = Field(default=None, alias="linksModuleData")
    locations: Optional[List[LatLongPoint]] = Field(default=None, description="Note: This field is currently not supported to trigger geo notifications.")
    messages: Optional[List[Message]] = Field(default=None, description="An array of messages displayed in the app. All users of this object will receive its associated messages. The maximum number of these fields is 10.")
    pass_constraints: Optional[PassConstraints] = Field(default=None, alias="passConstraints")
    passenger_names: Optional[StrictStr] = Field(default=None, description="The name(s) of the passengers the ticket is assigned to. The above `passengerType` field is meant to give Google context on this field.", alias="passengerNames")
    passenger_type: Optional[StrictStr] = Field(default=None, description="The number of passengers.", alias="passengerType")
    purchase_details: Optional[PurchaseDetails] = Field(default=None, alias="purchaseDetails")
    rotating_barcode: Optional[RotatingBarcode] = Field(default=None, alias="rotatingBarcode")
    smart_tap_redemption_value: Optional[StrictStr] = Field(default=None, description="The value that will be transmitted to a Smart Tap certified terminal over NFC for this object. The class level fields `enableSmartTap` and `redemptionIssuers` must also be set up correctly in order for the pass to support Smart Tap. Only ASCII characters are supported.", alias="smartTapRedemptionValue")
    state: Optional[StrictStr] = Field(default=None, description="Required. The state of the object. This field is used to determine how an object is displayed in the app. For example, an `inactive` object is moved to the \"Expired passes\" section.")
    text_modules_data: Optional[List[TextModuleData]] = Field(default=None, description="Text module data. If text module data is also defined on the class, both will be displayed. The maximum number of these fields displayed is 10 from the object and 10 from the class.", alias="textModulesData")
    ticket_leg: Optional[TicketLeg] = Field(default=None, alias="ticketLeg")
    ticket_legs: Optional[List[TicketLeg]] = Field(default=None, description="Each ticket may contain one or more legs. Each leg contains departure and arrival information along with boarding and seating information. If only one leg is to be specified then use the `ticketLeg` field instead. Both `ticketLeg` and `ticketLegs` may not be set.", alias="ticketLegs")
    ticket_number: Optional[StrictStr] = Field(default=None, description="The number of the ticket. This is a unique identifier for the ticket in the transit operator's system.", alias="ticketNumber")
    ticket_restrictions: Optional[TicketRestrictions] = Field(default=None, alias="ticketRestrictions")
    ticket_status: Optional[StrictStr] = Field(default=None, description="The status of the ticket. For states which affect display, use the `state` field instead.", alias="ticketStatus")
    trip_id: Optional[StrictStr] = Field(default=None, description="This id is used to group tickets together if the user has saved multiple tickets for the same trip.", alias="tripId")
    trip_type: Optional[StrictStr] = Field(default=None, description="Required. The type of trip this transit object represents. Used to determine the pass title and/or which symbol to use between the origin and destination.", alias="tripType")
    valid_time_interval: Optional[TimeInterval] = Field(default=None, alias="validTimeInterval")
    version: Optional[StrictStr] = Field(default=None, description="Deprecated")
    __properties: ClassVar[List[str]] = ["activationStatus", "appLinkData", "barcode", "classId", "classReference", "concessionCategory", "customConcessionCategory", "customTicketStatus", "deviceContext", "disableExpirationNotification", "groupingInfo", "hasLinkedDevice", "hasUsers", "heroImage", "hexBackgroundColor", "id", "imageModulesData", "infoModuleData", "linksModuleData", "locations", "messages", "passConstraints", "passengerNames", "passengerType", "purchaseDetails", "rotatingBarcode", "smartTapRedemptionValue", "state", "textModulesData", "ticketLeg", "ticketLegs", "ticketNumber", "ticketRestrictions", "ticketStatus", "tripId", "tripType", "validTimeInterval", "version"]

    @field_validator('concession_category')
    def concession_category_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CONCESSION_CATEGORY_UNSPECIFIED', 'ADULT', 'adult', 'CHILD', 'child', 'SENIOR', 'senior']):
            raise ValueError("must be one of enum values ('CONCESSION_CATEGORY_UNSPECIFIED', 'ADULT', 'adult', 'CHILD', 'child', 'SENIOR', 'senior')")
        return value

    @field_validator('passenger_type')
    def passenger_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PASSENGER_TYPE_UNSPECIFIED', 'SINGLE_PASSENGER', 'singlePassenger', 'MULTIPLE_PASSENGERS', 'multiplePassengers']):
            raise ValueError("must be one of enum values ('PASSENGER_TYPE_UNSPECIFIED', 'SINGLE_PASSENGER', 'singlePassenger', 'MULTIPLE_PASSENGERS', 'multiplePassengers')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'ACTIVE', 'active', 'COMPLETED', 'completed', 'EXPIRED', 'expired', 'INACTIVE', 'inactive']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'ACTIVE', 'active', 'COMPLETED', 'completed', 'EXPIRED', 'expired', 'INACTIVE', 'inactive')")
        return value

    @field_validator('ticket_status')
    def ticket_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['TICKET_STATUS_UNSPECIFIED', 'USED', 'used', 'REFUNDED', 'refunded', 'EXCHANGED', 'exchanged']):
            raise ValueError("must be one of enum values ('TICKET_STATUS_UNSPECIFIED', 'USED', 'used', 'REFUNDED', 'refunded', 'EXCHANGED', 'exchanged')")
        return value

    @field_validator('trip_type')
    def trip_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['TRIP_TYPE_UNSPECIFIED', 'ROUND_TRIP', 'roundTrip', 'ONE_WAY', 'oneWay']):
            raise ValueError("must be one of enum values ('TRIP_TYPE_UNSPECIFIED', 'ROUND_TRIP', 'roundTrip', 'ONE_WAY', 'oneWay')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TransitObject from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of activation_status
        if self.activation_status:
            _dict['activationStatus'] = self.activation_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of app_link_data
        if self.app_link_data:
            _dict['appLinkData'] = self.app_link_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of barcode
        if self.barcode:
            _dict['barcode'] = self.barcode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of class_reference
        if self.class_reference:
            _dict['classReference'] = self.class_reference.to_dict()
        # override the default output from pydantic by calling `to_dict()` of custom_concession_category
        if self.custom_concession_category:
            _dict['customConcessionCategory'] = self.custom_concession_category.to_dict()
        # override the default output from pydantic by calling `to_dict()` of custom_ticket_status
        if self.custom_ticket_status:
            _dict['customTicketStatus'] = self.custom_ticket_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of device_context
        if self.device_context:
            _dict['deviceContext'] = self.device_context.to_dict()
        # override the default output from pydantic by calling `to_dict()` of grouping_info
        if self.grouping_info:
            _dict['groupingInfo'] = self.grouping_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of hero_image
        if self.hero_image:
            _dict['heroImage'] = self.hero_image.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in image_modules_data (list)
        _items = []
        if self.image_modules_data:
            for _item_image_modules_data in self.image_modules_data:
                if _item_image_modules_data:
                    _items.append(_item_image_modules_data.to_dict())
            _dict['imageModulesData'] = _items
        # override the default output from pydantic by calling `to_dict()` of info_module_data
        if self.info_module_data:
            _dict['infoModuleData'] = self.info_module_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of links_module_data
        if self.links_module_data:
            _dict['linksModuleData'] = self.links_module_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in locations (list)
        _items = []
        if self.locations:
            for _item_locations in self.locations:
                if _item_locations:
                    _items.append(_item_locations.to_dict())
            _dict['locations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in messages (list)
        _items = []
        if self.messages:
            for _item_messages in self.messages:
                if _item_messages:
                    _items.append(_item_messages.to_dict())
            _dict['messages'] = _items
        # override the default output from pydantic by calling `to_dict()` of pass_constraints
        if self.pass_constraints:
            _dict['passConstraints'] = self.pass_constraints.to_dict()
        # override the default output from pydantic by calling `to_dict()` of purchase_details
        if self.purchase_details:
            _dict['purchaseDetails'] = self.purchase_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rotating_barcode
        if self.rotating_barcode:
            _dict['rotatingBarcode'] = self.rotating_barcode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in text_modules_data (list)
        _items = []
        if self.text_modules_data:
            for _item_text_modules_data in self.text_modules_data:
                if _item_text_modules_data:
                    _items.append(_item_text_modules_data.to_dict())
            _dict['textModulesData'] = _items
        # override the default output from pydantic by calling `to_dict()` of ticket_leg
        if self.ticket_leg:
            _dict['ticketLeg'] = self.ticket_leg.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in ticket_legs (list)
        _items = []
        if self.ticket_legs:
            for _item_ticket_legs in self.ticket_legs:
                if _item_ticket_legs:
                    _items.append(_item_ticket_legs.to_dict())
            _dict['ticketLegs'] = _items
        # override the default output from pydantic by calling `to_dict()` of ticket_restrictions
        if self.ticket_restrictions:
            _dict['ticketRestrictions'] = self.ticket_restrictions.to_dict()
        # override the default output from pydantic by calling `to_dict()` of valid_time_interval
        if self.valid_time_interval:
            _dict['validTimeInterval'] = self.valid_time_interval.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TransitObject from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "activationStatus": ActivationStatus.from_dict(obj["activationStatus"]) if obj.get("activationStatus") is not None else None,
            "appLinkData": AppLinkData.from_dict(obj["appLinkData"]) if obj.get("appLinkData") is not None else None,
            "barcode": Barcode.from_dict(obj["barcode"]) if obj.get("barcode") is not None else None,
            "classId": obj.get("classId"),
            "classReference": TransitClass.from_dict(obj["classReference"]) if obj.get("classReference") is not None else None,
            "concessionCategory": obj.get("concessionCategory"),
            "customConcessionCategory": LocalizedString.from_dict(obj["customConcessionCategory"]) if obj.get("customConcessionCategory") is not None else None,
            "customTicketStatus": LocalizedString.from_dict(obj["customTicketStatus"]) if obj.get("customTicketStatus") is not None else None,
            "deviceContext": DeviceContext.from_dict(obj["deviceContext"]) if obj.get("deviceContext") is not None else None,
            "disableExpirationNotification": obj.get("disableExpirationNotification"),
            "groupingInfo": GroupingInfo.from_dict(obj["groupingInfo"]) if obj.get("groupingInfo") is not None else None,
            "hasLinkedDevice": obj.get("hasLinkedDevice"),
            "hasUsers": obj.get("hasUsers"),
            "heroImage": Image.from_dict(obj["heroImage"]) if obj.get("heroImage") is not None else None,
            "hexBackgroundColor": obj.get("hexBackgroundColor"),
            "id": obj.get("id"),
            "imageModulesData": [ImageModuleData.from_dict(_item) for _item in obj["imageModulesData"]] if obj.get("imageModulesData") is not None else None,
            "infoModuleData": InfoModuleData.from_dict(obj["infoModuleData"]) if obj.get("infoModuleData") is not None else None,
            "linksModuleData": LinksModuleData.from_dict(obj["linksModuleData"]) if obj.get("linksModuleData") is not None else None,
            "locations": [LatLongPoint.from_dict(_item) for _item in obj["locations"]] if obj.get("locations") is not None else None,
            "messages": [Message.from_dict(_item) for _item in obj["messages"]] if obj.get("messages") is not None else None,
            "passConstraints": PassConstraints.from_dict(obj["passConstraints"]) if obj.get("passConstraints") is not None else None,
            "passengerNames": obj.get("passengerNames"),
            "passengerType": obj.get("passengerType"),
            "purchaseDetails": PurchaseDetails.from_dict(obj["purchaseDetails"]) if obj.get("purchaseDetails") is not None else None,
            "rotatingBarcode": RotatingBarcode.from_dict(obj["rotatingBarcode"]) if obj.get("rotatingBarcode") is not None else None,
            "smartTapRedemptionValue": obj.get("smartTapRedemptionValue"),
            "state": obj.get("state"),
            "textModulesData": [TextModuleData.from_dict(_item) for _item in obj["textModulesData"]] if obj.get("textModulesData") is not None else None,
            "ticketLeg": TicketLeg.from_dict(obj["ticketLeg"]) if obj.get("ticketLeg") is not None else None,
            "ticketLegs": [TicketLeg.from_dict(_item) for _item in obj["ticketLegs"]] if obj.get("ticketLegs") is not None else None,
            "ticketNumber": obj.get("ticketNumber"),
            "ticketRestrictions": TicketRestrictions.from_dict(obj["ticketRestrictions"]) if obj.get("ticketRestrictions") is not None else None,
            "ticketStatus": obj.get("ticketStatus"),
            "tripId": obj.get("tripId"),
            "tripType": obj.get("tripType"),
            "validTimeInterval": TimeInterval.from_dict(obj["validTimeInterval"]) if obj.get("validTimeInterval") is not None else None,
            "version": obj.get("version")
        })
        return _obj


