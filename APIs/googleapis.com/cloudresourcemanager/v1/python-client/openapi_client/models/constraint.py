# coding: utf-8

"""
    Cloud Resource Manager API

    Creates, reads, and updates metadata for Google Cloud Platform resource containers.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.list_constraint import ListConstraint
from typing import Optional, Set
from typing_extensions import Self

class Constraint(BaseModel):
    """
    A `Constraint` describes a way in which a resource's configuration can be restricted. For example, it controls which cloud services can be activated across an organization, or whether a Compute Engine instance can have serial port connections established. `Constraints` can be configured by the organization's policy administrator to fit the needs of the organzation by setting Policies for `Constraints` at different locations in the organization's resource hierarchy. Policies are inherited down the resource hierarchy from higher levels, but can also be overridden. For details about the inheritance rules please read about [Policies](/resource-manager/reference/rest/v1/Policy). `Constraints` have a default behavior determined by the `constraint_default` field, which is the enforcement behavior that is used in the absence of a `Policy` being defined or inherited for the resource in question.
    """ # noqa: E501
    boolean_constraint: Optional[Dict[str, Any]] = Field(default=None, description="A `Constraint` that is either enforced or not. For example a constraint `constraints/compute.disableSerialPortAccess`. If it is enforced on a VM instance, serial port connections will not be opened to that instance.", alias="booleanConstraint")
    constraint_default: Optional[StrictStr] = Field(default=None, description="The evaluation behavior of this constraint in the absence of 'Policy'.", alias="constraintDefault")
    description: Optional[StrictStr] = Field(default=None, description="Detailed description of what this `Constraint` controls as well as how and where it is enforced. Mutable.")
    display_name: Optional[StrictStr] = Field(default=None, description="The human readable name. Mutable.", alias="displayName")
    list_constraint: Optional[ListConstraint] = Field(default=None, alias="listConstraint")
    name: Optional[StrictStr] = Field(default=None, description="Immutable value, required to globally be unique. For example, `constraints/serviceuser.services`")
    version: Optional[StrictInt] = Field(default=None, description="Version of the `Constraint`. Default version is 0;")
    __properties: ClassVar[List[str]] = ["booleanConstraint", "constraintDefault", "description", "displayName", "listConstraint", "name", "version"]

    @field_validator('constraint_default')
    def constraint_default_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CONSTRAINT_DEFAULT_UNSPECIFIED', 'ALLOW', 'DENY']):
            raise ValueError("must be one of enum values ('CONSTRAINT_DEFAULT_UNSPECIFIED', 'ALLOW', 'DENY')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Constraint from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of list_constraint
        if self.list_constraint:
            _dict['listConstraint'] = self.list_constraint.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Constraint from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "booleanConstraint": obj.get("booleanConstraint"),
            "constraintDefault": obj.get("constraintDefault"),
            "description": obj.get("description"),
            "displayName": obj.get("displayName"),
            "listConstraint": ListConstraint.from_dict(obj["listConstraint"]) if obj.get("listConstraint") is not None else None,
            "name": obj.get("name"),
            "version": obj.get("version")
        })
        return _obj


