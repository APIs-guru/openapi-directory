# coding: utf-8

"""
    Cloud Resource Manager API

    Creates, reads, and updates metadata for Google Cloud Platform resource containers.

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class TagValue(BaseModel):
    """
    A TagValue is a child of a particular TagKey. This is used to group cloud resources for the purpose of controlling them using policies.
    """ # noqa: E501
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. Creation time.", alias="createTime")
    description: Optional[StrictStr] = Field(default=None, description="Optional. User-assigned description of the TagValue. Must not exceed 256 characters. Read-write.")
    etag: Optional[StrictStr] = Field(default=None, description="Optional. Entity tag which users can pass to prevent race conditions. This field is always set in server responses. See UpdateTagValueRequest for details.")
    name: Optional[StrictStr] = Field(default=None, description="Immutable. Resource name for TagValue in the format `tagValues/456`.")
    namespaced_name: Optional[StrictStr] = Field(default=None, description="Output only. The namespaced name of the TagValue. Can be in the form `{organization_id}/{tag_key_short_name}/{tag_value_short_name}` or `{project_id}/{tag_key_short_name}/{tag_value_short_name}` or `{project_number}/{tag_key_short_name}/{tag_value_short_name}`.", alias="namespacedName")
    parent: Optional[StrictStr] = Field(default=None, description="Immutable. The resource name of the new TagValue's parent TagKey. Must be of the form `tagKeys/{tag_key_id}`.")
    short_name: Optional[StrictStr] = Field(default=None, description="Required. Immutable. User-assigned short name for TagValue. The short name should be unique for TagValues within the same parent TagKey. The short name must be 63 characters or less, beginning and ending with an alphanumeric character ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and alphanumerics between.", alias="shortName")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. Update time.", alias="updateTime")
    __properties: ClassVar[List[str]] = ["createTime", "description", "etag", "name", "namespacedName", "parent", "shortName", "updateTime"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TagValue from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "namespaced_name",
            "update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TagValue from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "createTime": obj.get("createTime"),
            "description": obj.get("description"),
            "etag": obj.get("etag"),
            "name": obj.get("name"),
            "namespacedName": obj.get("namespacedName"),
            "parent": obj.get("parent"),
            "shortName": obj.get("shortName"),
            "updateTime": obj.get("updateTime")
        })
        return _obj


