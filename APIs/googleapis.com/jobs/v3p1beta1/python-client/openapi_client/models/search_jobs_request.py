# coding: utf-8

"""
    Cloud Talent Solution API

    Cloud Talent Solution provides the capability to create, read, update, and delete job postings, as well as search jobs based on keywords and filters. 

    The version of the OpenAPI document: v3p1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.custom_ranking_info import CustomRankingInfo
from openapi_client.models.histogram_facets import HistogramFacets
from openapi_client.models.histogram_query import HistogramQuery
from openapi_client.models.job_query import JobQuery
from openapi_client.models.request_metadata import RequestMetadata
from typing import Optional, Set
from typing_extensions import Self

class SearchJobsRequest(BaseModel):
    """
    Input only. The Request body of the `SearchJobs` call.
    """ # noqa: E501
    custom_ranking_info: Optional[CustomRankingInfo] = Field(default=None, alias="customRankingInfo")
    disable_keyword_match: Optional[StrictBool] = Field(default=None, description="Optional. Controls whether to disable exact keyword match on Job.job_title, Job.description, Job.company_display_name, Job.locations, Job.qualifications. When disable keyword match is turned off, a keyword match returns jobs that do not match given category filters when there are matching keywords. For example, the query \"program manager,\" a result is returned even if the job posting has the title \"software developer,\" which does not fall into \"program manager\" ontology, but does have \"program manager\" appearing in its description. For queries like \"cloud\" that does not contain title or location specific ontology, jobs with \"cloud\" keyword matches are returned regardless of this flag's value. Please use Company.keyword_searchable_custom_fields or Company.keyword_searchable_custom_attributes if company specific globally matched custom field/attribute string values is needed. Enabling keyword match improves recall of subsequent search requests. Defaults to false.", alias="disableKeywordMatch")
    diversification_level: Optional[StrictStr] = Field(default=None, description="Optional. Controls whether highly similar jobs are returned next to each other in the search results. Jobs are identified as highly similar based on their titles, job categories, and locations. Highly similar results are clustered so that only one representative job of the cluster is displayed to the job seeker higher up in the results, with the other jobs being displayed lower down in the results. Defaults to DiversificationLevel.SIMPLE if no value is specified.", alias="diversificationLevel")
    enable_broadening: Optional[StrictBool] = Field(default=None, description="Optional. Controls whether to broaden the search when it produces sparse results. Broadened queries append results to the end of the matching results list. Defaults to false.", alias="enableBroadening")
    histogram_facets: Optional[HistogramFacets] = Field(default=None, alias="histogramFacets")
    histogram_queries: Optional[List[HistogramQuery]] = Field(default=None, description="Optional. Expression based histogram requests for jobs matching JobQuery.", alias="histogramQueries")
    job_query: Optional[JobQuery] = Field(default=None, alias="jobQuery")
    job_view: Optional[StrictStr] = Field(default=None, description="Optional. The desired job attributes returned for jobs in the search response. Defaults to JobView.SMALL if no value is specified.", alias="jobView")
    offset: Optional[StrictInt] = Field(default=None, description="Optional. An integer that specifies the current offset (that is, starting result location, amongst the jobs deemed by the API as relevant) in search results. This field is only considered if page_token is unset. The maximum allowed value is 5000. Otherwise an error is thrown. For example, 0 means to return results starting from the first matching job, and 10 means to return from the 11th job. This can be used for pagination, (for example, pageSize = 10 and offset = 10 means to return from the second page).")
    order_by: Optional[StrictStr] = Field(default=None, description="Optional. The criteria determining how search results are sorted. Default is \"relevance desc\". Supported options are: * `\"relevance desc\"`: By relevance descending, as determined by the API algorithms. Relevance thresholding of query results is only available with this ordering. * `\"posting_publish_time desc\"`: By Job.posting_publish_time descending. * `\"posting_update_time desc\"`: By Job.posting_update_time descending. * `\"title\"`: By Job.title ascending. * `\"title desc\"`: By Job.title descending. * `\"annualized_base_compensation\"`: By job's CompensationInfo.annualized_base_compensation_range ascending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * `\"annualized_base_compensation desc\"`: By job's CompensationInfo.annualized_base_compensation_range descending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * `\"annualized_total_compensation\"`: By job's CompensationInfo.annualized_total_compensation_range ascending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * `\"annualized_total_compensation desc\"`: By job's CompensationInfo.annualized_total_compensation_range descending. Jobs whose annualized base compensation is unspecified are put at the end of search results. * `\"custom_ranking desc\"`: By the relevance score adjusted to the SearchJobsRequest.custom_ranking_info.ranking_expression with weight factor assigned by SearchJobsRequest.custom_ranking_info.importance_level in descending order. * Location sorting: Use the special syntax to order jobs by distance: \"`distance_from('Hawaii')`\": Order by distance from Hawaii. \"`distance_from(19.89, 155.5)`\": Order by distance from a coordinate. \"`distance_from('Hawaii'), distance_from('Puerto Rico')`\": Order by multiple locations. See details below. \"`distance_from('Hawaii'), distance_from(19.89, 155.5)`\": Order by multiple locations. See details below. The string can have a maximum of 256 characters. When multiple distance centers are provided, a job that is close to any of the distance centers would have a high rank. When a job has multiple locations, the job location closest to one of the distance centers will be used. Jobs that don't have locations will be ranked at the bottom. Distance is calculated with a precision of 11.3 meters (37.4 feet). Diversification strategy is still applied unless explicitly disabled in diversification_level.", alias="orderBy")
    page_size: Optional[StrictInt] = Field(default=None, description="Optional. A limit on the number of jobs returned in the search results. Increasing this value above the default value of 10 can increase search response time. The value can be between 1 and 100.", alias="pageSize")
    page_token: Optional[StrictStr] = Field(default=None, description="Optional. The token specifying the current offset within search results. See SearchJobsResponse.next_page_token for an explanation of how to obtain the next set of query results.", alias="pageToken")
    request_metadata: Optional[RequestMetadata] = Field(default=None, alias="requestMetadata")
    require_precise_result_size: Optional[StrictBool] = Field(default=None, description="This field is deprecated.", alias="requirePreciseResultSize")
    search_mode: Optional[StrictStr] = Field(default=None, description="Optional. Mode of a search. Defaults to SearchMode.JOB_SEARCH.", alias="searchMode")
    __properties: ClassVar[List[str]] = ["customRankingInfo", "disableKeywordMatch", "diversificationLevel", "enableBroadening", "histogramFacets", "histogramQueries", "jobQuery", "jobView", "offset", "orderBy", "pageSize", "pageToken", "requestMetadata", "requirePreciseResultSize", "searchMode"]

    @field_validator('diversification_level')
    def diversification_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DIVERSIFICATION_LEVEL_UNSPECIFIED', 'DISABLED', 'SIMPLE']):
            raise ValueError("must be one of enum values ('DIVERSIFICATION_LEVEL_UNSPECIFIED', 'DISABLED', 'SIMPLE')")
        return value

    @field_validator('job_view')
    def job_view_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['JOB_VIEW_UNSPECIFIED', 'JOB_VIEW_ID_ONLY', 'JOB_VIEW_MINIMAL', 'JOB_VIEW_SMALL', 'JOB_VIEW_FULL']):
            raise ValueError("must be one of enum values ('JOB_VIEW_UNSPECIFIED', 'JOB_VIEW_ID_ONLY', 'JOB_VIEW_MINIMAL', 'JOB_VIEW_SMALL', 'JOB_VIEW_FULL')")
        return value

    @field_validator('search_mode')
    def search_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SEARCH_MODE_UNSPECIFIED', 'JOB_SEARCH', 'FEATURED_JOB_SEARCH']):
            raise ValueError("must be one of enum values ('SEARCH_MODE_UNSPECIFIED', 'JOB_SEARCH', 'FEATURED_JOB_SEARCH')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SearchJobsRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of custom_ranking_info
        if self.custom_ranking_info:
            _dict['customRankingInfo'] = self.custom_ranking_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of histogram_facets
        if self.histogram_facets:
            _dict['histogramFacets'] = self.histogram_facets.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in histogram_queries (list)
        _items = []
        if self.histogram_queries:
            for _item_histogram_queries in self.histogram_queries:
                if _item_histogram_queries:
                    _items.append(_item_histogram_queries.to_dict())
            _dict['histogramQueries'] = _items
        # override the default output from pydantic by calling `to_dict()` of job_query
        if self.job_query:
            _dict['jobQuery'] = self.job_query.to_dict()
        # override the default output from pydantic by calling `to_dict()` of request_metadata
        if self.request_metadata:
            _dict['requestMetadata'] = self.request_metadata.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SearchJobsRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "customRankingInfo": CustomRankingInfo.from_dict(obj["customRankingInfo"]) if obj.get("customRankingInfo") is not None else None,
            "disableKeywordMatch": obj.get("disableKeywordMatch"),
            "diversificationLevel": obj.get("diversificationLevel"),
            "enableBroadening": obj.get("enableBroadening"),
            "histogramFacets": HistogramFacets.from_dict(obj["histogramFacets"]) if obj.get("histogramFacets") is not None else None,
            "histogramQueries": [HistogramQuery.from_dict(_item) for _item in obj["histogramQueries"]] if obj.get("histogramQueries") is not None else None,
            "jobQuery": JobQuery.from_dict(obj["jobQuery"]) if obj.get("jobQuery") is not None else None,
            "jobView": obj.get("jobView"),
            "offset": obj.get("offset"),
            "orderBy": obj.get("orderBy"),
            "pageSize": obj.get("pageSize"),
            "pageToken": obj.get("pageToken"),
            "requestMetadata": RequestMetadata.from_dict(obj["requestMetadata"]) if obj.get("requestMetadata") is not None else None,
            "requirePreciseResultSize": obj.get("requirePreciseResultSize"),
            "searchMode": obj.get("searchMode")
        })
        return _obj


