# coding: utf-8

"""
    Cloud Talent Solution API

    Cloud Talent Solution provides the capability to create, read, update, and delete job postings, as well as search jobs based on keywords and filters. 

    The version of the OpenAPI document: v3p1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.namespaced_debug_input import NamespacedDebugInput
from typing import Optional, Set
from typing_extensions import Self

class MendelDebugInput(BaseModel):
    """
    Message representing input to a Mendel server for debug forcing. See go/mendel-debug-forcing for more details. Next ID: 2
    """ # noqa: E501
    namespaced_debug_input: Optional[Dict[str, NamespacedDebugInput]] = Field(default=None, description="When a request spans multiple servers, a MendelDebugInput may travel with the request and take effect in all the servers. This field is a map of namespaces to NamespacedMendelDebugInput protos. In a single server, up to two NamespacedMendelDebugInput protos are applied: 1. NamespacedMendelDebugInput with the global namespace (key == \"\"). 2. NamespacedMendelDebugInput with the server's namespace. When both NamespacedMendelDebugInput protos are present, they are merged. See go/mendel-debug-forcing for more details.", alias="namespacedDebugInput")
    __properties: ClassVar[List[str]] = ["namespacedDebugInput"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MendelDebugInput from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in namespaced_debug_input (dict)
        _field_dict = {}
        if self.namespaced_debug_input:
            for _key_namespaced_debug_input in self.namespaced_debug_input:
                if self.namespaced_debug_input[_key_namespaced_debug_input]:
                    _field_dict[_key_namespaced_debug_input] = self.namespaced_debug_input[_key_namespaced_debug_input].to_dict()
            _dict['namespacedDebugInput'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MendelDebugInput from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "namespacedDebugInput": dict(
                (_k, NamespacedDebugInput.from_dict(_v))
                for _k, _v in obj["namespacedDebugInput"].items()
            )
            if obj.get("namespacedDebugInput") is not None
            else None
        })
        return _obj


