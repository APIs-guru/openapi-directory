# coding: utf-8

"""
    Google Sheets API

    Reads and writes Google Sheets.

    The version of the OpenAPI document: v4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.basic_series_data_point_style_override import BasicSeriesDataPointStyleOverride
from openapi_client.models.chart_data import ChartData
from openapi_client.models.color import Color
from openapi_client.models.color_style import ColorStyle
from openapi_client.models.data_label import DataLabel
from openapi_client.models.line_style import LineStyle
from openapi_client.models.point_style import PointStyle
from typing import Optional, Set
from typing_extensions import Self

class BasicChartSeries(BaseModel):
    """
    A single series of data in a chart. For example, if charting stock prices over time, multiple series may exist, one for the \"Open Price\", \"High Price\", \"Low Price\" and \"Close Price\".
    """ # noqa: E501
    color: Optional[Color] = None
    color_style: Optional[ColorStyle] = Field(default=None, alias="colorStyle")
    data_label: Optional[DataLabel] = Field(default=None, alias="dataLabel")
    line_style: Optional[LineStyle] = Field(default=None, alias="lineStyle")
    point_style: Optional[PointStyle] = Field(default=None, alias="pointStyle")
    series: Optional[ChartData] = None
    style_overrides: Optional[List[BasicSeriesDataPointStyleOverride]] = Field(default=None, description="Style override settings for series data points.", alias="styleOverrides")
    target_axis: Optional[StrictStr] = Field(default=None, description="The minor axis that will specify the range of values for this series. For example, if charting stocks over time, the \"Volume\" series may want to be pinned to the right with the prices pinned to the left, because the scale of trading volume is different than the scale of prices. It is an error to specify an axis that isn't a valid minor axis for the chart's type.", alias="targetAxis")
    type: Optional[StrictStr] = Field(default=None, description="The type of this series. Valid only if the chartType is COMBO. Different types will change the way the series is visualized. Only LINE, AREA, and COLUMN are supported.")
    __properties: ClassVar[List[str]] = ["color", "colorStyle", "dataLabel", "lineStyle", "pointStyle", "series", "styleOverrides", "targetAxis", "type"]

    @field_validator('target_axis')
    def target_axis_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['BASIC_CHART_AXIS_POSITION_UNSPECIFIED', 'BOTTOM_AXIS', 'LEFT_AXIS', 'RIGHT_AXIS']):
            raise ValueError("must be one of enum values ('BASIC_CHART_AXIS_POSITION_UNSPECIFIED', 'BOTTOM_AXIS', 'LEFT_AXIS', 'RIGHT_AXIS')")
        return value

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['BASIC_CHART_TYPE_UNSPECIFIED', 'BAR', 'LINE', 'AREA', 'COLUMN', 'SCATTER', 'COMBO', 'STEPPED_AREA']):
            raise ValueError("must be one of enum values ('BASIC_CHART_TYPE_UNSPECIFIED', 'BAR', 'LINE', 'AREA', 'COLUMN', 'SCATTER', 'COMBO', 'STEPPED_AREA')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of BasicChartSeries from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of color
        if self.color:
            _dict['color'] = self.color.to_dict()
        # override the default output from pydantic by calling `to_dict()` of color_style
        if self.color_style:
            _dict['colorStyle'] = self.color_style.to_dict()
        # override the default output from pydantic by calling `to_dict()` of data_label
        if self.data_label:
            _dict['dataLabel'] = self.data_label.to_dict()
        # override the default output from pydantic by calling `to_dict()` of line_style
        if self.line_style:
            _dict['lineStyle'] = self.line_style.to_dict()
        # override the default output from pydantic by calling `to_dict()` of point_style
        if self.point_style:
            _dict['pointStyle'] = self.point_style.to_dict()
        # override the default output from pydantic by calling `to_dict()` of series
        if self.series:
            _dict['series'] = self.series.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in style_overrides (list)
        _items = []
        if self.style_overrides:
            for _item_style_overrides in self.style_overrides:
                if _item_style_overrides:
                    _items.append(_item_style_overrides.to_dict())
            _dict['styleOverrides'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of BasicChartSeries from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "color": Color.from_dict(obj["color"]) if obj.get("color") is not None else None,
            "colorStyle": ColorStyle.from_dict(obj["colorStyle"]) if obj.get("colorStyle") is not None else None,
            "dataLabel": DataLabel.from_dict(obj["dataLabel"]) if obj.get("dataLabel") is not None else None,
            "lineStyle": LineStyle.from_dict(obj["lineStyle"]) if obj.get("lineStyle") is not None else None,
            "pointStyle": PointStyle.from_dict(obj["pointStyle"]) if obj.get("pointStyle") is not None else None,
            "series": ChartData.from_dict(obj["series"]) if obj.get("series") is not None else None,
            "styleOverrides": [BasicSeriesDataPointStyleOverride.from_dict(_item) for _item in obj["styleOverrides"]] if obj.get("styleOverrides") is not None else None,
            "targetAxis": obj.get("targetAxis"),
            "type": obj.get("type")
        })
        return _obj


