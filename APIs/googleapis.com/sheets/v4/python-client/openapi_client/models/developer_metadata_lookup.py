# coding: utf-8

"""
    Google Sheets API

    Reads and writes Google Sheets.

    The version of the OpenAPI document: v4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.developer_metadata_location import DeveloperMetadataLocation
from typing import Optional, Set
from typing_extensions import Self

class DeveloperMetadataLookup(BaseModel):
    """
    Selects DeveloperMetadata that matches all of the specified fields. For example, if only a metadata ID is specified this considers the DeveloperMetadata with that particular unique ID. If a metadata key is specified, this considers all developer metadata with that key. If a key, visibility, and location type are all specified, this considers all developer metadata with that key and visibility that are associated with a location of that type. In general, this selects all DeveloperMetadata that matches the intersection of all the specified fields; any field or combination of fields may be specified.
    """ # noqa: E501
    location_matching_strategy: Optional[StrictStr] = Field(default=None, description="Determines how this lookup matches the location. If this field is specified as EXACT, only developer metadata associated on the exact location specified is matched. If this field is specified to INTERSECTING, developer metadata associated on intersecting locations is also matched. If left unspecified, this field assumes a default value of INTERSECTING. If this field is specified, a metadataLocation must also be specified.", alias="locationMatchingStrategy")
    location_type: Optional[StrictStr] = Field(default=None, description="Limits the selected developer metadata to those entries which are associated with locations of the specified type. For example, when this field is specified as ROW this lookup only considers developer metadata associated on rows. If the field is left unspecified, all location types are considered. This field cannot be specified as SPREADSHEET when the locationMatchingStrategy is specified as INTERSECTING or when the metadataLocation is specified as a non-spreadsheet location: spreadsheet metadata cannot intersect any other developer metadata location. This field also must be left unspecified when the locationMatchingStrategy is specified as EXACT.", alias="locationType")
    metadata_id: Optional[StrictInt] = Field(default=None, description="Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_id.", alias="metadataId")
    metadata_key: Optional[StrictStr] = Field(default=None, description="Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_key.", alias="metadataKey")
    metadata_location: Optional[DeveloperMetadataLocation] = Field(default=None, alias="metadataLocation")
    metadata_value: Optional[StrictStr] = Field(default=None, description="Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_value.", alias="metadataValue")
    visibility: Optional[StrictStr] = Field(default=None, description="Limits the selected developer metadata to that which has a matching DeveloperMetadata.visibility. If left unspecified, all developer metadata visibile to the requesting project is considered.")
    __properties: ClassVar[List[str]] = ["locationMatchingStrategy", "locationType", "metadataId", "metadataKey", "metadataLocation", "metadataValue", "visibility"]

    @field_validator('location_matching_strategy')
    def location_matching_strategy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DEVELOPER_METADATA_LOCATION_MATCHING_STRATEGY_UNSPECIFIED', 'EXACT_LOCATION', 'INTERSECTING_LOCATION']):
            raise ValueError("must be one of enum values ('DEVELOPER_METADATA_LOCATION_MATCHING_STRATEGY_UNSPECIFIED', 'EXACT_LOCATION', 'INTERSECTING_LOCATION')")
        return value

    @field_validator('location_type')
    def location_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DEVELOPER_METADATA_LOCATION_TYPE_UNSPECIFIED', 'ROW', 'COLUMN', 'SHEET', 'SPREADSHEET']):
            raise ValueError("must be one of enum values ('DEVELOPER_METADATA_LOCATION_TYPE_UNSPECIFIED', 'ROW', 'COLUMN', 'SHEET', 'SPREADSHEET')")
        return value

    @field_validator('visibility')
    def visibility_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DEVELOPER_METADATA_VISIBILITY_UNSPECIFIED', 'DOCUMENT', 'PROJECT']):
            raise ValueError("must be one of enum values ('DEVELOPER_METADATA_VISIBILITY_UNSPECIFIED', 'DOCUMENT', 'PROJECT')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DeveloperMetadataLookup from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of metadata_location
        if self.metadata_location:
            _dict['metadataLocation'] = self.metadata_location.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DeveloperMetadataLookup from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "locationMatchingStrategy": obj.get("locationMatchingStrategy"),
            "locationType": obj.get("locationType"),
            "metadataId": obj.get("metadataId"),
            "metadataKey": obj.get("metadataKey"),
            "metadataLocation": DeveloperMetadataLocation.from_dict(obj["metadataLocation"]) if obj.get("metadataLocation") is not None else None,
            "metadataValue": obj.get("metadataValue"),
            "visibility": obj.get("visibility")
        })
        return _obj


