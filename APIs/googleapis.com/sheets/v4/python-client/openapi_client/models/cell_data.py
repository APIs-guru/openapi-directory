# coding: utf-8

"""
    Google Sheets API

    Reads and writes Google Sheets.

    The version of the OpenAPI document: v4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.cell_format import CellFormat
from openapi_client.models.data_source_formula import DataSourceFormula
from openapi_client.models.data_source_table import DataSourceTable
from openapi_client.models.data_validation_rule import DataValidationRule
from openapi_client.models.extended_value import ExtendedValue
from openapi_client.models.pivot_table import PivotTable
from openapi_client.models.text_format_run import TextFormatRun
from typing import Optional, Set
from typing_extensions import Self

class CellData(BaseModel):
    """
    Data about a specific cell.
    """ # noqa: E501
    data_source_formula: Optional[DataSourceFormula] = Field(default=None, alias="dataSourceFormula")
    data_source_table: Optional[DataSourceTable] = Field(default=None, alias="dataSourceTable")
    data_validation: Optional[DataValidationRule] = Field(default=None, alias="dataValidation")
    effective_format: Optional[CellFormat] = Field(default=None, alias="effectiveFormat")
    effective_value: Optional[ExtendedValue] = Field(default=None, alias="effectiveValue")
    formatted_value: Optional[StrictStr] = Field(default=None, description="The formatted value of the cell. This is the value as it's shown to the user. This field is read-only.", alias="formattedValue")
    hyperlink: Optional[StrictStr] = Field(default=None, description="A hyperlink this cell points to, if any. If the cell contains multiple hyperlinks, this field will be empty. This field is read-only. To set it, use a `=HYPERLINK` formula in the userEnteredValue.formulaValue field. A cell-level link can also be set from the userEnteredFormat.textFormat field. Alternatively, set a hyperlink in the textFormatRun.format.link field that spans the entire cell.")
    note: Optional[StrictStr] = Field(default=None, description="Any note on the cell.")
    pivot_table: Optional[PivotTable] = Field(default=None, alias="pivotTable")
    text_format_runs: Optional[List[TextFormatRun]] = Field(default=None, description="Runs of rich text applied to subsections of the cell. Runs are only valid on user entered strings, not formulas, bools, or numbers. Properties of a run start at a specific index in the text and continue until the next run. Runs will inherit the properties of the cell unless explicitly changed. When writing, the new runs will overwrite any prior runs. When writing a new user_entered_value, previous runs are erased.", alias="textFormatRuns")
    user_entered_format: Optional[CellFormat] = Field(default=None, alias="userEnteredFormat")
    user_entered_value: Optional[ExtendedValue] = Field(default=None, alias="userEnteredValue")
    __properties: ClassVar[List[str]] = ["dataSourceFormula", "dataSourceTable", "dataValidation", "effectiveFormat", "effectiveValue", "formattedValue", "hyperlink", "note", "pivotTable", "textFormatRuns", "userEnteredFormat", "userEnteredValue"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CellData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of data_source_formula
        if self.data_source_formula:
            _dict['dataSourceFormula'] = self.data_source_formula.to_dict()
        # override the default output from pydantic by calling `to_dict()` of data_source_table
        if self.data_source_table:
            _dict['dataSourceTable'] = self.data_source_table.to_dict()
        # override the default output from pydantic by calling `to_dict()` of data_validation
        if self.data_validation:
            _dict['dataValidation'] = self.data_validation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of effective_format
        if self.effective_format:
            _dict['effectiveFormat'] = self.effective_format.to_dict()
        # override the default output from pydantic by calling `to_dict()` of effective_value
        if self.effective_value:
            _dict['effectiveValue'] = self.effective_value.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pivot_table
        if self.pivot_table:
            _dict['pivotTable'] = self.pivot_table.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in text_format_runs (list)
        _items = []
        if self.text_format_runs:
            for _item_text_format_runs in self.text_format_runs:
                if _item_text_format_runs:
                    _items.append(_item_text_format_runs.to_dict())
            _dict['textFormatRuns'] = _items
        # override the default output from pydantic by calling `to_dict()` of user_entered_format
        if self.user_entered_format:
            _dict['userEnteredFormat'] = self.user_entered_format.to_dict()
        # override the default output from pydantic by calling `to_dict()` of user_entered_value
        if self.user_entered_value:
            _dict['userEnteredValue'] = self.user_entered_value.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CellData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "dataSourceFormula": DataSourceFormula.from_dict(obj["dataSourceFormula"]) if obj.get("dataSourceFormula") is not None else None,
            "dataSourceTable": DataSourceTable.from_dict(obj["dataSourceTable"]) if obj.get("dataSourceTable") is not None else None,
            "dataValidation": DataValidationRule.from_dict(obj["dataValidation"]) if obj.get("dataValidation") is not None else None,
            "effectiveFormat": CellFormat.from_dict(obj["effectiveFormat"]) if obj.get("effectiveFormat") is not None else None,
            "effectiveValue": ExtendedValue.from_dict(obj["effectiveValue"]) if obj.get("effectiveValue") is not None else None,
            "formattedValue": obj.get("formattedValue"),
            "hyperlink": obj.get("hyperlink"),
            "note": obj.get("note"),
            "pivotTable": PivotTable.from_dict(obj["pivotTable"]) if obj.get("pivotTable") is not None else None,
            "textFormatRuns": [TextFormatRun.from_dict(_item) for _item in obj["textFormatRuns"]] if obj.get("textFormatRuns") is not None else None,
            "userEnteredFormat": CellFormat.from_dict(obj["userEnteredFormat"]) if obj.get("userEnteredFormat") is not None else None,
            "userEnteredValue": ExtendedValue.from_dict(obj["userEnteredValue"]) if obj.get("userEnteredValue") is not None else None
        })
        return _obj


