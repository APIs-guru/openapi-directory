# coding: utf-8

"""
    Service Control API

    Provides admission control and telemetry reporting for services integrated with Service Infrastructure. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.authentication_info import AuthenticationInfo
from openapi_client.models.authorization_info import AuthorizationInfo
from openapi_client.models.policy_violation_info import PolicyViolationInfo
from openapi_client.models.request_metadata import RequestMetadata
from openapi_client.models.resource_location import ResourceLocation
from openapi_client.models.status import Status
from typing import Optional, Set
from typing_extensions import Self

class AuditLog(BaseModel):
    """
    Common audit log format for Google Cloud Platform API operations. 
    """ # noqa: E501
    authentication_info: Optional[AuthenticationInfo] = Field(default=None, alias="authenticationInfo")
    authorization_info: Optional[List[AuthorizationInfo]] = Field(default=None, description="Authorization information. If there are multiple resources or permissions involved, then there is one AuthorizationInfo element for each {resource, permission} tuple.", alias="authorizationInfo")
    metadata: Optional[Dict[str, Any]] = Field(default=None, description="Other service-specific data about the request, response, and other information associated with the current audited event.")
    method_name: Optional[StrictStr] = Field(default=None, description="The name of the service method or operation. For API calls, this should be the name of the API method. For example, \"google.cloud.bigquery.v2.TableService.InsertTable\" \"google.logging.v2.ConfigServiceV2.CreateSink\"", alias="methodName")
    num_response_items: Optional[StrictStr] = Field(default=None, description="The number of items returned from a List or Query API method, if applicable.", alias="numResponseItems")
    policy_violation_info: Optional[PolicyViolationInfo] = Field(default=None, alias="policyViolationInfo")
    request: Optional[Dict[str, Any]] = Field(default=None, description="The operation request. This may not include all request parameters, such as those that are too large, privacy-sensitive, or duplicated elsewhere in the log record. It should never include user-generated data, such as file contents. When the JSON object represented here has a proto equivalent, the proto name will be indicated in the `@type` property.")
    request_metadata: Optional[RequestMetadata] = Field(default=None, alias="requestMetadata")
    resource_location: Optional[ResourceLocation] = Field(default=None, alias="resourceLocation")
    resource_name: Optional[StrictStr] = Field(default=None, description="The resource or collection that is the target of the operation. The name is a scheme-less URI, not including the API service name. For example: \"projects/PROJECT_ID/zones/us-central1-a/instances\" \"projects/PROJECT_ID/datasets/DATASET_ID\"", alias="resourceName")
    resource_original_state: Optional[Dict[str, Any]] = Field(default=None, description="The resource's original state before mutation. Present only for operations which have successfully modified the targeted resource(s). In general, this field should contain all changed fields, except those that are already been included in `request`, `response`, `metadata` or `service_data` fields. When the JSON object represented here has a proto equivalent, the proto name will be indicated in the `@type` property.", alias="resourceOriginalState")
    response: Optional[Dict[str, Any]] = Field(default=None, description="The operation response. This may not include all response elements, such as those that are too large, privacy-sensitive, or duplicated elsewhere in the log record. It should never include user-generated data, such as file contents. When the JSON object represented here has a proto equivalent, the proto name will be indicated in the `@type` property.")
    service_data: Optional[Dict[str, Any]] = Field(default=None, description="Deprecated. Use the `metadata` field instead. Other service-specific data about the request, response, and other activities.", alias="serviceData")
    service_name: Optional[StrictStr] = Field(default=None, description="The name of the API service performing the operation. For example, `\"compute.googleapis.com\"`.", alias="serviceName")
    status: Optional[Status] = None
    __properties: ClassVar[List[str]] = ["authenticationInfo", "authorizationInfo", "metadata", "methodName", "numResponseItems", "policyViolationInfo", "request", "requestMetadata", "resourceLocation", "resourceName", "resourceOriginalState", "response", "serviceData", "serviceName", "status"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AuditLog from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of authentication_info
        if self.authentication_info:
            _dict['authenticationInfo'] = self.authentication_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in authorization_info (list)
        _items = []
        if self.authorization_info:
            for _item_authorization_info in self.authorization_info:
                if _item_authorization_info:
                    _items.append(_item_authorization_info.to_dict())
            _dict['authorizationInfo'] = _items
        # override the default output from pydantic by calling `to_dict()` of policy_violation_info
        if self.policy_violation_info:
            _dict['policyViolationInfo'] = self.policy_violation_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of request_metadata
        if self.request_metadata:
            _dict['requestMetadata'] = self.request_metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of resource_location
        if self.resource_location:
            _dict['resourceLocation'] = self.resource_location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of status
        if self.status:
            _dict['status'] = self.status.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AuditLog from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "authenticationInfo": AuthenticationInfo.from_dict(obj["authenticationInfo"]) if obj.get("authenticationInfo") is not None else None,
            "authorizationInfo": [AuthorizationInfo.from_dict(_item) for _item in obj["authorizationInfo"]] if obj.get("authorizationInfo") is not None else None,
            "metadata": obj.get("metadata"),
            "methodName": obj.get("methodName"),
            "numResponseItems": obj.get("numResponseItems"),
            "policyViolationInfo": PolicyViolationInfo.from_dict(obj["policyViolationInfo"]) if obj.get("policyViolationInfo") is not None else None,
            "request": obj.get("request"),
            "requestMetadata": RequestMetadata.from_dict(obj["requestMetadata"]) if obj.get("requestMetadata") is not None else None,
            "resourceLocation": ResourceLocation.from_dict(obj["resourceLocation"]) if obj.get("resourceLocation") is not None else None,
            "resourceName": obj.get("resourceName"),
            "resourceOriginalState": obj.get("resourceOriginalState"),
            "response": obj.get("response"),
            "serviceData": obj.get("serviceData"),
            "serviceName": obj.get("serviceName"),
            "status": Status.from_dict(obj["status"]) if obj.get("status") is not None else None
        })
        return _obj


