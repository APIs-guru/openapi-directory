# coding: utf-8

"""
    Service Control API

    Provides admission control and telemetry reporting for services integrated with Service Infrastructure. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.metric_value_set import MetricValueSet
from typing import Optional, Set
from typing_extensions import Self

class QuotaOperation(BaseModel):
    """
    Represents information regarding a quota operation.
    """ # noqa: E501
    consumer_id: Optional[StrictStr] = Field(default=None, description="Identity of the consumer for whom this quota operation is being performed. This can be in one of the following formats: project:, project_number:, api_key:.", alias="consumerId")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Labels describing the operation.")
    method_name: Optional[StrictStr] = Field(default=None, description="Fully qualified name of the API method for which this quota operation is requested. This name is used for matching quota rules or metric rules and billing status rules defined in service configuration. This field should not be set if any of the following is true: (1) the quota operation is performed on non-API resources. (2) quota_metrics is set because the caller is doing quota override. Example of an RPC method name: google.example.library.v1.LibraryService.CreateShelf", alias="methodName")
    operation_id: Optional[StrictStr] = Field(default=None, description="Identity of the operation. For Allocation Quota, this is expected to be unique within the scope of the service that generated the operation, and guarantees idempotency in case of retries. In order to ensure best performance and latency in the Quota backends, operation_ids are optimally associated with time, so that related operations can be accessed fast in storage. For this reason, the recommended token for services that intend to operate at a high QPS is Unix time in nanos + UUID", alias="operationId")
    quota_metrics: Optional[List[MetricValueSet]] = Field(default=None, description="Represents information about this operation. Each MetricValueSet corresponds to a metric defined in the service configuration. The data type used in the MetricValueSet must agree with the data type specified in the metric definition. Within a single operation, it is not allowed to have more than one MetricValue instances that have the same metric names and identical label value combinations. If a request has such duplicated MetricValue instances, the entire request is rejected with an invalid argument error. This field is mutually exclusive with method_name.", alias="quotaMetrics")
    quota_mode: Optional[StrictStr] = Field(default=None, description="Quota mode for this operation.", alias="quotaMode")
    __properties: ClassVar[List[str]] = ["consumerId", "labels", "methodName", "operationId", "quotaMetrics", "quotaMode"]

    @field_validator('quota_mode')
    def quota_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'NORMAL', 'BEST_EFFORT', 'CHECK_ONLY', 'ADJUST_ONLY']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'NORMAL', 'BEST_EFFORT', 'CHECK_ONLY', 'ADJUST_ONLY')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of QuotaOperation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in quota_metrics (list)
        _items = []
        if self.quota_metrics:
            for _item_quota_metrics in self.quota_metrics:
                if _item_quota_metrics:
                    _items.append(_item_quota_metrics.to_dict())
            _dict['quotaMetrics'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of QuotaOperation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "consumerId": obj.get("consumerId"),
            "labels": obj.get("labels"),
            "methodName": obj.get("methodName"),
            "operationId": obj.get("operationId"),
            "quotaMetrics": [MetricValueSet.from_dict(_item) for _item in obj["quotaMetrics"]] if obj.get("quotaMetrics") is not None else None,
            "quotaMode": obj.get("quotaMode")
        })
        return _obj


