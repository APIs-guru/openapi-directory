# coding: utf-8

"""
    Service Control API

    Provides admission control and telemetry reporting for services integrated with Service Infrastructure. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.exemplar import Exemplar
from openapi_client.models.explicit_buckets import ExplicitBuckets
from openapi_client.models.exponential_buckets import ExponentialBuckets
from openapi_client.models.linear_buckets import LinearBuckets
from typing import Optional, Set
from typing_extensions import Self

class Distribution(BaseModel):
    """
    Distribution represents a frequency distribution of double-valued sample points. It contains the size of the population of sample points plus additional optional information: * the arithmetic mean of the samples * the minimum and maximum of the samples * the sum-squared-deviation of the samples, used to compute variance * a histogram of the values of the sample points
    """ # noqa: E501
    bucket_counts: Optional[List[StrictStr]] = Field(default=None, description="The number of samples in each histogram bucket. `bucket_counts` are optional. If present, they must sum to the `count` value. The buckets are defined below in `bucket_option`. There are N buckets. `bucket_counts[0]` is the number of samples in the underflow bucket. `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples in each of the finite buckets. And `bucket_counts[N] is the number of samples in the overflow bucket. See the comments of `bucket_option` below for more details. Any suffix of trailing zeros may be omitted.", alias="bucketCounts")
    count: Optional[StrictStr] = Field(default=None, description="The total number of samples in the distribution. Must be >= 0.")
    exemplars: Optional[List[Exemplar]] = Field(default=None, description="Example points. Must be in increasing order of `value` field.")
    explicit_buckets: Optional[ExplicitBuckets] = Field(default=None, alias="explicitBuckets")
    exponential_buckets: Optional[ExponentialBuckets] = Field(default=None, alias="exponentialBuckets")
    linear_buckets: Optional[LinearBuckets] = Field(default=None, alias="linearBuckets")
    maximum: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The maximum of the population of values. Ignored if `count` is zero.")
    mean: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The arithmetic mean of the samples in the distribution. If `count` is zero then this field must be zero.")
    minimum: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The minimum of the population of values. Ignored if `count` is zero.")
    sum_of_squared_deviation: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The sum of squared deviations from the mean: Sum[i=1..count]((x_i - mean)^2) where each x_i is a sample values. If `count` is zero then this field must be zero, otherwise validation of the request fails.", alias="sumOfSquaredDeviation")
    __properties: ClassVar[List[str]] = ["bucketCounts", "count", "exemplars", "explicitBuckets", "exponentialBuckets", "linearBuckets", "maximum", "mean", "minimum", "sumOfSquaredDeviation"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Distribution from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in exemplars (list)
        _items = []
        if self.exemplars:
            for _item_exemplars in self.exemplars:
                if _item_exemplars:
                    _items.append(_item_exemplars.to_dict())
            _dict['exemplars'] = _items
        # override the default output from pydantic by calling `to_dict()` of explicit_buckets
        if self.explicit_buckets:
            _dict['explicitBuckets'] = self.explicit_buckets.to_dict()
        # override the default output from pydantic by calling `to_dict()` of exponential_buckets
        if self.exponential_buckets:
            _dict['exponentialBuckets'] = self.exponential_buckets.to_dict()
        # override the default output from pydantic by calling `to_dict()` of linear_buckets
        if self.linear_buckets:
            _dict['linearBuckets'] = self.linear_buckets.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Distribution from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "bucketCounts": obj.get("bucketCounts"),
            "count": obj.get("count"),
            "exemplars": [Exemplar.from_dict(_item) for _item in obj["exemplars"]] if obj.get("exemplars") is not None else None,
            "explicitBuckets": ExplicitBuckets.from_dict(obj["explicitBuckets"]) if obj.get("explicitBuckets") is not None else None,
            "exponentialBuckets": ExponentialBuckets.from_dict(obj["exponentialBuckets"]) if obj.get("exponentialBuckets") is not None else None,
            "linearBuckets": LinearBuckets.from_dict(obj["linearBuckets"]) if obj.get("linearBuckets") is not None else None,
            "maximum": obj.get("maximum"),
            "mean": obj.get("mean"),
            "minimum": obj.get("minimum"),
            "sumOfSquaredDeviation": obj.get("sumOfSquaredDeviation")
        })
        return _obj


