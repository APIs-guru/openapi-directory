# coding: utf-8

"""
    Cloud Workstations API

    Allows administrators to create managed developer environments in the cloud. 

    The version of the OpenAPI document: v1beta
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.container import Container
from openapi_client.models.customer_encryption_key import CustomerEncryptionKey
from openapi_client.models.ephemeral_directory import EphemeralDirectory
from openapi_client.models.host import Host
from openapi_client.models.persistent_directory import PersistentDirectory
from openapi_client.models.readiness_check import ReadinessCheck
from openapi_client.models.status import Status
from typing import Optional, Set
from typing_extensions import Self

class WorkstationConfig(BaseModel):
    """
    A workstation configuration resource in the Cloud Workstations API. Workstation configurations act as templates for workstations. The workstation configuration defines details such as the workstation virtual machine (VM) instance type, persistent storage, container image defining environment, which IDE or Code Editor to use, and more. Administrators and platform teams can also use [Identity and Access Management (IAM)](https://cloud.google.com/iam/docs/overview) rules to grant access to teams or to individual developers.
    """ # noqa: E501
    annotations: Optional[Dict[str, StrictStr]] = Field(default=None, description="Optional. Client-specified annotations.")
    conditions: Optional[List[Status]] = Field(default=None, description="Output only. Status conditions describing the current resource state.")
    container: Optional[Container] = None
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. Time when this workstation configuration was created.", alias="createTime")
    degraded: Optional[StrictBool] = Field(default=None, description="Output only. Whether this resource is degraded, in which case it may require user action to restore full functionality. See also the conditions field.")
    delete_time: Optional[StrictStr] = Field(default=None, description="Output only. Time when this workstation configuration was soft-deleted.", alias="deleteTime")
    disable_tcp_connections: Optional[StrictBool] = Field(default=None, description="Optional. Disables support for plain TCP connections in the workstation. By default the service supports TCP connections via a websocket relay. Setting this option to true disables that relay, which prevents the usage of services that require plain tcp connections, such as ssh. When enabled, all communication must occur over https or wss.", alias="disableTcpConnections")
    display_name: Optional[StrictStr] = Field(default=None, description="Optional. Human-readable name for this workstation configuration.", alias="displayName")
    enable_audit_agent: Optional[StrictBool] = Field(default=None, description="Optional. Whether to enable Linux `auditd` logging on the workstation. When enabled, a service account must also be specified that has `logging.buckets.write` permission on the project. Operating system audit logging is distinct from [Cloud Audit Logs](https://cloud.google.com/workstations/docs/audit-logging).", alias="enableAuditAgent")
    encryption_key: Optional[CustomerEncryptionKey] = Field(default=None, alias="encryptionKey")
    ephemeral_directories: Optional[List[EphemeralDirectory]] = Field(default=None, description="Optional. Ephemeral directories which won't persist across workstation sessions.", alias="ephemeralDirectories")
    etag: Optional[StrictStr] = Field(default=None, description="Optional. Checksum computed by the server. May be sent on update and delete requests to make sure that the client has an up-to-date value before proceeding.")
    host: Optional[Host] = None
    idle_timeout: Optional[StrictStr] = Field(default=None, description="Optional. Number of seconds to wait before automatically stopping a workstation after it last received user traffic. A value of `\"0s\"` indicates that Cloud Workstations VMs created with this configuration should never time out due to idleness. Provide [duration](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration) terminated by `s` for seconds—for example, `\"7200s\"` (2 hours). The default is `\"1200s\"` (20 minutes).", alias="idleTimeout")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Optional. [Labels](https://cloud.google.com/workstations/docs/label-resources) that are applied to the workstation configuration and that are also propagated to the underlying Compute Engine resources.")
    name: Optional[StrictStr] = Field(default=None, description="Identifier. Full name of this workstation configuration.")
    persistent_directories: Optional[List[PersistentDirectory]] = Field(default=None, description="Optional. Directories to persist across workstation sessions.", alias="persistentDirectories")
    readiness_checks: Optional[List[ReadinessCheck]] = Field(default=None, description="Optional. Readiness checks to perform when starting a workstation using this workstation configuration. Mark a workstation as running only after all specified readiness checks return 200 status codes.", alias="readinessChecks")
    reconciling: Optional[StrictBool] = Field(default=None, description="Output only. Indicates whether this workstation configuration is currently being updated to match its intended state.")
    replica_zones: Optional[List[StrictStr]] = Field(default=None, description="Optional. Immutable. Specifies the zones used to replicate the VM and disk resources within the region. If set, exactly two zones within the workstation cluster's region must be specified—for example, `['us-central1-a', 'us-central1-f']`. If this field is empty, two default zones within the region are used. Immutable after the workstation configuration is created.", alias="replicaZones")
    running_timeout: Optional[StrictStr] = Field(default=None, description="Optional. Number of seconds that a workstation can run until it is automatically shut down. We recommend that workstations be shut down daily to reduce costs and so that security updates can be applied upon restart. The idle_timeout and running_timeout fields are independent of each other. Note that the running_timeout field shuts down VMs after the specified time, regardless of whether or not the VMs are idle. Provide duration terminated by `s` for seconds—for example, `\"54000s\"` (15 hours). Defaults to `\"43200s\"` (12 hours). A value of `\"0s\"` indicates that workstations using this configuration should never time out. If encryption_key is set, it must be greater than `\"0s\"` and less than `\"86400s\"` (24 hours). Warning: A value of `\"0s\"` indicates that Cloud Workstations VMs created with this configuration have no maximum running time. This is strongly discouraged because you incur costs and will not pick up security updates.", alias="runningTimeout")
    uid: Optional[StrictStr] = Field(default=None, description="Output only. A system-assigned unique identifier for this workstation configuration.")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. Time when this workstation configuration was most recently updated.", alias="updateTime")
    __properties: ClassVar[List[str]] = ["annotations", "conditions", "container", "createTime", "degraded", "deleteTime", "disableTcpConnections", "displayName", "enableAuditAgent", "encryptionKey", "ephemeralDirectories", "etag", "host", "idleTimeout", "labels", "name", "persistentDirectories", "readinessChecks", "reconciling", "replicaZones", "runningTimeout", "uid", "updateTime"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of WorkstationConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "conditions",
            "create_time",
            "degraded",
            "delete_time",
            "reconciling",
            "uid",
            "update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in conditions (list)
        _items = []
        if self.conditions:
            for _item_conditions in self.conditions:
                if _item_conditions:
                    _items.append(_item_conditions.to_dict())
            _dict['conditions'] = _items
        # override the default output from pydantic by calling `to_dict()` of container
        if self.container:
            _dict['container'] = self.container.to_dict()
        # override the default output from pydantic by calling `to_dict()` of encryption_key
        if self.encryption_key:
            _dict['encryptionKey'] = self.encryption_key.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in ephemeral_directories (list)
        _items = []
        if self.ephemeral_directories:
            for _item_ephemeral_directories in self.ephemeral_directories:
                if _item_ephemeral_directories:
                    _items.append(_item_ephemeral_directories.to_dict())
            _dict['ephemeralDirectories'] = _items
        # override the default output from pydantic by calling `to_dict()` of host
        if self.host:
            _dict['host'] = self.host.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in persistent_directories (list)
        _items = []
        if self.persistent_directories:
            for _item_persistent_directories in self.persistent_directories:
                if _item_persistent_directories:
                    _items.append(_item_persistent_directories.to_dict())
            _dict['persistentDirectories'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in readiness_checks (list)
        _items = []
        if self.readiness_checks:
            for _item_readiness_checks in self.readiness_checks:
                if _item_readiness_checks:
                    _items.append(_item_readiness_checks.to_dict())
            _dict['readinessChecks'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of WorkstationConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "annotations": obj.get("annotations"),
            "conditions": [Status.from_dict(_item) for _item in obj["conditions"]] if obj.get("conditions") is not None else None,
            "container": Container.from_dict(obj["container"]) if obj.get("container") is not None else None,
            "createTime": obj.get("createTime"),
            "degraded": obj.get("degraded"),
            "deleteTime": obj.get("deleteTime"),
            "disableTcpConnections": obj.get("disableTcpConnections"),
            "displayName": obj.get("displayName"),
            "enableAuditAgent": obj.get("enableAuditAgent"),
            "encryptionKey": CustomerEncryptionKey.from_dict(obj["encryptionKey"]) if obj.get("encryptionKey") is not None else None,
            "ephemeralDirectories": [EphemeralDirectory.from_dict(_item) for _item in obj["ephemeralDirectories"]] if obj.get("ephemeralDirectories") is not None else None,
            "etag": obj.get("etag"),
            "host": Host.from_dict(obj["host"]) if obj.get("host") is not None else None,
            "idleTimeout": obj.get("idleTimeout"),
            "labels": obj.get("labels"),
            "name": obj.get("name"),
            "persistentDirectories": [PersistentDirectory.from_dict(_item) for _item in obj["persistentDirectories"]] if obj.get("persistentDirectories") is not None else None,
            "readinessChecks": [ReadinessCheck.from_dict(_item) for _item in obj["readinessChecks"]] if obj.get("readinessChecks") is not None else None,
            "reconciling": obj.get("reconciling"),
            "replicaZones": obj.get("replicaZones"),
            "runningTimeout": obj.get("runningTimeout"),
            "uid": obj.get("uid"),
            "updateTime": obj.get("updateTime")
        })
        return _obj


