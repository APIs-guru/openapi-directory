# coding: utf-8

"""
    Google Tasks API

    The Google Tasks API lets you manage your tasks and task lists.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.task_links_inner import TaskLinksInner
from typing import Optional, Set
from typing_extensions import Self

class Task(BaseModel):
    """
    Task
    """ # noqa: E501
    completed: Optional[StrictStr] = Field(default=None, description="Completion date of the task (as a RFC 3339 timestamp). This field is omitted if the task has not been completed.")
    deleted: Optional[StrictBool] = Field(default=None, description="Flag indicating whether the task has been deleted. The default is False.")
    due: Optional[StrictStr] = Field(default=None, description="Due date of the task (as a RFC 3339 timestamp). Optional. The due date only records date information; the time portion of the timestamp is discarded when setting the due date. It isn't possible to read or write the time that a task is due via the API.")
    etag: Optional[StrictStr] = Field(default=None, description="ETag of the resource.")
    hidden: Optional[StrictBool] = Field(default=None, description="Flag indicating whether the task is hidden. This is the case if the task had been marked completed when the task list was last cleared. The default is False. This field is read-only.")
    id: Optional[StrictStr] = Field(default=None, description="Task identifier.")
    kind: Optional[StrictStr] = Field(default=None, description="Type of the resource. This is always \"tasks#task\".")
    links: Optional[List[TaskLinksInner]] = Field(default=None, description="Collection of links. This collection is read-only.")
    notes: Optional[StrictStr] = Field(default=None, description="Notes describing the task. Optional.")
    parent: Optional[StrictStr] = Field(default=None, description="Parent task identifier. This field is omitted if it is a top-level task. This field is read-only. Use the \"move\" method to move the task under a different parent or to the top level.")
    position: Optional[StrictStr] = Field(default=None, description="String indicating the position of the task among its sibling tasks under the same parent task or at the top level. If this string is greater than another task's corresponding position string according to lexicographical ordering, the task is positioned after the other task under the same parent task (or at the top level). This field is read-only. Use the \"move\" method to move the task to another position.")
    self_link: Optional[StrictStr] = Field(default=None, description="URL pointing to this task. Used to retrieve, update, or delete this task.", alias="selfLink")
    status: Optional[StrictStr] = Field(default=None, description="Status of the task. This is either \"needsAction\" or \"completed\".")
    title: Optional[StrictStr] = Field(default=None, description="Title of the task.")
    updated: Optional[StrictStr] = Field(default=None, description="Last modification time of the task (as a RFC 3339 timestamp).")
    __properties: ClassVar[List[str]] = ["completed", "deleted", "due", "etag", "hidden", "id", "kind", "links", "notes", "parent", "position", "selfLink", "status", "title", "updated"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Task from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in links (list)
        _items = []
        if self.links:
            for _item_links in self.links:
                if _item_links:
                    _items.append(_item_links.to_dict())
            _dict['links'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Task from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "completed": obj.get("completed"),
            "deleted": obj.get("deleted"),
            "due": obj.get("due"),
            "etag": obj.get("etag"),
            "hidden": obj.get("hidden"),
            "id": obj.get("id"),
            "kind": obj.get("kind"),
            "links": [TaskLinksInner.from_dict(_item) for _item in obj["links"]] if obj.get("links") is not None else None,
            "notes": obj.get("notes"),
            "parent": obj.get("parent"),
            "position": obj.get("position"),
            "selfLink": obj.get("selfLink"),
            "status": obj.get("status"),
            "title": obj.get("title"),
            "updated": obj.get("updated")
        })
        return _obj


