# coding: utf-8

"""
    GKE Hub API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1alpha
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.common_feature_spec import CommonFeatureSpec
from openapi_client.models.common_feature_state import CommonFeatureState
from openapi_client.models.common_fleet_default_member_config_spec import CommonFleetDefaultMemberConfigSpec
from openapi_client.models.feature_resource_state import FeatureResourceState
from openapi_client.models.membership_feature_spec import MembershipFeatureSpec
from openapi_client.models.membership_feature_state import MembershipFeatureState
from openapi_client.models.scope_feature_spec import ScopeFeatureSpec
from openapi_client.models.scope_feature_state import ScopeFeatureState
from typing import Optional, Set
from typing_extensions import Self

class Feature(BaseModel):
    """
    Feature represents the settings and status of any Hub Feature.
    """ # noqa: E501
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. When the Feature resource was created.", alias="createTime")
    delete_time: Optional[StrictStr] = Field(default=None, description="Output only. When the Feature resource was deleted.", alias="deleteTime")
    fleet_default_member_config: Optional[CommonFleetDefaultMemberConfigSpec] = Field(default=None, alias="fleetDefaultMemberConfig")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Labels for this Feature.")
    membership_specs: Optional[Dict[str, MembershipFeatureSpec]] = Field(default=None, description="Optional. Membership-specific configuration for this Feature. If this Feature does not support any per-Membership configuration, this field may be unused. The keys indicate which Membership the configuration is for, in the form: `projects/{p}/locations/{l}/memberships/{m}` Where {p} is the project, {l} is a valid location and {m} is a valid Membership in this project at that location. {p} WILL match the Feature's project. {p} will always be returned as the project number, but the project ID is also accepted during input. If the same Membership is specified in the map twice (using the project ID form, and the project number form), exactly ONE of the entries will be saved, with no guarantees as to which. For this reason, it is recommended the same format be used for all entries when mutating a Feature.", alias="membershipSpecs")
    membership_states: Optional[Dict[str, MembershipFeatureState]] = Field(default=None, description="Output only. Membership-specific Feature status. If this Feature does report any per-Membership status, this field may be unused. The keys indicate which Membership the state is for, in the form: `projects/{p}/locations/{l}/memberships/{m}` Where {p} is the project number, {l} is a valid location and {m} is a valid Membership in this project at that location. {p} MUST match the Feature's project number.", alias="membershipStates")
    name: Optional[StrictStr] = Field(default=None, description="Output only. The full, unique name of this Feature resource in the format `projects/*/locations/*/features/*`.")
    resource_state: Optional[FeatureResourceState] = Field(default=None, alias="resourceState")
    scope_specs: Optional[Dict[str, ScopeFeatureSpec]] = Field(default=None, description="Optional. Scope-specific configuration for this Feature. If this Feature does not support any per-Scope configuration, this field may be unused. The keys indicate which Scope the configuration is for, in the form: `projects/{p}/locations/global/scopes/{s}` Where {p} is the project, {s} is a valid Scope in this project. {p} WILL match the Feature's project. {p} will always be returned as the project number, but the project ID is also accepted during input. If the same Scope is specified in the map twice (using the project ID form, and the project number form), exactly ONE of the entries will be saved, with no guarantees as to which. For this reason, it is recommended the same format be used for all entries when mutating a Feature.", alias="scopeSpecs")
    scope_states: Optional[Dict[str, ScopeFeatureState]] = Field(default=None, description="Output only. Scope-specific Feature status. If this Feature does report any per-Scope status, this field may be unused. The keys indicate which Scope the state is for, in the form: `projects/{p}/locations/global/scopes/{s}` Where {p} is the project, {s} is a valid Scope in this project. {p} WILL match the Feature's project.", alias="scopeStates")
    spec: Optional[CommonFeatureSpec] = None
    state: Optional[CommonFeatureState] = None
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. When the Feature resource was last updated.", alias="updateTime")
    __properties: ClassVar[List[str]] = ["createTime", "deleteTime", "fleetDefaultMemberConfig", "labels", "membershipSpecs", "membershipStates", "name", "resourceState", "scopeSpecs", "scopeStates", "spec", "state", "updateTime"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Feature from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "delete_time",
            "membership_states",
            "name",
            "scope_states",
            "update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of fleet_default_member_config
        if self.fleet_default_member_config:
            _dict['fleetDefaultMemberConfig'] = self.fleet_default_member_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in membership_specs (dict)
        _field_dict = {}
        if self.membership_specs:
            for _key_membership_specs in self.membership_specs:
                if self.membership_specs[_key_membership_specs]:
                    _field_dict[_key_membership_specs] = self.membership_specs[_key_membership_specs].to_dict()
            _dict['membershipSpecs'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in membership_states (dict)
        _field_dict = {}
        if self.membership_states:
            for _key_membership_states in self.membership_states:
                if self.membership_states[_key_membership_states]:
                    _field_dict[_key_membership_states] = self.membership_states[_key_membership_states].to_dict()
            _dict['membershipStates'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of resource_state
        if self.resource_state:
            _dict['resourceState'] = self.resource_state.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in scope_specs (dict)
        _field_dict = {}
        if self.scope_specs:
            for _key_scope_specs in self.scope_specs:
                if self.scope_specs[_key_scope_specs]:
                    _field_dict[_key_scope_specs] = self.scope_specs[_key_scope_specs].to_dict()
            _dict['scopeSpecs'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in scope_states (dict)
        _field_dict = {}
        if self.scope_states:
            for _key_scope_states in self.scope_states:
                if self.scope_states[_key_scope_states]:
                    _field_dict[_key_scope_states] = self.scope_states[_key_scope_states].to_dict()
            _dict['scopeStates'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of spec
        if self.spec:
            _dict['spec'] = self.spec.to_dict()
        # override the default output from pydantic by calling `to_dict()` of state
        if self.state:
            _dict['state'] = self.state.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Feature from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "createTime": obj.get("createTime"),
            "deleteTime": obj.get("deleteTime"),
            "fleetDefaultMemberConfig": CommonFleetDefaultMemberConfigSpec.from_dict(obj["fleetDefaultMemberConfig"]) if obj.get("fleetDefaultMemberConfig") is not None else None,
            "labels": obj.get("labels"),
            "membershipSpecs": dict(
                (_k, MembershipFeatureSpec.from_dict(_v))
                for _k, _v in obj["membershipSpecs"].items()
            )
            if obj.get("membershipSpecs") is not None
            else None,
            "membershipStates": dict(
                (_k, MembershipFeatureState.from_dict(_v))
                for _k, _v in obj["membershipStates"].items()
            )
            if obj.get("membershipStates") is not None
            else None,
            "name": obj.get("name"),
            "resourceState": FeatureResourceState.from_dict(obj["resourceState"]) if obj.get("resourceState") is not None else None,
            "scopeSpecs": dict(
                (_k, ScopeFeatureSpec.from_dict(_v))
                for _k, _v in obj["scopeSpecs"].items()
            )
            if obj.get("scopeSpecs") is not None
            else None,
            "scopeStates": dict(
                (_k, ScopeFeatureState.from_dict(_v))
                for _k, _v in obj["scopeStates"].items()
            )
            if obj.get("scopeStates") is not None
            else None,
            "spec": CommonFeatureSpec.from_dict(obj["spec"]) if obj.get("spec") is not None else None,
            "state": CommonFeatureState.from_dict(obj["state"]) if obj.get("state") is not None else None,
            "updateTime": obj.get("updateTime")
        })
        return _obj


