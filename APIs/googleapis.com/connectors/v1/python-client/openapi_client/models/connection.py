# coding: utf-8

"""
    Connectors API

    Enables users to create and manage connections to Google Cloud services and third-party business applications using the Connectors interface.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.auth_config import AuthConfig
from openapi_client.models.config_variable import ConfigVariable
from openapi_client.models.connection_status import ConnectionStatus
from openapi_client.models.connector_version_infra_config import ConnectorVersionInfraConfig
from openapi_client.models.connectors_log_config import ConnectorsLogConfig
from openapi_client.models.destination_config import DestinationConfig
from openapi_client.models.eventing_config import EventingConfig
from openapi_client.models.eventing_runtime_data import EventingRuntimeData
from openapi_client.models.lock_config import LockConfig
from openapi_client.models.node_config import NodeConfig
from openapi_client.models.ssl_config import SslConfig
from typing import Optional, Set
from typing_extensions import Self

class Connection(BaseModel):
    """
    Connection represents an instance of connector.
    """ # noqa: E501
    auth_config: Optional[AuthConfig] = Field(default=None, alias="authConfig")
    config_variables: Optional[List[ConfigVariable]] = Field(default=None, description="Optional. Configuration for configuring the connection with an external system.", alias="configVariables")
    connection_revision: Optional[StrictStr] = Field(default=None, description="Output only. Connection revision. This field is only updated when the connection is created or updated by User.", alias="connectionRevision")
    connector_version: Optional[StrictStr] = Field(default=None, description="Required. Connector version on which the connection is created. The format is: projects/*/locations/*/providers/*/connectors/*/versions/* Only global location is supported for ConnectorVersion resource.", alias="connectorVersion")
    connector_version_infra_config: Optional[ConnectorVersionInfraConfig] = Field(default=None, alias="connectorVersionInfraConfig")
    connector_version_launch_stage: Optional[StrictStr] = Field(default=None, description="Output only. Flag to mark the version indicating the launch stage.", alias="connectorVersionLaunchStage")
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. Created time.", alias="createTime")
    description: Optional[StrictStr] = Field(default=None, description="Optional. Description of the resource.")
    destination_configs: Optional[List[DestinationConfig]] = Field(default=None, description="Optional. Configuration of the Connector's destination. Only accepted for Connectors that accepts user defined destination(s).", alias="destinationConfigs")
    envoy_image_location: Optional[StrictStr] = Field(default=None, description="Output only. GCR location where the envoy image is stored. formatted like: gcr.io/{bucketName}/{imageName}", alias="envoyImageLocation")
    eventing_config: Optional[EventingConfig] = Field(default=None, alias="eventingConfig")
    eventing_enablement_type: Optional[StrictStr] = Field(default=None, description="Optional. Eventing enablement type. Will be nil if eventing is not enabled.", alias="eventingEnablementType")
    eventing_runtime_data: Optional[EventingRuntimeData] = Field(default=None, alias="eventingRuntimeData")
    image_location: Optional[StrictStr] = Field(default=None, description="Output only. GCR location where the runtime image is stored. formatted like: gcr.io/{bucketName}/{imageName}", alias="imageLocation")
    is_trusted_tester: Optional[StrictBool] = Field(default=None, description="Output only. Is trusted tester program enabled for the project.", alias="isTrustedTester")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Optional. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources")
    lock_config: Optional[LockConfig] = Field(default=None, alias="lockConfig")
    log_config: Optional[ConnectorsLogConfig] = Field(default=None, alias="logConfig")
    name: Optional[StrictStr] = Field(default=None, description="Output only. Resource name of the Connection. Format: projects/{project}/locations/{location}/connections/{connection}")
    node_config: Optional[NodeConfig] = Field(default=None, alias="nodeConfig")
    service_account: Optional[StrictStr] = Field(default=None, description="Optional. Service account needed for runtime plane to access Google Cloud resources.", alias="serviceAccount")
    service_directory: Optional[StrictStr] = Field(default=None, description="Output only. The name of the Service Directory service name. Used for Private Harpoon to resolve the ILB address. e.g. \"projects/cloud-connectors-e2e-testing/locations/us-central1/namespaces/istio-system/services/istio-ingressgateway-connectors\"", alias="serviceDirectory")
    ssl_config: Optional[SslConfig] = Field(default=None, alias="sslConfig")
    status: Optional[ConnectionStatus] = None
    subscription_type: Optional[StrictStr] = Field(default=None, description="Output only. This subscription type enum states the subscription type of the project.", alias="subscriptionType")
    suspended: Optional[StrictBool] = Field(default=None, description="Optional. Suspended indicates if a user has suspended a connection or not.")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. Updated time.", alias="updateTime")
    __properties: ClassVar[List[str]] = ["authConfig", "configVariables", "connectionRevision", "connectorVersion", "connectorVersionInfraConfig", "connectorVersionLaunchStage", "createTime", "description", "destinationConfigs", "envoyImageLocation", "eventingConfig", "eventingEnablementType", "eventingRuntimeData", "imageLocation", "isTrustedTester", "labels", "lockConfig", "logConfig", "name", "nodeConfig", "serviceAccount", "serviceDirectory", "sslConfig", "status", "subscriptionType", "suspended", "updateTime"]

    @field_validator('connector_version_launch_stage')
    def connector_version_launch_stage_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['LAUNCH_STAGE_UNSPECIFIED', 'PREVIEW', 'GA', 'DEPRECATED', 'PRIVATE_PREVIEW']):
            raise ValueError("must be one of enum values ('LAUNCH_STAGE_UNSPECIFIED', 'PREVIEW', 'GA', 'DEPRECATED', 'PRIVATE_PREVIEW')")
        return value

    @field_validator('eventing_enablement_type')
    def eventing_enablement_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['EVENTING_ENABLEMENT_TYPE_UNSPECIFIED', 'EVENTING_AND_CONNECTION', 'ONLY_EVENTING']):
            raise ValueError("must be one of enum values ('EVENTING_ENABLEMENT_TYPE_UNSPECIFIED', 'EVENTING_AND_CONNECTION', 'ONLY_EVENTING')")
        return value

    @field_validator('subscription_type')
    def subscription_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SUBSCRIPTION_TYPE_UNSPECIFIED', 'PAY_G', 'PAID']):
            raise ValueError("must be one of enum values ('SUBSCRIPTION_TYPE_UNSPECIFIED', 'PAY_G', 'PAID')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Connection from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "connection_revision",
            "connector_version_launch_stage",
            "create_time",
            "envoy_image_location",
            "image_location",
            "is_trusted_tester",
            "name",
            "service_directory",
            "subscription_type",
            "update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of auth_config
        if self.auth_config:
            _dict['authConfig'] = self.auth_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in config_variables (list)
        _items = []
        if self.config_variables:
            for _item_config_variables in self.config_variables:
                if _item_config_variables:
                    _items.append(_item_config_variables.to_dict())
            _dict['configVariables'] = _items
        # override the default output from pydantic by calling `to_dict()` of connector_version_infra_config
        if self.connector_version_infra_config:
            _dict['connectorVersionInfraConfig'] = self.connector_version_infra_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in destination_configs (list)
        _items = []
        if self.destination_configs:
            for _item_destination_configs in self.destination_configs:
                if _item_destination_configs:
                    _items.append(_item_destination_configs.to_dict())
            _dict['destinationConfigs'] = _items
        # override the default output from pydantic by calling `to_dict()` of eventing_config
        if self.eventing_config:
            _dict['eventingConfig'] = self.eventing_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of eventing_runtime_data
        if self.eventing_runtime_data:
            _dict['eventingRuntimeData'] = self.eventing_runtime_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of lock_config
        if self.lock_config:
            _dict['lockConfig'] = self.lock_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of log_config
        if self.log_config:
            _dict['logConfig'] = self.log_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of node_config
        if self.node_config:
            _dict['nodeConfig'] = self.node_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ssl_config
        if self.ssl_config:
            _dict['sslConfig'] = self.ssl_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of status
        if self.status:
            _dict['status'] = self.status.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Connection from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "authConfig": AuthConfig.from_dict(obj["authConfig"]) if obj.get("authConfig") is not None else None,
            "configVariables": [ConfigVariable.from_dict(_item) for _item in obj["configVariables"]] if obj.get("configVariables") is not None else None,
            "connectionRevision": obj.get("connectionRevision"),
            "connectorVersion": obj.get("connectorVersion"),
            "connectorVersionInfraConfig": ConnectorVersionInfraConfig.from_dict(obj["connectorVersionInfraConfig"]) if obj.get("connectorVersionInfraConfig") is not None else None,
            "connectorVersionLaunchStage": obj.get("connectorVersionLaunchStage"),
            "createTime": obj.get("createTime"),
            "description": obj.get("description"),
            "destinationConfigs": [DestinationConfig.from_dict(_item) for _item in obj["destinationConfigs"]] if obj.get("destinationConfigs") is not None else None,
            "envoyImageLocation": obj.get("envoyImageLocation"),
            "eventingConfig": EventingConfig.from_dict(obj["eventingConfig"]) if obj.get("eventingConfig") is not None else None,
            "eventingEnablementType": obj.get("eventingEnablementType"),
            "eventingRuntimeData": EventingRuntimeData.from_dict(obj["eventingRuntimeData"]) if obj.get("eventingRuntimeData") is not None else None,
            "imageLocation": obj.get("imageLocation"),
            "isTrustedTester": obj.get("isTrustedTester"),
            "labels": obj.get("labels"),
            "lockConfig": LockConfig.from_dict(obj["lockConfig"]) if obj.get("lockConfig") is not None else None,
            "logConfig": ConnectorsLogConfig.from_dict(obj["logConfig"]) if obj.get("logConfig") is not None else None,
            "name": obj.get("name"),
            "nodeConfig": NodeConfig.from_dict(obj["nodeConfig"]) if obj.get("nodeConfig") is not None else None,
            "serviceAccount": obj.get("serviceAccount"),
            "serviceDirectory": obj.get("serviceDirectory"),
            "sslConfig": SslConfig.from_dict(obj["sslConfig"]) if obj.get("sslConfig") is not None else None,
            "status": ConnectionStatus.from_dict(obj["status"]) if obj.get("status") is not None else None,
            "subscriptionType": obj.get("subscriptionType"),
            "suspended": obj.get("suspended"),
            "updateTime": obj.get("updateTime")
        })
        return _obj


