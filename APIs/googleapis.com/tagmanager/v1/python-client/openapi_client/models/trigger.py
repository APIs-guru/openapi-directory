# coding: utf-8

"""
    Tag Manager API

    This API allows clients to access and modify container and tag configuration.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.condition import Condition
from openapi_client.models.parameter import Parameter
from typing import Optional, Set
from typing_extensions import Self

class Trigger(BaseModel):
    """
    Represents a Google Tag Manager Trigger
    """ # noqa: E501
    account_id: Optional[StrictStr] = Field(default=None, description="GTM Account ID.", alias="accountId")
    auto_event_filter: Optional[List[Condition]] = Field(default=None, description="Used in the case of auto event tracking. @mutable tagmanager.accounts.containers.triggers.create @mutable tagmanager.accounts.containers.triggers.update", alias="autoEventFilter")
    check_validation: Optional[Parameter] = Field(default=None, alias="checkValidation")
    container_id: Optional[StrictStr] = Field(default=None, description="GTM Container ID.", alias="containerId")
    continuous_time_min_milliseconds: Optional[Parameter] = Field(default=None, alias="continuousTimeMinMilliseconds")
    custom_event_filter: Optional[List[Condition]] = Field(default=None, description="Used in the case of custom event, which is fired iff all Conditions are true. @mutable tagmanager.accounts.containers.triggers.create @mutable tagmanager.accounts.containers.triggers.update", alias="customEventFilter")
    event_name: Optional[Parameter] = Field(default=None, alias="eventName")
    filter: Optional[List[Condition]] = Field(default=None, description="The trigger will only fire iff all Conditions are true. @mutable tagmanager.accounts.containers.triggers.create @mutable tagmanager.accounts.containers.triggers.update")
    fingerprint: Optional[StrictStr] = Field(default=None, description="The fingerprint of the GTM Trigger as computed at storage time. This value is recomputed whenever the trigger is modified.")
    horizontal_scroll_percentage_list: Optional[Parameter] = Field(default=None, alias="horizontalScrollPercentageList")
    interval: Optional[Parameter] = None
    interval_seconds: Optional[Parameter] = Field(default=None, alias="intervalSeconds")
    limit: Optional[Parameter] = None
    max_timer_length_seconds: Optional[Parameter] = Field(default=None, alias="maxTimerLengthSeconds")
    name: Optional[StrictStr] = Field(default=None, description="Trigger display name. @mutable tagmanager.accounts.containers.triggers.create @mutable tagmanager.accounts.containers.triggers.update")
    parameter: Optional[List[Parameter]] = Field(default=None, description="Additional parameters. @mutable tagmanager.accounts.containers.workspaces.triggers.create @mutable tagmanager.accounts.containers.workspaces.triggers.update")
    parent_folder_id: Optional[StrictStr] = Field(default=None, description="Parent folder id.", alias="parentFolderId")
    selector: Optional[Parameter] = None
    total_time_min_milliseconds: Optional[Parameter] = Field(default=None, alias="totalTimeMinMilliseconds")
    trigger_id: Optional[StrictStr] = Field(default=None, description="The Trigger ID uniquely identifies the GTM Trigger.", alias="triggerId")
    type: Optional[StrictStr] = Field(default=None, description="Defines the data layer event that causes this trigger. @mutable tagmanager.accounts.containers.triggers.create @mutable tagmanager.accounts.containers.triggers.update")
    unique_trigger_id: Optional[Parameter] = Field(default=None, alias="uniqueTriggerId")
    vertical_scroll_percentage_list: Optional[Parameter] = Field(default=None, alias="verticalScrollPercentageList")
    visibility_selector: Optional[Parameter] = Field(default=None, alias="visibilitySelector")
    visible_percentage_max: Optional[Parameter] = Field(default=None, alias="visiblePercentageMax")
    visible_percentage_min: Optional[Parameter] = Field(default=None, alias="visiblePercentageMin")
    wait_for_tags: Optional[Parameter] = Field(default=None, alias="waitForTags")
    wait_for_tags_timeout: Optional[Parameter] = Field(default=None, alias="waitForTagsTimeout")
    __properties: ClassVar[List[str]] = ["accountId", "autoEventFilter", "checkValidation", "containerId", "continuousTimeMinMilliseconds", "customEventFilter", "eventName", "filter", "fingerprint", "horizontalScrollPercentageList", "interval", "intervalSeconds", "limit", "maxTimerLengthSeconds", "name", "parameter", "parentFolderId", "selector", "totalTimeMinMilliseconds", "triggerId", "type", "uniqueTriggerId", "verticalScrollPercentageList", "visibilitySelector", "visiblePercentageMax", "visiblePercentageMin", "waitForTags", "waitForTagsTimeout"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['pageview', 'domReady', 'windowLoaded', 'customEvent', 'triggerGroup', 'always', 'formSubmission', 'click', 'linkClick', 'jsError', 'historyChange', 'timer', 'ampClick', 'ampTimer', 'ampScroll', 'ampVisibility', 'youTubeVideo', 'scrollDepth', 'elementVisibility']):
            raise ValueError("must be one of enum values ('pageview', 'domReady', 'windowLoaded', 'customEvent', 'triggerGroup', 'always', 'formSubmission', 'click', 'linkClick', 'jsError', 'historyChange', 'timer', 'ampClick', 'ampTimer', 'ampScroll', 'ampVisibility', 'youTubeVideo', 'scrollDepth', 'elementVisibility')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Trigger from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in auto_event_filter (list)
        _items = []
        if self.auto_event_filter:
            for _item_auto_event_filter in self.auto_event_filter:
                if _item_auto_event_filter:
                    _items.append(_item_auto_event_filter.to_dict())
            _dict['autoEventFilter'] = _items
        # override the default output from pydantic by calling `to_dict()` of check_validation
        if self.check_validation:
            _dict['checkValidation'] = self.check_validation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of continuous_time_min_milliseconds
        if self.continuous_time_min_milliseconds:
            _dict['continuousTimeMinMilliseconds'] = self.continuous_time_min_milliseconds.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in custom_event_filter (list)
        _items = []
        if self.custom_event_filter:
            for _item_custom_event_filter in self.custom_event_filter:
                if _item_custom_event_filter:
                    _items.append(_item_custom_event_filter.to_dict())
            _dict['customEventFilter'] = _items
        # override the default output from pydantic by calling `to_dict()` of event_name
        if self.event_name:
            _dict['eventName'] = self.event_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in filter (list)
        _items = []
        if self.filter:
            for _item_filter in self.filter:
                if _item_filter:
                    _items.append(_item_filter.to_dict())
            _dict['filter'] = _items
        # override the default output from pydantic by calling `to_dict()` of horizontal_scroll_percentage_list
        if self.horizontal_scroll_percentage_list:
            _dict['horizontalScrollPercentageList'] = self.horizontal_scroll_percentage_list.to_dict()
        # override the default output from pydantic by calling `to_dict()` of interval
        if self.interval:
            _dict['interval'] = self.interval.to_dict()
        # override the default output from pydantic by calling `to_dict()` of interval_seconds
        if self.interval_seconds:
            _dict['intervalSeconds'] = self.interval_seconds.to_dict()
        # override the default output from pydantic by calling `to_dict()` of limit
        if self.limit:
            _dict['limit'] = self.limit.to_dict()
        # override the default output from pydantic by calling `to_dict()` of max_timer_length_seconds
        if self.max_timer_length_seconds:
            _dict['maxTimerLengthSeconds'] = self.max_timer_length_seconds.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in parameter (list)
        _items = []
        if self.parameter:
            for _item_parameter in self.parameter:
                if _item_parameter:
                    _items.append(_item_parameter.to_dict())
            _dict['parameter'] = _items
        # override the default output from pydantic by calling `to_dict()` of selector
        if self.selector:
            _dict['selector'] = self.selector.to_dict()
        # override the default output from pydantic by calling `to_dict()` of total_time_min_milliseconds
        if self.total_time_min_milliseconds:
            _dict['totalTimeMinMilliseconds'] = self.total_time_min_milliseconds.to_dict()
        # override the default output from pydantic by calling `to_dict()` of unique_trigger_id
        if self.unique_trigger_id:
            _dict['uniqueTriggerId'] = self.unique_trigger_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of vertical_scroll_percentage_list
        if self.vertical_scroll_percentage_list:
            _dict['verticalScrollPercentageList'] = self.vertical_scroll_percentage_list.to_dict()
        # override the default output from pydantic by calling `to_dict()` of visibility_selector
        if self.visibility_selector:
            _dict['visibilitySelector'] = self.visibility_selector.to_dict()
        # override the default output from pydantic by calling `to_dict()` of visible_percentage_max
        if self.visible_percentage_max:
            _dict['visiblePercentageMax'] = self.visible_percentage_max.to_dict()
        # override the default output from pydantic by calling `to_dict()` of visible_percentage_min
        if self.visible_percentage_min:
            _dict['visiblePercentageMin'] = self.visible_percentage_min.to_dict()
        # override the default output from pydantic by calling `to_dict()` of wait_for_tags
        if self.wait_for_tags:
            _dict['waitForTags'] = self.wait_for_tags.to_dict()
        # override the default output from pydantic by calling `to_dict()` of wait_for_tags_timeout
        if self.wait_for_tags_timeout:
            _dict['waitForTagsTimeout'] = self.wait_for_tags_timeout.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Trigger from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accountId": obj.get("accountId"),
            "autoEventFilter": [Condition.from_dict(_item) for _item in obj["autoEventFilter"]] if obj.get("autoEventFilter") is not None else None,
            "checkValidation": Parameter.from_dict(obj["checkValidation"]) if obj.get("checkValidation") is not None else None,
            "containerId": obj.get("containerId"),
            "continuousTimeMinMilliseconds": Parameter.from_dict(obj["continuousTimeMinMilliseconds"]) if obj.get("continuousTimeMinMilliseconds") is not None else None,
            "customEventFilter": [Condition.from_dict(_item) for _item in obj["customEventFilter"]] if obj.get("customEventFilter") is not None else None,
            "eventName": Parameter.from_dict(obj["eventName"]) if obj.get("eventName") is not None else None,
            "filter": [Condition.from_dict(_item) for _item in obj["filter"]] if obj.get("filter") is not None else None,
            "fingerprint": obj.get("fingerprint"),
            "horizontalScrollPercentageList": Parameter.from_dict(obj["horizontalScrollPercentageList"]) if obj.get("horizontalScrollPercentageList") is not None else None,
            "interval": Parameter.from_dict(obj["interval"]) if obj.get("interval") is not None else None,
            "intervalSeconds": Parameter.from_dict(obj["intervalSeconds"]) if obj.get("intervalSeconds") is not None else None,
            "limit": Parameter.from_dict(obj["limit"]) if obj.get("limit") is not None else None,
            "maxTimerLengthSeconds": Parameter.from_dict(obj["maxTimerLengthSeconds"]) if obj.get("maxTimerLengthSeconds") is not None else None,
            "name": obj.get("name"),
            "parameter": [Parameter.from_dict(_item) for _item in obj["parameter"]] if obj.get("parameter") is not None else None,
            "parentFolderId": obj.get("parentFolderId"),
            "selector": Parameter.from_dict(obj["selector"]) if obj.get("selector") is not None else None,
            "totalTimeMinMilliseconds": Parameter.from_dict(obj["totalTimeMinMilliseconds"]) if obj.get("totalTimeMinMilliseconds") is not None else None,
            "triggerId": obj.get("triggerId"),
            "type": obj.get("type"),
            "uniqueTriggerId": Parameter.from_dict(obj["uniqueTriggerId"]) if obj.get("uniqueTriggerId") is not None else None,
            "verticalScrollPercentageList": Parameter.from_dict(obj["verticalScrollPercentageList"]) if obj.get("verticalScrollPercentageList") is not None else None,
            "visibilitySelector": Parameter.from_dict(obj["visibilitySelector"]) if obj.get("visibilitySelector") is not None else None,
            "visiblePercentageMax": Parameter.from_dict(obj["visiblePercentageMax"]) if obj.get("visiblePercentageMax") is not None else None,
            "visiblePercentageMin": Parameter.from_dict(obj["visiblePercentageMin"]) if obj.get("visiblePercentageMin") is not None else None,
            "waitForTags": Parameter.from_dict(obj["waitForTags"]) if obj.get("waitForTags") is not None else None,
            "waitForTagsTimeout": Parameter.from_dict(obj["waitForTagsTimeout"]) if obj.get("waitForTagsTimeout") is not None else None
        })
        return _obj


