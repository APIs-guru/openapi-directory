# coding: utf-8

"""
    Tag Manager API

    This API allows clients to access and modify container and tag configuration.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class Container(BaseModel):
    """
    Represents a Google Tag Manager Container.
    """ # noqa: E501
    account_id: Optional[StrictStr] = Field(default=None, description="GTM Account ID.", alias="accountId")
    container_id: Optional[StrictStr] = Field(default=None, description="The Container ID uniquely identifies the GTM Container.", alias="containerId")
    domain_name: Optional[List[StrictStr]] = Field(default=None, description="Optional list of domain names associated with the Container. @mutable tagmanager.accounts.containers.create @mutable tagmanager.accounts.containers.update", alias="domainName")
    enabled_built_in_variable: Optional[List[StrictStr]] = Field(default=None, description="List of enabled built-in variables. Valid values include: pageUrl, pageHostname, pagePath, referrer, event, clickElement, clickClasses, clickId, clickTarget, clickUrl, clickText, formElement, formClasses, formId, formTarget, formUrl, formText, errorMessage, errorUrl, errorLine, newHistoryFragment, oldHistoryFragment, newHistoryState, oldHistoryState, historySource, containerVersion, debugMode, randomNumber, containerId. @mutable tagmanager.accounts.containers.create @mutable tagmanager.accounts.containers.update", alias="enabledBuiltInVariable")
    fingerprint: Optional[StrictStr] = Field(default=None, description="The fingerprint of the GTM Container as computed at storage time. This value is recomputed whenever the account is modified.")
    name: Optional[StrictStr] = Field(default=None, description="Container display name. @mutable tagmanager.accounts.containers.create @mutable tagmanager.accounts.containers.update")
    notes: Optional[StrictStr] = Field(default=None, description="Container Notes. @mutable tagmanager.accounts.containers.create @mutable tagmanager.accounts.containers.update")
    public_id: Optional[StrictStr] = Field(default=None, description="Container Public ID.", alias="publicId")
    time_zone_country_id: Optional[StrictStr] = Field(default=None, description="Container Country ID. @mutable tagmanager.accounts.containers.create @mutable tagmanager.accounts.containers.update", alias="timeZoneCountryId")
    time_zone_id: Optional[StrictStr] = Field(default=None, description="Container Time Zone ID. @mutable tagmanager.accounts.containers.create @mutable tagmanager.accounts.containers.update", alias="timeZoneId")
    usage_context: Optional[List[StrictStr]] = Field(default=None, description="List of Usage Contexts for the Container. Valid values include: web, android, ios. @mutable tagmanager.accounts.containers.create @mutable tagmanager.accounts.containers.update", alias="usageContext")
    __properties: ClassVar[List[str]] = ["accountId", "containerId", "domainName", "enabledBuiltInVariable", "fingerprint", "name", "notes", "publicId", "timeZoneCountryId", "timeZoneId", "usageContext"]

    @field_validator('enabled_built_in_variable')
    def enabled_built_in_variable_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['pageUrl', 'pageHostname', 'pagePath', 'referrer', 'event', 'clickElement', 'clickClasses', 'clickId', 'clickTarget', 'clickUrl', 'clickText', 'firstPartyServingUrl', 'formElement', 'formClasses', 'formId', 'formTarget', 'formUrl', 'formText', 'environmentName', 'errorMessage', 'errorUrl', 'errorLine', 'newHistoryUrl', 'oldHistoryUrl', 'newHistoryFragment', 'oldHistoryFragment', 'newHistoryState', 'oldHistoryState', 'historySource', 'containerVersion', 'debugMode', 'randomNumber', 'containerId', 'appId', 'appName', 'appVersionCode', 'appVersionName', 'language', 'osVersion', 'platform', 'sdkVersion', 'deviceName', 'resolution', 'advertiserId', 'advertisingTrackingEnabled', 'htmlId', 'ampBrowserLanguage', 'ampCanonicalPath', 'ampCanonicalUrl', 'ampCanonicalHost', 'ampReferrer', 'ampTitle', 'ampClientId', 'ampClientTimezone', 'ampClientTimestamp', 'ampClientScreenWidth', 'ampClientScreenHeight', 'ampClientScrollX', 'ampClientScrollY', 'ampClientMaxScrollX', 'ampClientMaxScrollY', 'ampTotalEngagedTime', 'ampPageViewId', 'ampPageLoadTime', 'ampPageDownloadTime', 'ampGtmEvent', 'eventName', 'firebaseEventParameterCampaign', 'firebaseEventParameterCampaignAclid', 'firebaseEventParameterCampaignAnid', 'firebaseEventParameterCampaignClickTimestamp', 'firebaseEventParameterCampaignContent', 'firebaseEventParameterCampaignCp1', 'firebaseEventParameterCampaignGclid', 'firebaseEventParameterCampaignSource', 'firebaseEventParameterCampaignTerm', 'firebaseEventParameterCurrency', 'firebaseEventParameterDynamicLinkAcceptTime', 'firebaseEventParameterDynamicLinkLinkid', 'firebaseEventParameterNotificationMessageDeviceTime', 'firebaseEventParameterNotificationMessageId', 'firebaseEventParameterNotificationMessageName', 'firebaseEventParameterNotificationMessageTime', 'firebaseEventParameterNotificationTopic', 'firebaseEventParameterPreviousAppVersion', 'firebaseEventParameterPreviousOsVersion', 'firebaseEventParameterPrice', 'firebaseEventParameterProductId', 'firebaseEventParameterQuantity', 'firebaseEventParameterValue', 'videoProvider', 'videoUrl', 'videoTitle', 'videoDuration', 'videoPercent', 'videoVisible', 'videoStatus', 'videoCurrentTime', 'scrollDepthThreshold', 'scrollDepthUnits', 'scrollDepthDirection', 'elementVisibilityRatio', 'elementVisibilityTime', 'elementVisibilityFirstTime', 'elementVisibilityRecentTime']):
                raise ValueError("each list item must be one of ('pageUrl', 'pageHostname', 'pagePath', 'referrer', 'event', 'clickElement', 'clickClasses', 'clickId', 'clickTarget', 'clickUrl', 'clickText', 'firstPartyServingUrl', 'formElement', 'formClasses', 'formId', 'formTarget', 'formUrl', 'formText', 'environmentName', 'errorMessage', 'errorUrl', 'errorLine', 'newHistoryUrl', 'oldHistoryUrl', 'newHistoryFragment', 'oldHistoryFragment', 'newHistoryState', 'oldHistoryState', 'historySource', 'containerVersion', 'debugMode', 'randomNumber', 'containerId', 'appId', 'appName', 'appVersionCode', 'appVersionName', 'language', 'osVersion', 'platform', 'sdkVersion', 'deviceName', 'resolution', 'advertiserId', 'advertisingTrackingEnabled', 'htmlId', 'ampBrowserLanguage', 'ampCanonicalPath', 'ampCanonicalUrl', 'ampCanonicalHost', 'ampReferrer', 'ampTitle', 'ampClientId', 'ampClientTimezone', 'ampClientTimestamp', 'ampClientScreenWidth', 'ampClientScreenHeight', 'ampClientScrollX', 'ampClientScrollY', 'ampClientMaxScrollX', 'ampClientMaxScrollY', 'ampTotalEngagedTime', 'ampPageViewId', 'ampPageLoadTime', 'ampPageDownloadTime', 'ampGtmEvent', 'eventName', 'firebaseEventParameterCampaign', 'firebaseEventParameterCampaignAclid', 'firebaseEventParameterCampaignAnid', 'firebaseEventParameterCampaignClickTimestamp', 'firebaseEventParameterCampaignContent', 'firebaseEventParameterCampaignCp1', 'firebaseEventParameterCampaignGclid', 'firebaseEventParameterCampaignSource', 'firebaseEventParameterCampaignTerm', 'firebaseEventParameterCurrency', 'firebaseEventParameterDynamicLinkAcceptTime', 'firebaseEventParameterDynamicLinkLinkid', 'firebaseEventParameterNotificationMessageDeviceTime', 'firebaseEventParameterNotificationMessageId', 'firebaseEventParameterNotificationMessageName', 'firebaseEventParameterNotificationMessageTime', 'firebaseEventParameterNotificationTopic', 'firebaseEventParameterPreviousAppVersion', 'firebaseEventParameterPreviousOsVersion', 'firebaseEventParameterPrice', 'firebaseEventParameterProductId', 'firebaseEventParameterQuantity', 'firebaseEventParameterValue', 'videoProvider', 'videoUrl', 'videoTitle', 'videoDuration', 'videoPercent', 'videoVisible', 'videoStatus', 'videoCurrentTime', 'scrollDepthThreshold', 'scrollDepthUnits', 'scrollDepthDirection', 'elementVisibilityRatio', 'elementVisibilityTime', 'elementVisibilityFirstTime', 'elementVisibilityRecentTime')")
        return value

    @field_validator('usage_context')
    def usage_context_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['web', 'android', 'ios', 'androidSdk5', 'iosSdk5', 'amp']):
                raise ValueError("each list item must be one of ('web', 'android', 'ios', 'androidSdk5', 'iosSdk5', 'amp')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Container from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Container from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accountId": obj.get("accountId"),
            "containerId": obj.get("containerId"),
            "domainName": obj.get("domainName"),
            "enabledBuiltInVariable": obj.get("enabledBuiltInVariable"),
            "fingerprint": obj.get("fingerprint"),
            "name": obj.get("name"),
            "notes": obj.get("notes"),
            "publicId": obj.get("publicId"),
            "timeZoneCountryId": obj.get("timeZoneCountryId"),
            "timeZoneId": obj.get("timeZoneId"),
            "usageContext": obj.get("usageContext")
        })
        return _obj


