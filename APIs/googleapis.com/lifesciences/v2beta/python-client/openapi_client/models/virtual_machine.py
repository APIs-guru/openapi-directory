# coding: utf-8

"""
    Cloud Life Sciences API

    Cloud Life Sciences is a suite of services and tools for managing, processing, and transforming life sciences data.

    The version of the OpenAPI document: v2beta
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.accelerator import Accelerator
from openapi_client.models.disk import Disk
from openapi_client.models.network import Network
from openapi_client.models.service_account import ServiceAccount
from openapi_client.models.volume import Volume
from typing import Optional, Set
from typing_extensions import Self

class VirtualMachine(BaseModel):
    """
    Carries information about a Compute Engine VM resource.
    """ # noqa: E501
    accelerators: Optional[List[Accelerator]] = Field(default=None, description="The list of accelerators to attach to the VM.")
    boot_disk_size_gb: Optional[StrictInt] = Field(default=None, description="The size of the boot disk, in GB. The boot disk must be large enough to accommodate all of the Docker images from each action in the pipeline at the same time. If not specified, a small but reasonable default value is used.", alias="bootDiskSizeGb")
    boot_image: Optional[StrictStr] = Field(default=None, description="The host operating system image to use. Currently, only Container-Optimized OS images can be used. The default value is `projects/cos-cloud/global/images/family/cos-stable`, which selects the latest stable release of Container-Optimized OS. This option is provided to allow testing against the beta release of the operating system to ensure that the new version does not interact negatively with production pipelines. To test a pipeline against the beta release of Container-Optimized OS, use the value `projects/cos-cloud/global/images/family/cos-beta`.", alias="bootImage")
    cpu_platform: Optional[StrictStr] = Field(default=None, description="The CPU platform to request. An instance based on a newer platform can be allocated, but never one with fewer capabilities. The value of this parameter must be a valid Compute Engine CPU platform name (such as \"Intel Skylake\"). This parameter is only useful for carefully optimized work loads where the CPU platform has a significant impact. For more information about the effect of this parameter, see https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.", alias="cpuPlatform")
    disks: Optional[List[Disk]] = Field(default=None, description="The list of disks to create and attach to the VM. Specify either the `volumes[]` field or the `disks[]` field, but not both.")
    docker_cache_images: Optional[List[StrictStr]] = Field(default=None, description="The Compute Engine Disk Images to use as a Docker cache. The disks will be mounted into the Docker folder in a way that the images present in the cache will not need to be pulled. The digests of the cached images must match those of the tags used or the latest version will still be pulled. The root directory of the ext4 image must contain `image` and `overlay2` directories copied from the Docker directory of a VM where the desired Docker images have already been pulled. Any images pulled that are not cached will be stored on the first cache disk instead of the boot disk. Only a single image is supported.", alias="dockerCacheImages")
    enable_stackdriver_monitoring: Optional[StrictBool] = Field(default=None, description="Whether Stackdriver monitoring should be enabled on the VM.", alias="enableStackdriverMonitoring")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Optional set of labels to apply to the VM and any attached disk resources. These labels must adhere to the [name and value restrictions](https://cloud.google.com/compute/docs/labeling-resources) on VM labels imposed by Compute Engine. Labels keys with the prefix 'google-' are reserved for use by Google. Labels applied at creation time to the VM. Applied on a best-effort basis to attached disk resources shortly after VM creation.")
    machine_type: Optional[StrictStr] = Field(default=None, description="Required. The machine type of the virtual machine to create. Must be the short name of a standard machine type (such as \"n1-standard-1\") or a custom machine type (such as \"custom-1-4096\", where \"1\" indicates the number of vCPUs and \"4096\" indicates the memory in MB). See [Creating an instance with a custom machine type](https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#create) for more specifications on creating a custom machine type.", alias="machineType")
    network: Optional[Network] = None
    nvidia_driver_version: Optional[StrictStr] = Field(default=None, description="The NVIDIA driver version to use when attaching an NVIDIA GPU accelerator. The version specified here must be compatible with the GPU libraries contained in the container being executed, and must be one of the drivers hosted in the `nvidia-drivers-us-public` bucket on Google Cloud Storage.", alias="nvidiaDriverVersion")
    preemptible: Optional[StrictBool] = Field(default=None, description="If true, allocate a preemptible VM.")
    reservation: Optional[StrictStr] = Field(default=None, description="If specified, the VM will only be allocated inside the matching reservation. It will fail if the VM parameters don't match the reservation.")
    service_account: Optional[ServiceAccount] = Field(default=None, alias="serviceAccount")
    volumes: Optional[List[Volume]] = Field(default=None, description="The list of disks and other storage to create or attach to the VM. Specify either the `volumes[]` field or the `disks[]` field, but not both.")
    __properties: ClassVar[List[str]] = ["accelerators", "bootDiskSizeGb", "bootImage", "cpuPlatform", "disks", "dockerCacheImages", "enableStackdriverMonitoring", "labels", "machineType", "network", "nvidiaDriverVersion", "preemptible", "reservation", "serviceAccount", "volumes"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VirtualMachine from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in accelerators (list)
        _items = []
        if self.accelerators:
            for _item_accelerators in self.accelerators:
                if _item_accelerators:
                    _items.append(_item_accelerators.to_dict())
            _dict['accelerators'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in disks (list)
        _items = []
        if self.disks:
            for _item_disks in self.disks:
                if _item_disks:
                    _items.append(_item_disks.to_dict())
            _dict['disks'] = _items
        # override the default output from pydantic by calling `to_dict()` of network
        if self.network:
            _dict['network'] = self.network.to_dict()
        # override the default output from pydantic by calling `to_dict()` of service_account
        if self.service_account:
            _dict['serviceAccount'] = self.service_account.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in volumes (list)
        _items = []
        if self.volumes:
            for _item_volumes in self.volumes:
                if _item_volumes:
                    _items.append(_item_volumes.to_dict())
            _dict['volumes'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VirtualMachine from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accelerators": [Accelerator.from_dict(_item) for _item in obj["accelerators"]] if obj.get("accelerators") is not None else None,
            "bootDiskSizeGb": obj.get("bootDiskSizeGb"),
            "bootImage": obj.get("bootImage"),
            "cpuPlatform": obj.get("cpuPlatform"),
            "disks": [Disk.from_dict(_item) for _item in obj["disks"]] if obj.get("disks") is not None else None,
            "dockerCacheImages": obj.get("dockerCacheImages"),
            "enableStackdriverMonitoring": obj.get("enableStackdriverMonitoring"),
            "labels": obj.get("labels"),
            "machineType": obj.get("machineType"),
            "network": Network.from_dict(obj["network"]) if obj.get("network") is not None else None,
            "nvidiaDriverVersion": obj.get("nvidiaDriverVersion"),
            "preemptible": obj.get("preemptible"),
            "reservation": obj.get("reservation"),
            "serviceAccount": ServiceAccount.from_dict(obj["serviceAccount"]) if obj.get("serviceAccount") is not None else None,
            "volumes": [Volume.from_dict(_item) for _item in obj["volumes"]] if obj.get("volumes") is not None else None
        })
        return _obj


