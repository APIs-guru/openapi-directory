# coding: utf-8

"""
    Network Security API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_networksecurity_v1_certificate_provider import GoogleCloudNetworksecurityV1CertificateProvider
from openapi_client.models.mtls_policy import MTLSPolicy
from typing import Optional, Set
from typing_extensions import Self

class ServerTlsPolicy(BaseModel):
    """
    ServerTlsPolicy is a resource that specifies how a server should authenticate incoming requests. This resource itself does not affect configuration unless it is attached to a target HTTPS proxy or endpoint config selector resource. ServerTlsPolicy in the form accepted by external HTTPS load balancers can be attached only to TargetHttpsProxy with an `EXTERNAL` or `EXTERNAL_MANAGED` load balancing scheme. Traffic Director compatible ServerTlsPolicies can be attached to EndpointPolicy and TargetHttpsProxy with Traffic Director `INTERNAL_SELF_MANAGED` load balancing scheme.
    """ # noqa: E501
    allow_open: Optional[StrictBool] = Field(default=None, description="This field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies. Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility. Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.", alias="allowOpen")
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. The timestamp when the resource was created.", alias="createTime")
    description: Optional[StrictStr] = Field(default=None, description="Free-text description of the resource.")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Set of label tags associated with the resource.")
    mtls_policy: Optional[MTLSPolicy] = Field(default=None, alias="mtlsPolicy")
    name: Optional[StrictStr] = Field(default=None, description="Required. Name of the ServerTlsPolicy resource. It matches the pattern `projects/*/locations/{location}/serverTlsPolicies/{server_tls_policy}`")
    server_certificate: Optional[GoogleCloudNetworksecurityV1CertificateProvider] = Field(default=None, alias="serverCertificate")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. The timestamp when the resource was updated.", alias="updateTime")
    __properties: ClassVar[List[str]] = ["allowOpen", "createTime", "description", "labels", "mtlsPolicy", "name", "serverCertificate", "updateTime"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ServerTlsPolicy from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of mtls_policy
        if self.mtls_policy:
            _dict['mtlsPolicy'] = self.mtls_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of server_certificate
        if self.server_certificate:
            _dict['serverCertificate'] = self.server_certificate.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ServerTlsPolicy from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "allowOpen": obj.get("allowOpen"),
            "createTime": obj.get("createTime"),
            "description": obj.get("description"),
            "labels": obj.get("labels"),
            "mtlsPolicy": MTLSPolicy.from_dict(obj["mtlsPolicy"]) if obj.get("mtlsPolicy") is not None else None,
            "name": obj.get("name"),
            "serverCertificate": GoogleCloudNetworksecurityV1CertificateProvider.from_dict(obj["serverCertificate"]) if obj.get("serverCertificate") is not None else None,
            "updateTime": obj.get("updateTime")
        })
        return _obj


