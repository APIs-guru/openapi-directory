# coding: utf-8

"""
    Campaign Manager 360 API

    Build applications to efficiently manage large or complex trafficking, reporting, and attribution workflows for Campaign Manager 360.

    The version of the OpenAPI document: v3.5
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictBytes, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class MediaResponseInfo(BaseModel):
    """
    This message is for backends to pass their scotty media specific fields to ESF. Backend will include this in their response message to ESF. Example: ExportFile is an rpc defined for upload using scotty from ESF. rpc ExportFile(ExportFileRequest) returns (ExportFileResponse) Message ExportFileResponse will include apiserving.MediaResponseInfo to tell ESF about data like dynamic_dropzone it needs to pass to Scotty. message ExportFileResponse { optional gdata.Media blob = 1; optional apiserving.MediaResponseInfo media_response_info = 2 }
    """ # noqa: E501
    custom_data: Optional[StrictStr] = Field(default=None, description="Data to copy from backend response to the next backend requests. Custom data is returned to Scotty in the agent_state field, which Scotty will then provide in subsequent upload notifications.", alias="customData")
    data_storage_transform: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="Specifies any transformation to be applied to data before persisting it or retrieving from storage. E.g., encryption options for blobstore2. This should be of the form uploader_service.DataStorageTransform.", alias="dataStorageTransform")
    dynamic_drop_target: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="Specifies the Scotty Drop Target to use for uploads. If present in a media response, Scotty does not upload to a standard drop zone. Instead, Scotty saves the upload directly to the location specified in this drop target. Unlike drop zones, the drop target is the final storage location for an upload. So, the agent does not need to clone the blob at the end of the upload. The agent is responsible for garbage collecting any orphaned blobs that may occur due to aborted uploads. For more information, see the drop target design doc here: http://goto/ScottyDropTarget This field will be preferred to dynamicDropzone. If provided, the identified field in the response must be of the type uploader.agent.DropTarget.", alias="dynamicDropTarget")
    dynamic_dropzone: Optional[StrictStr] = Field(default=None, description="Specifies the Scotty dropzone to use for uploads.", alias="dynamicDropzone")
    request_class: Optional[StrictStr] = Field(default=None, description="Request class to use for all Blobstore operations for this request.", alias="requestClass")
    scotty_agent_user_id: Optional[StrictStr] = Field(default=None, description="Requester ID passed along to be recorded in the Scotty logs", alias="scottyAgentUserId")
    scotty_customer_log: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="Customer-specific data to be recorded in the Scotty logs type is logs_proto_scotty.CustomerLog", alias="scottyCustomerLog")
    traffic_class_field: Optional[StrictStr] = Field(default=None, description="Specifies the TrafficClass that Scotty should use for any RPCs to fetch the response bytes. Will override the traffic class GTOS of the incoming http request. This is a temporary field to facilitate whitelisting and experimentation by the bigstore agent only. For instance, this does not apply to RTMP reads. WARNING: DO NOT USE WITHOUT PERMISSION FROM THE SCOTTY TEAM.", alias="trafficClassField")
    verify_hash_from_header: Optional[StrictBool] = Field(default=None, description="Tells Scotty to verify hashes on the agent's behalf by parsing out the X-Goog-Hash header.", alias="verifyHashFromHeader")
    __properties: ClassVar[List[str]] = ["customData", "dataStorageTransform", "dynamicDropTarget", "dynamicDropzone", "requestClass", "scottyAgentUserId", "scottyCustomerLog", "trafficClassField", "verifyHashFromHeader"]

    @field_validator('request_class')
    def request_class_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNKNOWN_REQUEST_CLASS', 'LATENCY_SENSITIVE', 'PRODUCTION_BATCH', 'BEST_EFFORT']):
            raise ValueError("must be one of enum values ('UNKNOWN_REQUEST_CLASS', 'LATENCY_SENSITIVE', 'PRODUCTION_BATCH', 'BEST_EFFORT')")
        return value

    @field_validator('traffic_class_field')
    def traffic_class_field_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['BE1', 'AF1', 'AF2', 'AF3', 'AF4', 'NC1', 'NC0', 'BE0', 'LLQ', 'LLQ1', 'LLQ2']):
            raise ValueError("must be one of enum values ('BE1', 'AF1', 'AF2', 'AF3', 'AF4', 'NC1', 'NC0', 'BE0', 'LLQ', 'LLQ1', 'LLQ2')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MediaResponseInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MediaResponseInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "customData": obj.get("customData"),
            "dataStorageTransform": obj.get("dataStorageTransform"),
            "dynamicDropTarget": obj.get("dynamicDropTarget"),
            "dynamicDropzone": obj.get("dynamicDropzone"),
            "requestClass": obj.get("requestClass"),
            "scottyAgentUserId": obj.get("scottyAgentUserId"),
            "scottyCustomerLog": obj.get("scottyCustomerLog"),
            "trafficClassField": obj.get("trafficClassField"),
            "verifyHashFromHeader": obj.get("verifyHashFromHeader")
        })
        return _obj


