# coding: utf-8

"""
    Campaign Manager 360 API

    Build applications to efficiently manage large or complex trafficking, reporting, and attribution workflows for Campaign Manager 360.

    The version of the OpenAPI document: v3.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.browser import Browser
from openapi_client.models.connection_type import ConnectionType
from openapi_client.models.mobile_carrier import MobileCarrier
from openapi_client.models.operating_system import OperatingSystem
from openapi_client.models.operating_system_version import OperatingSystemVersion
from openapi_client.models.platform_type import PlatformType
from typing import Optional, Set
from typing_extensions import Self

class TechnologyTargeting(BaseModel):
    """
    Technology Targeting.
    """ # noqa: E501
    browsers: Optional[List[Browser]] = Field(default=None, description="Browsers that this ad targets. For each browser either set browserVersionId or dartId along with the version numbers. If both are specified, only browserVersionId will be used. The other fields are populated automatically when the ad is inserted or updated.")
    connection_types: Optional[List[ConnectionType]] = Field(default=None, description="Connection types that this ad targets. For each connection type only id is required. The other fields are populated automatically when the ad is inserted or updated.", alias="connectionTypes")
    mobile_carriers: Optional[List[MobileCarrier]] = Field(default=None, description="Mobile carriers that this ad targets. For each mobile carrier only id is required, and the other fields are populated automatically when the ad is inserted or updated. If targeting a mobile carrier, do not set targeting for any zip codes.", alias="mobileCarriers")
    operating_system_versions: Optional[List[OperatingSystemVersion]] = Field(default=None, description="Operating system versions that this ad targets. To target all versions, use operatingSystems. For each operating system version, only id is required. The other fields are populated automatically when the ad is inserted or updated. If targeting an operating system version, do not set targeting for the corresponding operating system in operatingSystems.", alias="operatingSystemVersions")
    operating_systems: Optional[List[OperatingSystem]] = Field(default=None, description="Operating systems that this ad targets. To target specific versions, use operatingSystemVersions. For each operating system only dartId is required. The other fields are populated automatically when the ad is inserted or updated. If targeting an operating system, do not set targeting for operating system versions for the same operating system.", alias="operatingSystems")
    platform_types: Optional[List[PlatformType]] = Field(default=None, description="Platform types that this ad targets. For example, desktop, mobile, or tablet. For each platform type, only id is required, and the other fields are populated automatically when the ad is inserted or updated.", alias="platformTypes")
    __properties: ClassVar[List[str]] = ["browsers", "connectionTypes", "mobileCarriers", "operatingSystemVersions", "operatingSystems", "platformTypes"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TechnologyTargeting from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in browsers (list)
        _items = []
        if self.browsers:
            for _item_browsers in self.browsers:
                if _item_browsers:
                    _items.append(_item_browsers.to_dict())
            _dict['browsers'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in connection_types (list)
        _items = []
        if self.connection_types:
            for _item_connection_types in self.connection_types:
                if _item_connection_types:
                    _items.append(_item_connection_types.to_dict())
            _dict['connectionTypes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mobile_carriers (list)
        _items = []
        if self.mobile_carriers:
            for _item_mobile_carriers in self.mobile_carriers:
                if _item_mobile_carriers:
                    _items.append(_item_mobile_carriers.to_dict())
            _dict['mobileCarriers'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in operating_system_versions (list)
        _items = []
        if self.operating_system_versions:
            for _item_operating_system_versions in self.operating_system_versions:
                if _item_operating_system_versions:
                    _items.append(_item_operating_system_versions.to_dict())
            _dict['operatingSystemVersions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in operating_systems (list)
        _items = []
        if self.operating_systems:
            for _item_operating_systems in self.operating_systems:
                if _item_operating_systems:
                    _items.append(_item_operating_systems.to_dict())
            _dict['operatingSystems'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in platform_types (list)
        _items = []
        if self.platform_types:
            for _item_platform_types in self.platform_types:
                if _item_platform_types:
                    _items.append(_item_platform_types.to_dict())
            _dict['platformTypes'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TechnologyTargeting from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "browsers": [Browser.from_dict(_item) for _item in obj["browsers"]] if obj.get("browsers") is not None else None,
            "connectionTypes": [ConnectionType.from_dict(_item) for _item in obj["connectionTypes"]] if obj.get("connectionTypes") is not None else None,
            "mobileCarriers": [MobileCarrier.from_dict(_item) for _item in obj["mobileCarriers"]] if obj.get("mobileCarriers") is not None else None,
            "operatingSystemVersions": [OperatingSystemVersion.from_dict(_item) for _item in obj["operatingSystemVersions"]] if obj.get("operatingSystemVersions") is not None else None,
            "operatingSystems": [OperatingSystem.from_dict(_item) for _item in obj["operatingSystems"]] if obj.get("operatingSystems") is not None else None,
            "platformTypes": [PlatformType.from_dict(_item) for _item in obj["platformTypes"]] if obj.get("platformTypes") is not None else None
        })
        return _obj


