# coding: utf-8

"""
    Campaign Manager 360 API

    Build applications to efficiently manage large or complex trafficking, reporting, and attribution workflows for Campaign Manager 360.

    The version of the OpenAPI document: v4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.custom_viewability_metric import CustomViewabilityMetric
from openapi_client.models.dimension_value import DimensionValue
from openapi_client.models.lookback_configuration import LookbackConfiguration
from openapi_client.models.omniture_settings import OmnitureSettings
from openapi_client.models.tag_settings import TagSettings
from openapi_client.models.third_party_authentication_token import ThirdPartyAuthenticationToken
from openapi_client.models.user_defined_variable_configuration import UserDefinedVariableConfiguration
from typing import Optional, Set
from typing_extensions import Self

class FloodlightConfiguration(BaseModel):
    """
    Contains properties of a Floodlight configuration.
    """ # noqa: E501
    account_id: Optional[StrictStr] = Field(default=None, description="Account ID of this floodlight configuration. This is a read-only field that can be left blank.", alias="accountId")
    advertiser_id: Optional[StrictStr] = Field(default=None, description="Advertiser ID of the parent advertiser of this floodlight configuration.", alias="advertiserId")
    advertiser_id_dimension_value: Optional[DimensionValue] = Field(default=None, alias="advertiserIdDimensionValue")
    analytics_data_sharing_enabled: Optional[StrictBool] = Field(default=None, description="Whether advertiser data is shared with Google Analytics.", alias="analyticsDataSharingEnabled")
    custom_viewability_metric: Optional[CustomViewabilityMetric] = Field(default=None, alias="customViewabilityMetric")
    exposure_to_conversion_enabled: Optional[StrictBool] = Field(default=None, description="Whether the exposure-to-conversion report is enabled. This report shows detailed pathway information on up to 10 of the most recent ad exposures seen by a user before converting.", alias="exposureToConversionEnabled")
    first_day_of_week: Optional[StrictStr] = Field(default=None, alias="firstDayOfWeek")
    id: Optional[StrictStr] = Field(default=None, description="ID of this floodlight configuration. This is a read-only, auto-generated field.")
    id_dimension_value: Optional[DimensionValue] = Field(default=None, alias="idDimensionValue")
    in_app_attribution_tracking_enabled: Optional[StrictBool] = Field(default=None, description="Whether in-app attribution tracking is enabled.", alias="inAppAttributionTrackingEnabled")
    kind: Optional[StrictStr] = Field(default=None, description="Identifies what kind of resource this is. Value: the fixed string \"dfareporting#floodlightConfiguration\".")
    lookback_configuration: Optional[LookbackConfiguration] = Field(default=None, alias="lookbackConfiguration")
    natural_search_conversion_attribution_option: Optional[StrictStr] = Field(default=None, description="Types of attribution options for natural search conversions.", alias="naturalSearchConversionAttributionOption")
    omniture_settings: Optional[OmnitureSettings] = Field(default=None, alias="omnitureSettings")
    subaccount_id: Optional[StrictStr] = Field(default=None, description="Subaccount ID of this floodlight configuration. This is a read-only field that can be left blank.", alias="subaccountId")
    tag_settings: Optional[TagSettings] = Field(default=None, alias="tagSettings")
    third_party_authentication_tokens: Optional[List[ThirdPartyAuthenticationToken]] = Field(default=None, description="List of third-party authentication tokens enabled for this configuration.", alias="thirdPartyAuthenticationTokens")
    user_defined_variable_configurations: Optional[List[UserDefinedVariableConfiguration]] = Field(default=None, description="List of user defined variables enabled for this configuration.", alias="userDefinedVariableConfigurations")
    __properties: ClassVar[List[str]] = ["accountId", "advertiserId", "advertiserIdDimensionValue", "analyticsDataSharingEnabled", "customViewabilityMetric", "exposureToConversionEnabled", "firstDayOfWeek", "id", "idDimensionValue", "inAppAttributionTrackingEnabled", "kind", "lookbackConfiguration", "naturalSearchConversionAttributionOption", "omnitureSettings", "subaccountId", "tagSettings", "thirdPartyAuthenticationTokens", "userDefinedVariableConfigurations"]

    @field_validator('first_day_of_week')
    def first_day_of_week_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SUNDAY', 'MONDAY']):
            raise ValueError("must be one of enum values ('SUNDAY', 'MONDAY')")
        return value

    @field_validator('natural_search_conversion_attribution_option')
    def natural_search_conversion_attribution_option_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['EXCLUDE_NATURAL_SEARCH_CONVERSION_ATTRIBUTION', 'INCLUDE_NATURAL_SEARCH_CONVERSION_ATTRIBUTION', 'INCLUDE_NATURAL_SEARCH_TIERED_CONVERSION_ATTRIBUTION']):
            raise ValueError("must be one of enum values ('EXCLUDE_NATURAL_SEARCH_CONVERSION_ATTRIBUTION', 'INCLUDE_NATURAL_SEARCH_CONVERSION_ATTRIBUTION', 'INCLUDE_NATURAL_SEARCH_TIERED_CONVERSION_ATTRIBUTION')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FloodlightConfiguration from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of advertiser_id_dimension_value
        if self.advertiser_id_dimension_value:
            _dict['advertiserIdDimensionValue'] = self.advertiser_id_dimension_value.to_dict()
        # override the default output from pydantic by calling `to_dict()` of custom_viewability_metric
        if self.custom_viewability_metric:
            _dict['customViewabilityMetric'] = self.custom_viewability_metric.to_dict()
        # override the default output from pydantic by calling `to_dict()` of id_dimension_value
        if self.id_dimension_value:
            _dict['idDimensionValue'] = self.id_dimension_value.to_dict()
        # override the default output from pydantic by calling `to_dict()` of lookback_configuration
        if self.lookback_configuration:
            _dict['lookbackConfiguration'] = self.lookback_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of omniture_settings
        if self.omniture_settings:
            _dict['omnitureSettings'] = self.omniture_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tag_settings
        if self.tag_settings:
            _dict['tagSettings'] = self.tag_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in third_party_authentication_tokens (list)
        _items = []
        if self.third_party_authentication_tokens:
            for _item_third_party_authentication_tokens in self.third_party_authentication_tokens:
                if _item_third_party_authentication_tokens:
                    _items.append(_item_third_party_authentication_tokens.to_dict())
            _dict['thirdPartyAuthenticationTokens'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in user_defined_variable_configurations (list)
        _items = []
        if self.user_defined_variable_configurations:
            for _item_user_defined_variable_configurations in self.user_defined_variable_configurations:
                if _item_user_defined_variable_configurations:
                    _items.append(_item_user_defined_variable_configurations.to_dict())
            _dict['userDefinedVariableConfigurations'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FloodlightConfiguration from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accountId": obj.get("accountId"),
            "advertiserId": obj.get("advertiserId"),
            "advertiserIdDimensionValue": DimensionValue.from_dict(obj["advertiserIdDimensionValue"]) if obj.get("advertiserIdDimensionValue") is not None else None,
            "analyticsDataSharingEnabled": obj.get("analyticsDataSharingEnabled"),
            "customViewabilityMetric": CustomViewabilityMetric.from_dict(obj["customViewabilityMetric"]) if obj.get("customViewabilityMetric") is not None else None,
            "exposureToConversionEnabled": obj.get("exposureToConversionEnabled"),
            "firstDayOfWeek": obj.get("firstDayOfWeek"),
            "id": obj.get("id"),
            "idDimensionValue": DimensionValue.from_dict(obj["idDimensionValue"]) if obj.get("idDimensionValue") is not None else None,
            "inAppAttributionTrackingEnabled": obj.get("inAppAttributionTrackingEnabled"),
            "kind": obj.get("kind"),
            "lookbackConfiguration": LookbackConfiguration.from_dict(obj["lookbackConfiguration"]) if obj.get("lookbackConfiguration") is not None else None,
            "naturalSearchConversionAttributionOption": obj.get("naturalSearchConversionAttributionOption"),
            "omnitureSettings": OmnitureSettings.from_dict(obj["omnitureSettings"]) if obj.get("omnitureSettings") is not None else None,
            "subaccountId": obj.get("subaccountId"),
            "tagSettings": TagSettings.from_dict(obj["tagSettings"]) if obj.get("tagSettings") is not None else None,
            "thirdPartyAuthenticationTokens": [ThirdPartyAuthenticationToken.from_dict(_item) for _item in obj["thirdPartyAuthenticationTokens"]] if obj.get("thirdPartyAuthenticationTokens") is not None else None,
            "userDefinedVariableConfigurations": [UserDefinedVariableConfiguration.from_dict(_item) for _item in obj["userDefinedVariableConfigurations"]] if obj.get("userDefinedVariableConfigurations") is not None else None
        })
        return _obj


