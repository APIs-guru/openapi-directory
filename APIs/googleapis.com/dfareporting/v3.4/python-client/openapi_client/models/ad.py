# coding: utf-8

"""
    Campaign Manager 360 API

    Build applications to efficiently manage large or complex trafficking, reporting, and attribution workflows for Campaign Manager 360.

    The version of the OpenAPI document: v3.4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.click_through_url import ClickThroughUrl
from openapi_client.models.click_through_url_suffix_properties import ClickThroughUrlSuffixProperties
from openapi_client.models.creative_group_assignment import CreativeGroupAssignment
from openapi_client.models.creative_rotation import CreativeRotation
from openapi_client.models.day_part_targeting import DayPartTargeting
from openapi_client.models.default_click_through_event_tag_properties import DefaultClickThroughEventTagProperties
from openapi_client.models.delivery_schedule import DeliverySchedule
from openapi_client.models.dimension_value import DimensionValue
from openapi_client.models.event_tag_override import EventTagOverride
from openapi_client.models.geo_targeting import GeoTargeting
from openapi_client.models.key_value_targeting_expression import KeyValueTargetingExpression
from openapi_client.models.language_targeting import LanguageTargeting
from openapi_client.models.last_modified_info import LastModifiedInfo
from openapi_client.models.list_targeting_expression import ListTargetingExpression
from openapi_client.models.placement_assignment import PlacementAssignment
from openapi_client.models.size import Size
from openapi_client.models.technology_targeting import TechnologyTargeting
from typing import Optional, Set
from typing_extensions import Self

class Ad(BaseModel):
    """
    Contains properties of a Campaign Manager ad.
    """ # noqa: E501
    account_id: Optional[StrictStr] = Field(default=None, description="Account ID of this ad. This is a read-only field that can be left blank.", alias="accountId")
    active: Optional[StrictBool] = Field(default=None, description="Whether this ad is active. When true, archived must be false.")
    advertiser_id: Optional[StrictStr] = Field(default=None, description="Advertiser ID of this ad. This is a required field on insertion.", alias="advertiserId")
    advertiser_id_dimension_value: Optional[DimensionValue] = Field(default=None, alias="advertiserIdDimensionValue")
    archived: Optional[StrictBool] = Field(default=None, description="Whether this ad is archived. When true, active must be false.")
    audience_segment_id: Optional[StrictStr] = Field(default=None, description="Audience segment ID that is being targeted for this ad. Applicable when type is AD_SERVING_STANDARD_AD.", alias="audienceSegmentId")
    campaign_id: Optional[StrictStr] = Field(default=None, description="Campaign ID of this ad. This is a required field on insertion.", alias="campaignId")
    campaign_id_dimension_value: Optional[DimensionValue] = Field(default=None, alias="campaignIdDimensionValue")
    click_through_url: Optional[ClickThroughUrl] = Field(default=None, alias="clickThroughUrl")
    click_through_url_suffix_properties: Optional[ClickThroughUrlSuffixProperties] = Field(default=None, alias="clickThroughUrlSuffixProperties")
    comments: Optional[StrictStr] = Field(default=None, description="Comments for this ad.")
    compatibility: Optional[StrictStr] = Field(default=None, description="Compatibility of this ad. Applicable when type is AD_SERVING_DEFAULT_AD. DISPLAY and DISPLAY_INTERSTITIAL refer to either rendering on desktop or on mobile devices or in mobile apps for regular or interstitial ads, respectively. APP and APP_INTERSTITIAL are only used for existing default ads. New mobile placements must be assigned DISPLAY or DISPLAY_INTERSTITIAL and default ads created for those placements will be limited to those compatibility types. IN_STREAM_VIDEO refers to rendering in-stream video ads developed with the VAST standard.")
    create_info: Optional[LastModifiedInfo] = Field(default=None, alias="createInfo")
    creative_group_assignments: Optional[List[CreativeGroupAssignment]] = Field(default=None, description="Creative group assignments for this ad. Applicable when type is AD_SERVING_CLICK_TRACKER. Only one assignment per creative group number is allowed for a maximum of two assignments.", alias="creativeGroupAssignments")
    creative_rotation: Optional[CreativeRotation] = Field(default=None, alias="creativeRotation")
    day_part_targeting: Optional[DayPartTargeting] = Field(default=None, alias="dayPartTargeting")
    default_click_through_event_tag_properties: Optional[DefaultClickThroughEventTagProperties] = Field(default=None, alias="defaultClickThroughEventTagProperties")
    delivery_schedule: Optional[DeliverySchedule] = Field(default=None, alias="deliverySchedule")
    dynamic_click_tracker: Optional[StrictBool] = Field(default=None, description="Whether this ad is a dynamic click tracker. Applicable when type is AD_SERVING_CLICK_TRACKER. This is a required field on insert, and is read-only after insert.", alias="dynamicClickTracker")
    end_time: Optional[datetime] = Field(default=None, alias="endTime")
    event_tag_overrides: Optional[List[EventTagOverride]] = Field(default=None, description="Event tag overrides for this ad.", alias="eventTagOverrides")
    geo_targeting: Optional[GeoTargeting] = Field(default=None, alias="geoTargeting")
    id: Optional[StrictStr] = Field(default=None, description="ID of this ad. This is a read-only, auto-generated field.")
    id_dimension_value: Optional[DimensionValue] = Field(default=None, alias="idDimensionValue")
    key_value_targeting_expression: Optional[KeyValueTargetingExpression] = Field(default=None, alias="keyValueTargetingExpression")
    kind: Optional[StrictStr] = Field(default=None, description="Identifies what kind of resource this is. Value: the fixed string \"dfareporting#ad\".")
    language_targeting: Optional[LanguageTargeting] = Field(default=None, alias="languageTargeting")
    last_modified_info: Optional[LastModifiedInfo] = Field(default=None, alias="lastModifiedInfo")
    name: Optional[StrictStr] = Field(default=None, description="Name of this ad. This is a required field and must be less than 256 characters long.")
    placement_assignments: Optional[List[PlacementAssignment]] = Field(default=None, description="Placement assignments for this ad.", alias="placementAssignments")
    remarketing_list_expression: Optional[ListTargetingExpression] = Field(default=None, alias="remarketingListExpression")
    size: Optional[Size] = None
    ssl_compliant: Optional[StrictBool] = Field(default=None, description="Whether this ad is ssl compliant. This is a read-only field that is auto-generated when the ad is inserted or updated.", alias="sslCompliant")
    ssl_required: Optional[StrictBool] = Field(default=None, description="Whether this ad requires ssl. This is a read-only field that is auto-generated when the ad is inserted or updated.", alias="sslRequired")
    start_time: Optional[datetime] = Field(default=None, alias="startTime")
    subaccount_id: Optional[StrictStr] = Field(default=None, description="Subaccount ID of this ad. This is a read-only field that can be left blank.", alias="subaccountId")
    targeting_template_id: Optional[StrictStr] = Field(default=None, description="Targeting template ID, used to apply preconfigured targeting information to this ad. This cannot be set while any of dayPartTargeting, geoTargeting, keyValueTargetingExpression, languageTargeting, remarketingListExpression, or technologyTargeting are set. Applicable when type is AD_SERVING_STANDARD_AD.", alias="targetingTemplateId")
    technology_targeting: Optional[TechnologyTargeting] = Field(default=None, alias="technologyTargeting")
    type: Optional[StrictStr] = Field(default=None, description="Type of ad. This is a required field on insertion. Note that default ads ( AD_SERVING_DEFAULT_AD) cannot be created directly (see Creative resource).")
    __properties: ClassVar[List[str]] = ["accountId", "active", "advertiserId", "advertiserIdDimensionValue", "archived", "audienceSegmentId", "campaignId", "campaignIdDimensionValue", "clickThroughUrl", "clickThroughUrlSuffixProperties", "comments", "compatibility", "createInfo", "creativeGroupAssignments", "creativeRotation", "dayPartTargeting", "defaultClickThroughEventTagProperties", "deliverySchedule", "dynamicClickTracker", "endTime", "eventTagOverrides", "geoTargeting", "id", "idDimensionValue", "keyValueTargetingExpression", "kind", "languageTargeting", "lastModifiedInfo", "name", "placementAssignments", "remarketingListExpression", "size", "sslCompliant", "sslRequired", "startTime", "subaccountId", "targetingTemplateId", "technologyTargeting", "type"]

    @field_validator('compatibility')
    def compatibility_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DISPLAY', 'DISPLAY_INTERSTITIAL', 'APP', 'APP_INTERSTITIAL', 'IN_STREAM_VIDEO', 'IN_STREAM_AUDIO']):
            raise ValueError("must be one of enum values ('DISPLAY', 'DISPLAY_INTERSTITIAL', 'APP', 'APP_INTERSTITIAL', 'IN_STREAM_VIDEO', 'IN_STREAM_AUDIO')")
        return value

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AD_SERVING_STANDARD_AD', 'AD_SERVING_DEFAULT_AD', 'AD_SERVING_CLICK_TRACKER', 'AD_SERVING_TRACKING', 'AD_SERVING_BRAND_SAFE_AD']):
            raise ValueError("must be one of enum values ('AD_SERVING_STANDARD_AD', 'AD_SERVING_DEFAULT_AD', 'AD_SERVING_CLICK_TRACKER', 'AD_SERVING_TRACKING', 'AD_SERVING_BRAND_SAFE_AD')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Ad from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of advertiser_id_dimension_value
        if self.advertiser_id_dimension_value:
            _dict['advertiserIdDimensionValue'] = self.advertiser_id_dimension_value.to_dict()
        # override the default output from pydantic by calling `to_dict()` of campaign_id_dimension_value
        if self.campaign_id_dimension_value:
            _dict['campaignIdDimensionValue'] = self.campaign_id_dimension_value.to_dict()
        # override the default output from pydantic by calling `to_dict()` of click_through_url
        if self.click_through_url:
            _dict['clickThroughUrl'] = self.click_through_url.to_dict()
        # override the default output from pydantic by calling `to_dict()` of click_through_url_suffix_properties
        if self.click_through_url_suffix_properties:
            _dict['clickThroughUrlSuffixProperties'] = self.click_through_url_suffix_properties.to_dict()
        # override the default output from pydantic by calling `to_dict()` of create_info
        if self.create_info:
            _dict['createInfo'] = self.create_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in creative_group_assignments (list)
        _items = []
        if self.creative_group_assignments:
            for _item_creative_group_assignments in self.creative_group_assignments:
                if _item_creative_group_assignments:
                    _items.append(_item_creative_group_assignments.to_dict())
            _dict['creativeGroupAssignments'] = _items
        # override the default output from pydantic by calling `to_dict()` of creative_rotation
        if self.creative_rotation:
            _dict['creativeRotation'] = self.creative_rotation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of day_part_targeting
        if self.day_part_targeting:
            _dict['dayPartTargeting'] = self.day_part_targeting.to_dict()
        # override the default output from pydantic by calling `to_dict()` of default_click_through_event_tag_properties
        if self.default_click_through_event_tag_properties:
            _dict['defaultClickThroughEventTagProperties'] = self.default_click_through_event_tag_properties.to_dict()
        # override the default output from pydantic by calling `to_dict()` of delivery_schedule
        if self.delivery_schedule:
            _dict['deliverySchedule'] = self.delivery_schedule.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in event_tag_overrides (list)
        _items = []
        if self.event_tag_overrides:
            for _item_event_tag_overrides in self.event_tag_overrides:
                if _item_event_tag_overrides:
                    _items.append(_item_event_tag_overrides.to_dict())
            _dict['eventTagOverrides'] = _items
        # override the default output from pydantic by calling `to_dict()` of geo_targeting
        if self.geo_targeting:
            _dict['geoTargeting'] = self.geo_targeting.to_dict()
        # override the default output from pydantic by calling `to_dict()` of id_dimension_value
        if self.id_dimension_value:
            _dict['idDimensionValue'] = self.id_dimension_value.to_dict()
        # override the default output from pydantic by calling `to_dict()` of key_value_targeting_expression
        if self.key_value_targeting_expression:
            _dict['keyValueTargetingExpression'] = self.key_value_targeting_expression.to_dict()
        # override the default output from pydantic by calling `to_dict()` of language_targeting
        if self.language_targeting:
            _dict['languageTargeting'] = self.language_targeting.to_dict()
        # override the default output from pydantic by calling `to_dict()` of last_modified_info
        if self.last_modified_info:
            _dict['lastModifiedInfo'] = self.last_modified_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in placement_assignments (list)
        _items = []
        if self.placement_assignments:
            for _item_placement_assignments in self.placement_assignments:
                if _item_placement_assignments:
                    _items.append(_item_placement_assignments.to_dict())
            _dict['placementAssignments'] = _items
        # override the default output from pydantic by calling `to_dict()` of remarketing_list_expression
        if self.remarketing_list_expression:
            _dict['remarketingListExpression'] = self.remarketing_list_expression.to_dict()
        # override the default output from pydantic by calling `to_dict()` of size
        if self.size:
            _dict['size'] = self.size.to_dict()
        # override the default output from pydantic by calling `to_dict()` of technology_targeting
        if self.technology_targeting:
            _dict['technologyTargeting'] = self.technology_targeting.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Ad from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accountId": obj.get("accountId"),
            "active": obj.get("active"),
            "advertiserId": obj.get("advertiserId"),
            "advertiserIdDimensionValue": DimensionValue.from_dict(obj["advertiserIdDimensionValue"]) if obj.get("advertiserIdDimensionValue") is not None else None,
            "archived": obj.get("archived"),
            "audienceSegmentId": obj.get("audienceSegmentId"),
            "campaignId": obj.get("campaignId"),
            "campaignIdDimensionValue": DimensionValue.from_dict(obj["campaignIdDimensionValue"]) if obj.get("campaignIdDimensionValue") is not None else None,
            "clickThroughUrl": ClickThroughUrl.from_dict(obj["clickThroughUrl"]) if obj.get("clickThroughUrl") is not None else None,
            "clickThroughUrlSuffixProperties": ClickThroughUrlSuffixProperties.from_dict(obj["clickThroughUrlSuffixProperties"]) if obj.get("clickThroughUrlSuffixProperties") is not None else None,
            "comments": obj.get("comments"),
            "compatibility": obj.get("compatibility"),
            "createInfo": LastModifiedInfo.from_dict(obj["createInfo"]) if obj.get("createInfo") is not None else None,
            "creativeGroupAssignments": [CreativeGroupAssignment.from_dict(_item) for _item in obj["creativeGroupAssignments"]] if obj.get("creativeGroupAssignments") is not None else None,
            "creativeRotation": CreativeRotation.from_dict(obj["creativeRotation"]) if obj.get("creativeRotation") is not None else None,
            "dayPartTargeting": DayPartTargeting.from_dict(obj["dayPartTargeting"]) if obj.get("dayPartTargeting") is not None else None,
            "defaultClickThroughEventTagProperties": DefaultClickThroughEventTagProperties.from_dict(obj["defaultClickThroughEventTagProperties"]) if obj.get("defaultClickThroughEventTagProperties") is not None else None,
            "deliverySchedule": DeliverySchedule.from_dict(obj["deliverySchedule"]) if obj.get("deliverySchedule") is not None else None,
            "dynamicClickTracker": obj.get("dynamicClickTracker"),
            "endTime": obj.get("endTime"),
            "eventTagOverrides": [EventTagOverride.from_dict(_item) for _item in obj["eventTagOverrides"]] if obj.get("eventTagOverrides") is not None else None,
            "geoTargeting": GeoTargeting.from_dict(obj["geoTargeting"]) if obj.get("geoTargeting") is not None else None,
            "id": obj.get("id"),
            "idDimensionValue": DimensionValue.from_dict(obj["idDimensionValue"]) if obj.get("idDimensionValue") is not None else None,
            "keyValueTargetingExpression": KeyValueTargetingExpression.from_dict(obj["keyValueTargetingExpression"]) if obj.get("keyValueTargetingExpression") is not None else None,
            "kind": obj.get("kind"),
            "languageTargeting": LanguageTargeting.from_dict(obj["languageTargeting"]) if obj.get("languageTargeting") is not None else None,
            "lastModifiedInfo": LastModifiedInfo.from_dict(obj["lastModifiedInfo"]) if obj.get("lastModifiedInfo") is not None else None,
            "name": obj.get("name"),
            "placementAssignments": [PlacementAssignment.from_dict(_item) for _item in obj["placementAssignments"]] if obj.get("placementAssignments") is not None else None,
            "remarketingListExpression": ListTargetingExpression.from_dict(obj["remarketingListExpression"]) if obj.get("remarketingListExpression") is not None else None,
            "size": Size.from_dict(obj["size"]) if obj.get("size") is not None else None,
            "sslCompliant": obj.get("sslCompliant"),
            "sslRequired": obj.get("sslRequired"),
            "startTime": obj.get("startTime"),
            "subaccountId": obj.get("subaccountId"),
            "targetingTemplateId": obj.get("targetingTemplateId"),
            "technologyTargeting": TechnologyTargeting.from_dict(obj["technologyTargeting"]) if obj.get("technologyTargeting") is not None else None,
            "type": obj.get("type")
        })
        return _obj


