# coding: utf-8

"""
    Cloud Functions API

    Manages lightweight user-provided functions executed in response to events.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.event_trigger import EventTrigger
from openapi_client.models.https_trigger import HttpsTrigger
from openapi_client.models.on_deploy_update_policy import OnDeployUpdatePolicy
from openapi_client.models.secret_env_var import SecretEnvVar
from openapi_client.models.secret_volume import SecretVolume
from openapi_client.models.source_repository import SourceRepository
from typing import Optional, Set
from typing_extensions import Self

class CloudFunction(BaseModel):
    """
    Describes a Cloud Function that contains user computation executed in response to an event. It encapsulate function and triggers configurations.
    """ # noqa: E501
    automatic_update_policy: Optional[Dict[str, Any]] = Field(default=None, description="Security patches are applied automatically to the runtime without requiring the function to be redeployed.", alias="automaticUpdatePolicy")
    available_memory_mb: Optional[StrictInt] = Field(default=None, description="The amount of memory in MB available for a function. Defaults to 256MB.", alias="availableMemoryMb")
    build_environment_variables: Optional[Dict[str, StrictStr]] = Field(default=None, description="Build environment variables that shall be available during build time.", alias="buildEnvironmentVariables")
    build_id: Optional[StrictStr] = Field(default=None, description="Output only. The Cloud Build ID of the latest successful deployment of the function.", alias="buildId")
    build_name: Optional[StrictStr] = Field(default=None, description="Output only. The Cloud Build Name of the function deployment. `projects//locations//builds/`.", alias="buildName")
    build_service_account: Optional[StrictStr] = Field(default=None, description="Optional. A service account the user provides for use with Cloud Build.", alias="buildServiceAccount")
    build_worker_pool: Optional[StrictStr] = Field(default=None, description="Name of the Cloud Build Custom Worker Pool that should be used to build the function. The format of this field is `projects/{project}/locations/{region}/workerPools/{workerPool}` where `{project}` and `{region}` are the project id and region respectively where the worker pool is defined and `{workerPool}` is the short name of the worker pool. If the project id is not the same as the function, then the Cloud Functions Service Agent (`service-@gcf-admin-robot.iam.gserviceaccount.com`) must be granted the role Cloud Build Custom Workers Builder (`roles/cloudbuild.customworkers.builder`) in the project.", alias="buildWorkerPool")
    description: Optional[StrictStr] = Field(default=None, description="User-provided description of a function.")
    docker_registry: Optional[StrictStr] = Field(default=None, description="Docker Registry to use for this deployment. If unspecified, it defaults to `ARTIFACT_REGISTRY`. If `docker_repository` field is specified, this field should either be left unspecified or set to `ARTIFACT_REGISTRY`.", alias="dockerRegistry")
    docker_repository: Optional[StrictStr] = Field(default=None, description="User managed repository created in Artifact Registry optionally with a customer managed encryption key. If specified, deployments will use Artifact Registry. If unspecified and the deployment is eligible to use Artifact Registry, GCF will create and use a repository named 'gcf-artifacts' for every deployed region. This is the repository to which the function docker image will be pushed after it is built by Cloud Build. It must match the pattern `projects/{project}/locations/{location}/repositories/{repository}`. Cross-project repositories are not supported. Cross-location repositories are not supported. Repository format must be 'DOCKER'.", alias="dockerRepository")
    entry_point: Optional[StrictStr] = Field(default=None, description="The name of the function (as defined in source code) that will be executed. Defaults to the resource name suffix (ID of the function), if not specified.", alias="entryPoint")
    environment_variables: Optional[Dict[str, StrictStr]] = Field(default=None, description="Environment variables that shall be available during function execution.", alias="environmentVariables")
    event_trigger: Optional[EventTrigger] = Field(default=None, alias="eventTrigger")
    https_trigger: Optional[HttpsTrigger] = Field(default=None, alias="httpsTrigger")
    ingress_settings: Optional[StrictStr] = Field(default=None, description="The ingress settings for the function, controlling what traffic can reach it.", alias="ingressSettings")
    kms_key_name: Optional[StrictStr] = Field(default=None, description="Resource name of a KMS crypto key (managed by the user) used to encrypt/decrypt function resources. It must match the pattern `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`. If specified, you must also provide an artifact registry repository using the `docker_repository` field that was created with the same KMS crypto key. The following service accounts need to be granted the role 'Cloud KMS CryptoKey Encrypter/Decrypter (roles/cloudkms.cryptoKeyEncrypterDecrypter)' on the Key/KeyRing/Project/Organization (least access preferred). 1. Google Cloud Functions service account (service-{project_number}@gcf-admin-robot.iam.gserviceaccount.com) - Required to protect the function's image. 2. Google Storage service account (service-{project_number}@gs-project-accounts.iam.gserviceaccount.com) - Required to protect the function's source code. If this service account does not exist, deploying a function without a KMS key or retrieving the service agent name provisions it. For more information, see https://cloud.google.com/storage/docs/projects#service-agents and https://cloud.google.com/storage/docs/getting-service-agent#gsutil. Google Cloud Functions delegates access to service agents to protect function resources in internal projects that are not accessible by the end user.", alias="kmsKeyName")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Labels associated with this Cloud Function.")
    max_instances: Optional[StrictInt] = Field(default=None, description="The limit on the maximum number of function instances that may coexist at a given time. In some cases, such as rapid traffic surges, Cloud Functions may, for a short period of time, create more instances than the specified max instances limit. If your function cannot tolerate this temporary behavior, you may want to factor in a safety margin and set a lower max instances value than your function can tolerate. See the [Max Instances](https://cloud.google.com/functions/docs/max-instances) Guide for more details.", alias="maxInstances")
    min_instances: Optional[StrictInt] = Field(default=None, description="A lower bound for the number function instances that may coexist at a given time.", alias="minInstances")
    name: Optional[StrictStr] = Field(default=None, description="A user-defined name of the function. Function names must be unique globally and match pattern `projects/*/locations/*/functions/*`")
    network: Optional[StrictStr] = Field(default=None, description="Deprecated: use vpc_connector")
    on_deploy_update_policy: Optional[OnDeployUpdatePolicy] = Field(default=None, alias="onDeployUpdatePolicy")
    runtime: Optional[StrictStr] = Field(default=None, description="The runtime in which to run the function. Required when deploying a new function, optional when updating an existing function. For a complete list of possible choices, see the [`gcloud` command reference](https://cloud.google.com/sdk/gcloud/reference/functions/deploy#--runtime).")
    secret_environment_variables: Optional[List[SecretEnvVar]] = Field(default=None, description="Secret environment variables configuration.", alias="secretEnvironmentVariables")
    secret_volumes: Optional[List[SecretVolume]] = Field(default=None, description="Secret volumes configuration.", alias="secretVolumes")
    service_account_email: Optional[StrictStr] = Field(default=None, description="The email of the function's service account. If empty, defaults to `{project_id}@appspot.gserviceaccount.com`.", alias="serviceAccountEmail")
    source_archive_url: Optional[StrictStr] = Field(default=None, description="The Google Cloud Storage URL, starting with `gs://`, pointing to the zip archive which contains the function.", alias="sourceArchiveUrl")
    source_repository: Optional[SourceRepository] = Field(default=None, alias="sourceRepository")
    source_token: Optional[StrictStr] = Field(default=None, description="Input only. An identifier for Firebase function sources. Disclaimer: This field is only supported for Firebase function deployments.", alias="sourceToken")
    source_upload_url: Optional[StrictStr] = Field(default=None, description="The Google Cloud Storage signed URL used for source uploading, generated by calling [google.cloud.functions.v1.GenerateUploadUrl]. The signature is validated on write methods (Create, Update) The signature is stripped from the Function object on read methods (Get, List)", alias="sourceUploadUrl")
    status: Optional[StrictStr] = Field(default=None, description="Output only. Status of the function deployment.")
    timeout: Optional[StrictStr] = Field(default=None, description="The function execution timeout. Execution is considered failed and can be terminated if the function is not completed at the end of the timeout period. Defaults to 60 seconds.")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. The last update timestamp of a Cloud Function.", alias="updateTime")
    version_id: Optional[StrictStr] = Field(default=None, description="Output only. The version identifier of the Cloud Function. Each deployment attempt results in a new version of a function being created.", alias="versionId")
    vpc_connector: Optional[StrictStr] = Field(default=None, description="The VPC Network Connector that this cloud function can connect to. It can be either the fully-qualified URI, or the short name of the network connector resource. The format of this field is `projects/*/locations/*/connectors/*` This field is mutually exclusive with `network` field and will eventually replace it. See [the VPC documentation](https://cloud.google.com/compute/docs/vpc) for more information on connecting Cloud projects.", alias="vpcConnector")
    vpc_connector_egress_settings: Optional[StrictStr] = Field(default=None, description="The egress settings for the connector, controlling what traffic is diverted through it.", alias="vpcConnectorEgressSettings")
    __properties: ClassVar[List[str]] = ["automaticUpdatePolicy", "availableMemoryMb", "buildEnvironmentVariables", "buildId", "buildName", "buildServiceAccount", "buildWorkerPool", "description", "dockerRegistry", "dockerRepository", "entryPoint", "environmentVariables", "eventTrigger", "httpsTrigger", "ingressSettings", "kmsKeyName", "labels", "maxInstances", "minInstances", "name", "network", "onDeployUpdatePolicy", "runtime", "secretEnvironmentVariables", "secretVolumes", "serviceAccountEmail", "sourceArchiveUrl", "sourceRepository", "sourceToken", "sourceUploadUrl", "status", "timeout", "updateTime", "versionId", "vpcConnector", "vpcConnectorEgressSettings"]

    @field_validator('docker_registry')
    def docker_registry_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DOCKER_REGISTRY_UNSPECIFIED', 'CONTAINER_REGISTRY', 'ARTIFACT_REGISTRY']):
            raise ValueError("must be one of enum values ('DOCKER_REGISTRY_UNSPECIFIED', 'CONTAINER_REGISTRY', 'ARTIFACT_REGISTRY')")
        return value

    @field_validator('ingress_settings')
    def ingress_settings_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['INGRESS_SETTINGS_UNSPECIFIED', 'ALLOW_ALL', 'ALLOW_INTERNAL_ONLY', 'ALLOW_INTERNAL_AND_GCLB']):
            raise ValueError("must be one of enum values ('INGRESS_SETTINGS_UNSPECIFIED', 'ALLOW_ALL', 'ALLOW_INTERNAL_ONLY', 'ALLOW_INTERNAL_AND_GCLB')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CLOUD_FUNCTION_STATUS_UNSPECIFIED', 'ACTIVE', 'OFFLINE', 'DEPLOY_IN_PROGRESS', 'DELETE_IN_PROGRESS', 'UNKNOWN']):
            raise ValueError("must be one of enum values ('CLOUD_FUNCTION_STATUS_UNSPECIFIED', 'ACTIVE', 'OFFLINE', 'DEPLOY_IN_PROGRESS', 'DELETE_IN_PROGRESS', 'UNKNOWN')")
        return value

    @field_validator('vpc_connector_egress_settings')
    def vpc_connector_egress_settings_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED', 'PRIVATE_RANGES_ONLY', 'ALL_TRAFFIC']):
            raise ValueError("must be one of enum values ('VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED', 'PRIVATE_RANGES_ONLY', 'ALL_TRAFFIC')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CloudFunction from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "build_id",
            "build_name",
            "status",
            "update_time",
            "version_id",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of event_trigger
        if self.event_trigger:
            _dict['eventTrigger'] = self.event_trigger.to_dict()
        # override the default output from pydantic by calling `to_dict()` of https_trigger
        if self.https_trigger:
            _dict['httpsTrigger'] = self.https_trigger.to_dict()
        # override the default output from pydantic by calling `to_dict()` of on_deploy_update_policy
        if self.on_deploy_update_policy:
            _dict['onDeployUpdatePolicy'] = self.on_deploy_update_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in secret_environment_variables (list)
        _items = []
        if self.secret_environment_variables:
            for _item_secret_environment_variables in self.secret_environment_variables:
                if _item_secret_environment_variables:
                    _items.append(_item_secret_environment_variables.to_dict())
            _dict['secretEnvironmentVariables'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in secret_volumes (list)
        _items = []
        if self.secret_volumes:
            for _item_secret_volumes in self.secret_volumes:
                if _item_secret_volumes:
                    _items.append(_item_secret_volumes.to_dict())
            _dict['secretVolumes'] = _items
        # override the default output from pydantic by calling `to_dict()` of source_repository
        if self.source_repository:
            _dict['sourceRepository'] = self.source_repository.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CloudFunction from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "automaticUpdatePolicy": obj.get("automaticUpdatePolicy"),
            "availableMemoryMb": obj.get("availableMemoryMb"),
            "buildEnvironmentVariables": obj.get("buildEnvironmentVariables"),
            "buildId": obj.get("buildId"),
            "buildName": obj.get("buildName"),
            "buildServiceAccount": obj.get("buildServiceAccount"),
            "buildWorkerPool": obj.get("buildWorkerPool"),
            "description": obj.get("description"),
            "dockerRegistry": obj.get("dockerRegistry"),
            "dockerRepository": obj.get("dockerRepository"),
            "entryPoint": obj.get("entryPoint"),
            "environmentVariables": obj.get("environmentVariables"),
            "eventTrigger": EventTrigger.from_dict(obj["eventTrigger"]) if obj.get("eventTrigger") is not None else None,
            "httpsTrigger": HttpsTrigger.from_dict(obj["httpsTrigger"]) if obj.get("httpsTrigger") is not None else None,
            "ingressSettings": obj.get("ingressSettings"),
            "kmsKeyName": obj.get("kmsKeyName"),
            "labels": obj.get("labels"),
            "maxInstances": obj.get("maxInstances"),
            "minInstances": obj.get("minInstances"),
            "name": obj.get("name"),
            "network": obj.get("network"),
            "onDeployUpdatePolicy": OnDeployUpdatePolicy.from_dict(obj["onDeployUpdatePolicy"]) if obj.get("onDeployUpdatePolicy") is not None else None,
            "runtime": obj.get("runtime"),
            "secretEnvironmentVariables": [SecretEnvVar.from_dict(_item) for _item in obj["secretEnvironmentVariables"]] if obj.get("secretEnvironmentVariables") is not None else None,
            "secretVolumes": [SecretVolume.from_dict(_item) for _item in obj["secretVolumes"]] if obj.get("secretVolumes") is not None else None,
            "serviceAccountEmail": obj.get("serviceAccountEmail"),
            "sourceArchiveUrl": obj.get("sourceArchiveUrl"),
            "sourceRepository": SourceRepository.from_dict(obj["sourceRepository"]) if obj.get("sourceRepository") is not None else None,
            "sourceToken": obj.get("sourceToken"),
            "sourceUploadUrl": obj.get("sourceUploadUrl"),
            "status": obj.get("status"),
            "timeout": obj.get("timeout"),
            "updateTime": obj.get("updateTime"),
            "versionId": obj.get("versionId"),
            "vpcConnector": obj.get("vpcConnector"),
            "vpcConnectorEgressSettings": obj.get("vpcConnectorEgressSettings")
        })
        return _obj


