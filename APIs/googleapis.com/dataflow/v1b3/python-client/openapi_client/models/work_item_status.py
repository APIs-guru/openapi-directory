# coding: utf-8

"""
    Dataflow API

    Manages Google Cloud Dataflow projects on Google Cloud Platform.

    The version of the OpenAPI document: v1b3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.approximate_progress import ApproximateProgress
from openapi_client.models.approximate_reported_progress import ApproximateReportedProgress
from openapi_client.models.counter_update import CounterUpdate
from openapi_client.models.dynamic_source_split import DynamicSourceSplit
from openapi_client.models.metric_update import MetricUpdate
from openapi_client.models.position import Position
from openapi_client.models.source_fork import SourceFork
from openapi_client.models.source_operation_response import SourceOperationResponse
from openapi_client.models.status import Status
from typing import Optional, Set
from typing_extensions import Self

class WorkItemStatus(BaseModel):
    """
    Conveys a worker's progress through the work described by a WorkItem.
    """ # noqa: E501
    completed: Optional[StrictBool] = Field(default=None, description="True if the WorkItem was completed (successfully or unsuccessfully).")
    counter_updates: Optional[List[CounterUpdate]] = Field(default=None, description="Worker output counters for this WorkItem.", alias="counterUpdates")
    dynamic_source_split: Optional[DynamicSourceSplit] = Field(default=None, alias="dynamicSourceSplit")
    errors: Optional[List[Status]] = Field(default=None, description="Specifies errors which occurred during processing. If errors are provided, and completed = true, then the WorkItem is considered to have failed.")
    metric_updates: Optional[List[MetricUpdate]] = Field(default=None, description="DEPRECATED in favor of counter_updates.", alias="metricUpdates")
    progress: Optional[ApproximateProgress] = None
    report_index: Optional[StrictStr] = Field(default=None, description="The report index. When a WorkItem is leased, the lease will contain an initial report index. When a WorkItem's status is reported to the system, the report should be sent with that report index, and the response will contain the index the worker should use for the next report. Reports received with unexpected index values will be rejected by the service. In order to preserve idempotency, the worker should not alter the contents of a report, even if the worker must submit the same report multiple times before getting back a response. The worker should not submit a subsequent report until the response for the previous report had been received from the service.", alias="reportIndex")
    reported_progress: Optional[ApproximateReportedProgress] = Field(default=None, alias="reportedProgress")
    requested_lease_duration: Optional[StrictStr] = Field(default=None, description="Amount of time the worker requests for its lease.", alias="requestedLeaseDuration")
    source_fork: Optional[SourceFork] = Field(default=None, alias="sourceFork")
    source_operation_response: Optional[SourceOperationResponse] = Field(default=None, alias="sourceOperationResponse")
    stop_position: Optional[Position] = Field(default=None, alias="stopPosition")
    total_throttler_wait_time_seconds: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Total time the worker spent being throttled by external systems.", alias="totalThrottlerWaitTimeSeconds")
    work_item_id: Optional[StrictStr] = Field(default=None, description="Identifies the WorkItem.", alias="workItemId")
    __properties: ClassVar[List[str]] = ["completed", "counterUpdates", "dynamicSourceSplit", "errors", "metricUpdates", "progress", "reportIndex", "reportedProgress", "requestedLeaseDuration", "sourceFork", "sourceOperationResponse", "stopPosition", "totalThrottlerWaitTimeSeconds", "workItemId"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of WorkItemStatus from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in counter_updates (list)
        _items = []
        if self.counter_updates:
            for _item_counter_updates in self.counter_updates:
                if _item_counter_updates:
                    _items.append(_item_counter_updates.to_dict())
            _dict['counterUpdates'] = _items
        # override the default output from pydantic by calling `to_dict()` of dynamic_source_split
        if self.dynamic_source_split:
            _dict['dynamicSourceSplit'] = self.dynamic_source_split.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in errors (list)
        _items = []
        if self.errors:
            for _item_errors in self.errors:
                if _item_errors:
                    _items.append(_item_errors.to_dict())
            _dict['errors'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in metric_updates (list)
        _items = []
        if self.metric_updates:
            for _item_metric_updates in self.metric_updates:
                if _item_metric_updates:
                    _items.append(_item_metric_updates.to_dict())
            _dict['metricUpdates'] = _items
        # override the default output from pydantic by calling `to_dict()` of progress
        if self.progress:
            _dict['progress'] = self.progress.to_dict()
        # override the default output from pydantic by calling `to_dict()` of reported_progress
        if self.reported_progress:
            _dict['reportedProgress'] = self.reported_progress.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source_fork
        if self.source_fork:
            _dict['sourceFork'] = self.source_fork.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source_operation_response
        if self.source_operation_response:
            _dict['sourceOperationResponse'] = self.source_operation_response.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stop_position
        if self.stop_position:
            _dict['stopPosition'] = self.stop_position.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of WorkItemStatus from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "completed": obj.get("completed"),
            "counterUpdates": [CounterUpdate.from_dict(_item) for _item in obj["counterUpdates"]] if obj.get("counterUpdates") is not None else None,
            "dynamicSourceSplit": DynamicSourceSplit.from_dict(obj["dynamicSourceSplit"]) if obj.get("dynamicSourceSplit") is not None else None,
            "errors": [Status.from_dict(_item) for _item in obj["errors"]] if obj.get("errors") is not None else None,
            "metricUpdates": [MetricUpdate.from_dict(_item) for _item in obj["metricUpdates"]] if obj.get("metricUpdates") is not None else None,
            "progress": ApproximateProgress.from_dict(obj["progress"]) if obj.get("progress") is not None else None,
            "reportIndex": obj.get("reportIndex"),
            "reportedProgress": ApproximateReportedProgress.from_dict(obj["reportedProgress"]) if obj.get("reportedProgress") is not None else None,
            "requestedLeaseDuration": obj.get("requestedLeaseDuration"),
            "sourceFork": SourceFork.from_dict(obj["sourceFork"]) if obj.get("sourceFork") is not None else None,
            "sourceOperationResponse": SourceOperationResponse.from_dict(obj["sourceOperationResponse"]) if obj.get("sourceOperationResponse") is not None else None,
            "stopPosition": Position.from_dict(obj["stopPosition"]) if obj.get("stopPosition") is not None else None,
            "totalThrottlerWaitTimeSeconds": obj.get("totalThrottlerWaitTimeSeconds"),
            "workItemId": obj.get("workItemId")
        })
        return _obj


