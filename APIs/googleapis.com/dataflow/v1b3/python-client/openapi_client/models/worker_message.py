# coding: utf-8

"""
    Dataflow API

    Manages Google Cloud Dataflow projects on Google Cloud Platform.

    The version of the OpenAPI document: v1b3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.data_sampling_report import DataSamplingReport
from openapi_client.models.per_worker_metrics import PerWorkerMetrics
from openapi_client.models.resource_utilization_report import ResourceUtilizationReport
from openapi_client.models.streaming_scaling_report import StreamingScalingReport
from openapi_client.models.worker_health_report import WorkerHealthReport
from openapi_client.models.worker_lifecycle_event import WorkerLifecycleEvent
from openapi_client.models.worker_message_code import WorkerMessageCode
from openapi_client.models.worker_shutdown_notice import WorkerShutdownNotice
from openapi_client.models.worker_thread_scaling_report import WorkerThreadScalingReport
from typing import Optional, Set
from typing_extensions import Self

class WorkerMessage(BaseModel):
    """
    WorkerMessage provides information to the backend about a worker.
    """ # noqa: E501
    data_sampling_report: Optional[DataSamplingReport] = Field(default=None, alias="dataSamplingReport")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Labels are used to group WorkerMessages. For example, a worker_message about a particular container might have the labels: { \"JOB_ID\": \"2015-04-22\", \"WORKER_ID\": \"wordcount-vm-2015â€¦\" \"CONTAINER_TYPE\": \"worker\", \"CONTAINER_ID\": \"ac1234def\"} Label tags typically correspond to Label enum values. However, for ease of development other strings can be used as tags. LABEL_UNSPECIFIED should not be used here.")
    per_worker_metrics: Optional[PerWorkerMetrics] = Field(default=None, alias="perWorkerMetrics")
    streaming_scaling_report: Optional[StreamingScalingReport] = Field(default=None, alias="streamingScalingReport")
    time: Optional[StrictStr] = Field(default=None, description="The timestamp of the worker_message.")
    worker_health_report: Optional[WorkerHealthReport] = Field(default=None, alias="workerHealthReport")
    worker_lifecycle_event: Optional[WorkerLifecycleEvent] = Field(default=None, alias="workerLifecycleEvent")
    worker_message_code: Optional[WorkerMessageCode] = Field(default=None, alias="workerMessageCode")
    worker_metrics: Optional[ResourceUtilizationReport] = Field(default=None, alias="workerMetrics")
    worker_shutdown_notice: Optional[WorkerShutdownNotice] = Field(default=None, alias="workerShutdownNotice")
    worker_thread_scaling_report: Optional[WorkerThreadScalingReport] = Field(default=None, alias="workerThreadScalingReport")
    __properties: ClassVar[List[str]] = ["dataSamplingReport", "labels", "perWorkerMetrics", "streamingScalingReport", "time", "workerHealthReport", "workerLifecycleEvent", "workerMessageCode", "workerMetrics", "workerShutdownNotice", "workerThreadScalingReport"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of WorkerMessage from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of data_sampling_report
        if self.data_sampling_report:
            _dict['dataSamplingReport'] = self.data_sampling_report.to_dict()
        # override the default output from pydantic by calling `to_dict()` of per_worker_metrics
        if self.per_worker_metrics:
            _dict['perWorkerMetrics'] = self.per_worker_metrics.to_dict()
        # override the default output from pydantic by calling `to_dict()` of streaming_scaling_report
        if self.streaming_scaling_report:
            _dict['streamingScalingReport'] = self.streaming_scaling_report.to_dict()
        # override the default output from pydantic by calling `to_dict()` of worker_health_report
        if self.worker_health_report:
            _dict['workerHealthReport'] = self.worker_health_report.to_dict()
        # override the default output from pydantic by calling `to_dict()` of worker_lifecycle_event
        if self.worker_lifecycle_event:
            _dict['workerLifecycleEvent'] = self.worker_lifecycle_event.to_dict()
        # override the default output from pydantic by calling `to_dict()` of worker_message_code
        if self.worker_message_code:
            _dict['workerMessageCode'] = self.worker_message_code.to_dict()
        # override the default output from pydantic by calling `to_dict()` of worker_metrics
        if self.worker_metrics:
            _dict['workerMetrics'] = self.worker_metrics.to_dict()
        # override the default output from pydantic by calling `to_dict()` of worker_shutdown_notice
        if self.worker_shutdown_notice:
            _dict['workerShutdownNotice'] = self.worker_shutdown_notice.to_dict()
        # override the default output from pydantic by calling `to_dict()` of worker_thread_scaling_report
        if self.worker_thread_scaling_report:
            _dict['workerThreadScalingReport'] = self.worker_thread_scaling_report.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of WorkerMessage from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "dataSamplingReport": DataSamplingReport.from_dict(obj["dataSamplingReport"]) if obj.get("dataSamplingReport") is not None else None,
            "labels": obj.get("labels"),
            "perWorkerMetrics": PerWorkerMetrics.from_dict(obj["perWorkerMetrics"]) if obj.get("perWorkerMetrics") is not None else None,
            "streamingScalingReport": StreamingScalingReport.from_dict(obj["streamingScalingReport"]) if obj.get("streamingScalingReport") is not None else None,
            "time": obj.get("time"),
            "workerHealthReport": WorkerHealthReport.from_dict(obj["workerHealthReport"]) if obj.get("workerHealthReport") is not None else None,
            "workerLifecycleEvent": WorkerLifecycleEvent.from_dict(obj["workerLifecycleEvent"]) if obj.get("workerLifecycleEvent") is not None else None,
            "workerMessageCode": WorkerMessageCode.from_dict(obj["workerMessageCode"]) if obj.get("workerMessageCode") is not None else None,
            "workerMetrics": ResourceUtilizationReport.from_dict(obj["workerMetrics"]) if obj.get("workerMetrics") is not None else None,
            "workerShutdownNotice": WorkerShutdownNotice.from_dict(obj["workerShutdownNotice"]) if obj.get("workerShutdownNotice") is not None else None,
            "workerThreadScalingReport": WorkerThreadScalingReport.from_dict(obj["workerThreadScalingReport"]) if obj.get("workerThreadScalingReport") is not None else None
        })
        return _obj


