# coding: utf-8

"""
    Network Services API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.http_route_header_modifier import HttpRouteHeaderModifier
from typing import Optional, Set
from typing_extensions import Self

class HttpRouteDestination(BaseModel):
    """
    Specifications of a destination to which the request should be routed to.
    """ # noqa: E501
    request_header_modifier: Optional[HttpRouteHeaderModifier] = Field(default=None, alias="requestHeaderModifier")
    response_header_modifier: Optional[HttpRouteHeaderModifier] = Field(default=None, alias="responseHeaderModifier")
    service_name: Optional[StrictStr] = Field(default=None, description="The URL of a BackendService to route traffic to.", alias="serviceName")
    weight: Optional[StrictInt] = Field(default=None, description="Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: - weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weights are specified for any one service name, they need to be specified for all of them. If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.")
    __properties: ClassVar[List[str]] = ["requestHeaderModifier", "responseHeaderModifier", "serviceName", "weight"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of HttpRouteDestination from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of request_header_modifier
        if self.request_header_modifier:
            _dict['requestHeaderModifier'] = self.request_header_modifier.to_dict()
        # override the default output from pydantic by calling `to_dict()` of response_header_modifier
        if self.response_header_modifier:
            _dict['responseHeaderModifier'] = self.response_header_modifier.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of HttpRouteDestination from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "requestHeaderModifier": HttpRouteHeaderModifier.from_dict(obj["requestHeaderModifier"]) if obj.get("requestHeaderModifier") is not None else None,
            "responseHeaderModifier": HttpRouteHeaderModifier.from_dict(obj["responseHeaderModifier"]) if obj.get("responseHeaderModifier") is not None else None,
            "serviceName": obj.get("serviceName"),
            "weight": obj.get("weight")
        })
        return _obj


