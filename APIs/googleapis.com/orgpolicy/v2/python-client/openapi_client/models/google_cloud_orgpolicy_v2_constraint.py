# coding: utf-8

"""
    Organization Policy API

    The Organization Policy API allows users to configure governance rules on their Google Cloud resources across the resource hierarchy.

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_orgpolicy_v2_constraint_list_constraint import GoogleCloudOrgpolicyV2ConstraintListConstraint
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudOrgpolicyV2Constraint(BaseModel):
    """
    A constraint describes a way to restrict resource's configuration. For example, you could enforce a constraint that controls which Google Cloud services can be activated across an organization, or whether a Compute Engine instance can have serial port connections established. Constraints can be configured by the organization policy administrator to fit the needs of the organization by setting a policy that includes constraints at different locations in the organization's resource hierarchy. Policies are inherited down the resource hierarchy from higher levels, but can also be overridden. For details about the inheritance rules please read about `policies`. Constraints have a default behavior determined by the `constraint_default` field, which is the enforcement behavior that is used in the absence of a policy being defined or inherited for the resource in question.
    """ # noqa: E501
    boolean_constraint: Optional[Dict[str, Any]] = Field(default=None, description="A constraint that is either enforced or not. For example, a constraint `constraints/compute.disableSerialPortAccess`. If it is enforced on a VM instance, serial port connections will not be opened to that instance.", alias="booleanConstraint")
    constraint_default: Optional[StrictStr] = Field(default=None, description="The evaluation behavior of this constraint in the absence of a policy.", alias="constraintDefault")
    description: Optional[StrictStr] = Field(default=None, description="Detailed description of what this constraint controls as well as how and where it is enforced. Mutable.")
    display_name: Optional[StrictStr] = Field(default=None, description="The human readable name. Mutable.", alias="displayName")
    list_constraint: Optional[GoogleCloudOrgpolicyV2ConstraintListConstraint] = Field(default=None, alias="listConstraint")
    name: Optional[StrictStr] = Field(default=None, description="Immutable. The resource name of the constraint. Must be in one of the following forms: * `projects/{project_number}/constraints/{constraint_name}` * `folders/{folder_id}/constraints/{constraint_name}` * `organizations/{organization_id}/constraints/{constraint_name}` For example, \"/projects/123/constraints/compute.disableSerialPortAccess\".")
    supports_dry_run: Optional[StrictBool] = Field(default=None, description="Shows if dry run is supported for this constraint or not.", alias="supportsDryRun")
    __properties: ClassVar[List[str]] = ["booleanConstraint", "constraintDefault", "description", "displayName", "listConstraint", "name", "supportsDryRun"]

    @field_validator('constraint_default')
    def constraint_default_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CONSTRAINT_DEFAULT_UNSPECIFIED', 'ALLOW', 'DENY']):
            raise ValueError("must be one of enum values ('CONSTRAINT_DEFAULT_UNSPECIFIED', 'ALLOW', 'DENY')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudOrgpolicyV2Constraint from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of list_constraint
        if self.list_constraint:
            _dict['listConstraint'] = self.list_constraint.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudOrgpolicyV2Constraint from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "booleanConstraint": obj.get("booleanConstraint"),
            "constraintDefault": obj.get("constraintDefault"),
            "description": obj.get("description"),
            "displayName": obj.get("displayName"),
            "listConstraint": GoogleCloudOrgpolicyV2ConstraintListConstraint.from_dict(obj["listConstraint"]) if obj.get("listConstraint") is not None else None,
            "name": obj.get("name"),
            "supportsDryRun": obj.get("supportsDryRun")
        })
        return _obj


