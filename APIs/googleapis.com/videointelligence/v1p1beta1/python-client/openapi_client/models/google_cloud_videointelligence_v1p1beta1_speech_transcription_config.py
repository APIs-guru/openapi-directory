# coding: utf-8

"""
    Cloud Video Intelligence API

    Detects objects, explicit content, and scene changes in videos. It also specifies the region for annotation and transcribes speech to text. Supports both asynchronous API and streaming API.

    The version of the OpenAPI document: v1p1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_videointelligence_v1p1beta1_speech_context import GoogleCloudVideointelligenceV1p1beta1SpeechContext
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudVideointelligenceV1p1beta1SpeechTranscriptionConfig(BaseModel):
    """
    Config for SPEECH_TRANSCRIPTION.
    """ # noqa: E501
    audio_tracks: Optional[List[StrictInt]] = Field(default=None, description="Optional. For file formats, such as MXF or MKV, supporting multiple audio tracks, specify up to two tracks. Default: track 0.", alias="audioTracks")
    diarization_speaker_count: Optional[StrictInt] = Field(default=None, description="Optional. If set, specifies the estimated number of speakers in the conversation. If not set, defaults to '2'. Ignored unless enable_speaker_diarization is set to true.", alias="diarizationSpeakerCount")
    enable_automatic_punctuation: Optional[StrictBool] = Field(default=None, description="Optional. If 'true', adds punctuation to recognition result hypotheses. This feature is only available in select languages. Setting this for requests in other languages has no effect at all. The default 'false' value does not add punctuation to result hypotheses. NOTE: \"This is currently offered as an experimental service, complimentary to all users. In the future this may be exclusively available as a premium feature.\"", alias="enableAutomaticPunctuation")
    enable_speaker_diarization: Optional[StrictBool] = Field(default=None, description="Optional. If 'true', enables speaker detection for each recognized word in the top alternative of the recognition result using a speaker_tag provided in the WordInfo. Note: When this is true, we send all the words from the beginning of the audio for the top alternative in every consecutive response. This is done in order to improve our speaker tags as our models learn to identify the speakers in the conversation over time.", alias="enableSpeakerDiarization")
    enable_word_confidence: Optional[StrictBool] = Field(default=None, description="Optional. If `true`, the top result includes a list of words and the confidence for those words. If `false`, no word-level confidence information is returned. The default is `false`.", alias="enableWordConfidence")
    filter_profanity: Optional[StrictBool] = Field(default=None, description="Optional. If set to `true`, the server will attempt to filter out profanities, replacing all but the initial character in each filtered word with asterisks, e.g. \"f***\". If set to `false` or omitted, profanities won't be filtered out.", alias="filterProfanity")
    language_code: Optional[StrictStr] = Field(default=None, description="Required. *Required* The language of the supplied audio as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag. Example: \"en-US\". See [Language Support](https://cloud.google.com/speech/docs/languages) for a list of the currently supported language codes.", alias="languageCode")
    max_alternatives: Optional[StrictInt] = Field(default=None, description="Optional. Maximum number of recognition hypotheses to be returned. Specifically, the maximum number of `SpeechRecognitionAlternative` messages within each `SpeechTranscription`. The server may return fewer than `max_alternatives`. Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of one. If omitted, will return a maximum of one.", alias="maxAlternatives")
    speech_contexts: Optional[List[GoogleCloudVideointelligenceV1p1beta1SpeechContext]] = Field(default=None, description="Optional. A means to provide context to assist the speech recognition.", alias="speechContexts")
    __properties: ClassVar[List[str]] = ["audioTracks", "diarizationSpeakerCount", "enableAutomaticPunctuation", "enableSpeakerDiarization", "enableWordConfidence", "filterProfanity", "languageCode", "maxAlternatives", "speechContexts"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudVideointelligenceV1p1beta1SpeechTranscriptionConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in speech_contexts (list)
        _items = []
        if self.speech_contexts:
            for _item_speech_contexts in self.speech_contexts:
                if _item_speech_contexts:
                    _items.append(_item_speech_contexts.to_dict())
            _dict['speechContexts'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudVideointelligenceV1p1beta1SpeechTranscriptionConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "audioTracks": obj.get("audioTracks"),
            "diarizationSpeakerCount": obj.get("diarizationSpeakerCount"),
            "enableAutomaticPunctuation": obj.get("enableAutomaticPunctuation"),
            "enableSpeakerDiarization": obj.get("enableSpeakerDiarization"),
            "enableWordConfidence": obj.get("enableWordConfidence"),
            "filterProfanity": obj.get("filterProfanity"),
            "languageCode": obj.get("languageCode"),
            "maxAlternatives": obj.get("maxAlternatives"),
            "speechContexts": [GoogleCloudVideointelligenceV1p1beta1SpeechContext.from_dict(_item) for _item in obj["speechContexts"]] if obj.get("speechContexts") is not None else None
        })
        return _obj


