# coding: utf-8

"""
    Semantic Tile API

    Serves vector tiles containing geospatial data. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.area import Area
from openapi_client.models.extruded_area import ExtrudedArea
from openapi_client.models.line import Line
from openapi_client.models.modeled_volume import ModeledVolume
from typing import Optional, Set
from typing_extensions import Self

class Geometry(BaseModel):
    """
    Represents the geometry of a feature, that is, the shape that it has on the map. The local tile coordinate system has the origin at the north-west (upper-left) corner of the tile, and is scaled to 4096 units across each edge. The height (Z) axis has the same scale factor: an extruded area with a max_z value of 4096 has the same height as the width of the tile that it is on. There is no clipping boundary, so it is possible that some coordinates will lie outside the tile boundaries.
    """ # noqa: E501
    areas: Optional[List[Area]] = Field(default=None, description="The areas present in this geometry.")
    extruded_areas: Optional[List[ExtrudedArea]] = Field(default=None, description="The extruded areas present in this geometry. Not populated if modeled_volumes are included in this geometry unless always_include_building_footprints is set in GetFeatureTileRequest, in which case the client should decide which (extruded areas or modeled volumes) should be used (they should not be rendered together).", alias="extrudedAreas")
    lines: Optional[List[Line]] = Field(default=None, description="The lines present in this geometry.")
    modeled_volumes: Optional[List[ModeledVolume]] = Field(default=None, description="The modeled volumes present in this geometry. Not populated unless enable_modeled_volumes has been set in GetFeatureTileRequest.", alias="modeledVolumes")
    __properties: ClassVar[List[str]] = ["areas", "extrudedAreas", "lines", "modeledVolumes"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Geometry from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in areas (list)
        _items = []
        if self.areas:
            for _item_areas in self.areas:
                if _item_areas:
                    _items.append(_item_areas.to_dict())
            _dict['areas'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in extruded_areas (list)
        _items = []
        if self.extruded_areas:
            for _item_extruded_areas in self.extruded_areas:
                if _item_extruded_areas:
                    _items.append(_item_extruded_areas.to_dict())
            _dict['extrudedAreas'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in lines (list)
        _items = []
        if self.lines:
            for _item_lines in self.lines:
                if _item_lines:
                    _items.append(_item_lines.to_dict())
            _dict['lines'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in modeled_volumes (list)
        _items = []
        if self.modeled_volumes:
            for _item_modeled_volumes in self.modeled_volumes:
                if _item_modeled_volumes:
                    _items.append(_item_modeled_volumes.to_dict())
            _dict['modeledVolumes'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Geometry from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "areas": [Area.from_dict(_item) for _item in obj["areas"]] if obj.get("areas") is not None else None,
            "extrudedAreas": [ExtrudedArea.from_dict(_item) for _item in obj["extrudedAreas"]] if obj.get("extrudedAreas") is not None else None,
            "lines": [Line.from_dict(_item) for _item in obj["lines"]] if obj.get("lines") is not None else None,
            "modeledVolumes": [ModeledVolume.from_dict(_item) for _item in obj["modeledVolumes"]] if obj.get("modeledVolumes") is not None else None
        })
        return _obj


