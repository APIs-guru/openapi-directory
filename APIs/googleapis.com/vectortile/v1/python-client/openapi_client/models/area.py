# coding: utf-8

"""
    Semantic Tile API

    Serves vector tiles containing geospatial data. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.basemap_z_order import BasemapZOrder
from openapi_client.models.vertex2_d_list import Vertex2DList
from typing import Optional, Set
from typing_extensions import Self

class Area(BaseModel):
    """
    Represents an area. Used to represent regions such as water, parks, etc. Next ID: 10
    """ # noqa: E501
    basemap_z_order: Optional[BasemapZOrder] = Field(default=None, alias="basemapZOrder")
    has_external_edges: Optional[StrictBool] = Field(default=None, description="True if the polygon is not entirely internal to the feature that it belongs to: that is, some of the edges are bordering another feature.", alias="hasExternalEdges")
    internal_edges: Optional[List[StrictInt]] = Field(default=None, description="When has_external_edges is true, the polygon has some edges that border another feature. This field indicates the internal edges that do not border another feature. Each value is an index into the vertices array, and denotes the start vertex of the internal edge (the next vertex in the boundary loop is the end of the edge). If the selected vertex is the last vertex in the boundary loop, then the edge between that vertex and the starting vertex of the loop is internal. This field may be used for styling. For example, building parapets could be placed only on the external edges of a building polygon, or water could be lighter colored near the external edges of a body of water. If has_external_edges is false, all edges are internal and this field will be empty.", alias="internalEdges")
    loop_breaks: Optional[List[StrictInt]] = Field(default=None, description="Identifies the boundary loops of the polygon. Only set for INDEXED_TRIANGLE polygons. Each value is an index into the vertices array indicating the beginning of a loop. For instance, values of [2, 5] would indicate loop_data contained 3 loops with indices 0-1, 2-4, and 5-end. This may be used in conjunction with the internal_edges field for styling polygon boundaries. Note that an edge may be on a polygon boundary but still internal to the feature. For example, a feature split across multiple tiles will have an internal polygon boundary edge along the edge of the tile.", alias="loopBreaks")
    triangle_indices: Optional[List[StrictInt]] = Field(default=None, description="When the polygon encoding is of type INDEXED_TRIANGLES, this contains the indices of the triangle vertices in the vertex_offsets field. There are 3 vertex indices per triangle.", alias="triangleIndices")
    type: Optional[StrictStr] = Field(default=None, description="The polygon encoding type used for this area.")
    vertex_offsets: Optional[Vertex2DList] = Field(default=None, alias="vertexOffsets")
    z_order: Optional[StrictInt] = Field(default=None, description="The z-ordering of this area. Areas with a lower z-order should be rendered beneath areas with a higher z-order. This z-ordering does not imply anything about the altitude of the line relative to the ground, but it can be used to prevent z-fighting during rendering on the client. This z-ordering can only be used to compare areas, and cannot be compared with the z_order field in the Line message. The z-order may be negative or zero. Prefer Area.basemap_z_order.", alias="zOrder")
    __properties: ClassVar[List[str]] = ["basemapZOrder", "hasExternalEdges", "internalEdges", "loopBreaks", "triangleIndices", "type", "vertexOffsets", "zOrder"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['TRIANGLE_FAN', 'INDEXED_TRIANGLES', 'TRIANGLE_STRIP']):
            raise ValueError("must be one of enum values ('TRIANGLE_FAN', 'INDEXED_TRIANGLES', 'TRIANGLE_STRIP')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Area from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of basemap_z_order
        if self.basemap_z_order:
            _dict['basemapZOrder'] = self.basemap_z_order.to_dict()
        # override the default output from pydantic by calling `to_dict()` of vertex_offsets
        if self.vertex_offsets:
            _dict['vertexOffsets'] = self.vertex_offsets.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Area from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "basemapZOrder": BasemapZOrder.from_dict(obj["basemapZOrder"]) if obj.get("basemapZOrder") is not None else None,
            "hasExternalEdges": obj.get("hasExternalEdges"),
            "internalEdges": obj.get("internalEdges"),
            "loopBreaks": obj.get("loopBreaks"),
            "triangleIndices": obj.get("triangleIndices"),
            "type": obj.get("type"),
            "vertexOffsets": Vertex2DList.from_dict(obj["vertexOffsets"]) if obj.get("vertexOffsets") is not None else None,
            "zOrder": obj.get("zOrder")
        })
        return _obj


