# coding: utf-8

"""
    Semantic Tile API

    Serves vector tiles containing geospatial data. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.feature import Feature
from openapi_client.models.provider_info import ProviderInfo
from openapi_client.models.tile_coordinates import TileCoordinates
from typing import Optional, Set
from typing_extensions import Self

class FeatureTile(BaseModel):
    """
    A tile containing information about the map features located in the region it covers.
    """ # noqa: E501
    coordinates: Optional[TileCoordinates] = None
    features: Optional[List[Feature]] = Field(default=None, description="Features present on this map tile.")
    name: Optional[StrictStr] = Field(default=None, description="Resource name of the tile. The tile resource name is prefixed by its collection ID `tiles/` followed by the resource ID, which encodes the tile's global x and y coordinates and zoom level as `@,,z`. For example, `tiles/@1,2,3z`.")
    providers: Optional[List[ProviderInfo]] = Field(default=None, description="Data providers for the data contained in this tile.")
    status: Optional[StrictStr] = Field(default=None, description="Tile response status code to support tile caching.")
    version_id: Optional[StrictStr] = Field(default=None, description="An opaque value, usually less than 30 characters, that contains version info about this tile and the data that was used to generate it. The client should store this value in its tile cache and pass it back to the API in the client_tile_version_id field of subsequent tile requests in order to enable the API to detect when the new tile would be the same as the one the client already has in its cache. Also see STATUS_OK_DATA_UNCHANGED.", alias="versionId")
    __properties: ClassVar[List[str]] = ["coordinates", "features", "name", "providers", "status", "versionId"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATUS_OK', 'STATUS_OK_DATA_UNCHANGED']):
            raise ValueError("must be one of enum values ('STATUS_OK', 'STATUS_OK_DATA_UNCHANGED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FeatureTile from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of coordinates
        if self.coordinates:
            _dict['coordinates'] = self.coordinates.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in features (list)
        _items = []
        if self.features:
            for _item_features in self.features:
                if _item_features:
                    _items.append(_item_features.to_dict())
            _dict['features'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in providers (list)
        _items = []
        if self.providers:
            for _item_providers in self.providers:
                if _item_providers:
                    _items.append(_item_providers.to_dict())
            _dict['providers'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FeatureTile from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "coordinates": TileCoordinates.from_dict(obj["coordinates"]) if obj.get("coordinates") is not None else None,
            "features": [Feature.from_dict(_item) for _item in obj["features"]] if obj.get("features") is not None else None,
            "name": obj.get("name"),
            "providers": [ProviderInfo.from_dict(_item) for _item in obj["providers"]] if obj.get("providers") is not None else None,
            "status": obj.get("status"),
            "versionId": obj.get("versionId")
        })
        return _obj


