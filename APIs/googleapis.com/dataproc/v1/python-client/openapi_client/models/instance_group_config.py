# coding: utf-8

"""
    Cloud Dataproc API

    Manages Hadoop-based clusters and jobs on Google Cloud Platform.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.accelerator_config import AcceleratorConfig
from openapi_client.models.disk_config import DiskConfig
from openapi_client.models.instance_flexibility_policy import InstanceFlexibilityPolicy
from openapi_client.models.instance_reference import InstanceReference
from openapi_client.models.managed_group_config import ManagedGroupConfig
from openapi_client.models.startup_config import StartupConfig
from typing import Optional, Set
from typing_extensions import Self

class InstanceGroupConfig(BaseModel):
    """
    The config settings for Compute Engine resources in an instance group, such as a master or worker group.
    """ # noqa: E501
    accelerators: Optional[List[AcceleratorConfig]] = Field(default=None, description="Optional. The Compute Engine accelerator configuration for these instances.")
    disk_config: Optional[DiskConfig] = Field(default=None, alias="diskConfig")
    image_uri: Optional[StrictStr] = Field(default=None, description="Optional. The Compute Engine image resource used for cluster instances.The URI can represent an image or image family.Image examples: https://www.googleapis.com/compute/v1/projects/[project_id]/global/images/[image-id] projects/[project_id]/global/images/[image-id] image-idImage family examples. Dataproc will use the most recent image from the family: https://www.googleapis.com/compute/v1/projects/[project_id]/global/images/family/[custom-image-family-name] projects/[project_id]/global/images/family/[custom-image-family-name]If the URI is unspecified, it will be inferred from SoftwareConfig.image_version or the system default.", alias="imageUri")
    instance_flexibility_policy: Optional[InstanceFlexibilityPolicy] = Field(default=None, alias="instanceFlexibilityPolicy")
    instance_names: Optional[List[StrictStr]] = Field(default=None, description="Output only. The list of instance names. Dataproc derives the names from cluster_name, num_instances, and the instance group.", alias="instanceNames")
    instance_references: Optional[List[InstanceReference]] = Field(default=None, description="Output only. List of references to Compute Engine instances.", alias="instanceReferences")
    is_preemptible: Optional[StrictBool] = Field(default=None, description="Output only. Specifies that this instance group contains preemptible instances.", alias="isPreemptible")
    machine_type_uri: Optional[StrictStr] = Field(default=None, description="Optional. The Compute Engine machine type used for cluster instances.A full URL, partial URI, or short name are valid. Examples: https://www.googleapis.com/compute/v1/projects/[project_id]/zones/[zone]/machineTypes/n1-standard-2 projects/[project_id]/zones/[zone]/machineTypes/n1-standard-2 n1-standard-2Auto Zone Exception: If you are using the Dataproc Auto Zone Placement (https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement) feature, you must use the short name of the machine type resource, for example, n1-standard-2.", alias="machineTypeUri")
    managed_group_config: Optional[ManagedGroupConfig] = Field(default=None, alias="managedGroupConfig")
    min_cpu_platform: Optional[StrictStr] = Field(default=None, description="Optional. Specifies the minimum cpu platform for the Instance Group. See Dataproc -> Minimum CPU Platform (https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).", alias="minCpuPlatform")
    min_num_instances: Optional[StrictInt] = Field(default=None, description="Optional. The minimum number of primary worker instances to create. If min_num_instances is set, cluster creation will succeed if the number of primary workers created is at least equal to the min_num_instances number.Example: Cluster creation request with num_instances = 5 and min_num_instances = 3: If 4 VMs are created and 1 instance fails, the failed VM is deleted. The cluster is resized to 4 instances and placed in a RUNNING state. If 2 instances are created and 3 instances fail, the cluster in placed in an ERROR state. The failed VMs are not deleted.", alias="minNumInstances")
    num_instances: Optional[StrictInt] = Field(default=None, description="Optional. The number of VM instances in the instance group. For HA cluster master_config groups, must be set to 3. For standard cluster master_config groups, must be set to 1.", alias="numInstances")
    preemptibility: Optional[StrictStr] = Field(default=None, description="Optional. Specifies the preemptibility of the instance group.The default value for master and worker groups is NON_PREEMPTIBLE. This default cannot be changed.The default value for secondary instances is PREEMPTIBLE.")
    startup_config: Optional[StartupConfig] = Field(default=None, alias="startupConfig")
    __properties: ClassVar[List[str]] = ["accelerators", "diskConfig", "imageUri", "instanceFlexibilityPolicy", "instanceNames", "instanceReferences", "isPreemptible", "machineTypeUri", "managedGroupConfig", "minCpuPlatform", "minNumInstances", "numInstances", "preemptibility", "startupConfig"]

    @field_validator('preemptibility')
    def preemptibility_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PREEMPTIBILITY_UNSPECIFIED', 'NON_PREEMPTIBLE', 'PREEMPTIBLE', 'SPOT']):
            raise ValueError("must be one of enum values ('PREEMPTIBILITY_UNSPECIFIED', 'NON_PREEMPTIBLE', 'PREEMPTIBLE', 'SPOT')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of InstanceGroupConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "instance_names",
            "instance_references",
            "is_preemptible",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in accelerators (list)
        _items = []
        if self.accelerators:
            for _item_accelerators in self.accelerators:
                if _item_accelerators:
                    _items.append(_item_accelerators.to_dict())
            _dict['accelerators'] = _items
        # override the default output from pydantic by calling `to_dict()` of disk_config
        if self.disk_config:
            _dict['diskConfig'] = self.disk_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of instance_flexibility_policy
        if self.instance_flexibility_policy:
            _dict['instanceFlexibilityPolicy'] = self.instance_flexibility_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in instance_references (list)
        _items = []
        if self.instance_references:
            for _item_instance_references in self.instance_references:
                if _item_instance_references:
                    _items.append(_item_instance_references.to_dict())
            _dict['instanceReferences'] = _items
        # override the default output from pydantic by calling `to_dict()` of managed_group_config
        if self.managed_group_config:
            _dict['managedGroupConfig'] = self.managed_group_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of startup_config
        if self.startup_config:
            _dict['startupConfig'] = self.startup_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of InstanceGroupConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accelerators": [AcceleratorConfig.from_dict(_item) for _item in obj["accelerators"]] if obj.get("accelerators") is not None else None,
            "diskConfig": DiskConfig.from_dict(obj["diskConfig"]) if obj.get("diskConfig") is not None else None,
            "imageUri": obj.get("imageUri"),
            "instanceFlexibilityPolicy": InstanceFlexibilityPolicy.from_dict(obj["instanceFlexibilityPolicy"]) if obj.get("instanceFlexibilityPolicy") is not None else None,
            "instanceNames": obj.get("instanceNames"),
            "instanceReferences": [InstanceReference.from_dict(_item) for _item in obj["instanceReferences"]] if obj.get("instanceReferences") is not None else None,
            "isPreemptible": obj.get("isPreemptible"),
            "machineTypeUri": obj.get("machineTypeUri"),
            "managedGroupConfig": ManagedGroupConfig.from_dict(obj["managedGroupConfig"]) if obj.get("managedGroupConfig") is not None else None,
            "minCpuPlatform": obj.get("minCpuPlatform"),
            "minNumInstances": obj.get("minNumInstances"),
            "numInstances": obj.get("numInstances"),
            "preemptibility": obj.get("preemptibility"),
            "startupConfig": StartupConfig.from_dict(obj["startupConfig"]) if obj.get("startupConfig") is not None else None
        })
        return _obj


