# coding: utf-8

"""
    Cloud Billing Budget API

    The Cloud Billing Budget API stores Cloud Billing budgets, which define a budget plan and the rules to execute as spend is tracked against that plan.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_billing_budgets_v1_custom_period import GoogleCloudBillingBudgetsV1CustomPeriod
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudBillingBudgetsV1Filter(BaseModel):
    """
    A filter for a budget, limiting the scope of the cost to calculate.
    """ # noqa: E501
    calendar_period: Optional[StrictStr] = Field(default=None, description="Optional. Specifies to track usage for recurring calendar period. For example, assume that CalendarPeriod.QUARTER is set. The budget tracks usage from April 1 to June 30, when the current calendar month is April, May, June. After that, it tracks usage from July 1 to September 30 when the current calendar month is July, August, September, so on.", alias="calendarPeriod")
    credit_types: Optional[List[StrictStr]] = Field(default=None, description="Optional. If Filter.credit_types_treatment is INCLUDE_SPECIFIED_CREDITS, this is a list of credit types to be subtracted from gross cost to determine the spend for threshold calculations. See [a list of acceptable credit type values](https://cloud.google.com/billing/docs/how-to/export-data-bigquery-tables#credits-type). If Filter.credit_types_treatment is **not** INCLUDE_SPECIFIED_CREDITS, this field must be empty.", alias="creditTypes")
    credit_types_treatment: Optional[StrictStr] = Field(default=None, description="Optional. If not set, default behavior is `INCLUDE_ALL_CREDITS`.", alias="creditTypesTreatment")
    custom_period: Optional[GoogleCloudBillingBudgetsV1CustomPeriod] = Field(default=None, alias="customPeriod")
    labels: Optional[Dict[str, List[Any]]] = Field(default=None, description="Optional. A single label and value pair specifying that usage from only this set of labeled resources should be included in the budget. If omitted, the report includes all labeled and unlabeled usage. An object containing a single `\"key\": value` pair. Example: `{ \"name\": \"wrench\" }`. _Currently, multiple entries or multiple values per entry are not allowed._")
    projects: Optional[List[StrictStr]] = Field(default=None, description="Optional. A set of projects of the form `projects/{project}`, specifying that usage from only this set of projects should be included in the budget. If omitted, the report includes all usage for the billing account, regardless of which project the usage occurred on.")
    resource_ancestors: Optional[List[StrictStr]] = Field(default=None, description="Optional. A set of folder and organization names of the form `folders/{folderId}` or `organizations/{organizationId}`, specifying that usage from only this set of folders and organizations should be included in the budget. If omitted, the budget includes all usage that the billing account pays for. If the folder or organization contains projects that are paid for by a different Cloud Billing account, the budget *doesn't* apply to those projects.", alias="resourceAncestors")
    services: Optional[List[StrictStr]] = Field(default=None, description="Optional. A set of services of the form `services/{service_id}`, specifying that usage from only this set of services should be included in the budget. If omitted, the report includes usage for all the services. The service names are available through the Catalog API: https://cloud.google.com/billing/v1/how-tos/catalog-api.")
    subaccounts: Optional[List[StrictStr]] = Field(default=None, description="Optional. A set of subaccounts of the form `billingAccounts/{account_id}`, specifying that usage from only this set of subaccounts should be included in the budget. If a subaccount is set to the name of the parent account, usage from the parent account is included. If the field is omitted, the report includes usage from the parent account and all subaccounts, if they exist.")
    __properties: ClassVar[List[str]] = ["calendarPeriod", "creditTypes", "creditTypesTreatment", "customPeriod", "labels", "projects", "resourceAncestors", "services", "subaccounts"]

    @field_validator('calendar_period')
    def calendar_period_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CALENDAR_PERIOD_UNSPECIFIED', 'MONTH', 'QUARTER', 'YEAR']):
            raise ValueError("must be one of enum values ('CALENDAR_PERIOD_UNSPECIFIED', 'MONTH', 'QUARTER', 'YEAR')")
        return value

    @field_validator('credit_types_treatment')
    def credit_types_treatment_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CREDIT_TYPES_TREATMENT_UNSPECIFIED', 'INCLUDE_ALL_CREDITS', 'EXCLUDE_ALL_CREDITS', 'INCLUDE_SPECIFIED_CREDITS']):
            raise ValueError("must be one of enum values ('CREDIT_TYPES_TREATMENT_UNSPECIFIED', 'INCLUDE_ALL_CREDITS', 'EXCLUDE_ALL_CREDITS', 'INCLUDE_SPECIFIED_CREDITS')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudBillingBudgetsV1Filter from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of custom_period
        if self.custom_period:
            _dict['customPeriod'] = self.custom_period.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudBillingBudgetsV1Filter from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "calendarPeriod": obj.get("calendarPeriod"),
            "creditTypes": obj.get("creditTypes"),
            "creditTypesTreatment": obj.get("creditTypesTreatment"),
            "customPeriod": GoogleCloudBillingBudgetsV1CustomPeriod.from_dict(obj["customPeriod"]) if obj.get("customPeriod") is not None else None,
            "labels": obj.get("labels"),
            "projects": obj.get("projects"),
            "resourceAncestors": obj.get("resourceAncestors"),
            "services": obj.get("services"),
            "subaccounts": obj.get("subaccounts")
        })
        return _obj


