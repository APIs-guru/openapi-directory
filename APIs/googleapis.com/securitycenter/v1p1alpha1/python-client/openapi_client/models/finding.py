# coding: utf-8

"""
    Security Command Center API

    Security Command Center API provides access to temporal views of assets and findings within an organization.

    The version of the OpenAPI document: v1p1alpha1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.access import Access
from openapi_client.models.application import Application
from openapi_client.models.attack_exposure import AttackExposure
from openapi_client.models.backup_disaster_recovery import BackupDisasterRecovery
from openapi_client.models.cloud_dlp_data_profile import CloudDlpDataProfile
from openapi_client.models.cloud_dlp_inspection import CloudDlpInspection
from openapi_client.models.compliance import Compliance
from openapi_client.models.connection import Connection
from openapi_client.models.contact_details import ContactDetails
from openapi_client.models.container import Container
from openapi_client.models.database import Database
from openapi_client.models.exfiltration import Exfiltration
from openapi_client.models.file import File
from openapi_client.models.google_cloud_securitycenter_v1_external_system import GoogleCloudSecuritycenterV1ExternalSystem
from openapi_client.models.iam_binding import IamBinding
from openapi_client.models.indicator import Indicator
from openapi_client.models.kernel_rootkit import KernelRootkit
from openapi_client.models.kubernetes import Kubernetes
from openapi_client.models.load_balancer import LoadBalancer
from openapi_client.models.log_entry import LogEntry
from openapi_client.models.mitre_attack import MitreAttack
from openapi_client.models.org_policy import OrgPolicy
from openapi_client.models.process import Process
from openapi_client.models.security_marks import SecurityMarks
from openapi_client.models.security_posture import SecurityPosture
from openapi_client.models.vulnerability import Vulnerability
from typing import Optional, Set
from typing_extensions import Self

class Finding(BaseModel):
    """
    Security Command Center finding. A finding is a record of assessment data like security, risk, health, or privacy, that is ingested into Security Command Center for presentation, notification, analysis, policy testing, and enforcement. For example, a cross-site scripting (XSS) vulnerability in an App Engine application is a finding.
    """ # noqa: E501
    access: Optional[Access] = None
    application: Optional[Application] = None
    attack_exposure: Optional[AttackExposure] = Field(default=None, alias="attackExposure")
    backup_disaster_recovery: Optional[BackupDisasterRecovery] = Field(default=None, alias="backupDisasterRecovery")
    canonical_name: Optional[StrictStr] = Field(default=None, description="The canonical name of the finding. It's either \"organizations/{organization_id}/sources/{source_id}/findings/{finding_id}\", \"folders/{folder_id}/sources/{source_id}/findings/{finding_id}\" or \"projects/{project_number}/sources/{source_id}/findings/{finding_id}\", depending on the closest CRM ancestor of the resource associated with the finding.", alias="canonicalName")
    category: Optional[StrictStr] = Field(default=None, description="The additional taxonomy group within findings from a given source. This field is immutable after creation time. Example: \"XSS_FLASH_INJECTION\"")
    cloud_dlp_data_profile: Optional[CloudDlpDataProfile] = Field(default=None, alias="cloudDlpDataProfile")
    cloud_dlp_inspection: Optional[CloudDlpInspection] = Field(default=None, alias="cloudDlpInspection")
    compliances: Optional[List[Compliance]] = Field(default=None, description="Contains compliance information for security standards associated to the finding.")
    connections: Optional[List[Connection]] = Field(default=None, description="Contains information about the IP connection associated with the finding.")
    contacts: Optional[Dict[str, ContactDetails]] = Field(default=None, description="Output only. Map containing the points of contact for the given finding. The key represents the type of contact, while the value contains a list of all the contacts that pertain. Please refer to: https://cloud.google.com/resource-manager/docs/managing-notification-contacts#notification-categories { \"security\": { \"contacts\": [ { \"email\": \"person1@company.com\" }, { \"email\": \"person2@company.com\" } ] } }")
    containers: Optional[List[Container]] = Field(default=None, description="Containers associated with the finding. This field provides information for both Kubernetes and non-Kubernetes containers.")
    create_time: Optional[StrictStr] = Field(default=None, description="The time at which the finding was created in Security Command Center.", alias="createTime")
    database: Optional[Database] = None
    description: Optional[StrictStr] = Field(default=None, description="Contains more details about the finding.")
    event_time: Optional[StrictStr] = Field(default=None, description="The time the finding was first detected. If an existing finding is updated, then this is the time the update occurred. For example, if the finding represents an open firewall, this property captures the time the detector believes the firewall became open. The accuracy is determined by the detector. If the finding is later resolved, then this time reflects when the finding was resolved. This must not be set to a value greater than the current timestamp.", alias="eventTime")
    exfiltration: Optional[Exfiltration] = None
    external_systems: Optional[Dict[str, GoogleCloudSecuritycenterV1ExternalSystem]] = Field(default=None, description="Output only. Third party SIEM/SOAR fields within SCC, contains external system information and external system finding fields.", alias="externalSystems")
    external_uri: Optional[StrictStr] = Field(default=None, description="The URI that, if available, points to a web page outside of Security Command Center where additional information about the finding can be found. This field is guaranteed to be either empty or a well formed URL.", alias="externalUri")
    files: Optional[List[File]] = Field(default=None, description="File associated with the finding.")
    finding_class: Optional[StrictStr] = Field(default=None, description="The class of the finding.", alias="findingClass")
    iam_bindings: Optional[List[IamBinding]] = Field(default=None, description="Represents IAM bindings associated with the finding.", alias="iamBindings")
    indicator: Optional[Indicator] = None
    kernel_rootkit: Optional[KernelRootkit] = Field(default=None, alias="kernelRootkit")
    kubernetes: Optional[Kubernetes] = None
    load_balancers: Optional[List[LoadBalancer]] = Field(default=None, description="The load balancers associated with the finding.", alias="loadBalancers")
    log_entries: Optional[List[LogEntry]] = Field(default=None, description="Log entries that are relevant to the finding.", alias="logEntries")
    mitre_attack: Optional[MitreAttack] = Field(default=None, alias="mitreAttack")
    module_name: Optional[StrictStr] = Field(default=None, description="Unique identifier of the module which generated the finding. Example: folders/598186756061/securityHealthAnalyticsSettings/customModules/56799441161885", alias="moduleName")
    mute: Optional[StrictStr] = Field(default=None, description="Indicates the mute state of a finding (either muted, unmuted or undefined). Unlike other attributes of a finding, a finding provider shouldn't set the value of mute.")
    mute_initiator: Optional[StrictStr] = Field(default=None, description="Records additional information about the mute operation, for example, the [mute configuration](/security-command-center/docs/how-to-mute-findings) that muted the finding and the user who muted the finding.", alias="muteInitiator")
    mute_update_time: Optional[StrictStr] = Field(default=None, description="Output only. The most recent time this finding was muted or unmuted.", alias="muteUpdateTime")
    name: Optional[StrictStr] = Field(default=None, description="The [relative resource name](https://cloud.google.com/apis/design/resource_names#relative_resource_name) of the finding. Example: \"organizations/{organization_id}/sources/{source_id}/findings/{finding_id}\", \"folders/{folder_id}/sources/{source_id}/findings/{finding_id}\", \"projects/{project_id}/sources/{source_id}/findings/{finding_id}\".")
    next_steps: Optional[StrictStr] = Field(default=None, description="Steps to address the finding.", alias="nextSteps")
    org_policies: Optional[List[OrgPolicy]] = Field(default=None, description="Contains information about the org policies associated with the finding.", alias="orgPolicies")
    parent: Optional[StrictStr] = Field(default=None, description="The relative resource name of the source the finding belongs to. See: https://cloud.google.com/apis/design/resource_names#relative_resource_name This field is immutable after creation time. For example: \"organizations/{organization_id}/sources/{source_id}\"")
    parent_display_name: Optional[StrictStr] = Field(default=None, description="Output only. The human readable display name of the finding source such as \"Event Threat Detection\" or \"Security Health Analytics\".", alias="parentDisplayName")
    processes: Optional[List[Process]] = Field(default=None, description="Represents operating system processes associated with the Finding.")
    resource_name: Optional[StrictStr] = Field(default=None, description="For findings on Google Cloud resources, the full resource name of the Google Cloud resource this finding is for. See: https://cloud.google.com/apis/design/resource_names#full_resource_name When the finding is for a non-Google Cloud resource, the resourceName can be a customer or partner defined string. This field is immutable after creation time.", alias="resourceName")
    security_marks: Optional[SecurityMarks] = Field(default=None, alias="securityMarks")
    security_posture: Optional[SecurityPosture] = Field(default=None, alias="securityPosture")
    severity: Optional[StrictStr] = Field(default=None, description="The severity of the finding. This field is managed by the source that writes the finding.")
    source_properties: Optional[Dict[str, Any]] = Field(default=None, description="Source specific properties. These properties are managed by the source that writes the finding. The key names in the source_properties map must be between 1 and 255 characters, and must start with a letter and contain alphanumeric characters or underscores only.", alias="sourceProperties")
    state: Optional[StrictStr] = Field(default=None, description="The state of the finding.")
    vulnerability: Optional[Vulnerability] = None
    __properties: ClassVar[List[str]] = ["access", "application", "attackExposure", "backupDisasterRecovery", "canonicalName", "category", "cloudDlpDataProfile", "cloudDlpInspection", "compliances", "connections", "contacts", "containers", "createTime", "database", "description", "eventTime", "exfiltration", "externalSystems", "externalUri", "files", "findingClass", "iamBindings", "indicator", "kernelRootkit", "kubernetes", "loadBalancers", "logEntries", "mitreAttack", "moduleName", "mute", "muteInitiator", "muteUpdateTime", "name", "nextSteps", "orgPolicies", "parent", "parentDisplayName", "processes", "resourceName", "securityMarks", "securityPosture", "severity", "sourceProperties", "state", "vulnerability"]

    @field_validator('finding_class')
    def finding_class_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['FINDING_CLASS_UNSPECIFIED', 'THREAT', 'VULNERABILITY', 'MISCONFIGURATION', 'OBSERVATION', 'SCC_ERROR', 'POSTURE_VIOLATION']):
            raise ValueError("must be one of enum values ('FINDING_CLASS_UNSPECIFIED', 'THREAT', 'VULNERABILITY', 'MISCONFIGURATION', 'OBSERVATION', 'SCC_ERROR', 'POSTURE_VIOLATION')")
        return value

    @field_validator('mute')
    def mute_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MUTE_UNSPECIFIED', 'MUTED', 'UNMUTED', 'UNDEFINED']):
            raise ValueError("must be one of enum values ('MUTE_UNSPECIFIED', 'MUTED', 'UNMUTED', 'UNDEFINED')")
        return value

    @field_validator('severity')
    def severity_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SEVERITY_UNSPECIFIED', 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW']):
            raise ValueError("must be one of enum values ('SEVERITY_UNSPECIFIED', 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'ACTIVE', 'INACTIVE']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'ACTIVE', 'INACTIVE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Finding from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "contacts",
            "external_systems",
            "mute_update_time",
            "parent_display_name",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of access
        if self.access:
            _dict['access'] = self.access.to_dict()
        # override the default output from pydantic by calling `to_dict()` of application
        if self.application:
            _dict['application'] = self.application.to_dict()
        # override the default output from pydantic by calling `to_dict()` of attack_exposure
        if self.attack_exposure:
            _dict['attackExposure'] = self.attack_exposure.to_dict()
        # override the default output from pydantic by calling `to_dict()` of backup_disaster_recovery
        if self.backup_disaster_recovery:
            _dict['backupDisasterRecovery'] = self.backup_disaster_recovery.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_dlp_data_profile
        if self.cloud_dlp_data_profile:
            _dict['cloudDlpDataProfile'] = self.cloud_dlp_data_profile.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_dlp_inspection
        if self.cloud_dlp_inspection:
            _dict['cloudDlpInspection'] = self.cloud_dlp_inspection.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in compliances (list)
        _items = []
        if self.compliances:
            for _item_compliances in self.compliances:
                if _item_compliances:
                    _items.append(_item_compliances.to_dict())
            _dict['compliances'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in connections (list)
        _items = []
        if self.connections:
            for _item_connections in self.connections:
                if _item_connections:
                    _items.append(_item_connections.to_dict())
            _dict['connections'] = _items
        # override the default output from pydantic by calling `to_dict()` of each value in contacts (dict)
        _field_dict = {}
        if self.contacts:
            for _key_contacts in self.contacts:
                if self.contacts[_key_contacts]:
                    _field_dict[_key_contacts] = self.contacts[_key_contacts].to_dict()
            _dict['contacts'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each item in containers (list)
        _items = []
        if self.containers:
            for _item_containers in self.containers:
                if _item_containers:
                    _items.append(_item_containers.to_dict())
            _dict['containers'] = _items
        # override the default output from pydantic by calling `to_dict()` of database
        if self.database:
            _dict['database'] = self.database.to_dict()
        # override the default output from pydantic by calling `to_dict()` of exfiltration
        if self.exfiltration:
            _dict['exfiltration'] = self.exfiltration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in external_systems (dict)
        _field_dict = {}
        if self.external_systems:
            for _key_external_systems in self.external_systems:
                if self.external_systems[_key_external_systems]:
                    _field_dict[_key_external_systems] = self.external_systems[_key_external_systems].to_dict()
            _dict['externalSystems'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each item in files (list)
        _items = []
        if self.files:
            for _item_files in self.files:
                if _item_files:
                    _items.append(_item_files.to_dict())
            _dict['files'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in iam_bindings (list)
        _items = []
        if self.iam_bindings:
            for _item_iam_bindings in self.iam_bindings:
                if _item_iam_bindings:
                    _items.append(_item_iam_bindings.to_dict())
            _dict['iamBindings'] = _items
        # override the default output from pydantic by calling `to_dict()` of indicator
        if self.indicator:
            _dict['indicator'] = self.indicator.to_dict()
        # override the default output from pydantic by calling `to_dict()` of kernel_rootkit
        if self.kernel_rootkit:
            _dict['kernelRootkit'] = self.kernel_rootkit.to_dict()
        # override the default output from pydantic by calling `to_dict()` of kubernetes
        if self.kubernetes:
            _dict['kubernetes'] = self.kubernetes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in load_balancers (list)
        _items = []
        if self.load_balancers:
            for _item_load_balancers in self.load_balancers:
                if _item_load_balancers:
                    _items.append(_item_load_balancers.to_dict())
            _dict['loadBalancers'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in log_entries (list)
        _items = []
        if self.log_entries:
            for _item_log_entries in self.log_entries:
                if _item_log_entries:
                    _items.append(_item_log_entries.to_dict())
            _dict['logEntries'] = _items
        # override the default output from pydantic by calling `to_dict()` of mitre_attack
        if self.mitre_attack:
            _dict['mitreAttack'] = self.mitre_attack.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in org_policies (list)
        _items = []
        if self.org_policies:
            for _item_org_policies in self.org_policies:
                if _item_org_policies:
                    _items.append(_item_org_policies.to_dict())
            _dict['orgPolicies'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in processes (list)
        _items = []
        if self.processes:
            for _item_processes in self.processes:
                if _item_processes:
                    _items.append(_item_processes.to_dict())
            _dict['processes'] = _items
        # override the default output from pydantic by calling `to_dict()` of security_marks
        if self.security_marks:
            _dict['securityMarks'] = self.security_marks.to_dict()
        # override the default output from pydantic by calling `to_dict()` of security_posture
        if self.security_posture:
            _dict['securityPosture'] = self.security_posture.to_dict()
        # override the default output from pydantic by calling `to_dict()` of vulnerability
        if self.vulnerability:
            _dict['vulnerability'] = self.vulnerability.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Finding from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "access": Access.from_dict(obj["access"]) if obj.get("access") is not None else None,
            "application": Application.from_dict(obj["application"]) if obj.get("application") is not None else None,
            "attackExposure": AttackExposure.from_dict(obj["attackExposure"]) if obj.get("attackExposure") is not None else None,
            "backupDisasterRecovery": BackupDisasterRecovery.from_dict(obj["backupDisasterRecovery"]) if obj.get("backupDisasterRecovery") is not None else None,
            "canonicalName": obj.get("canonicalName"),
            "category": obj.get("category"),
            "cloudDlpDataProfile": CloudDlpDataProfile.from_dict(obj["cloudDlpDataProfile"]) if obj.get("cloudDlpDataProfile") is not None else None,
            "cloudDlpInspection": CloudDlpInspection.from_dict(obj["cloudDlpInspection"]) if obj.get("cloudDlpInspection") is not None else None,
            "compliances": [Compliance.from_dict(_item) for _item in obj["compliances"]] if obj.get("compliances") is not None else None,
            "connections": [Connection.from_dict(_item) for _item in obj["connections"]] if obj.get("connections") is not None else None,
            "contacts": dict(
                (_k, ContactDetails.from_dict(_v))
                for _k, _v in obj["contacts"].items()
            )
            if obj.get("contacts") is not None
            else None,
            "containers": [Container.from_dict(_item) for _item in obj["containers"]] if obj.get("containers") is not None else None,
            "createTime": obj.get("createTime"),
            "database": Database.from_dict(obj["database"]) if obj.get("database") is not None else None,
            "description": obj.get("description"),
            "eventTime": obj.get("eventTime"),
            "exfiltration": Exfiltration.from_dict(obj["exfiltration"]) if obj.get("exfiltration") is not None else None,
            "externalSystems": dict(
                (_k, GoogleCloudSecuritycenterV1ExternalSystem.from_dict(_v))
                for _k, _v in obj["externalSystems"].items()
            )
            if obj.get("externalSystems") is not None
            else None,
            "externalUri": obj.get("externalUri"),
            "files": [File.from_dict(_item) for _item in obj["files"]] if obj.get("files") is not None else None,
            "findingClass": obj.get("findingClass"),
            "iamBindings": [IamBinding.from_dict(_item) for _item in obj["iamBindings"]] if obj.get("iamBindings") is not None else None,
            "indicator": Indicator.from_dict(obj["indicator"]) if obj.get("indicator") is not None else None,
            "kernelRootkit": KernelRootkit.from_dict(obj["kernelRootkit"]) if obj.get("kernelRootkit") is not None else None,
            "kubernetes": Kubernetes.from_dict(obj["kubernetes"]) if obj.get("kubernetes") is not None else None,
            "loadBalancers": [LoadBalancer.from_dict(_item) for _item in obj["loadBalancers"]] if obj.get("loadBalancers") is not None else None,
            "logEntries": [LogEntry.from_dict(_item) for _item in obj["logEntries"]] if obj.get("logEntries") is not None else None,
            "mitreAttack": MitreAttack.from_dict(obj["mitreAttack"]) if obj.get("mitreAttack") is not None else None,
            "moduleName": obj.get("moduleName"),
            "mute": obj.get("mute"),
            "muteInitiator": obj.get("muteInitiator"),
            "muteUpdateTime": obj.get("muteUpdateTime"),
            "name": obj.get("name"),
            "nextSteps": obj.get("nextSteps"),
            "orgPolicies": [OrgPolicy.from_dict(_item) for _item in obj["orgPolicies"]] if obj.get("orgPolicies") is not None else None,
            "parent": obj.get("parent"),
            "parentDisplayName": obj.get("parentDisplayName"),
            "processes": [Process.from_dict(_item) for _item in obj["processes"]] if obj.get("processes") is not None else None,
            "resourceName": obj.get("resourceName"),
            "securityMarks": SecurityMarks.from_dict(obj["securityMarks"]) if obj.get("securityMarks") is not None else None,
            "securityPosture": SecurityPosture.from_dict(obj["securityPosture"]) if obj.get("securityPosture") is not None else None,
            "severity": obj.get("severity"),
            "sourceProperties": obj.get("sourceProperties"),
            "state": obj.get("state"),
            "vulnerability": Vulnerability.from_dict(obj["vulnerability"]) if obj.get("vulnerability") is not None else None
        })
        return _obj


