# coding: utf-8

"""
    Transcoder API

    This API converts video files into formats suitable for consumer distribution. 

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.ad_break import AdBreak
from openapi_client.models.edit_atom import EditAtom
from openapi_client.models.elementary_stream import ElementaryStream
from openapi_client.models.input import Input
from openapi_client.models.manifest import Manifest
from openapi_client.models.mux_stream import MuxStream
from openapi_client.models.output import Output
from openapi_client.models.overlay import Overlay
from openapi_client.models.pubsub_destination import PubsubDestination
from openapi_client.models.sprite_sheet import SpriteSheet
from typing import Optional, Set
from typing_extensions import Self

class JobConfig(BaseModel):
    """
    Job configuration
    """ # noqa: E501
    ad_breaks: Optional[List[AdBreak]] = Field(default=None, description="List of ad breaks. Specifies where to insert ad break tags in the output manifests.", alias="adBreaks")
    edit_list: Optional[List[EditAtom]] = Field(default=None, description="List of `Edit atom`s. Defines the ultimate timeline of the resulting file or manifest.", alias="editList")
    elementary_streams: Optional[List[ElementaryStream]] = Field(default=None, description="List of elementary streams.", alias="elementaryStreams")
    inputs: Optional[List[Input]] = Field(default=None, description="List of input assets stored in Cloud Storage.")
    manifests: Optional[List[Manifest]] = Field(default=None, description="List of output manifests.")
    mux_streams: Optional[List[MuxStream]] = Field(default=None, description="List of multiplexing settings for output streams.", alias="muxStreams")
    output: Optional[Output] = None
    overlays: Optional[List[Overlay]] = Field(default=None, description="List of overlays on the output video, in descending Z-order.")
    pubsub_destination: Optional[PubsubDestination] = Field(default=None, alias="pubsubDestination")
    sprite_sheets: Optional[List[SpriteSheet]] = Field(default=None, description="List of output sprite sheets.", alias="spriteSheets")
    __properties: ClassVar[List[str]] = ["adBreaks", "editList", "elementaryStreams", "inputs", "manifests", "muxStreams", "output", "overlays", "pubsubDestination", "spriteSheets"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of JobConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in ad_breaks (list)
        _items = []
        if self.ad_breaks:
            for _item_ad_breaks in self.ad_breaks:
                if _item_ad_breaks:
                    _items.append(_item_ad_breaks.to_dict())
            _dict['adBreaks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in edit_list (list)
        _items = []
        if self.edit_list:
            for _item_edit_list in self.edit_list:
                if _item_edit_list:
                    _items.append(_item_edit_list.to_dict())
            _dict['editList'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in elementary_streams (list)
        _items = []
        if self.elementary_streams:
            for _item_elementary_streams in self.elementary_streams:
                if _item_elementary_streams:
                    _items.append(_item_elementary_streams.to_dict())
            _dict['elementaryStreams'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in inputs (list)
        _items = []
        if self.inputs:
            for _item_inputs in self.inputs:
                if _item_inputs:
                    _items.append(_item_inputs.to_dict())
            _dict['inputs'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in manifests (list)
        _items = []
        if self.manifests:
            for _item_manifests in self.manifests:
                if _item_manifests:
                    _items.append(_item_manifests.to_dict())
            _dict['manifests'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mux_streams (list)
        _items = []
        if self.mux_streams:
            for _item_mux_streams in self.mux_streams:
                if _item_mux_streams:
                    _items.append(_item_mux_streams.to_dict())
            _dict['muxStreams'] = _items
        # override the default output from pydantic by calling `to_dict()` of output
        if self.output:
            _dict['output'] = self.output.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in overlays (list)
        _items = []
        if self.overlays:
            for _item_overlays in self.overlays:
                if _item_overlays:
                    _items.append(_item_overlays.to_dict())
            _dict['overlays'] = _items
        # override the default output from pydantic by calling `to_dict()` of pubsub_destination
        if self.pubsub_destination:
            _dict['pubsubDestination'] = self.pubsub_destination.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in sprite_sheets (list)
        _items = []
        if self.sprite_sheets:
            for _item_sprite_sheets in self.sprite_sheets:
                if _item_sprite_sheets:
                    _items.append(_item_sprite_sheets.to_dict())
            _dict['spriteSheets'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of JobConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "adBreaks": [AdBreak.from_dict(_item) for _item in obj["adBreaks"]] if obj.get("adBreaks") is not None else None,
            "editList": [EditAtom.from_dict(_item) for _item in obj["editList"]] if obj.get("editList") is not None else None,
            "elementaryStreams": [ElementaryStream.from_dict(_item) for _item in obj["elementaryStreams"]] if obj.get("elementaryStreams") is not None else None,
            "inputs": [Input.from_dict(_item) for _item in obj["inputs"]] if obj.get("inputs") is not None else None,
            "manifests": [Manifest.from_dict(_item) for _item in obj["manifests"]] if obj.get("manifests") is not None else None,
            "muxStreams": [MuxStream.from_dict(_item) for _item in obj["muxStreams"]] if obj.get("muxStreams") is not None else None,
            "output": Output.from_dict(obj["output"]) if obj.get("output") is not None else None,
            "overlays": [Overlay.from_dict(_item) for _item in obj["overlays"]] if obj.get("overlays") is not None else None,
            "pubsubDestination": PubsubDestination.from_dict(obj["pubsubDestination"]) if obj.get("pubsubDestination") is not None else None,
            "spriteSheets": [SpriteSheet.from_dict(_item) for _item in obj["spriteSheets"]] if obj.get("spriteSheets") is not None else None
        })
        return _obj


