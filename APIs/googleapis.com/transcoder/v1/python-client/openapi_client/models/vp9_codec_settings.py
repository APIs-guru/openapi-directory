# coding: utf-8

"""
    Transcoder API

    This API converts video files into formats suitable for consumer distribution. For more information, see the Transcoder API overview. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class Vp9CodecSettings(BaseModel):
    """
    VP9 codec settings.
    """ # noqa: E501
    bitrate_bps: Optional[StrictInt] = Field(default=None, description="Required. The video bitrate in bits per second. The minimum value is 1,000. The maximum value is 480,000,000.", alias="bitrateBps")
    crf_level: Optional[StrictInt] = Field(default=None, description="Target CRF level. Must be between 10 and 36, where 10 is the highest quality and 36 is the most efficient compression. The default is 21. **Note:** This field is not supported.", alias="crfLevel")
    frame_rate: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Required. The target video frame rate in frames per second (FPS). Must be less than or equal to 120.", alias="frameRate")
    frame_rate_conversion_strategy: Optional[StrictStr] = Field(default=None, description="Optional. Frame rate conversion strategy for desired frame rate. The default is `DOWNSAMPLE`.", alias="frameRateConversionStrategy")
    gop_duration: Optional[StrictStr] = Field(default=None, description="Select the GOP size based on the specified duration. The default is `3s`. Note that `gopDuration` must be less than or equal to [`segmentDuration`](#SegmentSettings), and [`segmentDuration`](#SegmentSettings) must be divisible by `gopDuration`.", alias="gopDuration")
    gop_frame_count: Optional[StrictInt] = Field(default=None, description="Select the GOP size based on the specified frame count. Must be greater than zero.", alias="gopFrameCount")
    height_pixels: Optional[StrictInt] = Field(default=None, description="The height of the video in pixels. Must be an even integer. When not specified, the height is adjusted to match the specified width and input aspect ratio. If both are omitted, the input height is used. For portrait videos that contain horizontal ASR and rotation metadata, provide the height, in pixels, per the horizontal ASR. The API calculates the width per the horizontal ASR. The API detects any rotation metadata and swaps the requested height and width for the output.", alias="heightPixels")
    hlg: Optional[Dict[str, Any]] = Field(default=None, description="Convert the input video to a Hybrid Log Gamma (HLG) video.")
    pixel_format: Optional[StrictStr] = Field(default=None, description="Pixel format to use. The default is `yuv420p`. Supported pixel formats: - `yuv420p` pixel format - `yuv422p` pixel format - `yuv444p` pixel format - `yuv420p10` 10-bit HDR pixel format - `yuv422p10` 10-bit HDR pixel format - `yuv444p10` 10-bit HDR pixel format - `yuv420p12` 12-bit HDR pixel format - `yuv422p12` 12-bit HDR pixel format - `yuv444p12` 12-bit HDR pixel format", alias="pixelFormat")
    profile: Optional[StrictStr] = Field(default=None, description="Enforces the specified codec profile. The following profiles are supported: * `profile0` (default) * `profile1` * `profile2` * `profile3` The available options are [WebM-compatible](https://www.webmproject.org/vp9/profiles/). Note that certain values for this field may cause the transcoder to override other fields you set in the `Vp9CodecSettings` message.")
    rate_control_mode: Optional[StrictStr] = Field(default=None, description="Specify the mode. The default is `vbr`. Supported rate control modes: - `vbr` - variable bitrate", alias="rateControlMode")
    sdr: Optional[Dict[str, Any]] = Field(default=None, description="Convert the input video to a Standard Dynamic Range (SDR) video.")
    width_pixels: Optional[StrictInt] = Field(default=None, description="The width of the video in pixels. Must be an even integer. When not specified, the width is adjusted to match the specified height and input aspect ratio. If both are omitted, the input width is used. For portrait videos that contain horizontal ASR and rotation metadata, provide the width, in pixels, per the horizontal ASR. The API calculates the height per the horizontal ASR. The API detects any rotation metadata and swaps the requested height and width for the output.", alias="widthPixels")
    __properties: ClassVar[List[str]] = ["bitrateBps", "crfLevel", "frameRate", "frameRateConversionStrategy", "gopDuration", "gopFrameCount", "heightPixels", "hlg", "pixelFormat", "profile", "rateControlMode", "sdr", "widthPixels"]

    @field_validator('frame_rate_conversion_strategy')
    def frame_rate_conversion_strategy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED', 'DOWNSAMPLE', 'DROP_DUPLICATE']):
            raise ValueError("must be one of enum values ('FRAME_RATE_CONVERSION_STRATEGY_UNSPECIFIED', 'DOWNSAMPLE', 'DROP_DUPLICATE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Vp9CodecSettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Vp9CodecSettings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "bitrateBps": obj.get("bitrateBps"),
            "crfLevel": obj.get("crfLevel"),
            "frameRate": obj.get("frameRate"),
            "frameRateConversionStrategy": obj.get("frameRateConversionStrategy"),
            "gopDuration": obj.get("gopDuration"),
            "gopFrameCount": obj.get("gopFrameCount"),
            "heightPixels": obj.get("heightPixels"),
            "hlg": obj.get("hlg"),
            "pixelFormat": obj.get("pixelFormat"),
            "profile": obj.get("profile"),
            "rateControlMode": obj.get("rateControlMode"),
            "sdr": obj.get("sdr"),
            "widthPixels": obj.get("widthPixels")
        })
        return _obj


