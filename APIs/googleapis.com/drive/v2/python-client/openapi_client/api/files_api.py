# coding: utf-8

"""
    Google Drive API

    The Google Drive API allows clients to access resources from Google Drive.

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.channel import Channel
from openapi_client.models.file import File
from openapi_client.models.file_list import FileList
from openapi_client.models.generated_ids import GeneratedIds
from openapi_client.models.label_list import LabelList
from openapi_client.models.modify_labels_request import ModifyLabelsRequest
from openapi_client.models.modify_labels_response import ModifyLabelsResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class FilesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def drive_files_copy(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to copy.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Whether to convert this file to the corresponding Docs Editors format.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Copying files into multiple folders is no longer supported. Use shortcuts instead.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If `ocr` is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the head revision of the new copy. A file can have a maximum of 200 pinned revisions.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The visibility of the new file. This parameter is only relevant when the source is not a native Google Doc and convert=false.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> File:
        """drive_files_copy

        Creates a copy of the specified file.

        :param file_id: The ID of the file to copy. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param convert: Whether to convert this file to the corresponding Docs Editors format.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Copying files into multiple folders is no longer supported. Use shortcuts instead.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If `ocr` is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the head revision of the new copy. A file can have a maximum of 200 pinned revisions.
        :type pinned: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param visibility: The visibility of the new file. This parameter is only relevant when the source is not a native Google Doc and convert=false.
        :type visibility: str
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_copy_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            visibility=visibility,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_copy_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to copy.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Whether to convert this file to the corresponding Docs Editors format.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Copying files into multiple folders is no longer supported. Use shortcuts instead.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If `ocr` is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the head revision of the new copy. A file can have a maximum of 200 pinned revisions.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The visibility of the new file. This parameter is only relevant when the source is not a native Google Doc and convert=false.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[File]:
        """drive_files_copy

        Creates a copy of the specified file.

        :param file_id: The ID of the file to copy. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param convert: Whether to convert this file to the corresponding Docs Editors format.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Copying files into multiple folders is no longer supported. Use shortcuts instead.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If `ocr` is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the head revision of the new copy. A file can have a maximum of 200 pinned revisions.
        :type pinned: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param visibility: The visibility of the new file. This parameter is only relevant when the source is not a native Google Doc and convert=false.
        :type visibility: str
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_copy_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            visibility=visibility,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_copy_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to copy.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Whether to convert this file to the corresponding Docs Editors format.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Copying files into multiple folders is no longer supported. Use shortcuts instead.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If `ocr` is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the head revision of the new copy. A file can have a maximum of 200 pinned revisions.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The visibility of the new file. This parameter is only relevant when the source is not a native Google Doc and convert=false.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_copy

        Creates a copy of the specified file.

        :param file_id: The ID of the file to copy. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param convert: Whether to convert this file to the corresponding Docs Editors format.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Copying files into multiple folders is no longer supported. Use shortcuts instead.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If `ocr` is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the head revision of the new copy. A file can have a maximum of 200 pinned revisions.
        :type pinned: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param visibility: The visibility of the new file. This parameter is only relevant when the source is not a native Google Doc and convert=false.
        :type visibility: str
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_copy_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            visibility=visibility,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_copy_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        convert,
        enforce_single_parent,
        include_labels,
        include_permissions_for_view,
        ocr,
        ocr_language,
        pinned,
        supports_all_drives,
        supports_team_drives,
        timed_text_language,
        timed_text_track_name,
        visibility,
        file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if convert is not None:
            
            _query_params.append(('convert', convert))
            
        if enforce_single_parent is not None:
            
            _query_params.append(('enforceSingleParent', enforce_single_parent))
            
        if include_labels is not None:
            
            _query_params.append(('includeLabels', include_labels))
            
        if include_permissions_for_view is not None:
            
            _query_params.append(('includePermissionsForView', include_permissions_for_view))
            
        if ocr is not None:
            
            _query_params.append(('ocr', ocr))
            
        if ocr_language is not None:
            
            _query_params.append(('ocrLanguage', ocr_language))
            
        if pinned is not None:
            
            _query_params.append(('pinned', pinned))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        if timed_text_language is not None:
            
            _query_params.append(('timedTextLanguage', timed_text_language))
            
        if timed_text_track_name is not None:
            
            _query_params.append(('timedTextTrackName', timed_text_track_name))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if file is not None:
            _body_params = file


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files/{fileId}/copy',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_delete(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to delete.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """drive_files_delete

        Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive, the user must be an `organizer` on the parent folder. If the target is a folder, all descendants owned by the user are also deleted.

        :param file_id: The ID of the file to delete. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param enforce_single_parent: Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.
        :type enforce_single_parent: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_delete_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            enforce_single_parent=enforce_single_parent,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_delete_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to delete.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """drive_files_delete

        Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive, the user must be an `organizer` on the parent folder. If the target is a folder, all descendants owned by the user are also deleted.

        :param file_id: The ID of the file to delete. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param enforce_single_parent: Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.
        :type enforce_single_parent: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_delete_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            enforce_single_parent=enforce_single_parent,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_delete_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to delete.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_delete

        Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive, the user must be an `organizer` on the parent folder. If the target is a folder, all descendants owned by the user are also deleted.

        :param file_id: The ID of the file to delete. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param enforce_single_parent: Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.
        :type enforce_single_parent: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_delete_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            enforce_single_parent=enforce_single_parent,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_delete_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        enforce_single_parent,
        supports_all_drives,
        supports_team_drives,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if enforce_single_parent is not None:
            
            _query_params.append(('enforceSingleParent', enforce_single_parent))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/files/{fileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_empty_trash(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        drive_id: Annotated[Optional[StrictStr], Field(description="If set, empties the trash of the provided shared drive.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """drive_files_empty_trash

        Permanently deletes all of the user's trashed files.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param drive_id: If set, empties the trash of the provided shared drive.
        :type drive_id: str
        :param enforce_single_parent: Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.
        :type enforce_single_parent: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_empty_trash_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            drive_id=drive_id,
            enforce_single_parent=enforce_single_parent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_empty_trash_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        drive_id: Annotated[Optional[StrictStr], Field(description="If set, empties the trash of the provided shared drive.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """drive_files_empty_trash

        Permanently deletes all of the user's trashed files.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param drive_id: If set, empties the trash of the provided shared drive.
        :type drive_id: str
        :param enforce_single_parent: Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.
        :type enforce_single_parent: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_empty_trash_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            drive_id=drive_id,
            enforce_single_parent=enforce_single_parent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_empty_trash_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        drive_id: Annotated[Optional[StrictStr], Field(description="If set, empties the trash of the provided shared drive.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_empty_trash

        Permanently deletes all of the user's trashed files.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param drive_id: If set, empties the trash of the provided shared drive.
        :type drive_id: str
        :param enforce_single_parent: Deprecated: If an item is not in a shared drive and its last parent is deleted but the item itself is not, the item is placed under its owner's root.
        :type enforce_single_parent: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_empty_trash_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            drive_id=drive_id,
            enforce_single_parent=enforce_single_parent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_empty_trash_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        drive_id,
        enforce_single_parent,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if drive_id is not None:
            
            _query_params.append(('driveId', drive_id))
            
        if enforce_single_parent is not None:
            
            _query_params.append(('enforceSingleParent', enforce_single_parent))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/files/trash',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_export(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file.")],
        mime_type: Annotated[StrictStr, Field(description="Required. The MIME type of the format requested for this export.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """drive_files_export

        Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.

        :param file_id: The ID of the file. (required)
        :type file_id: str
        :param mime_type: Required. The MIME type of the format requested for this export. (required)
        :type mime_type: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_export_serialize(
            file_id=file_id,
            mime_type=mime_type,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_export_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file.")],
        mime_type: Annotated[StrictStr, Field(description="Required. The MIME type of the format requested for this export.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """drive_files_export

        Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.

        :param file_id: The ID of the file. (required)
        :type file_id: str
        :param mime_type: Required. The MIME type of the format requested for this export. (required)
        :type mime_type: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_export_serialize(
            file_id=file_id,
            mime_type=mime_type,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_export_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file.")],
        mime_type: Annotated[StrictStr, Field(description="Required. The MIME type of the format requested for this export.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_export

        Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.

        :param file_id: The ID of the file. (required)
        :type file_id: str
        :param mime_type: Required. The MIME type of the format requested for this export. (required)
        :type mime_type: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_export_serialize(
            file_id=file_id,
            mime_type=mime_type,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_export_serialize(
        self,
        file_id,
        mime_type,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if mime_type is not None:
            
            _query_params.append(('mimeType', mime_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/files/{fileId}/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_generate_ids(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="Maximum number of IDs to return.")] = None,
        space: Annotated[Optional[StrictStr], Field(description="The space in which the IDs can be used to create new files. Supported values are `drive` and `appDataFolder`. (Default: `drive`)")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The type of items which the IDs can be used for. Supported values are `files` and `shortcuts`. Note that `shortcuts` are only supported in the `drive` `space`. (Default: `files`)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GeneratedIds:
        """drive_files_generate_ids

        Generates a set of file IDs which can be provided in insert or copy requests.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param max_results: Maximum number of IDs to return.
        :type max_results: int
        :param space: The space in which the IDs can be used to create new files. Supported values are `drive` and `appDataFolder`. (Default: `drive`)
        :type space: str
        :param type: The type of items which the IDs can be used for. Supported values are `files` and `shortcuts`. Note that `shortcuts` are only supported in the `drive` `space`. (Default: `files`)
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_generate_ids_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            max_results=max_results,
            space=space,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeneratedIds",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_generate_ids_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="Maximum number of IDs to return.")] = None,
        space: Annotated[Optional[StrictStr], Field(description="The space in which the IDs can be used to create new files. Supported values are `drive` and `appDataFolder`. (Default: `drive`)")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The type of items which the IDs can be used for. Supported values are `files` and `shortcuts`. Note that `shortcuts` are only supported in the `drive` `space`. (Default: `files`)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GeneratedIds]:
        """drive_files_generate_ids

        Generates a set of file IDs which can be provided in insert or copy requests.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param max_results: Maximum number of IDs to return.
        :type max_results: int
        :param space: The space in which the IDs can be used to create new files. Supported values are `drive` and `appDataFolder`. (Default: `drive`)
        :type space: str
        :param type: The type of items which the IDs can be used for. Supported values are `files` and `shortcuts`. Note that `shortcuts` are only supported in the `drive` `space`. (Default: `files`)
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_generate_ids_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            max_results=max_results,
            space=space,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeneratedIds",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_generate_ids_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="Maximum number of IDs to return.")] = None,
        space: Annotated[Optional[StrictStr], Field(description="The space in which the IDs can be used to create new files. Supported values are `drive` and `appDataFolder`. (Default: `drive`)")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The type of items which the IDs can be used for. Supported values are `files` and `shortcuts`. Note that `shortcuts` are only supported in the `drive` `space`. (Default: `files`)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_generate_ids

        Generates a set of file IDs which can be provided in insert or copy requests.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param max_results: Maximum number of IDs to return.
        :type max_results: int
        :param space: The space in which the IDs can be used to create new files. Supported values are `drive` and `appDataFolder`. (Default: `drive`)
        :type space: str
        :param type: The type of items which the IDs can be used for. Supported values are `files` and `shortcuts`. Note that `shortcuts` are only supported in the `drive` `space`. (Default: `files`)
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_generate_ids_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            max_results=max_results,
            space=space,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeneratedIds",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_generate_ids_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        max_results,
        space,
        type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if max_results is not None:
            
            _query_params.append(('maxResults', max_results))
            
        if space is not None:
            
            _query_params.append(('space', space))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/files/generateIds',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_get(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID for the file in question.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        acknowledge_abuse: Annotated[Optional[StrictBool], Field(description="Whether the user is acknowledging the risk of downloading known malware or other abusive files.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Deprecated: This parameter has no function.")] = None,
        revision_id: Annotated[Optional[StrictStr], Field(description="Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `files.update` with `modifiedDateBehavior=noChange, updateViewedDate=true` and an empty request body.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> File:
        """drive_files_get

         Gets a file's metadata or content by ID. If you provide the URL parameter `alt=media`, then the response includes the file contents in the response body. Downloading content with `alt=media` only works if the file is stored in Drive. To download Google Docs, Sheets, and Slides use [`files.export`](/drive/api/reference/rest/v2/files/export) instead. For more information, see [Download & export files](/drive/api/guides/manage-downloads).

        :param file_id: The ID for the file in question. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param acknowledge_abuse: Whether the user is acknowledging the risk of downloading known malware or other abusive files.
        :type acknowledge_abuse: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param projection: Deprecated: This parameter has no function.
        :type projection: str
        :param revision_id: Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.
        :type revision_id: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param update_viewed_date: Deprecated: Use `files.update` with `modifiedDateBehavior=noChange, updateViewedDate=true` and an empty request body.
        :type update_viewed_date: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_get_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            acknowledge_abuse=acknowledge_abuse,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            projection=projection,
            revision_id=revision_id,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            update_viewed_date=update_viewed_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_get_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID for the file in question.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        acknowledge_abuse: Annotated[Optional[StrictBool], Field(description="Whether the user is acknowledging the risk of downloading known malware or other abusive files.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Deprecated: This parameter has no function.")] = None,
        revision_id: Annotated[Optional[StrictStr], Field(description="Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `files.update` with `modifiedDateBehavior=noChange, updateViewedDate=true` and an empty request body.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[File]:
        """drive_files_get

         Gets a file's metadata or content by ID. If you provide the URL parameter `alt=media`, then the response includes the file contents in the response body. Downloading content with `alt=media` only works if the file is stored in Drive. To download Google Docs, Sheets, and Slides use [`files.export`](/drive/api/reference/rest/v2/files/export) instead. For more information, see [Download & export files](/drive/api/guides/manage-downloads).

        :param file_id: The ID for the file in question. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param acknowledge_abuse: Whether the user is acknowledging the risk of downloading known malware or other abusive files.
        :type acknowledge_abuse: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param projection: Deprecated: This parameter has no function.
        :type projection: str
        :param revision_id: Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.
        :type revision_id: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param update_viewed_date: Deprecated: Use `files.update` with `modifiedDateBehavior=noChange, updateViewedDate=true` and an empty request body.
        :type update_viewed_date: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_get_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            acknowledge_abuse=acknowledge_abuse,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            projection=projection,
            revision_id=revision_id,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            update_viewed_date=update_viewed_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_get_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID for the file in question.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        acknowledge_abuse: Annotated[Optional[StrictBool], Field(description="Whether the user is acknowledging the risk of downloading known malware or other abusive files.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Deprecated: This parameter has no function.")] = None,
        revision_id: Annotated[Optional[StrictStr], Field(description="Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `files.update` with `modifiedDateBehavior=noChange, updateViewedDate=true` and an empty request body.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_get

         Gets a file's metadata or content by ID. If you provide the URL parameter `alt=media`, then the response includes the file contents in the response body. Downloading content with `alt=media` only works if the file is stored in Drive. To download Google Docs, Sheets, and Slides use [`files.export`](/drive/api/reference/rest/v2/files/export) instead. For more information, see [Download & export files](/drive/api/guides/manage-downloads).

        :param file_id: The ID for the file in question. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param acknowledge_abuse: Whether the user is acknowledging the risk of downloading known malware or other abusive files.
        :type acknowledge_abuse: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param projection: Deprecated: This parameter has no function.
        :type projection: str
        :param revision_id: Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.
        :type revision_id: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param update_viewed_date: Deprecated: Use `files.update` with `modifiedDateBehavior=noChange, updateViewedDate=true` and an empty request body.
        :type update_viewed_date: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_get_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            acknowledge_abuse=acknowledge_abuse,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            projection=projection,
            revision_id=revision_id,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            update_viewed_date=update_viewed_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_get_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        acknowledge_abuse,
        include_labels,
        include_permissions_for_view,
        projection,
        revision_id,
        supports_all_drives,
        supports_team_drives,
        update_viewed_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if acknowledge_abuse is not None:
            
            _query_params.append(('acknowledgeAbuse', acknowledge_abuse))
            
        if include_labels is not None:
            
            _query_params.append(('includeLabels', include_labels))
            
        if include_permissions_for_view is not None:
            
            _query_params.append(('includePermissionsForView', include_permissions_for_view))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if revision_id is not None:
            
            _query_params.append(('revisionId', revision_id))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        if update_viewed_date is not None:
            
            _query_params.append(('updateViewedDate', update_viewed_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/files/{fileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_insert(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Whether to convert this file to the corresponding Docs Editors format.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Creating files in multiple folders is no longer supported.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If ocr is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the head revision of the uploaded file. A file can have a maximum of 200 pinned revisions.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        use_content_as_indexable_text: Annotated[Optional[StrictBool], Field(description="Whether to use the content as indexable text.")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The visibility of the new file. This parameter is only relevant when convert=false.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> File:
        """drive_files_insert

         Inserts a new file. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads). Apps creating shortcuts with `files.insert` must specify the MIME type `application/vnd.google-apps.shortcut`. Apps should specify a file extension in the `title` property when inserting files with the API. For example, an operation to insert a JPEG file should specify something like `\"title\": \"cat.jpg\"` in the metadata. Subsequent `GET` requests include the read-only `fileExtension` property populated with the extension originally specified in the `title` property. When a Google Drive user requests to download a file, or when the file is downloaded through the sync client, Drive builds a full filename (with extension) based on the title. In cases where the extension is missing, Drive attempts to determine the extension based on the file's MIME type.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param convert: Whether to convert this file to the corresponding Docs Editors format.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Creating files in multiple folders is no longer supported.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If ocr is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the head revision of the uploaded file. A file can have a maximum of 200 pinned revisions.
        :type pinned: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param use_content_as_indexable_text: Whether to use the content as indexable text.
        :type use_content_as_indexable_text: bool
        :param visibility: The visibility of the new file. This parameter is only relevant when convert=false.
        :type visibility: str
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_insert_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            use_content_as_indexable_text=use_content_as_indexable_text,
            visibility=visibility,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_insert_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Whether to convert this file to the corresponding Docs Editors format.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Creating files in multiple folders is no longer supported.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If ocr is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the head revision of the uploaded file. A file can have a maximum of 200 pinned revisions.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        use_content_as_indexable_text: Annotated[Optional[StrictBool], Field(description="Whether to use the content as indexable text.")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The visibility of the new file. This parameter is only relevant when convert=false.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[File]:
        """drive_files_insert

         Inserts a new file. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads). Apps creating shortcuts with `files.insert` must specify the MIME type `application/vnd.google-apps.shortcut`. Apps should specify a file extension in the `title` property when inserting files with the API. For example, an operation to insert a JPEG file should specify something like `\"title\": \"cat.jpg\"` in the metadata. Subsequent `GET` requests include the read-only `fileExtension` property populated with the extension originally specified in the `title` property. When a Google Drive user requests to download a file, or when the file is downloaded through the sync client, Drive builds a full filename (with extension) based on the title. In cases where the extension is missing, Drive attempts to determine the extension based on the file's MIME type.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param convert: Whether to convert this file to the corresponding Docs Editors format.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Creating files in multiple folders is no longer supported.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If ocr is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the head revision of the uploaded file. A file can have a maximum of 200 pinned revisions.
        :type pinned: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param use_content_as_indexable_text: Whether to use the content as indexable text.
        :type use_content_as_indexable_text: bool
        :param visibility: The visibility of the new file. This parameter is only relevant when convert=false.
        :type visibility: str
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_insert_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            use_content_as_indexable_text=use_content_as_indexable_text,
            visibility=visibility,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_insert_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Whether to convert this file to the corresponding Docs Editors format.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Creating files in multiple folders is no longer supported.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If ocr is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the head revision of the uploaded file. A file can have a maximum of 200 pinned revisions.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        use_content_as_indexable_text: Annotated[Optional[StrictBool], Field(description="Whether to use the content as indexable text.")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The visibility of the new file. This parameter is only relevant when convert=false.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_insert

         Inserts a new file. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads). Apps creating shortcuts with `files.insert` must specify the MIME type `application/vnd.google-apps.shortcut`. Apps should specify a file extension in the `title` property when inserting files with the API. For example, an operation to insert a JPEG file should specify something like `\"title\": \"cat.jpg\"` in the metadata. Subsequent `GET` requests include the read-only `fileExtension` property populated with the extension originally specified in the `title` property. When a Google Drive user requests to download a file, or when the file is downloaded through the sync client, Drive builds a full filename (with extension) based on the title. In cases where the extension is missing, Drive attempts to determine the extension based on the file's MIME type.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param convert: Whether to convert this file to the corresponding Docs Editors format.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Creating files in multiple folders is no longer supported.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If ocr is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the head revision of the uploaded file. A file can have a maximum of 200 pinned revisions.
        :type pinned: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param use_content_as_indexable_text: Whether to use the content as indexable text.
        :type use_content_as_indexable_text: bool
        :param visibility: The visibility of the new file. This parameter is only relevant when convert=false.
        :type visibility: str
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_insert_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            use_content_as_indexable_text=use_content_as_indexable_text,
            visibility=visibility,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_insert_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        convert,
        enforce_single_parent,
        include_labels,
        include_permissions_for_view,
        ocr,
        ocr_language,
        pinned,
        supports_all_drives,
        supports_team_drives,
        timed_text_language,
        timed_text_track_name,
        use_content_as_indexable_text,
        visibility,
        file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if convert is not None:
            
            _query_params.append(('convert', convert))
            
        if enforce_single_parent is not None:
            
            _query_params.append(('enforceSingleParent', enforce_single_parent))
            
        if include_labels is not None:
            
            _query_params.append(('includeLabels', include_labels))
            
        if include_permissions_for_view is not None:
            
            _query_params.append(('includePermissionsForView', include_permissions_for_view))
            
        if ocr is not None:
            
            _query_params.append(('ocr', ocr))
            
        if ocr_language is not None:
            
            _query_params.append(('ocrLanguage', ocr_language))
            
        if pinned is not None:
            
            _query_params.append(('pinned', pinned))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        if timed_text_language is not None:
            
            _query_params.append(('timedTextLanguage', timed_text_language))
            
        if timed_text_track_name is not None:
            
            _query_params.append(('timedTextTrackName', timed_text_track_name))
            
        if use_content_as_indexable_text is not None:
            
            _query_params.append(('useContentAsIndexableText', use_content_as_indexable_text))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if file is not None:
            _body_params = file


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/octet-stream'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_list(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        corpora: Annotated[Optional[StrictStr], Field(description="Bodies of items (files/documents) to which the query applies. Supported bodies are `default`, `domain`, `drive` and `allDrives`. Prefer `default` or `drive` to `allDrives` for efficiency.")] = None,
        corpus: Annotated[Optional[StrictStr], Field(description="Deprecated: The body of items (files/documents) to which the query applies. Use `corpora` instead.")] = None,
        drive_id: Annotated[Optional[StrictStr], Field(description="ID of the shared drive to search.")] = None,
        include_items_from_all_drives: Annotated[Optional[StrictBool], Field(description="Whether both My Drive and shared drive items should be included in results.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        include_team_drive_items: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `includeItemsFromAllDrives` instead.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The maximum number of files to return per page. Partial or empty result pages are possible even before the end of the files list has been reached.")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="A comma-separated list of sort keys. Valid keys are `createdDate`, `folder`, `lastViewedByMeDate`, `modifiedByMeDate`, `modifiedDate`, `quotaBytesUsed`, `recency`, `sharedWithMeDate`, `starred`, `title`, and `title_natural`. Each key sorts ascending by default, but may be reversed with the `desc` modifier. Example usage: ?orderBy=folder,modifiedDate desc,title. Please note that there is a current limitation for users with approximately one million files in which the requested sort order is ignored.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="Page token for files.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Deprecated: This parameter has no function.")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Query string for searching files.")] = None,
        spaces: Annotated[Optional[StrictStr], Field(description="A comma-separated list of spaces to query. Supported values are `drive`, and `appDataFolder`.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        team_drive_id: Annotated[Optional[StrictStr], Field(description="Deprecated: Use `driveId` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileList:
        """drive_files_list

         Lists the user's files. This method accepts the `q` parameter, which is a search query combining one or more search terms. For more information, see the [Search for files & folders](/drive/api/guides/search-files) guide. *Note:* This method returns *all* files by default, including trashed files. If you don't want trashed files to appear in the list, use the `trashed=false` query parameter to remove trashed files from the results.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param corpora: Bodies of items (files/documents) to which the query applies. Supported bodies are `default`, `domain`, `drive` and `allDrives`. Prefer `default` or `drive` to `allDrives` for efficiency.
        :type corpora: str
        :param corpus: Deprecated: The body of items (files/documents) to which the query applies. Use `corpora` instead.
        :type corpus: str
        :param drive_id: ID of the shared drive to search.
        :type drive_id: str
        :param include_items_from_all_drives: Whether both My Drive and shared drive items should be included in results.
        :type include_items_from_all_drives: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param include_team_drive_items: Deprecated: Use `includeItemsFromAllDrives` instead.
        :type include_team_drive_items: bool
        :param max_results: The maximum number of files to return per page. Partial or empty result pages are possible even before the end of the files list has been reached.
        :type max_results: int
        :param order_by: A comma-separated list of sort keys. Valid keys are `createdDate`, `folder`, `lastViewedByMeDate`, `modifiedByMeDate`, `modifiedDate`, `quotaBytesUsed`, `recency`, `sharedWithMeDate`, `starred`, `title`, and `title_natural`. Each key sorts ascending by default, but may be reversed with the `desc` modifier. Example usage: ?orderBy=folder,modifiedDate desc,title. Please note that there is a current limitation for users with approximately one million files in which the requested sort order is ignored.
        :type order_by: str
        :param page_token: Page token for files.
        :type page_token: str
        :param projection: Deprecated: This parameter has no function.
        :type projection: str
        :param q: Query string for searching files.
        :type q: str
        :param spaces: A comma-separated list of spaces to query. Supported values are `drive`, and `appDataFolder`.
        :type spaces: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param team_drive_id: Deprecated: Use `driveId` instead.
        :type team_drive_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_list_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            corpora=corpora,
            corpus=corpus,
            drive_id=drive_id,
            include_items_from_all_drives=include_items_from_all_drives,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            include_team_drive_items=include_team_drive_items,
            max_results=max_results,
            order_by=order_by,
            page_token=page_token,
            projection=projection,
            q=q,
            spaces=spaces,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            team_drive_id=team_drive_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_list_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        corpora: Annotated[Optional[StrictStr], Field(description="Bodies of items (files/documents) to which the query applies. Supported bodies are `default`, `domain`, `drive` and `allDrives`. Prefer `default` or `drive` to `allDrives` for efficiency.")] = None,
        corpus: Annotated[Optional[StrictStr], Field(description="Deprecated: The body of items (files/documents) to which the query applies. Use `corpora` instead.")] = None,
        drive_id: Annotated[Optional[StrictStr], Field(description="ID of the shared drive to search.")] = None,
        include_items_from_all_drives: Annotated[Optional[StrictBool], Field(description="Whether both My Drive and shared drive items should be included in results.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        include_team_drive_items: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `includeItemsFromAllDrives` instead.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The maximum number of files to return per page. Partial or empty result pages are possible even before the end of the files list has been reached.")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="A comma-separated list of sort keys. Valid keys are `createdDate`, `folder`, `lastViewedByMeDate`, `modifiedByMeDate`, `modifiedDate`, `quotaBytesUsed`, `recency`, `sharedWithMeDate`, `starred`, `title`, and `title_natural`. Each key sorts ascending by default, but may be reversed with the `desc` modifier. Example usage: ?orderBy=folder,modifiedDate desc,title. Please note that there is a current limitation for users with approximately one million files in which the requested sort order is ignored.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="Page token for files.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Deprecated: This parameter has no function.")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Query string for searching files.")] = None,
        spaces: Annotated[Optional[StrictStr], Field(description="A comma-separated list of spaces to query. Supported values are `drive`, and `appDataFolder`.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        team_drive_id: Annotated[Optional[StrictStr], Field(description="Deprecated: Use `driveId` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileList]:
        """drive_files_list

         Lists the user's files. This method accepts the `q` parameter, which is a search query combining one or more search terms. For more information, see the [Search for files & folders](/drive/api/guides/search-files) guide. *Note:* This method returns *all* files by default, including trashed files. If you don't want trashed files to appear in the list, use the `trashed=false` query parameter to remove trashed files from the results.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param corpora: Bodies of items (files/documents) to which the query applies. Supported bodies are `default`, `domain`, `drive` and `allDrives`. Prefer `default` or `drive` to `allDrives` for efficiency.
        :type corpora: str
        :param corpus: Deprecated: The body of items (files/documents) to which the query applies. Use `corpora` instead.
        :type corpus: str
        :param drive_id: ID of the shared drive to search.
        :type drive_id: str
        :param include_items_from_all_drives: Whether both My Drive and shared drive items should be included in results.
        :type include_items_from_all_drives: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param include_team_drive_items: Deprecated: Use `includeItemsFromAllDrives` instead.
        :type include_team_drive_items: bool
        :param max_results: The maximum number of files to return per page. Partial or empty result pages are possible even before the end of the files list has been reached.
        :type max_results: int
        :param order_by: A comma-separated list of sort keys. Valid keys are `createdDate`, `folder`, `lastViewedByMeDate`, `modifiedByMeDate`, `modifiedDate`, `quotaBytesUsed`, `recency`, `sharedWithMeDate`, `starred`, `title`, and `title_natural`. Each key sorts ascending by default, but may be reversed with the `desc` modifier. Example usage: ?orderBy=folder,modifiedDate desc,title. Please note that there is a current limitation for users with approximately one million files in which the requested sort order is ignored.
        :type order_by: str
        :param page_token: Page token for files.
        :type page_token: str
        :param projection: Deprecated: This parameter has no function.
        :type projection: str
        :param q: Query string for searching files.
        :type q: str
        :param spaces: A comma-separated list of spaces to query. Supported values are `drive`, and `appDataFolder`.
        :type spaces: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param team_drive_id: Deprecated: Use `driveId` instead.
        :type team_drive_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_list_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            corpora=corpora,
            corpus=corpus,
            drive_id=drive_id,
            include_items_from_all_drives=include_items_from_all_drives,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            include_team_drive_items=include_team_drive_items,
            max_results=max_results,
            order_by=order_by,
            page_token=page_token,
            projection=projection,
            q=q,
            spaces=spaces,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            team_drive_id=team_drive_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_list_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        corpora: Annotated[Optional[StrictStr], Field(description="Bodies of items (files/documents) to which the query applies. Supported bodies are `default`, `domain`, `drive` and `allDrives`. Prefer `default` or `drive` to `allDrives` for efficiency.")] = None,
        corpus: Annotated[Optional[StrictStr], Field(description="Deprecated: The body of items (files/documents) to which the query applies. Use `corpora` instead.")] = None,
        drive_id: Annotated[Optional[StrictStr], Field(description="ID of the shared drive to search.")] = None,
        include_items_from_all_drives: Annotated[Optional[StrictBool], Field(description="Whether both My Drive and shared drive items should be included in results.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        include_team_drive_items: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `includeItemsFromAllDrives` instead.")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The maximum number of files to return per page. Partial or empty result pages are possible even before the end of the files list has been reached.")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="A comma-separated list of sort keys. Valid keys are `createdDate`, `folder`, `lastViewedByMeDate`, `modifiedByMeDate`, `modifiedDate`, `quotaBytesUsed`, `recency`, `sharedWithMeDate`, `starred`, `title`, and `title_natural`. Each key sorts ascending by default, but may be reversed with the `desc` modifier. Example usage: ?orderBy=folder,modifiedDate desc,title. Please note that there is a current limitation for users with approximately one million files in which the requested sort order is ignored.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="Page token for files.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Deprecated: This parameter has no function.")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Query string for searching files.")] = None,
        spaces: Annotated[Optional[StrictStr], Field(description="A comma-separated list of spaces to query. Supported values are `drive`, and `appDataFolder`.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        team_drive_id: Annotated[Optional[StrictStr], Field(description="Deprecated: Use `driveId` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_list

         Lists the user's files. This method accepts the `q` parameter, which is a search query combining one or more search terms. For more information, see the [Search for files & folders](/drive/api/guides/search-files) guide. *Note:* This method returns *all* files by default, including trashed files. If you don't want trashed files to appear in the list, use the `trashed=false` query parameter to remove trashed files from the results.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param corpora: Bodies of items (files/documents) to which the query applies. Supported bodies are `default`, `domain`, `drive` and `allDrives`. Prefer `default` or `drive` to `allDrives` for efficiency.
        :type corpora: str
        :param corpus: Deprecated: The body of items (files/documents) to which the query applies. Use `corpora` instead.
        :type corpus: str
        :param drive_id: ID of the shared drive to search.
        :type drive_id: str
        :param include_items_from_all_drives: Whether both My Drive and shared drive items should be included in results.
        :type include_items_from_all_drives: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param include_team_drive_items: Deprecated: Use `includeItemsFromAllDrives` instead.
        :type include_team_drive_items: bool
        :param max_results: The maximum number of files to return per page. Partial or empty result pages are possible even before the end of the files list has been reached.
        :type max_results: int
        :param order_by: A comma-separated list of sort keys. Valid keys are `createdDate`, `folder`, `lastViewedByMeDate`, `modifiedByMeDate`, `modifiedDate`, `quotaBytesUsed`, `recency`, `sharedWithMeDate`, `starred`, `title`, and `title_natural`. Each key sorts ascending by default, but may be reversed with the `desc` modifier. Example usage: ?orderBy=folder,modifiedDate desc,title. Please note that there is a current limitation for users with approximately one million files in which the requested sort order is ignored.
        :type order_by: str
        :param page_token: Page token for files.
        :type page_token: str
        :param projection: Deprecated: This parameter has no function.
        :type projection: str
        :param q: Query string for searching files.
        :type q: str
        :param spaces: A comma-separated list of spaces to query. Supported values are `drive`, and `appDataFolder`.
        :type spaces: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param team_drive_id: Deprecated: Use `driveId` instead.
        :type team_drive_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_list_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            corpora=corpora,
            corpus=corpus,
            drive_id=drive_id,
            include_items_from_all_drives=include_items_from_all_drives,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            include_team_drive_items=include_team_drive_items,
            max_results=max_results,
            order_by=order_by,
            page_token=page_token,
            projection=projection,
            q=q,
            spaces=spaces,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            team_drive_id=team_drive_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_list_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        corpora,
        corpus,
        drive_id,
        include_items_from_all_drives,
        include_labels,
        include_permissions_for_view,
        include_team_drive_items,
        max_results,
        order_by,
        page_token,
        projection,
        q,
        spaces,
        supports_all_drives,
        supports_team_drives,
        team_drive_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if corpora is not None:
            
            _query_params.append(('corpora', corpora))
            
        if corpus is not None:
            
            _query_params.append(('corpus', corpus))
            
        if drive_id is not None:
            
            _query_params.append(('driveId', drive_id))
            
        if include_items_from_all_drives is not None:
            
            _query_params.append(('includeItemsFromAllDrives', include_items_from_all_drives))
            
        if include_labels is not None:
            
            _query_params.append(('includeLabels', include_labels))
            
        if include_permissions_for_view is not None:
            
            _query_params.append(('includePermissionsForView', include_permissions_for_view))
            
        if include_team_drive_items is not None:
            
            _query_params.append(('includeTeamDriveItems', include_team_drive_items))
            
        if max_results is not None:
            
            _query_params.append(('maxResults', max_results))
            
        if order_by is not None:
            
            _query_params.append(('orderBy', order_by))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if spaces is not None:
            
            _query_params.append(('spaces', spaces))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        if team_drive_id is not None:
            
            _query_params.append(('teamDriveId', team_drive_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/files',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_list_labels(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID for the file.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of labels to return per page. When not set, defaults to 100.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The token for continuing a previous list request on the next page. This should be set to the value of `nextPageToken` from the previous response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LabelList:
        """drive_files_list_labels

        Lists the labels on a file.

        :param file_id: The ID for the file. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param max_results: The maximum number of labels to return per page. When not set, defaults to 100.
        :type max_results: int
        :param page_token: The token for continuing a previous list request on the next page. This should be set to the value of `nextPageToken` from the previous response.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_list_labels_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            max_results=max_results,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LabelList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_list_labels_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID for the file.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of labels to return per page. When not set, defaults to 100.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The token for continuing a previous list request on the next page. This should be set to the value of `nextPageToken` from the previous response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LabelList]:
        """drive_files_list_labels

        Lists the labels on a file.

        :param file_id: The ID for the file. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param max_results: The maximum number of labels to return per page. When not set, defaults to 100.
        :type max_results: int
        :param page_token: The token for continuing a previous list request on the next page. This should be set to the value of `nextPageToken` from the previous response.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_list_labels_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            max_results=max_results,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LabelList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_list_labels_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID for the file.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        max_results: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="The maximum number of labels to return per page. When not set, defaults to 100.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The token for continuing a previous list request on the next page. This should be set to the value of `nextPageToken` from the previous response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_list_labels

        Lists the labels on a file.

        :param file_id: The ID for the file. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param max_results: The maximum number of labels to return per page. When not set, defaults to 100.
        :type max_results: int
        :param page_token: The token for continuing a previous list request on the next page. This should be set to the value of `nextPageToken` from the previous response.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_list_labels_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            max_results=max_results,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LabelList",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_list_labels_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        max_results,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if max_results is not None:
            
            _query_params.append(('maxResults', max_results))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/files/{fileId}/listLabels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_modify_labels(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to which the labels belong.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        modify_labels_request: Optional[ModifyLabelsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ModifyLabelsResponse:
        """drive_files_modify_labels

        Modifies the set of labels applied to a file. Returns a list of the labels that were added or modified.

        :param file_id: The ID of the file to which the labels belong. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param modify_labels_request:
        :type modify_labels_request: ModifyLabelsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_modify_labels_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            modify_labels_request=modify_labels_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyLabelsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_modify_labels_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to which the labels belong.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        modify_labels_request: Optional[ModifyLabelsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ModifyLabelsResponse]:
        """drive_files_modify_labels

        Modifies the set of labels applied to a file. Returns a list of the labels that were added or modified.

        :param file_id: The ID of the file to which the labels belong. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param modify_labels_request:
        :type modify_labels_request: ModifyLabelsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_modify_labels_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            modify_labels_request=modify_labels_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyLabelsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_modify_labels_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to which the labels belong.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        modify_labels_request: Optional[ModifyLabelsRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_modify_labels

        Modifies the set of labels applied to a file. Returns a list of the labels that were added or modified.

        :param file_id: The ID of the file to which the labels belong. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param modify_labels_request:
        :type modify_labels_request: ModifyLabelsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_modify_labels_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            modify_labels_request=modify_labels_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ModifyLabelsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_modify_labels_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        modify_labels_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if modify_labels_request is not None:
            _body_params = modify_labels_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files/{fileId}/modifyLabels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_patch(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to update.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        add_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to add.")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Deprecated: This parameter has no function.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        modified_date_behavior: Annotated[Optional[StrictStr], Field(description="Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.")] = None,
        new_revision: Annotated[Optional[StrictBool], Field(description="Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045). Note that this field is ignored if there is no payload in the request.")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If ocr is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the new revision. A file can have a maximum of 200 pinned revisions. Note that this field is ignored if there is no payload in the request.")] = None,
        remove_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to remove.")] = None,
        set_modified_date: Annotated[Optional[StrictBool], Field(description="Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Whether to update the view date after successfully updating the file.")] = None,
        use_content_as_indexable_text: Annotated[Optional[StrictBool], Field(description="Whether to use the content as indexable text.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> File:
        """drive_files_patch

        Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.

        :param file_id: The ID of the file to update. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param add_parents: Comma-separated list of parent IDs to add.
        :type add_parents: str
        :param convert: Deprecated: This parameter has no function.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param modified_date_behavior: Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.
        :type modified_date_behavior: str
        :param new_revision: Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045). Note that this field is ignored if there is no payload in the request.
        :type new_revision: bool
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If ocr is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the new revision. A file can have a maximum of 200 pinned revisions. Note that this field is ignored if there is no payload in the request.
        :type pinned: bool
        :param remove_parents: Comma-separated list of parent IDs to remove.
        :type remove_parents: str
        :param set_modified_date: Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.
        :type set_modified_date: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param update_viewed_date: Whether to update the view date after successfully updating the file.
        :type update_viewed_date: bool
        :param use_content_as_indexable_text: Whether to use the content as indexable text.
        :type use_content_as_indexable_text: bool
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_patch_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            add_parents=add_parents,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            modified_date_behavior=modified_date_behavior,
            new_revision=new_revision,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            remove_parents=remove_parents,
            set_modified_date=set_modified_date,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            update_viewed_date=update_viewed_date,
            use_content_as_indexable_text=use_content_as_indexable_text,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_patch_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to update.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        add_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to add.")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Deprecated: This parameter has no function.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        modified_date_behavior: Annotated[Optional[StrictStr], Field(description="Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.")] = None,
        new_revision: Annotated[Optional[StrictBool], Field(description="Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045). Note that this field is ignored if there is no payload in the request.")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If ocr is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the new revision. A file can have a maximum of 200 pinned revisions. Note that this field is ignored if there is no payload in the request.")] = None,
        remove_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to remove.")] = None,
        set_modified_date: Annotated[Optional[StrictBool], Field(description="Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Whether to update the view date after successfully updating the file.")] = None,
        use_content_as_indexable_text: Annotated[Optional[StrictBool], Field(description="Whether to use the content as indexable text.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[File]:
        """drive_files_patch

        Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.

        :param file_id: The ID of the file to update. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param add_parents: Comma-separated list of parent IDs to add.
        :type add_parents: str
        :param convert: Deprecated: This parameter has no function.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param modified_date_behavior: Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.
        :type modified_date_behavior: str
        :param new_revision: Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045). Note that this field is ignored if there is no payload in the request.
        :type new_revision: bool
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If ocr is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the new revision. A file can have a maximum of 200 pinned revisions. Note that this field is ignored if there is no payload in the request.
        :type pinned: bool
        :param remove_parents: Comma-separated list of parent IDs to remove.
        :type remove_parents: str
        :param set_modified_date: Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.
        :type set_modified_date: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param update_viewed_date: Whether to update the view date after successfully updating the file.
        :type update_viewed_date: bool
        :param use_content_as_indexable_text: Whether to use the content as indexable text.
        :type use_content_as_indexable_text: bool
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_patch_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            add_parents=add_parents,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            modified_date_behavior=modified_date_behavior,
            new_revision=new_revision,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            remove_parents=remove_parents,
            set_modified_date=set_modified_date,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            update_viewed_date=update_viewed_date,
            use_content_as_indexable_text=use_content_as_indexable_text,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_patch_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to update.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        add_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to add.")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Deprecated: This parameter has no function.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        modified_date_behavior: Annotated[Optional[StrictStr], Field(description="Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.")] = None,
        new_revision: Annotated[Optional[StrictBool], Field(description="Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045). Note that this field is ignored if there is no payload in the request.")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If ocr is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the new revision. A file can have a maximum of 200 pinned revisions. Note that this field is ignored if there is no payload in the request.")] = None,
        remove_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to remove.")] = None,
        set_modified_date: Annotated[Optional[StrictBool], Field(description="Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Whether to update the view date after successfully updating the file.")] = None,
        use_content_as_indexable_text: Annotated[Optional[StrictBool], Field(description="Whether to use the content as indexable text.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_patch

        Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.

        :param file_id: The ID of the file to update. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param add_parents: Comma-separated list of parent IDs to add.
        :type add_parents: str
        :param convert: Deprecated: This parameter has no function.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param modified_date_behavior: Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.
        :type modified_date_behavior: str
        :param new_revision: Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045). Note that this field is ignored if there is no payload in the request.
        :type new_revision: bool
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If ocr is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the new revision. A file can have a maximum of 200 pinned revisions. Note that this field is ignored if there is no payload in the request.
        :type pinned: bool
        :param remove_parents: Comma-separated list of parent IDs to remove.
        :type remove_parents: str
        :param set_modified_date: Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.
        :type set_modified_date: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param update_viewed_date: Whether to update the view date after successfully updating the file.
        :type update_viewed_date: bool
        :param use_content_as_indexable_text: Whether to use the content as indexable text.
        :type use_content_as_indexable_text: bool
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_patch_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            add_parents=add_parents,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            modified_date_behavior=modified_date_behavior,
            new_revision=new_revision,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            remove_parents=remove_parents,
            set_modified_date=set_modified_date,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            update_viewed_date=update_viewed_date,
            use_content_as_indexable_text=use_content_as_indexable_text,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_patch_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        add_parents,
        convert,
        enforce_single_parent,
        include_labels,
        include_permissions_for_view,
        modified_date_behavior,
        new_revision,
        ocr,
        ocr_language,
        pinned,
        remove_parents,
        set_modified_date,
        supports_all_drives,
        supports_team_drives,
        timed_text_language,
        timed_text_track_name,
        update_viewed_date,
        use_content_as_indexable_text,
        file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if add_parents is not None:
            
            _query_params.append(('addParents', add_parents))
            
        if convert is not None:
            
            _query_params.append(('convert', convert))
            
        if enforce_single_parent is not None:
            
            _query_params.append(('enforceSingleParent', enforce_single_parent))
            
        if include_labels is not None:
            
            _query_params.append(('includeLabels', include_labels))
            
        if include_permissions_for_view is not None:
            
            _query_params.append(('includePermissionsForView', include_permissions_for_view))
            
        if modified_date_behavior is not None:
            
            _query_params.append(('modifiedDateBehavior', modified_date_behavior))
            
        if new_revision is not None:
            
            _query_params.append(('newRevision', new_revision))
            
        if ocr is not None:
            
            _query_params.append(('ocr', ocr))
            
        if ocr_language is not None:
            
            _query_params.append(('ocrLanguage', ocr_language))
            
        if pinned is not None:
            
            _query_params.append(('pinned', pinned))
            
        if remove_parents is not None:
            
            _query_params.append(('removeParents', remove_parents))
            
        if set_modified_date is not None:
            
            _query_params.append(('setModifiedDate', set_modified_date))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        if timed_text_language is not None:
            
            _query_params.append(('timedTextLanguage', timed_text_language))
            
        if timed_text_track_name is not None:
            
            _query_params.append(('timedTextTrackName', timed_text_track_name))
            
        if update_viewed_date is not None:
            
            _query_params.append(('updateViewedDate', update_viewed_date))
            
        if use_content_as_indexable_text is not None:
            
            _query_params.append(('useContentAsIndexableText', use_content_as_indexable_text))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if file is not None:
            _body_params = file


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/files/{fileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_touch(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to update.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> File:
        """drive_files_touch

        Set the file's updated time to the current server time.

        :param file_id: The ID of the file to update. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_touch_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_touch_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to update.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[File]:
        """drive_files_touch

        Set the file's updated time to the current server time.

        :param file_id: The ID of the file to update. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_touch_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_touch_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to update.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_touch

        Set the file's updated time to the current server time.

        :param file_id: The ID of the file to update. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_touch_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_touch_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        include_labels,
        include_permissions_for_view,
        supports_all_drives,
        supports_team_drives,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if include_labels is not None:
            
            _query_params.append(('includeLabels', include_labels))
            
        if include_permissions_for_view is not None:
            
            _query_params.append(('includePermissionsForView', include_permissions_for_view))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files/{fileId}/touch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_trash(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to trash.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> File:
        """drive_files_trash

        Moves a file to the trash. The currently authenticated user must own the file or be at least a `fileOrganizer` on the parent for shared drive files.

        :param file_id: The ID of the file to trash. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_trash_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_trash_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to trash.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[File]:
        """drive_files_trash

        Moves a file to the trash. The currently authenticated user must own the file or be at least a `fileOrganizer` on the parent for shared drive files.

        :param file_id: The ID of the file to trash. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_trash_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_trash_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to trash.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_trash

        Moves a file to the trash. The currently authenticated user must own the file or be at least a `fileOrganizer` on the parent for shared drive files.

        :param file_id: The ID of the file to trash. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_trash_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_trash_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        include_labels,
        include_permissions_for_view,
        supports_all_drives,
        supports_team_drives,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if include_labels is not None:
            
            _query_params.append(('includeLabels', include_labels))
            
        if include_permissions_for_view is not None:
            
            _query_params.append(('includePermissionsForView', include_permissions_for_view))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files/{fileId}/trash',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_untrash(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to untrash.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> File:
        """drive_files_untrash

        Restores a file from the trash. The currently authenticated user must own the file or be at least a `fileOrganizer` on the parent for shared drive files.

        :param file_id: The ID of the file to untrash. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_untrash_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_untrash_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to untrash.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[File]:
        """drive_files_untrash

        Restores a file from the trash. The currently authenticated user must own the file or be at least a `fileOrganizer` on the parent for shared drive files.

        :param file_id: The ID of the file to untrash. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_untrash_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_untrash_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to untrash.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_untrash

        Restores a file from the trash. The currently authenticated user must own the file or be at least a `fileOrganizer` on the parent for shared drive files.

        :param file_id: The ID of the file to untrash. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_untrash_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_untrash_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        include_labels,
        include_permissions_for_view,
        supports_all_drives,
        supports_team_drives,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if include_labels is not None:
            
            _query_params.append(('includeLabels', include_labels))
            
        if include_permissions_for_view is not None:
            
            _query_params.append(('includePermissionsForView', include_permissions_for_view))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files/{fileId}/untrash',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_update(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to update.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        add_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to add.")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Deprecated: This parameter has no function.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        modified_date_behavior: Annotated[Optional[StrictStr], Field(description="Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.")] = None,
        new_revision: Annotated[Optional[StrictBool], Field(description="Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045).")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If ocr is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the new revision. A file can have a maximum of 200 pinned revisions.")] = None,
        remove_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to remove.")] = None,
        set_modified_date: Annotated[Optional[StrictBool], Field(description="Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Whether to update the view date after successfully updating the file.")] = None,
        use_content_as_indexable_text: Annotated[Optional[StrictBool], Field(description="Whether to use the content as indexable text.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> File:
        """drive_files_update

         Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might be changed automatically, such as `modifiedDate`. This method supports patch semantics. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads).

        :param file_id: The ID of the file to update. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param add_parents: Comma-separated list of parent IDs to add.
        :type add_parents: str
        :param convert: Deprecated: This parameter has no function.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param modified_date_behavior: Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.
        :type modified_date_behavior: str
        :param new_revision: Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045).
        :type new_revision: bool
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If ocr is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the new revision. A file can have a maximum of 200 pinned revisions.
        :type pinned: bool
        :param remove_parents: Comma-separated list of parent IDs to remove.
        :type remove_parents: str
        :param set_modified_date: Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.
        :type set_modified_date: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param update_viewed_date: Whether to update the view date after successfully updating the file.
        :type update_viewed_date: bool
        :param use_content_as_indexable_text: Whether to use the content as indexable text.
        :type use_content_as_indexable_text: bool
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_update_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            add_parents=add_parents,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            modified_date_behavior=modified_date_behavior,
            new_revision=new_revision,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            remove_parents=remove_parents,
            set_modified_date=set_modified_date,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            update_viewed_date=update_viewed_date,
            use_content_as_indexable_text=use_content_as_indexable_text,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_update_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to update.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        add_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to add.")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Deprecated: This parameter has no function.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        modified_date_behavior: Annotated[Optional[StrictStr], Field(description="Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.")] = None,
        new_revision: Annotated[Optional[StrictBool], Field(description="Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045).")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If ocr is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the new revision. A file can have a maximum of 200 pinned revisions.")] = None,
        remove_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to remove.")] = None,
        set_modified_date: Annotated[Optional[StrictBool], Field(description="Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Whether to update the view date after successfully updating the file.")] = None,
        use_content_as_indexable_text: Annotated[Optional[StrictBool], Field(description="Whether to use the content as indexable text.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[File]:
        """drive_files_update

         Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might be changed automatically, such as `modifiedDate`. This method supports patch semantics. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads).

        :param file_id: The ID of the file to update. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param add_parents: Comma-separated list of parent IDs to add.
        :type add_parents: str
        :param convert: Deprecated: This parameter has no function.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param modified_date_behavior: Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.
        :type modified_date_behavior: str
        :param new_revision: Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045).
        :type new_revision: bool
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If ocr is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the new revision. A file can have a maximum of 200 pinned revisions.
        :type pinned: bool
        :param remove_parents: Comma-separated list of parent IDs to remove.
        :type remove_parents: str
        :param set_modified_date: Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.
        :type set_modified_date: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param update_viewed_date: Whether to update the view date after successfully updating the file.
        :type update_viewed_date: bool
        :param use_content_as_indexable_text: Whether to use the content as indexable text.
        :type use_content_as_indexable_text: bool
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_update_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            add_parents=add_parents,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            modified_date_behavior=modified_date_behavior,
            new_revision=new_revision,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            remove_parents=remove_parents,
            set_modified_date=set_modified_date,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            update_viewed_date=update_viewed_date,
            use_content_as_indexable_text=use_content_as_indexable_text,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_update_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID of the file to update.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        add_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to add.")] = None,
        convert: Annotated[Optional[StrictBool], Field(description="Deprecated: This parameter has no function.")] = None,
        enforce_single_parent: Annotated[Optional[StrictBool], Field(description="Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        modified_date_behavior: Annotated[Optional[StrictStr], Field(description="Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.")] = None,
        new_revision: Annotated[Optional[StrictBool], Field(description="Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045).")] = None,
        ocr: Annotated[Optional[StrictBool], Field(description="Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.")] = None,
        ocr_language: Annotated[Optional[StrictStr], Field(description="If ocr is true, hints at the language to use. Valid values are BCP 47 codes.")] = None,
        pinned: Annotated[Optional[StrictBool], Field(description="Whether to pin the new revision. A file can have a maximum of 200 pinned revisions.")] = None,
        remove_parents: Annotated[Optional[StrictStr], Field(description="Comma-separated list of parent IDs to remove.")] = None,
        set_modified_date: Annotated[Optional[StrictBool], Field(description="Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        timed_text_language: Annotated[Optional[StrictStr], Field(description="The language of the timed text.")] = None,
        timed_text_track_name: Annotated[Optional[StrictStr], Field(description="The timed text track name.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Whether to update the view date after successfully updating the file.")] = None,
        use_content_as_indexable_text: Annotated[Optional[StrictBool], Field(description="Whether to use the content as indexable text.")] = None,
        file: Optional[File] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_update

         Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might be changed automatically, such as `modifiedDate`. This method supports patch semantics. This method supports an */upload* URI and accepts uploaded media with the following characteristics: - *Maximum file size:* 5,120 GB - *Accepted Media MIME types:*`*/*` Note: Specify a valid MIME type, rather than the literal `*/*` value. The literal `*/*` is only used to indicate that any valid MIME type can be uploaded. For more information on uploading files, see [Upload file data](/drive/api/guides/manage-uploads).

        :param file_id: The ID of the file to update. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param add_parents: Comma-separated list of parent IDs to add.
        :type add_parents: str
        :param convert: Deprecated: This parameter has no function.
        :type convert: bool
        :param enforce_single_parent: Deprecated: Adding files to multiple folders is no longer supported. Use `shortcuts` instead.
        :type enforce_single_parent: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param modified_date_behavior: Determines the behavior in which `modifiedDate` is updated. This overrides `setModifiedDate`.
        :type modified_date_behavior: str
        :param new_revision: Whether a blob upload should create a new revision. If false, the blob data in the current head revision is replaced. If true or not set, a new blob is created as head revision, and previous unpinned revisions are preserved for a short period of time. Pinned revisions are stored indefinitely, using additional storage quota, up to a maximum of 200 revisions. For details on how revisions are retained, see the [Drive Help Center](https://support.google.com/drive/answer/2409045).
        :type new_revision: bool
        :param ocr: Whether to attempt OCR on .jpg, .png, .gif, or .pdf uploads.
        :type ocr: bool
        :param ocr_language: If ocr is true, hints at the language to use. Valid values are BCP 47 codes.
        :type ocr_language: str
        :param pinned: Whether to pin the new revision. A file can have a maximum of 200 pinned revisions.
        :type pinned: bool
        :param remove_parents: Comma-separated list of parent IDs to remove.
        :type remove_parents: str
        :param set_modified_date: Whether to set the modified date using the value supplied in the request body. Setting this field to `true` is equivalent to `modifiedDateBehavior=fromBodyOrNow`, and `false` is equivalent to `modifiedDateBehavior=now`. To prevent any changes to the modified date set `modifiedDateBehavior=noChange`.
        :type set_modified_date: bool
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param timed_text_language: The language of the timed text.
        :type timed_text_language: str
        :param timed_text_track_name: The timed text track name.
        :type timed_text_track_name: str
        :param update_viewed_date: Whether to update the view date after successfully updating the file.
        :type update_viewed_date: bool
        :param use_content_as_indexable_text: Whether to use the content as indexable text.
        :type use_content_as_indexable_text: bool
        :param file:
        :type file: File
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_update_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            add_parents=add_parents,
            convert=convert,
            enforce_single_parent=enforce_single_parent,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            modified_date_behavior=modified_date_behavior,
            new_revision=new_revision,
            ocr=ocr,
            ocr_language=ocr_language,
            pinned=pinned,
            remove_parents=remove_parents,
            set_modified_date=set_modified_date,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            timed_text_language=timed_text_language,
            timed_text_track_name=timed_text_track_name,
            update_viewed_date=update_viewed_date,
            use_content_as_indexable_text=use_content_as_indexable_text,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "File",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_update_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        add_parents,
        convert,
        enforce_single_parent,
        include_labels,
        include_permissions_for_view,
        modified_date_behavior,
        new_revision,
        ocr,
        ocr_language,
        pinned,
        remove_parents,
        set_modified_date,
        supports_all_drives,
        supports_team_drives,
        timed_text_language,
        timed_text_track_name,
        update_viewed_date,
        use_content_as_indexable_text,
        file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if add_parents is not None:
            
            _query_params.append(('addParents', add_parents))
            
        if convert is not None:
            
            _query_params.append(('convert', convert))
            
        if enforce_single_parent is not None:
            
            _query_params.append(('enforceSingleParent', enforce_single_parent))
            
        if include_labels is not None:
            
            _query_params.append(('includeLabels', include_labels))
            
        if include_permissions_for_view is not None:
            
            _query_params.append(('includePermissionsForView', include_permissions_for_view))
            
        if modified_date_behavior is not None:
            
            _query_params.append(('modifiedDateBehavior', modified_date_behavior))
            
        if new_revision is not None:
            
            _query_params.append(('newRevision', new_revision))
            
        if ocr is not None:
            
            _query_params.append(('ocr', ocr))
            
        if ocr_language is not None:
            
            _query_params.append(('ocrLanguage', ocr_language))
            
        if pinned is not None:
            
            _query_params.append(('pinned', pinned))
            
        if remove_parents is not None:
            
            _query_params.append(('removeParents', remove_parents))
            
        if set_modified_date is not None:
            
            _query_params.append(('setModifiedDate', set_modified_date))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        if timed_text_language is not None:
            
            _query_params.append(('timedTextLanguage', timed_text_language))
            
        if timed_text_track_name is not None:
            
            _query_params.append(('timedTextTrackName', timed_text_track_name))
            
        if update_viewed_date is not None:
            
            _query_params.append(('updateViewedDate', update_viewed_date))
            
        if use_content_as_indexable_text is not None:
            
            _query_params.append(('useContentAsIndexableText', use_content_as_indexable_text))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if file is not None:
            _body_params = file


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/octet-stream'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/files/{fileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def drive_files_watch(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID for the file in question.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        acknowledge_abuse: Annotated[Optional[StrictBool], Field(description="Whether the user is acknowledging the risk of downloading known malware or other abusive files.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Deprecated: This parameter has no function.")] = None,
        revision_id: Annotated[Optional[StrictStr], Field(description="Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Deprecated: Use files.update with modifiedDateBehavior=noChange, updateViewedDate=true and an empty request body.")] = None,
        channel: Optional[Channel] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Channel:
        """drive_files_watch

        Subscribes to changes to a file.

        :param file_id: The ID for the file in question. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param acknowledge_abuse: Whether the user is acknowledging the risk of downloading known malware or other abusive files.
        :type acknowledge_abuse: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param projection: Deprecated: This parameter has no function.
        :type projection: str
        :param revision_id: Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.
        :type revision_id: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param update_viewed_date: Deprecated: Use files.update with modifiedDateBehavior=noChange, updateViewedDate=true and an empty request body.
        :type update_viewed_date: bool
        :param channel:
        :type channel: Channel
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_watch_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            acknowledge_abuse=acknowledge_abuse,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            projection=projection,
            revision_id=revision_id,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            update_viewed_date=update_viewed_date,
            channel=channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Channel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def drive_files_watch_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID for the file in question.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        acknowledge_abuse: Annotated[Optional[StrictBool], Field(description="Whether the user is acknowledging the risk of downloading known malware or other abusive files.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Deprecated: This parameter has no function.")] = None,
        revision_id: Annotated[Optional[StrictStr], Field(description="Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Deprecated: Use files.update with modifiedDateBehavior=noChange, updateViewedDate=true and an empty request body.")] = None,
        channel: Optional[Channel] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Channel]:
        """drive_files_watch

        Subscribes to changes to a file.

        :param file_id: The ID for the file in question. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param acknowledge_abuse: Whether the user is acknowledging the risk of downloading known malware or other abusive files.
        :type acknowledge_abuse: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param projection: Deprecated: This parameter has no function.
        :type projection: str
        :param revision_id: Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.
        :type revision_id: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param update_viewed_date: Deprecated: Use files.update with modifiedDateBehavior=noChange, updateViewedDate=true and an empty request body.
        :type update_viewed_date: bool
        :param channel:
        :type channel: Channel
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_watch_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            acknowledge_abuse=acknowledge_abuse,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            projection=projection,
            revision_id=revision_id,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            update_viewed_date=update_viewed_date,
            channel=channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Channel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def drive_files_watch_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="The ID for the file in question.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        acknowledge_abuse: Annotated[Optional[StrictBool], Field(description="Whether the user is acknowledging the risk of downloading known malware or other abusive files.")] = None,
        include_labels: Annotated[Optional[StrictStr], Field(description="A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.")] = None,
        include_permissions_for_view: Annotated[Optional[StrictStr], Field(description="Specifies which additional view's permissions to include in the response. Only `published` is supported.")] = None,
        projection: Annotated[Optional[StrictStr], Field(description="Deprecated: This parameter has no function.")] = None,
        revision_id: Annotated[Optional[StrictStr], Field(description="Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.")] = None,
        supports_all_drives: Annotated[Optional[StrictBool], Field(description="Whether the requesting application supports both My Drives and shared drives.")] = None,
        supports_team_drives: Annotated[Optional[StrictBool], Field(description="Deprecated: Use `supportsAllDrives` instead.")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Deprecated: Use files.update with modifiedDateBehavior=noChange, updateViewedDate=true and an empty request body.")] = None,
        channel: Optional[Channel] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """drive_files_watch

        Subscribes to changes to a file.

        :param file_id: The ID for the file in question. (required)
        :type file_id: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param acknowledge_abuse: Whether the user is acknowledging the risk of downloading known malware or other abusive files.
        :type acknowledge_abuse: bool
        :param include_labels: A comma-separated list of IDs of labels to include in the `labelInfo` part of the response.
        :type include_labels: str
        :param include_permissions_for_view: Specifies which additional view's permissions to include in the response. Only `published` is supported.
        :type include_permissions_for_view: str
        :param projection: Deprecated: This parameter has no function.
        :type projection: str
        :param revision_id: Specifies the Revision ID that should be downloaded. Ignored unless alt=media is specified.
        :type revision_id: str
        :param supports_all_drives: Whether the requesting application supports both My Drives and shared drives.
        :type supports_all_drives: bool
        :param supports_team_drives: Deprecated: Use `supportsAllDrives` instead.
        :type supports_team_drives: bool
        :param update_viewed_date: Deprecated: Use files.update with modifiedDateBehavior=noChange, updateViewedDate=true and an empty request body.
        :type update_viewed_date: bool
        :param channel:
        :type channel: Channel
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._drive_files_watch_serialize(
            file_id=file_id,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            acknowledge_abuse=acknowledge_abuse,
            include_labels=include_labels,
            include_permissions_for_view=include_permissions_for_view,
            projection=projection,
            revision_id=revision_id,
            supports_all_drives=supports_all_drives,
            supports_team_drives=supports_team_drives,
            update_viewed_date=update_viewed_date,
            channel=channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Channel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _drive_files_watch_serialize(
        self,
        file_id,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        acknowledge_abuse,
        include_labels,
        include_permissions_for_view,
        projection,
        revision_id,
        supports_all_drives,
        supports_team_drives,
        update_viewed_date,
        channel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if acknowledge_abuse is not None:
            
            _query_params.append(('acknowledgeAbuse', acknowledge_abuse))
            
        if include_labels is not None:
            
            _query_params.append(('includeLabels', include_labels))
            
        if include_permissions_for_view is not None:
            
            _query_params.append(('includePermissionsForView', include_permissions_for_view))
            
        if projection is not None:
            
            _query_params.append(('projection', projection))
            
        if revision_id is not None:
            
            _query_params.append(('revisionId', revision_id))
            
        if supports_all_drives is not None:
            
            _query_params.append(('supportsAllDrives', supports_all_drives))
            
        if supports_team_drives is not None:
            
            _query_params.append(('supportsTeamDrives', supports_team_drives))
            
        if update_viewed_date is not None:
            
            _query_params.append(('updateViewedDate', update_viewed_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if channel is not None:
            _body_params = channel


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/files/{fileId}/watch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


