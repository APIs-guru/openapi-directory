# coding: utf-8

"""
    Cloud Search API

    Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.enterprise_topaz_sidekick_common_document import EnterpriseTopazSidekickCommonDocument
from openapi_client.models.enterprise_topaz_sidekick_person import EnterpriseTopazSidekickPerson
from typing import Optional, Set
from typing_extensions import Self

class EnterpriseTopazSidekickAgendaEntry(BaseModel):
    """
    An AgendaEntry, e.g., a Calendar Event.
    """ # noqa: E501
    agenda_item_url: Optional[StrictStr] = Field(default=None, description="URL of the agenda item.", alias="agendaItemUrl")
    chronology: Optional[StrictStr] = Field(default=None, description="The chronology from the present.")
    creator: Optional[EnterpriseTopazSidekickPerson] = None
    current_user_attending_status: Optional[StrictStr] = Field(default=None, description="Attendance status for the current user making the request. This is a convenience data member in order to avoid figuring out the same by iterating the invitee list above on the caller side.", alias="currentUserAttendingStatus")
    description: Optional[StrictStr] = Field(default=None, description="Description of the agenda item (i.e., typically, summary in calendar event).")
    document: Optional[List[EnterpriseTopazSidekickCommonDocument]] = Field(default=None, description="Items related to the current AgendaEntry. E.g., related drive/mail/groups documents.")
    end_date: Optional[StrictStr] = Field(default=None, description="End date \"Friday, August 26\" in the user's timezone.", alias="endDate")
    end_time: Optional[StrictStr] = Field(default=None, description="End time (HH:mm) in the user's timezone.", alias="endTime")
    end_time_ms: Optional[StrictStr] = Field(default=None, description="End time in milliseconds", alias="endTimeMs")
    event_id: Optional[StrictStr] = Field(default=None, description="Event id provided by Calendar API.", alias="eventId")
    guests_can_invite_others: Optional[StrictBool] = Field(default=None, description="Whether the guests can invite other guests.", alias="guestsCanInviteOthers")
    guests_can_modify: Optional[StrictBool] = Field(default=None, description="Whether the guests can modify the event.", alias="guestsCanModify")
    guests_can_see_guests: Optional[StrictBool] = Field(default=None, description="Whether the guests of the event can be seen. If false, the user is going to be reported as the only attendee to the meeting, even though there may be more attendees.", alias="guestsCanSeeGuests")
    hangout_id: Optional[StrictStr] = Field(default=None, description="Hangout meeting identifier.", alias="hangoutId")
    hangout_url: Optional[StrictStr] = Field(default=None, description="Absolute URL for the Hangout meeting.", alias="hangoutUrl")
    invitee: Optional[List[EnterpriseTopazSidekickPerson]] = Field(default=None, description="People attending the meeting.")
    is_all_day: Optional[StrictBool] = Field(default=None, description="Whether the entry lasts all day.", alias="isAllDay")
    last_modification_time_ms: Optional[StrictStr] = Field(default=None, description="Last time the event was modified.", alias="lastModificationTimeMs")
    location: Optional[StrictStr] = Field(default=None, description="Agenda item location.")
    notify_to_user: Optional[StrictBool] = Field(default=None, description="Whether this should be notified to the user.", alias="notifyToUser")
    other_attendees_excluded: Optional[StrictBool] = Field(default=None, description="Whether guest list is not returned because number of attendees is too large.", alias="otherAttendeesExcluded")
    requester_is_owner: Optional[StrictBool] = Field(default=None, description="Whether the requester is the owner of the agenda entry.", alias="requesterIsOwner")
    show_full_event_details_to_use: Optional[StrictBool] = Field(default=None, description="Whether the details of this entry should be displayed to the user.", alias="showFullEventDetailsToUse")
    start_date: Optional[StrictStr] = Field(default=None, description="Start date \"Friday, August 26\" in the user's timezone.", alias="startDate")
    start_time: Optional[StrictStr] = Field(default=None, description="Start time (HH:mm) in the user's timezone.", alias="startTime")
    start_time_ms: Optional[StrictStr] = Field(default=None, description="Start time in milliseconds.", alias="startTimeMs")
    time_zone: Optional[StrictStr] = Field(default=None, description="User's calendar timezone;", alias="timeZone")
    title: Optional[StrictStr] = Field(default=None, description="Title of the agenda item.")
    __properties: ClassVar[List[str]] = ["agendaItemUrl", "chronology", "creator", "currentUserAttendingStatus", "description", "document", "endDate", "endTime", "endTimeMs", "eventId", "guestsCanInviteOthers", "guestsCanModify", "guestsCanSeeGuests", "hangoutId", "hangoutUrl", "invitee", "isAllDay", "lastModificationTimeMs", "location", "notifyToUser", "otherAttendeesExcluded", "requesterIsOwner", "showFullEventDetailsToUse", "startDate", "startTime", "startTimeMs", "timeZone", "title"]

    @field_validator('chronology')
    def chronology_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STALE', 'ALL_DAY', 'PAST', 'RECENTLY_PAST', 'PRESENT', 'NEAR_FUTURE', 'FUTURE']):
            raise ValueError("must be one of enum values ('STALE', 'ALL_DAY', 'PAST', 'RECENTLY_PAST', 'PRESENT', 'NEAR_FUTURE', 'FUTURE')")
        return value

    @field_validator('current_user_attending_status')
    def current_user_attending_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AWAITING', 'true', 'false', 'MAYBE']):
            raise ValueError("must be one of enum values ('AWAITING', 'true', 'false', 'MAYBE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of EnterpriseTopazSidekickAgendaEntry from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of creator
        if self.creator:
            _dict['creator'] = self.creator.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in document (list)
        _items = []
        if self.document:
            for _item_document in self.document:
                if _item_document:
                    _items.append(_item_document.to_dict())
            _dict['document'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in invitee (list)
        _items = []
        if self.invitee:
            for _item_invitee in self.invitee:
                if _item_invitee:
                    _items.append(_item_invitee.to_dict())
            _dict['invitee'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of EnterpriseTopazSidekickAgendaEntry from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "agendaItemUrl": obj.get("agendaItemUrl"),
            "chronology": obj.get("chronology"),
            "creator": EnterpriseTopazSidekickPerson.from_dict(obj["creator"]) if obj.get("creator") is not None else None,
            "currentUserAttendingStatus": obj.get("currentUserAttendingStatus"),
            "description": obj.get("description"),
            "document": [EnterpriseTopazSidekickCommonDocument.from_dict(_item) for _item in obj["document"]] if obj.get("document") is not None else None,
            "endDate": obj.get("endDate"),
            "endTime": obj.get("endTime"),
            "endTimeMs": obj.get("endTimeMs"),
            "eventId": obj.get("eventId"),
            "guestsCanInviteOthers": obj.get("guestsCanInviteOthers"),
            "guestsCanModify": obj.get("guestsCanModify"),
            "guestsCanSeeGuests": obj.get("guestsCanSeeGuests"),
            "hangoutId": obj.get("hangoutId"),
            "hangoutUrl": obj.get("hangoutUrl"),
            "invitee": [EnterpriseTopazSidekickPerson.from_dict(_item) for _item in obj["invitee"]] if obj.get("invitee") is not None else None,
            "isAllDay": obj.get("isAllDay"),
            "lastModificationTimeMs": obj.get("lastModificationTimeMs"),
            "location": obj.get("location"),
            "notifyToUser": obj.get("notifyToUser"),
            "otherAttendeesExcluded": obj.get("otherAttendeesExcluded"),
            "requesterIsOwner": obj.get("requesterIsOwner"),
            "showFullEventDetailsToUse": obj.get("showFullEventDetailsToUse"),
            "startDate": obj.get("startDate"),
            "startTime": obj.get("startTime"),
            "startTimeMs": obj.get("startTimeMs"),
            "timeZone": obj.get("timeZone"),
            "title": obj.get("title")
        })
        return _obj


