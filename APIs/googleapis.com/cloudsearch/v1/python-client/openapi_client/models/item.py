# coding: utf-8

"""
    Cloud Search API

    Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBytes, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.item_acl import ItemAcl
from openapi_client.models.item_content import ItemContent
from openapi_client.models.item_metadata import ItemMetadata
from openapi_client.models.item_status import ItemStatus
from openapi_client.models.item_structured_data import ItemStructuredData
from typing import Optional, Set
from typing_extensions import Self

class Item(BaseModel):
    """
    Represents a single object that is an item in the search index, such as a file, folder, or a database record.
    """ # noqa: E501
    acl: Optional[ItemAcl] = None
    content: Optional[ItemContent] = None
    item_type: Optional[StrictStr] = Field(default=None, description="The type for this item.", alias="itemType")
    metadata: Optional[ItemMetadata] = None
    name: Optional[StrictStr] = Field(default=None, description="The name of the Item. Format: datasources/{source_id}/items/{item_id} This is a required field. The maximum length is 1536 characters.")
    payload: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="Additional state connector can store for this item. The maximum length is 10000 bytes.")
    queue: Optional[StrictStr] = Field(default=None, description="Queue this item belongs to. The maximum length is 100 characters.")
    status: Optional[ItemStatus] = None
    structured_data: Optional[ItemStructuredData] = Field(default=None, alias="structuredData")
    version: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="Required. The indexing system stores the version from the datasource as a byte string and compares the Item version in the index to the version of the queued Item using lexical ordering. Cloud Search Indexing won't index or delete any queued item with a version value that is less than or equal to the version of the currently indexed item. The maximum length for this field is 1024 bytes. For information on how item version affects the deletion process, refer to [Handle revisions after manual deletes](https://developers.google.com/cloud-search/docs/guides/operations).")
    __properties: ClassVar[List[str]] = ["acl", "content", "itemType", "metadata", "name", "payload", "queue", "status", "structuredData", "version"]

    @field_validator('item_type')
    def item_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED', 'CONTENT_ITEM', 'CONTAINER_ITEM', 'VIRTUAL_CONTAINER_ITEM']):
            raise ValueError("must be one of enum values ('UNSPECIFIED', 'CONTENT_ITEM', 'CONTAINER_ITEM', 'VIRTUAL_CONTAINER_ITEM')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Item from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of acl
        if self.acl:
            _dict['acl'] = self.acl.to_dict()
        # override the default output from pydantic by calling `to_dict()` of content
        if self.content:
            _dict['content'] = self.content.to_dict()
        # override the default output from pydantic by calling `to_dict()` of metadata
        if self.metadata:
            _dict['metadata'] = self.metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of status
        if self.status:
            _dict['status'] = self.status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of structured_data
        if self.structured_data:
            _dict['structuredData'] = self.structured_data.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Item from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "acl": ItemAcl.from_dict(obj["acl"]) if obj.get("acl") is not None else None,
            "content": ItemContent.from_dict(obj["content"]) if obj.get("content") is not None else None,
            "itemType": obj.get("itemType"),
            "metadata": ItemMetadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None,
            "name": obj.get("name"),
            "payload": obj.get("payload"),
            "queue": obj.get("queue"),
            "status": ItemStatus.from_dict(obj["status"]) if obj.get("status") is not None else None,
            "structuredData": ItemStructuredData.from_dict(obj["structuredData"]) if obj.get("structuredData") is not None else None,
            "version": obj.get("version")
        })
        return _obj


