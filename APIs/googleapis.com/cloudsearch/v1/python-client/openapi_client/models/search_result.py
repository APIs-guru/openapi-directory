# coding: utf-8

"""
    Cloud Search API

    Cloud Search provides cloud-based search capabilities over Google Workspace data. The Cloud Search API allows indexing of non-Google Workspace data into Cloud Search.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.metadata import Metadata
from openapi_client.models.result_debug_info import ResultDebugInfo
from openapi_client.models.snippet import Snippet
from typing import Optional, Set
from typing_extensions import Self

class SearchResult(BaseModel):
    """
    Results containing indexed information for a document.
    """ # noqa: E501
    clustered_results: Optional[List[SearchResult]] = Field(default=None, description="If source is clustered, provide list of clustered results. There will only be one level of clustered results. If current source is not enabled for clustering, this field will be empty.", alias="clusteredResults")
    debug_info: Optional[ResultDebugInfo] = Field(default=None, alias="debugInfo")
    metadata: Optional[Metadata] = None
    snippet: Optional[Snippet] = None
    title: Optional[StrictStr] = Field(default=None, description="Title of the search result.")
    url: Optional[StrictStr] = Field(default=None, description="The URL of the search result. The URL contains a Google redirect to the actual item. This URL is signed and shouldn't be changed.")
    __properties: ClassVar[List[str]] = ["clusteredResults", "debugInfo", "metadata", "snippet", "title", "url"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SearchResult from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in clustered_results (list)
        _items = []
        if self.clustered_results:
            for _item_clustered_results in self.clustered_results:
                if _item_clustered_results:
                    _items.append(_item_clustered_results.to_dict())
            _dict['clusteredResults'] = _items
        # override the default output from pydantic by calling `to_dict()` of debug_info
        if self.debug_info:
            _dict['debugInfo'] = self.debug_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of metadata
        if self.metadata:
            _dict['metadata'] = self.metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of snippet
        if self.snippet:
            _dict['snippet'] = self.snippet.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SearchResult from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "clusteredResults": [SearchResult.from_dict(_item) for _item in obj["clusteredResults"]] if obj.get("clusteredResults") is not None else None,
            "debugInfo": ResultDebugInfo.from_dict(obj["debugInfo"]) if obj.get("debugInfo") is not None else None,
            "metadata": Metadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None,
            "snippet": Snippet.from_dict(obj["snippet"]) if obj.get("snippet") is not None else None,
            "title": obj.get("title"),
            "url": obj.get("url")
        })
        return _obj

# TODO: Rewrite to not use raise_errors
SearchResult.model_rebuild(raise_errors=False)

