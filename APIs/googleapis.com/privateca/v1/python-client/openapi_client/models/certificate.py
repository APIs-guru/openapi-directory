# coding: utf-8

"""
    Certificate Authority API

    The Certificate Authority Service API is a highly-available, scalable service that enables you to simplify and automate the management of private certificate authorities (CAs) while staying in control of your private keys. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.certificate_config import CertificateConfig
from openapi_client.models.certificate_description import CertificateDescription
from openapi_client.models.revocation_details import RevocationDetails
from typing import Optional, Set
from typing_extensions import Self

class Certificate(BaseModel):
    """
    A Certificate corresponds to a signed X.509 certificate issued by a CertificateAuthority.
    """ # noqa: E501
    certificate_description: Optional[CertificateDescription] = Field(default=None, alias="certificateDescription")
    certificate_template: Optional[StrictStr] = Field(default=None, description="Immutable. The resource name for a CertificateTemplate used to issue this certificate, in the format `projects/*/locations/*/certificateTemplates/*`. If this is specified, the caller must have the necessary permission to use this template. If this is omitted, no template will be used. This template must be in the same location as the Certificate.", alias="certificateTemplate")
    config: Optional[CertificateConfig] = None
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. The time at which this Certificate was created.", alias="createTime")
    issuer_certificate_authority: Optional[StrictStr] = Field(default=None, description="Output only. The resource name of the issuing CertificateAuthority in the format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.", alias="issuerCertificateAuthority")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Optional. Labels with user-defined metadata.")
    lifetime: Optional[StrictStr] = Field(default=None, description="Required. Immutable. The desired lifetime of a certificate. Used to create the \"not_before_time\" and \"not_after_time\" fields inside an X.509 certificate. Note that the lifetime may be truncated if it would extend past the life of any certificate authority in the issuing chain.")
    name: Optional[StrictStr] = Field(default=None, description="Output only. The resource name for this Certificate in the format `projects/*/locations/*/caPools/*/certificates/*`.")
    pem_certificate: Optional[StrictStr] = Field(default=None, description="Output only. The pem-encoded, signed X.509 certificate.", alias="pemCertificate")
    pem_certificate_chain: Optional[List[StrictStr]] = Field(default=None, description="Output only. The chain that may be used to verify the X.509 certificate. Expected to be in issuer-to-root order according to RFC 5246.", alias="pemCertificateChain")
    pem_csr: Optional[StrictStr] = Field(default=None, description="Immutable. A pem-encoded X.509 certificate signing request (CSR).", alias="pemCsr")
    revocation_details: Optional[RevocationDetails] = Field(default=None, alias="revocationDetails")
    subject_mode: Optional[StrictStr] = Field(default=None, description="Immutable. Specifies how the Certificate's identity fields are to be decided. If this is omitted, the `DEFAULT` subject mode will be used.", alias="subjectMode")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. The time at which this Certificate was updated.", alias="updateTime")
    __properties: ClassVar[List[str]] = ["certificateDescription", "certificateTemplate", "config", "createTime", "issuerCertificateAuthority", "labels", "lifetime", "name", "pemCertificate", "pemCertificateChain", "pemCsr", "revocationDetails", "subjectMode", "updateTime"]

    @field_validator('subject_mode')
    def subject_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SUBJECT_REQUEST_MODE_UNSPECIFIED', 'DEFAULT', 'REFLECTED_SPIFFE']):
            raise ValueError("must be one of enum values ('SUBJECT_REQUEST_MODE_UNSPECIFIED', 'DEFAULT', 'REFLECTED_SPIFFE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Certificate from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "issuer_certificate_authority",
            "name",
            "pem_certificate",
            "pem_certificate_chain",
            "update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of certificate_description
        if self.certificate_description:
            _dict['certificateDescription'] = self.certificate_description.to_dict()
        # override the default output from pydantic by calling `to_dict()` of config
        if self.config:
            _dict['config'] = self.config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of revocation_details
        if self.revocation_details:
            _dict['revocationDetails'] = self.revocation_details.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Certificate from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "certificateDescription": CertificateDescription.from_dict(obj["certificateDescription"]) if obj.get("certificateDescription") is not None else None,
            "certificateTemplate": obj.get("certificateTemplate"),
            "config": CertificateConfig.from_dict(obj["config"]) if obj.get("config") is not None else None,
            "createTime": obj.get("createTime"),
            "issuerCertificateAuthority": obj.get("issuerCertificateAuthority"),
            "labels": obj.get("labels"),
            "lifetime": obj.get("lifetime"),
            "name": obj.get("name"),
            "pemCertificate": obj.get("pemCertificate"),
            "pemCertificateChain": obj.get("pemCertificateChain"),
            "pemCsr": obj.get("pemCsr"),
            "revocationDetails": RevocationDetails.from_dict(obj["revocationDetails"]) if obj.get("revocationDetails") is not None else None,
            "subjectMode": obj.get("subjectMode"),
            "updateTime": obj.get("updateTime")
        })
        return _obj


