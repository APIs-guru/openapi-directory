# coding: utf-8

"""
    Cloud SQL Admin API

    API for Cloud SQL database instance management

    The version of the OpenAPI document: v1beta4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.acl_entry import AclEntry
from openapi_client.models.psc_config import PscConfig
from typing import Optional, Set
from typing_extensions import Self

class IpConfiguration(BaseModel):
    """
    IP Management configuration.
    """ # noqa: E501
    allocated_ip_range: Optional[StrictStr] = Field(default=None, description="The name of the allocated ip range for the private ip Cloud SQL instance. For example: \"google-managed-services-default\". If set, the instance ip will be created in the allocated range. The range name must comply with [RFC 1035](https://tools.ietf.org/html/rfc1035). Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?.`", alias="allocatedIpRange")
    authorized_networks: Optional[List[AclEntry]] = Field(default=None, description="The list of external networks that are allowed to connect to the instance using the IP. In 'CIDR' notation, also known as 'slash' notation (for example: `157.197.200.0/24`).", alias="authorizedNetworks")
    enable_private_path_for_google_cloud_services: Optional[StrictBool] = Field(default=None, description="Controls connectivity to private IP instances from Google services, such as BigQuery.", alias="enablePrivatePathForGoogleCloudServices")
    ipv4_enabled: Optional[StrictBool] = Field(default=None, description="Whether the instance is assigned a public IP address or not.", alias="ipv4Enabled")
    private_network: Optional[StrictStr] = Field(default=None, description="The resource link for the VPC network from which the Cloud SQL instance is accessible for private IP. For example, `/projects/myProject/global/networks/default`. This setting can be updated, but it cannot be removed after it is set.", alias="privateNetwork")
    psc_config: Optional[PscConfig] = Field(default=None, alias="pscConfig")
    require_ssl: Optional[StrictBool] = Field(default=None, description="Use `ssl_mode` instead for MySQL and PostgreSQL. SQL Server uses this flag. Whether SSL/TLS connections over IP are enforced. If set to false, then allow both non-SSL/non-TLS and SSL/TLS connections. For SSL/TLS connections, the client certificate won't be verified. If set to true, then only allow connections encrypted with SSL/TLS and with valid client certificates. If you want to enforce SSL/TLS without enforcing the requirement for valid client certificates, then use the `ssl_mode` flag instead of the legacy `require_ssl` flag.", alias="requireSsl")
    ssl_mode: Optional[StrictStr] = Field(default=None, description="Specify how SSL/TLS is enforced in database connections. MySQL and PostgreSQL use the `ssl_mode` flag. If you must use the `require_ssl` flag for backward compatibility, then only the following value pairs are valid: * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false` * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false` * `ssl_mode=TRUSTED_CLIENT_CERTIFICATE_REQUIRED` and `require_ssl=true` The value of `ssl_mode` gets priority over the value of `require_ssl`. For example, for the pair `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false`, the `ssl_mode=ENCRYPTED_ONLY` means only accept SSL connections, while the `require_ssl=false` means accept both non-SSL and SSL connections. MySQL and PostgreSQL databases respect `ssl_mode` in this case and accept only SSL connections. SQL Server uses the `require_ssl` flag. You can set the value for this flag to `true` or `false`.", alias="sslMode")
    __properties: ClassVar[List[str]] = ["allocatedIpRange", "authorizedNetworks", "enablePrivatePathForGoogleCloudServices", "ipv4Enabled", "privateNetwork", "pscConfig", "requireSsl", "sslMode"]

    @field_validator('ssl_mode')
    def ssl_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SSL_MODE_UNSPECIFIED', 'ALLOW_UNENCRYPTED_AND_ENCRYPTED', 'ENCRYPTED_ONLY', 'TRUSTED_CLIENT_CERTIFICATE_REQUIRED']):
            raise ValueError("must be one of enum values ('SSL_MODE_UNSPECIFIED', 'ALLOW_UNENCRYPTED_AND_ENCRYPTED', 'ENCRYPTED_ONLY', 'TRUSTED_CLIENT_CERTIFICATE_REQUIRED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of IpConfiguration from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in authorized_networks (list)
        _items = []
        if self.authorized_networks:
            for _item_authorized_networks in self.authorized_networks:
                if _item_authorized_networks:
                    _items.append(_item_authorized_networks.to_dict())
            _dict['authorizedNetworks'] = _items
        # override the default output from pydantic by calling `to_dict()` of psc_config
        if self.psc_config:
            _dict['pscConfig'] = self.psc_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of IpConfiguration from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "allocatedIpRange": obj.get("allocatedIpRange"),
            "authorizedNetworks": [AclEntry.from_dict(_item) for _item in obj["authorizedNetworks"]] if obj.get("authorizedNetworks") is not None else None,
            "enablePrivatePathForGoogleCloudServices": obj.get("enablePrivatePathForGoogleCloudServices"),
            "ipv4Enabled": obj.get("ipv4Enabled"),
            "privateNetwork": obj.get("privateNetwork"),
            "pscConfig": PscConfig.from_dict(obj["pscConfig"]) if obj.get("pscConfig") is not None else None,
            "requireSsl": obj.get("requireSsl"),
            "sslMode": obj.get("sslMode")
        })
        return _obj


