# coding: utf-8

"""
    Vertex AI Search for Retail API

    Vertex AI Search for Retail API is made up of Retail Search, Browse and Recommendations. These discovery AI solutions help you implement personalized search, browse and recommendations, based on machine learning models, across your websites and mobile applications.

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_retail_v2_search_request_facet_spec_facet_key import GoogleCloudRetailV2SearchRequestFacetSpecFacetKey
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudRetailV2SearchRequestFacetSpec(BaseModel):
    """
    A facet specification to perform faceted search.
    """ # noqa: E501
    enable_dynamic_position: Optional[StrictBool] = Field(default=None, description="Enables dynamic position for this facet. If set to true, the position of this facet among all facets in the response is determined by Google Retail Search. It is ordered together with dynamic facets if dynamic facets is enabled. If set to false, the position of this facet in the response is the same as in the request, and it is ranked before the facets with dynamic position enable and all dynamic facets. For example, you may always want to have rating facet returned in the response, but it's not necessarily to always display the rating facet at the top. In that case, you can set enable_dynamic_position to true so that the position of rating facet in response is determined by Google Retail Search. Another example, assuming you have the following facets in the request: * \"rating\", enable_dynamic_position = true * \"price\", enable_dynamic_position = false * \"brands\", enable_dynamic_position = false And also you have a dynamic facets enable, which generates a facet \"gender\". Then, the final order of the facets in the response can be (\"price\", \"brands\", \"rating\", \"gender\") or (\"price\", \"brands\", \"gender\", \"rating\") depends on how Google Retail Search orders \"gender\" and \"rating\" facets. However, notice that \"price\" and \"brands\" are always ranked at first and second position because their enable_dynamic_position values are false.", alias="enableDynamicPosition")
    excluded_filter_keys: Optional[List[StrictStr]] = Field(default=None, description="List of keys to exclude when faceting. By default, FacetKey.key is not excluded from the filter unless it is listed in this field. Listing a facet key in this field allows its values to appear as facet results, even when they are filtered out of search results. Using this field does not affect what search results are returned. For example, suppose there are 100 products with the color facet \"Red\" and 200 products with the color facet \"Blue\". A query containing the filter \"colorFamilies:ANY(\"Red\")\" and having \"colorFamilies\" as FacetKey.key would by default return only \"Red\" products in the search results, and also return \"Red\" with count 100 as the only color facet. Although there are also blue products available, \"Blue\" would not be shown as an available facet value. If \"colorFamilies\" is listed in \"excludedFilterKeys\", then the query returns the facet values \"Red\" with count 100 and \"Blue\" with count 200, because the \"colorFamilies\" key is now excluded from the filter. Because this field doesn't affect search results, the search results are still correctly filtered to return only \"Red\" products. A maximum of 100 values are allowed. Otherwise, an INVALID_ARGUMENT error is returned.", alias="excludedFilterKeys")
    facet_key: Optional[GoogleCloudRetailV2SearchRequestFacetSpecFacetKey] = Field(default=None, alias="facetKey")
    limit: Optional[StrictInt] = Field(default=None, description="Maximum of facet values that should be returned for this facet. If unspecified, defaults to 50. The maximum allowed value is 300. Values above 300 will be coerced to 300. If this field is negative, an INVALID_ARGUMENT is returned.")
    __properties: ClassVar[List[str]] = ["enableDynamicPosition", "excludedFilterKeys", "facetKey", "limit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudRetailV2SearchRequestFacetSpec from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of facet_key
        if self.facet_key:
            _dict['facetKey'] = self.facet_key.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudRetailV2SearchRequestFacetSpec from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "enableDynamicPosition": obj.get("enableDynamicPosition"),
            "excludedFilterKeys": obj.get("excludedFilterKeys"),
            "facetKey": GoogleCloudRetailV2SearchRequestFacetSpecFacetKey.from_dict(obj["facetKey"]) if obj.get("facetKey") is not None else None,
            "limit": obj.get("limit")
        })
        return _obj


