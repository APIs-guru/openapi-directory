# coding: utf-8

"""
    Vertex AI Search for Retail API

    Vertex AI Search for Retail API is made up of Retail Search, Browse and Recommendations. These discovery AI solutions help you implement personalized search, browse and recommendations, based on machine learning models, across your websites and mobile applications.

    The version of the OpenAPI document: v2beta
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_retail_v2beta_search_request_dynamic_facet_spec import GoogleCloudRetailV2betaSearchRequestDynamicFacetSpec
from openapi_client.models.google_cloud_retail_v2beta_search_request_personalization_spec import GoogleCloudRetailV2betaSearchRequestPersonalizationSpec
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudRetailV2betaServingConfig(BaseModel):
    """
    Configures metadata that is used to generate serving time results (e.g. search results or recommendation predictions).
    """ # noqa: E501
    boost_control_ids: Optional[List[StrictStr]] = Field(default=None, description="Condition boost specifications. If a product matches multiple conditions in the specifications, boost scores from these specifications are all applied and combined in a non-linear way. Maximum number of specifications is 100. Notice that if both ServingConfig.boost_control_ids and SearchRequest.boost_spec are set, the boost conditions from both places are evaluated. If a search request matches multiple boost conditions, the final boost score is equal to the sum of the boost scores from all matched boost conditions. Can only be set if solution_types is SOLUTION_TYPE_SEARCH.", alias="boostControlIds")
    display_name: Optional[StrictStr] = Field(default=None, description="Required. The human readable serving config display name. Used in Retail UI. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is returned.", alias="displayName")
    diversity_level: Optional[StrictStr] = Field(default=None, description="How much diversity to use in recommendation model results e.g. `medium-diversity` or `high-diversity`. Currently supported values: * `no-diversity` * `low-diversity` * `medium-diversity` * `high-diversity` * `auto-diversity` If not specified, we choose default based on recommendation model type. Default value: `no-diversity`. Can only be set if solution_types is SOLUTION_TYPE_RECOMMENDATION.", alias="diversityLevel")
    diversity_type: Optional[StrictStr] = Field(default=None, description="What kind of diversity to use - data driven or rule based. If unset, the server behavior defaults to RULE_BASED_DIVERSITY.", alias="diversityType")
    do_not_associate_control_ids: Optional[List[StrictStr]] = Field(default=None, description="Condition do not associate specifications. If multiple do not associate conditions match, all matching do not associate controls in the list will execute. - Order does not matter. - Maximum number of specifications is 100. Can only be set if solution_types is SOLUTION_TYPE_SEARCH.", alias="doNotAssociateControlIds")
    dynamic_facet_spec: Optional[GoogleCloudRetailV2betaSearchRequestDynamicFacetSpec] = Field(default=None, alias="dynamicFacetSpec")
    enable_category_filter_level: Optional[StrictStr] = Field(default=None, description="Whether to add additional category filters on the `similar-items` model. If not specified, we enable it by default. Allowed values are: * `no-category-match`: No additional filtering of original results from the model and the customer's filters. * `relaxed-category-match`: Only keep results with categories that match at least one item categories in the PredictRequests's context item. * If customer also sends filters in the PredictRequest, then the results will satisfy both conditions (user given and category match). Can only be set if solution_types is SOLUTION_TYPE_RECOMMENDATION.", alias="enableCategoryFilterLevel")
    facet_control_ids: Optional[List[StrictStr]] = Field(default=None, description="Facet specifications for faceted search. If empty, no facets are returned. The ids refer to the ids of Control resources with only the Facet control set. These controls are assumed to be in the same Catalog as the ServingConfig. A maximum of 100 values are allowed. Otherwise, an INVALID_ARGUMENT error is returned. Can only be set if solution_types is SOLUTION_TYPE_SEARCH.", alias="facetControlIds")
    filter_control_ids: Optional[List[StrictStr]] = Field(default=None, description="Condition filter specifications. If a product matches multiple conditions in the specifications, filters from these specifications are all applied and combined via the AND operator. Maximum number of specifications is 100. Can only be set if solution_types is SOLUTION_TYPE_SEARCH.", alias="filterControlIds")
    ignore_control_ids: Optional[List[StrictStr]] = Field(default=None, description="Condition ignore specifications. If multiple ignore conditions match, all matching ignore controls in the list will execute. - Order does not matter. - Maximum number of specifications is 100. Can only be set if solution_types is SOLUTION_TYPE_SEARCH.", alias="ignoreControlIds")
    model_id: Optional[StrictStr] = Field(default=None, description="The id of the model in the same Catalog to use at serving time. Currently only RecommendationModels are supported: https://cloud.google.com/retail/recommendations-ai/docs/create-models Can be changed but only to a compatible model (e.g. others-you-may-like CTR to others-you-may-like CVR). Required when solution_types is SOLUTION_TYPE_RECOMMENDATION.", alias="modelId")
    name: Optional[StrictStr] = Field(default=None, description="Immutable. Fully qualified name `projects/*/locations/global/catalogs/*/servingConfig/*`")
    oneway_synonyms_control_ids: Optional[List[StrictStr]] = Field(default=None, description="Condition oneway synonyms specifications. If multiple oneway synonyms conditions match, all matching oneway synonyms controls in the list will execute. Order of controls in the list will not matter. Maximum number of specifications is 100. Can only be set if solution_types is SOLUTION_TYPE_SEARCH.", alias="onewaySynonymsControlIds")
    personalization_spec: Optional[GoogleCloudRetailV2betaSearchRequestPersonalizationSpec] = Field(default=None, alias="personalizationSpec")
    price_reranking_level: Optional[StrictStr] = Field(default=None, description="How much price ranking we want in serving results. Price reranking causes product items with a similar recommendation probability to be ordered by price, with the highest-priced items first. This setting could result in a decrease in click-through and conversion rates. Allowed values are: * `no-price-reranking` * `low-price-reranking` * `medium-price-reranking` * `high-price-reranking` If not specified, we choose default based on model type. Default value: `no-price-reranking`. Can only be set if solution_types is SOLUTION_TYPE_RECOMMENDATION.", alias="priceRerankingLevel")
    redirect_control_ids: Optional[List[StrictStr]] = Field(default=None, description="Condition redirect specifications. Only the first triggered redirect action is applied, even if multiple apply. Maximum number of specifications is 1000. Can only be set if solution_types is SOLUTION_TYPE_SEARCH.", alias="redirectControlIds")
    replacement_control_ids: Optional[List[StrictStr]] = Field(default=None, description="Condition replacement specifications. - Applied according to the order in the list. - A previously replaced term can not be re-replaced. - Maximum number of specifications is 100. Can only be set if solution_types is SOLUTION_TYPE_SEARCH.", alias="replacementControlIds")
    solution_types: Optional[List[StrictStr]] = Field(default=None, description="Required. Immutable. Specifies the solution types that a serving config can be associated with. Currently we support setting only one type of solution.", alias="solutionTypes")
    twoway_synonyms_control_ids: Optional[List[StrictStr]] = Field(default=None, description="Condition synonyms specifications. If multiple syonyms conditions match, all matching synonyms control in the list will execute. Order of controls in the list will not matter. Maximum number of specifications is 100. Can only be set if solution_types is SOLUTION_TYPE_SEARCH.", alias="twowaySynonymsControlIds")
    __properties: ClassVar[List[str]] = ["boostControlIds", "displayName", "diversityLevel", "diversityType", "doNotAssociateControlIds", "dynamicFacetSpec", "enableCategoryFilterLevel", "facetControlIds", "filterControlIds", "ignoreControlIds", "modelId", "name", "onewaySynonymsControlIds", "personalizationSpec", "priceRerankingLevel", "redirectControlIds", "replacementControlIds", "solutionTypes", "twowaySynonymsControlIds"]

    @field_validator('diversity_type')
    def diversity_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DIVERSITY_TYPE_UNSPECIFIED', 'RULE_BASED_DIVERSITY', 'DATA_DRIVEN_DIVERSITY']):
            raise ValueError("must be one of enum values ('DIVERSITY_TYPE_UNSPECIFIED', 'RULE_BASED_DIVERSITY', 'DATA_DRIVEN_DIVERSITY')")
        return value

    @field_validator('solution_types')
    def solution_types_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['SOLUTION_TYPE_UNSPECIFIED', 'SOLUTION_TYPE_RECOMMENDATION', 'SOLUTION_TYPE_SEARCH']):
                raise ValueError("each list item must be one of ('SOLUTION_TYPE_UNSPECIFIED', 'SOLUTION_TYPE_RECOMMENDATION', 'SOLUTION_TYPE_SEARCH')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudRetailV2betaServingConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of dynamic_facet_spec
        if self.dynamic_facet_spec:
            _dict['dynamicFacetSpec'] = self.dynamic_facet_spec.to_dict()
        # override the default output from pydantic by calling `to_dict()` of personalization_spec
        if self.personalization_spec:
            _dict['personalizationSpec'] = self.personalization_spec.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudRetailV2betaServingConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "boostControlIds": obj.get("boostControlIds"),
            "displayName": obj.get("displayName"),
            "diversityLevel": obj.get("diversityLevel"),
            "diversityType": obj.get("diversityType"),
            "doNotAssociateControlIds": obj.get("doNotAssociateControlIds"),
            "dynamicFacetSpec": GoogleCloudRetailV2betaSearchRequestDynamicFacetSpec.from_dict(obj["dynamicFacetSpec"]) if obj.get("dynamicFacetSpec") is not None else None,
            "enableCategoryFilterLevel": obj.get("enableCategoryFilterLevel"),
            "facetControlIds": obj.get("facetControlIds"),
            "filterControlIds": obj.get("filterControlIds"),
            "ignoreControlIds": obj.get("ignoreControlIds"),
            "modelId": obj.get("modelId"),
            "name": obj.get("name"),
            "onewaySynonymsControlIds": obj.get("onewaySynonymsControlIds"),
            "personalizationSpec": GoogleCloudRetailV2betaSearchRequestPersonalizationSpec.from_dict(obj["personalizationSpec"]) if obj.get("personalizationSpec") is not None else None,
            "priceRerankingLevel": obj.get("priceRerankingLevel"),
            "redirectControlIds": obj.get("redirectControlIds"),
            "replacementControlIds": obj.get("replacementControlIds"),
            "solutionTypes": obj.get("solutionTypes"),
            "twowaySynonymsControlIds": obj.get("twowaySynonymsControlIds")
        })
        return _obj


