# coding: utf-8

"""
    Google Mirror

    Interacts with Glass users via the timeline.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.command import Command
from typing import Optional, Set
from typing_extensions import Self

class Contact(BaseModel):
    """
    A person or group that can be used as a creator or a contact.
    """ # noqa: E501
    accept_commands: Optional[List[Command]] = Field(default=None, description="A list of voice menu commands that a contact can handle. Glass shows up to three contacts for each voice menu command. If there are more than that, the three contacts with the highest priority are shown for that particular command.", alias="acceptCommands")
    accept_types: Optional[List[StrictStr]] = Field(default=None, description="A list of MIME types that a contact supports. The contact will be shown to the user if any of its acceptTypes matches any of the types of the attachments on the item. If no acceptTypes are given, the contact will be shown for all items.", alias="acceptTypes")
    display_name: Optional[StrictStr] = Field(default=None, description="The name to display for this contact.", alias="displayName")
    id: Optional[StrictStr] = Field(default=None, description="An ID for this contact. This is generated by the application and is treated as an opaque token.")
    image_urls: Optional[List[StrictStr]] = Field(default=None, description="Set of image URLs to display for a contact. Most contacts will have a single image, but a \"group\" contact may include up to 8 image URLs and they will be resized and cropped into a mosaic on the client.", alias="imageUrls")
    kind: Optional[StrictStr] = Field(default='mirror#contact', description="The type of resource. This is always mirror#contact.")
    phone_number: Optional[StrictStr] = Field(default=None, description="Primary phone number for the contact. This can be a fully-qualified number, with country calling code and area code, or a local number.", alias="phoneNumber")
    priority: Optional[StrictInt] = Field(default=None, description="Priority for the contact to determine ordering in a list of contacts. Contacts with higher priorities will be shown before ones with lower priorities.")
    sharing_features: Optional[List[StrictStr]] = Field(default=None, description="A list of sharing features that a contact can handle. Allowed values are:   - ADD_CAPTION", alias="sharingFeatures")
    source: Optional[StrictStr] = Field(default=None, description="The ID of the application that created this contact. This is populated by the API")
    speakable_name: Optional[StrictStr] = Field(default=None, description="Name of this contact as it should be pronounced. If this contact's name must be spoken as part of a voice disambiguation menu, this name is used as the expected pronunciation. This is useful for contact names with unpronounceable characters or whose display spelling is otherwise not phonetic.", alias="speakableName")
    type: Optional[StrictStr] = Field(default=None, description="The type for this contact. This is used for sorting in UIs. Allowed values are:   - INDIVIDUAL - Represents a single person. This is the default.  - GROUP - Represents more than a single person.")
    __properties: ClassVar[List[str]] = ["acceptCommands", "acceptTypes", "displayName", "id", "imageUrls", "kind", "phoneNumber", "priority", "sharingFeatures", "source", "speakableName", "type"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Contact from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in accept_commands (list)
        _items = []
        if self.accept_commands:
            for _item_accept_commands in self.accept_commands:
                if _item_accept_commands:
                    _items.append(_item_accept_commands.to_dict())
            _dict['acceptCommands'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Contact from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "acceptCommands": [Command.from_dict(_item) for _item in obj["acceptCommands"]] if obj.get("acceptCommands") is not None else None,
            "acceptTypes": obj.get("acceptTypes"),
            "displayName": obj.get("displayName"),
            "id": obj.get("id"),
            "imageUrls": obj.get("imageUrls"),
            "kind": obj.get("kind") if obj.get("kind") is not None else 'mirror#contact',
            "phoneNumber": obj.get("phoneNumber"),
            "priority": obj.get("priority"),
            "sharingFeatures": obj.get("sharingFeatures"),
            "source": obj.get("source"),
            "speakableName": obj.get("speakableName"),
            "type": obj.get("type")
        })
        return _obj


