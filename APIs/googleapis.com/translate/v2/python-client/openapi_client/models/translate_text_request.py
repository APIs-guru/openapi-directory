# coding: utf-8

"""
    Google Cloud Translation API

    The Google Cloud Translation API lets websites and programs integrate with     Google Translate programmatically.

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class TranslateTextRequest(BaseModel):
    """
    The main translation request message for the Cloud Translation API.
    """ # noqa: E501
    format: Optional[StrictStr] = Field(default=None, description="The format of the source text, in either HTML (default) or plain-text. A value of \"html\" indicates HTML and a value of \"text\" indicates plain-text.")
    model: Optional[StrictStr] = Field(default=None, description="The `model` type requested for this translation. Valid values are listed in public documentation.")
    q: Optional[List[StrictStr]] = Field(default=None, description="The input text to translate. Repeat this parameter to perform translation operations on multiple text inputs.")
    source: Optional[StrictStr] = Field(default=None, description="The language of the source text, set to one of the language codes listed in Language Support. If the source language is not specified, the API will attempt to identify the source language automatically and return it within the response.")
    target: Optional[StrictStr] = Field(default=None, description="The language to use for translation of the input text, set to one of the language codes listed in Language Support.")
    __properties: ClassVar[List[str]] = ["format", "model", "q", "source", "target"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TranslateTextRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TranslateTextRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "format": obj.get("format"),
            "model": obj.get("model"),
            "q": obj.get("q"),
            "source": obj.get("source"),
            "target": obj.get("target")
        })
        return _obj


