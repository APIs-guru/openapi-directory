# coding: utf-8

"""
    Cloud Debugger API (Deprecated)

    Examines the call stack and variables of a running application without stopping or slowing it down. (Deprecated) 

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.extended_source_context import ExtendedSourceContext
from openapi_client.models.source_context import SourceContext
from openapi_client.models.status_message import StatusMessage
from typing import Optional, Set
from typing_extensions import Self

class Debuggee(BaseModel):
    """
    Represents the debugged application. The application may include one or more replicated processes executing the same code. Each of these processes is attached with a debugger agent, carrying out the debugging commands. Agents attached to the same debuggee identify themselves as such by using exactly the same Debuggee message value when registering.
    """ # noqa: E501
    agent_version: Optional[StrictStr] = Field(default=None, description="Version ID of the agent. Schema: `domain/language-platform/vmajor.minor` (for example `google.com/java-gcp/v1.1`).", alias="agentVersion")
    canary_mode: Optional[StrictStr] = Field(default=None, description="Used when setting breakpoint canary for this debuggee.", alias="canaryMode")
    description: Optional[StrictStr] = Field(default=None, description="Human readable description of the debuggee. Including a human-readable project name, environment name and version information is recommended.")
    ext_source_contexts: Optional[List[ExtendedSourceContext]] = Field(default=None, description="References to the locations and revisions of the source code used in the deployed application.", alias="extSourceContexts")
    id: Optional[StrictStr] = Field(default=None, description="Unique identifier for the debuggee generated by the controller service.")
    is_disabled: Optional[StrictBool] = Field(default=None, description="If set to `true`, indicates that the agent should disable itself and detach from the debuggee.", alias="isDisabled")
    is_inactive: Optional[StrictBool] = Field(default=None, description="If set to `true`, indicates that Controller service does not detect any activity from the debuggee agents and the application is possibly stopped.", alias="isInactive")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="A set of custom debuggee properties, populated by the agent, to be displayed to the user.")
    project: Optional[StrictStr] = Field(default=None, description="Project the debuggee is associated with. Use project number or id when registering a Google Cloud Platform project.")
    source_contexts: Optional[List[SourceContext]] = Field(default=None, description="References to the locations and revisions of the source code used in the deployed application.", alias="sourceContexts")
    status: Optional[StatusMessage] = None
    uniquifier: Optional[StrictStr] = Field(default=None, description="Uniquifier to further distinguish the application. It is possible that different applications might have identical values in the debuggee message, thus, incorrectly identified as a single application by the Controller service. This field adds salt to further distinguish the application. Agents should consider seeding this field with value that identifies the code, binary, configuration and environment.")
    __properties: ClassVar[List[str]] = ["agentVersion", "canaryMode", "description", "extSourceContexts", "id", "isDisabled", "isInactive", "labels", "project", "sourceContexts", "status", "uniquifier"]

    @field_validator('canary_mode')
    def canary_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CANARY_MODE_UNSPECIFIED', 'CANARY_MODE_ALWAYS_ENABLED', 'CANARY_MODE_ALWAYS_DISABLED', 'CANARY_MODE_DEFAULT_ENABLED', 'CANARY_MODE_DEFAULT_DISABLED']):
            raise ValueError("must be one of enum values ('CANARY_MODE_UNSPECIFIED', 'CANARY_MODE_ALWAYS_ENABLED', 'CANARY_MODE_ALWAYS_DISABLED', 'CANARY_MODE_DEFAULT_ENABLED', 'CANARY_MODE_DEFAULT_DISABLED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Debuggee from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in ext_source_contexts (list)
        _items = []
        if self.ext_source_contexts:
            for _item_ext_source_contexts in self.ext_source_contexts:
                if _item_ext_source_contexts:
                    _items.append(_item_ext_source_contexts.to_dict())
            _dict['extSourceContexts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in source_contexts (list)
        _items = []
        if self.source_contexts:
            for _item_source_contexts in self.source_contexts:
                if _item_source_contexts:
                    _items.append(_item_source_contexts.to_dict())
            _dict['sourceContexts'] = _items
        # override the default output from pydantic by calling `to_dict()` of status
        if self.status:
            _dict['status'] = self.status.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Debuggee from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "agentVersion": obj.get("agentVersion"),
            "canaryMode": obj.get("canaryMode"),
            "description": obj.get("description"),
            "extSourceContexts": [ExtendedSourceContext.from_dict(_item) for _item in obj["extSourceContexts"]] if obj.get("extSourceContexts") is not None else None,
            "id": obj.get("id"),
            "isDisabled": obj.get("isDisabled"),
            "isInactive": obj.get("isInactive"),
            "labels": obj.get("labels"),
            "project": obj.get("project"),
            "sourceContexts": [SourceContext.from_dict(_item) for _item in obj["sourceContexts"]] if obj.get("sourceContexts") is not None else None,
            "status": StatusMessage.from_dict(obj["status"]) if obj.get("status") is not None else None,
            "uniquifier": obj.get("uniquifier")
        })
        return _obj


