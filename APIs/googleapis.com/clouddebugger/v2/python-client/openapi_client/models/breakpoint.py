# coding: utf-8

"""
    Cloud Debugger API (Deprecated)

    Examines the call stack and variables of a running application without stopping or slowing it down. (Deprecated) 

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.source_location import SourceLocation
from openapi_client.models.stack_frame import StackFrame
from openapi_client.models.status_message import StatusMessage
from openapi_client.models.variable import Variable
from typing import Optional, Set
from typing_extensions import Self

class Breakpoint(BaseModel):
    """
    ------------------------------------------------------------------------------ ## Breakpoint (the resource) Represents the breakpoint specification, status and results.
    """ # noqa: E501
    action: Optional[StrictStr] = Field(default=None, description="Action that the agent should perform when the code at the breakpoint location is hit.")
    canary_expire_time: Optional[StrictStr] = Field(default=None, description="The deadline for the breakpoint to stay in CANARY_ACTIVE state. The value is meaningless when the breakpoint is not in CANARY_ACTIVE state.", alias="canaryExpireTime")
    condition: Optional[StrictStr] = Field(default=None, description="Condition that triggers the breakpoint. The condition is a compound boolean expression composed using expressions in a programming language at the source location.")
    create_time: Optional[StrictStr] = Field(default=None, description="Time this breakpoint was created by the server in seconds resolution.", alias="createTime")
    evaluated_expressions: Optional[List[Variable]] = Field(default=None, description="Values of evaluated expressions at breakpoint time. The evaluated expressions appear in exactly the same order they are listed in the `expressions` field. The `name` field holds the original expression text, the `value` or `members` field holds the result of the evaluated expression. If the expression cannot be evaluated, the `status` inside the `Variable` will indicate an error and contain the error text.", alias="evaluatedExpressions")
    expressions: Optional[List[StrictStr]] = Field(default=None, description="List of read-only expressions to evaluate at the breakpoint location. The expressions are composed using expressions in the programming language at the source location. If the breakpoint action is `LOG`, the evaluated expressions are included in log statements.")
    final_time: Optional[StrictStr] = Field(default=None, description="Time this breakpoint was finalized as seen by the server in seconds resolution.", alias="finalTime")
    id: Optional[StrictStr] = Field(default=None, description="Breakpoint identifier, unique in the scope of the debuggee.")
    is_final_state: Optional[StrictBool] = Field(default=None, description="When true, indicates that this is a final result and the breakpoint state will not change from here on.", alias="isFinalState")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="A set of custom breakpoint properties, populated by the agent, to be displayed to the user.")
    location: Optional[SourceLocation] = None
    log_level: Optional[StrictStr] = Field(default=None, description="Indicates the severity of the log. Only relevant when action is `LOG`.", alias="logLevel")
    log_message_format: Optional[StrictStr] = Field(default=None, description="Only relevant when action is `LOG`. Defines the message to log when the breakpoint hits. The message may include parameter placeholders `$0`, `$1`, etc. These placeholders are replaced with the evaluated value of the appropriate expression. Expressions not referenced in `log_message_format` are not logged. Example: `Message received, id = $0, count = $1` with `expressions` = `[ message.id, message.count ]`.", alias="logMessageFormat")
    stack_frames: Optional[List[StackFrame]] = Field(default=None, description="The stack at breakpoint time, where stack_frames[0] represents the most recently entered function.", alias="stackFrames")
    state: Optional[StrictStr] = Field(default=None, description="The current state of the breakpoint.")
    status: Optional[StatusMessage] = None
    user_email: Optional[StrictStr] = Field(default=None, description="E-mail address of the user that created this breakpoint", alias="userEmail")
    variable_table: Optional[List[Variable]] = Field(default=None, description="The `variable_table` exists to aid with computation, memory and network traffic optimization. It enables storing a variable once and reference it from multiple variables, including variables stored in the `variable_table` itself. For example, the same `this` object, which may appear at many levels of the stack, can have all of its data stored once in this table. The stack frame variables then would hold only a reference to it. The variable `var_table_index` field is an index into this repeated field. The stored objects are nameless and get their name from the referencing variable. The effective variable is a merge of the referencing variable and the referenced variable.", alias="variableTable")
    __properties: ClassVar[List[str]] = ["action", "canaryExpireTime", "condition", "createTime", "evaluatedExpressions", "expressions", "finalTime", "id", "isFinalState", "labels", "location", "logLevel", "logMessageFormat", "stackFrames", "state", "status", "userEmail", "variableTable"]

    @field_validator('action')
    def action_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CAPTURE', 'LOG']):
            raise ValueError("must be one of enum values ('CAPTURE', 'LOG')")
        return value

    @field_validator('log_level')
    def log_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['INFO', 'WARNING', 'ERROR']):
            raise ValueError("must be one of enum values ('INFO', 'WARNING', 'ERROR')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'STATE_CANARY_PENDING_AGENTS', 'STATE_CANARY_ACTIVE', 'STATE_ROLLING_TO_ALL', 'STATE_IS_FINAL']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'STATE_CANARY_PENDING_AGENTS', 'STATE_CANARY_ACTIVE', 'STATE_ROLLING_TO_ALL', 'STATE_IS_FINAL')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Breakpoint from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in evaluated_expressions (list)
        _items = []
        if self.evaluated_expressions:
            for _item_evaluated_expressions in self.evaluated_expressions:
                if _item_evaluated_expressions:
                    _items.append(_item_evaluated_expressions.to_dict())
            _dict['evaluatedExpressions'] = _items
        # override the default output from pydantic by calling `to_dict()` of location
        if self.location:
            _dict['location'] = self.location.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in stack_frames (list)
        _items = []
        if self.stack_frames:
            for _item_stack_frames in self.stack_frames:
                if _item_stack_frames:
                    _items.append(_item_stack_frames.to_dict())
            _dict['stackFrames'] = _items
        # override the default output from pydantic by calling `to_dict()` of status
        if self.status:
            _dict['status'] = self.status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in variable_table (list)
        _items = []
        if self.variable_table:
            for _item_variable_table in self.variable_table:
                if _item_variable_table:
                    _items.append(_item_variable_table.to_dict())
            _dict['variableTable'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Breakpoint from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "action": obj.get("action"),
            "canaryExpireTime": obj.get("canaryExpireTime"),
            "condition": obj.get("condition"),
            "createTime": obj.get("createTime"),
            "evaluatedExpressions": [Variable.from_dict(_item) for _item in obj["evaluatedExpressions"]] if obj.get("evaluatedExpressions") is not None else None,
            "expressions": obj.get("expressions"),
            "finalTime": obj.get("finalTime"),
            "id": obj.get("id"),
            "isFinalState": obj.get("isFinalState"),
            "labels": obj.get("labels"),
            "location": SourceLocation.from_dict(obj["location"]) if obj.get("location") is not None else None,
            "logLevel": obj.get("logLevel"),
            "logMessageFormat": obj.get("logMessageFormat"),
            "stackFrames": [StackFrame.from_dict(_item) for _item in obj["stackFrames"]] if obj.get("stackFrames") is not None else None,
            "state": obj.get("state"),
            "status": StatusMessage.from_dict(obj["status"]) if obj.get("status") is not None else None,
            "userEmail": obj.get("userEmail"),
            "variableTable": [Variable.from_dict(_item) for _item in obj["variableTable"]] if obj.get("variableTable") is not None else None
        })
        return _obj


