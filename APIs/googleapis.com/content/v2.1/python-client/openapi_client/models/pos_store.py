# coding: utf-8

"""
    Content API for Shopping

    Manage your product listings and accounts for Google Shopping

    The version of the OpenAPI document: v2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class PosStore(BaseModel):
    """
    Store resource.
    """ # noqa: E501
    gcid_category: Optional[List[StrictStr]] = Field(default=None, description="The business type of the store.", alias="gcidCategory")
    kind: Optional[StrictStr] = Field(default=None, description="Identifies what kind of resource this is. Value: the fixed string \"`content#posStore`\"")
    matching_status: Optional[StrictStr] = Field(default=None, description="Output only. The matching status of POS store and Google Business Profile store. Possible values are: - \"`matched`\": The POS store is successfully matched with the Google Business Profile store. - \"`failed`\": The POS store is not matched with the Google Business Profile store. See matching_status_hint for further details. Note that there is up to 48 hours propagation delay for changes in Merchant Center (e.g. creation of new account, accounts linking) and Google Business Profile (e.g. store address update) which may affect the matching status. In such cases, after a delay call [pos.list](https://developers.google.com/shopping-content/reference/rest/v2.1/pos/list) to retrieve the updated matching status. ", alias="matchingStatus")
    matching_status_hint: Optional[StrictStr] = Field(default=None, description="Output only. The hint of why the matching has failed. This is only set when matching_status=failed. Possible values are: - \"`linked-store-not-found`\": There aren't any Google Business Profile stores available for matching. Connect your Merchant Center account with the Google Business Profile account. Or add a new Google Business Profile store corresponding to the POS store. - \"`store-match-not-found`\": The provided POS store couldn't be matched to any of the connected Google Business Profile stores. Merchant Center account is connected correctly and stores are available on Google Business Profile, but POS store location address does not match with Google Business Profile stores' addresses. Update POS store address or Google Business Profile store address to match correctly. - \"`store-match-unverified`\": The provided POS store couldn't be matched to any of the connected Google Business Profile stores, as the matched Google Business Profile store is unverified. Go through the Google Business Profile verification process to match correctly. ", alias="matchingStatusHint")
    phone_number: Optional[StrictStr] = Field(default=None, description="The store phone number.", alias="phoneNumber")
    place_id: Optional[StrictStr] = Field(default=None, description="The Google Place Id of the store location.", alias="placeId")
    store_address: Optional[StrictStr] = Field(default=None, description="Required. The street address of the store.", alias="storeAddress")
    store_code: Optional[StrictStr] = Field(default=None, description="Required. A store identifier that is unique for the given merchant.", alias="storeCode")
    store_name: Optional[StrictStr] = Field(default=None, description="The merchant or store name.", alias="storeName")
    website_url: Optional[StrictStr] = Field(default=None, description="The website url for the store or merchant.", alias="websiteUrl")
    __properties: ClassVar[List[str]] = ["gcidCategory", "kind", "matchingStatus", "matchingStatusHint", "phoneNumber", "placeId", "storeAddress", "storeCode", "storeName", "websiteUrl"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PosStore from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "matching_status",
            "matching_status_hint",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PosStore from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "gcidCategory": obj.get("gcidCategory"),
            "kind": obj.get("kind"),
            "matchingStatus": obj.get("matchingStatus"),
            "matchingStatusHint": obj.get("matchingStatusHint"),
            "phoneNumber": obj.get("phoneNumber"),
            "placeId": obj.get("placeId"),
            "storeAddress": obj.get("storeAddress"),
            "storeCode": obj.get("storeCode"),
            "storeName": obj.get("storeName"),
            "websiteUrl": obj.get("websiteUrl")
        })
        return _obj


