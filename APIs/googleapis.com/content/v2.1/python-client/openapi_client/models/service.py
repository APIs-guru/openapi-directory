# coding: utf-8

"""
    Content API for Shopping

    Manage your product listings and accounts for Google Shopping

    The version of the OpenAPI document: v2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.delivery_time import DeliveryTime
from openapi_client.models.minimum_order_value_table import MinimumOrderValueTable
from openapi_client.models.pickup_carrier_service import PickupCarrierService
from openapi_client.models.price import Price
from openapi_client.models.rate_group import RateGroup
from openapi_client.models.service_store_config import ServiceStoreConfig
from typing import Optional, Set
from typing_extensions import Self

class Service(BaseModel):
    """
    Service
    """ # noqa: E501
    active: Optional[StrictBool] = Field(default=None, description="A boolean exposing the active status of the shipping service. Required.")
    currency: Optional[StrictStr] = Field(default=None, description="The CLDR code of the currency to which this service applies. Must match that of the prices in rate groups.")
    delivery_country: Optional[StrictStr] = Field(default=None, description="The CLDR territory code of the country to which the service applies. Required.", alias="deliveryCountry")
    delivery_time: Optional[DeliveryTime] = Field(default=None, alias="deliveryTime")
    eligibility: Optional[StrictStr] = Field(default=None, description="Eligibility for this service. Acceptable values are: - \"`All scenarios`\" - \"`All scenarios except Shopping Actions`\" - \"`Shopping Actions`\" ")
    minimum_order_value: Optional[Price] = Field(default=None, alias="minimumOrderValue")
    minimum_order_value_table: Optional[MinimumOrderValueTable] = Field(default=None, alias="minimumOrderValueTable")
    name: Optional[StrictStr] = Field(default=None, description="Free-form name of the service. Must be unique within target account. Required.")
    pickup_service: Optional[PickupCarrierService] = Field(default=None, alias="pickupService")
    rate_groups: Optional[List[RateGroup]] = Field(default=None, description="Shipping rate group definitions. Only the last one is allowed to have an empty `applicableShippingLabels`, which means \"everything else\". The other `applicableShippingLabels` must not overlap.", alias="rateGroups")
    shipment_type: Optional[StrictStr] = Field(default=None, description="Type of locations this service ships orders to. Acceptable values are: - \"`delivery`\" - \"`pickup` (deprecated)\" - \"`local_delivery`\" - \"`collection_point`\" ", alias="shipmentType")
    store_config: Optional[ServiceStoreConfig] = Field(default=None, alias="storeConfig")
    __properties: ClassVar[List[str]] = ["active", "currency", "deliveryCountry", "deliveryTime", "eligibility", "minimumOrderValue", "minimumOrderValueTable", "name", "pickupService", "rateGroups", "shipmentType", "storeConfig"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Service from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of delivery_time
        if self.delivery_time:
            _dict['deliveryTime'] = self.delivery_time.to_dict()
        # override the default output from pydantic by calling `to_dict()` of minimum_order_value
        if self.minimum_order_value:
            _dict['minimumOrderValue'] = self.minimum_order_value.to_dict()
        # override the default output from pydantic by calling `to_dict()` of minimum_order_value_table
        if self.minimum_order_value_table:
            _dict['minimumOrderValueTable'] = self.minimum_order_value_table.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pickup_service
        if self.pickup_service:
            _dict['pickupService'] = self.pickup_service.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in rate_groups (list)
        _items = []
        if self.rate_groups:
            for _item_rate_groups in self.rate_groups:
                if _item_rate_groups:
                    _items.append(_item_rate_groups.to_dict())
            _dict['rateGroups'] = _items
        # override the default output from pydantic by calling `to_dict()` of store_config
        if self.store_config:
            _dict['storeConfig'] = self.store_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Service from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "active": obj.get("active"),
            "currency": obj.get("currency"),
            "deliveryCountry": obj.get("deliveryCountry"),
            "deliveryTime": DeliveryTime.from_dict(obj["deliveryTime"]) if obj.get("deliveryTime") is not None else None,
            "eligibility": obj.get("eligibility"),
            "minimumOrderValue": Price.from_dict(obj["minimumOrderValue"]) if obj.get("minimumOrderValue") is not None else None,
            "minimumOrderValueTable": MinimumOrderValueTable.from_dict(obj["minimumOrderValueTable"]) if obj.get("minimumOrderValueTable") is not None else None,
            "name": obj.get("name"),
            "pickupService": PickupCarrierService.from_dict(obj["pickupService"]) if obj.get("pickupService") is not None else None,
            "rateGroups": [RateGroup.from_dict(_item) for _item in obj["rateGroups"]] if obj.get("rateGroups") is not None else None,
            "shipmentType": obj.get("shipmentType"),
            "storeConfig": ServiceStoreConfig.from_dict(obj["storeConfig"]) if obj.get("storeConfig") is not None else None
        })
        return _obj


