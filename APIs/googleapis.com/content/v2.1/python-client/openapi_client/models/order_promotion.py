# coding: utf-8

"""
    Content API for Shopping

    Manage your product listings and accounts for Google Shopping

    The version of the OpenAPI document: v2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.order_promotion_item import OrderPromotionItem
from openapi_client.models.price import Price
from typing import Optional, Set
from typing_extensions import Self

class OrderPromotion(BaseModel):
    """
    OrderPromotion
    """ # noqa: E501
    applicable_items: Optional[List[OrderPromotionItem]] = Field(default=None, description="Items that this promotion may be applied to. If empty, there are no restrictions on applicable items and quantity. This field will also be empty for shipping promotions because shipping is not tied to any specific item.", alias="applicableItems")
    applied_items: Optional[List[OrderPromotionItem]] = Field(default=None, description="Items that this promotion have been applied to. Do not provide for `orders.createtestorder`. This field will be empty for shipping promotions because shipping is not tied to any specific item.", alias="appliedItems")
    end_time: Optional[StrictStr] = Field(default=None, description="Promotion end time in ISO 8601 format. Date, time, and offset required, for example, \"2020-01-02T09:00:00+01:00\" or \"2020-01-02T09:00:00Z\".", alias="endTime")
    funder: Optional[StrictStr] = Field(default=None, description="Required. The party funding the promotion. Only `merchant` is supported for `orders.createtestorder`. Acceptable values are: - \"`google`\" - \"`merchant`\" ")
    merchant_promotion_id: Optional[StrictStr] = Field(default=None, description="Required. This field is used to identify promotions within merchants' own systems.", alias="merchantPromotionId")
    price_value: Optional[Price] = Field(default=None, alias="priceValue")
    short_title: Optional[StrictStr] = Field(default=None, description="A short title of the promotion to be shown on the checkout page. Do not provide for `orders.createtestorder`.", alias="shortTitle")
    start_time: Optional[StrictStr] = Field(default=None, description="Promotion start time in ISO 8601 format. Date, time, and offset required, for example, \"2020-01-02T09:00:00+01:00\" or \"2020-01-02T09:00:00Z\".", alias="startTime")
    subtype: Optional[StrictStr] = Field(default=None, description="Required. The category of the promotion. Only `moneyOff` is supported for `orders.createtestorder`. Acceptable values are: - \"`buyMGetMoneyOff`\" - \"`buyMGetNMoneyOff`\" - \"`buyMGetNPercentOff`\" - \"`buyMGetPercentOff`\" - \"`freeGift`\" - \"`freeGiftWithItemId`\" - \"`freeGiftWithValue`\" - \"`freeShippingOvernight`\" - \"`freeShippingStandard`\" - \"`freeShippingTwoDay`\" - \"`moneyOff`\" - \"`percentOff`\" - \"`rewardPoints`\" - \"`salePrice`\" ")
    tax_value: Optional[Price] = Field(default=None, alias="taxValue")
    title: Optional[StrictStr] = Field(default=None, description="Required. The title of the promotion.")
    type: Optional[StrictStr] = Field(default=None, description="Required. The scope of the promotion. Only `product` is supported for `orders.createtestorder`. Acceptable values are: - \"`product`\" - \"`shipping`\" ")
    __properties: ClassVar[List[str]] = ["applicableItems", "appliedItems", "endTime", "funder", "merchantPromotionId", "priceValue", "shortTitle", "startTime", "subtype", "taxValue", "title", "type"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderPromotion from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in applicable_items (list)
        _items = []
        if self.applicable_items:
            for _item_applicable_items in self.applicable_items:
                if _item_applicable_items:
                    _items.append(_item_applicable_items.to_dict())
            _dict['applicableItems'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in applied_items (list)
        _items = []
        if self.applied_items:
            for _item_applied_items in self.applied_items:
                if _item_applied_items:
                    _items.append(_item_applied_items.to_dict())
            _dict['appliedItems'] = _items
        # override the default output from pydantic by calling `to_dict()` of price_value
        if self.price_value:
            _dict['priceValue'] = self.price_value.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tax_value
        if self.tax_value:
            _dict['taxValue'] = self.tax_value.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderPromotion from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "applicableItems": [OrderPromotionItem.from_dict(_item) for _item in obj["applicableItems"]] if obj.get("applicableItems") is not None else None,
            "appliedItems": [OrderPromotionItem.from_dict(_item) for _item in obj["appliedItems"]] if obj.get("appliedItems") is not None else None,
            "endTime": obj.get("endTime"),
            "funder": obj.get("funder"),
            "merchantPromotionId": obj.get("merchantPromotionId"),
            "priceValue": Price.from_dict(obj["priceValue"]) if obj.get("priceValue") is not None else None,
            "shortTitle": obj.get("shortTitle"),
            "startTime": obj.get("startTime"),
            "subtype": obj.get("subtype"),
            "taxValue": Price.from_dict(obj["taxValue"]) if obj.get("taxValue") is not None else None,
            "title": obj.get("title"),
            "type": obj.get("type")
        })
        return _obj


