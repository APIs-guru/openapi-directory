# coding: utf-8

"""
    Notebooks API

    Notebooks API is used to manage notebook resources in Google Cloud.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class DiagnosticConfig(BaseModel):
    """
    Defines flags that are used to run the diagnostic tool
    """ # noqa: E501
    copy_home_files_flag_enabled: Optional[StrictBool] = Field(default=None, description="Optional. Enables flag to copy all `/home/jupyter` folder contents", alias="copyHomeFilesFlagEnabled")
    gcs_bucket: Optional[StrictStr] = Field(default=None, description="Required. User Cloud Storage bucket location (REQUIRED). Must be formatted with path prefix (`gs://$GCS_BUCKET`). Permissions: User Managed Notebooks: - storage.buckets.writer: Must be given to the project's service account attached to VM. Google Managed Notebooks: - storage.buckets.writer: Must be given to the project's service account or user credentials attached to VM depending on authentication mode. Cloud Storage bucket Log file will be written to `gs://$GCS_BUCKET/$RELATIVE_PATH/$VM_DATE_$TIME.tar.gz`", alias="gcsBucket")
    packet_capture_flag_enabled: Optional[StrictBool] = Field(default=None, description="Optional. Enables flag to capture packets from the instance for 30 seconds", alias="packetCaptureFlagEnabled")
    relative_path: Optional[StrictStr] = Field(default=None, description="Optional. Defines the relative storage path in the Cloud Storage bucket where the diagnostic logs will be written: Default path will be the root directory of the Cloud Storage bucket (`gs://$GCS_BUCKET/$DATE_$TIME.tar.gz`) Example of full path where Log file will be written: `gs://$GCS_BUCKET/$RELATIVE_PATH/`", alias="relativePath")
    repair_flag_enabled: Optional[StrictBool] = Field(default=None, description="Optional. Enables flag to repair service for instance", alias="repairFlagEnabled")
    __properties: ClassVar[List[str]] = ["copyHomeFilesFlagEnabled", "gcsBucket", "packetCaptureFlagEnabled", "relativePath", "repairFlagEnabled"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DiagnosticConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DiagnosticConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "copyHomeFilesFlagEnabled": obj.get("copyHomeFilesFlagEnabled"),
            "gcsBucket": obj.get("gcsBucket"),
            "packetCaptureFlagEnabled": obj.get("packetCaptureFlagEnabled"),
            "relativePath": obj.get("relativePath"),
            "repairFlagEnabled": obj.get("repairFlagEnabled")
        })
        return _obj


