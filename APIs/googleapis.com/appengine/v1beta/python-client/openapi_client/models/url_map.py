# coding: utf-8

"""
    App Engine Admin API

    Provisions and manages developers' App Engine applications.

    The version of the OpenAPI document: v1beta
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.api_endpoint_handler import ApiEndpointHandler
from openapi_client.models.script_handler import ScriptHandler
from openapi_client.models.static_files_handler import StaticFilesHandler
from typing import Optional, Set
from typing_extensions import Self

class UrlMap(BaseModel):
    """
    URL pattern and description of how the URL should be handled. App Engine can handle URLs by executing application code or by serving static files uploaded with the version, such as images, CSS, or JavaScript.
    """ # noqa: E501
    api_endpoint: Optional[ApiEndpointHandler] = Field(default=None, alias="apiEndpoint")
    auth_fail_action: Optional[StrictStr] = Field(default=None, description="Action to take when users access resources that require authentication. Defaults to redirect.", alias="authFailAction")
    login: Optional[StrictStr] = Field(default=None, description="Level of login required to access this resource. Not supported for Node.js in the App Engine standard environment.")
    redirect_http_response_code: Optional[StrictStr] = Field(default=None, description="30x code to use when performing redirects for the secure field. Defaults to 302.", alias="redirectHttpResponseCode")
    script: Optional[ScriptHandler] = None
    security_level: Optional[StrictStr] = Field(default=None, description="Security (HTTPS) enforcement for this URL.", alias="securityLevel")
    static_files: Optional[StaticFilesHandler] = Field(default=None, alias="staticFiles")
    url_regex: Optional[StrictStr] = Field(default=None, description="URL prefix. Uses regular expression syntax, which means regexp special characters must be escaped, but should not contain groupings. All URLs that begin with this prefix are handled by this handler, using the portion of the URL after the prefix as part of the file path.", alias="urlRegex")
    __properties: ClassVar[List[str]] = ["apiEndpoint", "authFailAction", "login", "redirectHttpResponseCode", "script", "securityLevel", "staticFiles", "urlRegex"]

    @field_validator('auth_fail_action')
    def auth_fail_action_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AUTH_FAIL_ACTION_UNSPECIFIED', 'AUTH_FAIL_ACTION_REDIRECT', 'AUTH_FAIL_ACTION_UNAUTHORIZED']):
            raise ValueError("must be one of enum values ('AUTH_FAIL_ACTION_UNSPECIFIED', 'AUTH_FAIL_ACTION_REDIRECT', 'AUTH_FAIL_ACTION_UNAUTHORIZED')")
        return value

    @field_validator('login')
    def login_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['LOGIN_UNSPECIFIED', 'LOGIN_OPTIONAL', 'LOGIN_ADMIN', 'LOGIN_REQUIRED']):
            raise ValueError("must be one of enum values ('LOGIN_UNSPECIFIED', 'LOGIN_OPTIONAL', 'LOGIN_ADMIN', 'LOGIN_REQUIRED')")
        return value

    @field_validator('redirect_http_response_code')
    def redirect_http_response_code_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED', 'REDIRECT_HTTP_RESPONSE_CODE_301', 'REDIRECT_HTTP_RESPONSE_CODE_302', 'REDIRECT_HTTP_RESPONSE_CODE_303', 'REDIRECT_HTTP_RESPONSE_CODE_307']):
            raise ValueError("must be one of enum values ('REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED', 'REDIRECT_HTTP_RESPONSE_CODE_301', 'REDIRECT_HTTP_RESPONSE_CODE_302', 'REDIRECT_HTTP_RESPONSE_CODE_303', 'REDIRECT_HTTP_RESPONSE_CODE_307')")
        return value

    @field_validator('security_level')
    def security_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SECURE_UNSPECIFIED', 'SECURE_DEFAULT', 'SECURE_NEVER', 'SECURE_OPTIONAL', 'SECURE_ALWAYS']):
            raise ValueError("must be one of enum values ('SECURE_UNSPECIFIED', 'SECURE_DEFAULT', 'SECURE_NEVER', 'SECURE_OPTIONAL', 'SECURE_ALWAYS')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UrlMap from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of api_endpoint
        if self.api_endpoint:
            _dict['apiEndpoint'] = self.api_endpoint.to_dict()
        # override the default output from pydantic by calling `to_dict()` of script
        if self.script:
            _dict['script'] = self.script.to_dict()
        # override the default output from pydantic by calling `to_dict()` of static_files
        if self.static_files:
            _dict['staticFiles'] = self.static_files.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UrlMap from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "apiEndpoint": ApiEndpointHandler.from_dict(obj["apiEndpoint"]) if obj.get("apiEndpoint") is not None else None,
            "authFailAction": obj.get("authFailAction"),
            "login": obj.get("login"),
            "redirectHttpResponseCode": obj.get("redirectHttpResponseCode"),
            "script": ScriptHandler.from_dict(obj["script"]) if obj.get("script") is not None else None,
            "securityLevel": obj.get("securityLevel"),
            "staticFiles": StaticFilesHandler.from_dict(obj["staticFiles"]) if obj.get("staticFiles") is not None else None,
            "urlRegex": obj.get("urlRegex")
        })
        return _obj


