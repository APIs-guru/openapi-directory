# coding: utf-8

"""
    App Engine Admin API

    Provisions and manages developers' App Engine applications.

    The version of the OpenAPI document: v1beta
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.api_config_handler import ApiConfigHandler
from openapi_client.models.automatic_scaling import AutomaticScaling
from openapi_client.models.basic_scaling import BasicScaling
from openapi_client.models.deployment import Deployment
from openapi_client.models.endpoints_api_service import EndpointsApiService
from openapi_client.models.entrypoint import Entrypoint
from openapi_client.models.error_handler import ErrorHandler
from openapi_client.models.flexible_runtime_settings import FlexibleRuntimeSettings
from openapi_client.models.health_check import HealthCheck
from openapi_client.models.library import Library
from openapi_client.models.liveness_check import LivenessCheck
from openapi_client.models.manual_scaling import ManualScaling
from openapi_client.models.network import Network
from openapi_client.models.readiness_check import ReadinessCheck
from openapi_client.models.resources import Resources
from openapi_client.models.url_map import UrlMap
from openapi_client.models.vpc_access_connector import VpcAccessConnector
from typing import Optional, Set
from typing_extensions import Self

class Version(BaseModel):
    """
    A Version resource is a specific set of source code and configuration files that are deployed into a service.
    """ # noqa: E501
    api_config: Optional[ApiConfigHandler] = Field(default=None, alias="apiConfig")
    app_engine_apis: Optional[StrictBool] = Field(default=None, description="Allows App Engine second generation runtimes to access the legacy bundled services.", alias="appEngineApis")
    automatic_scaling: Optional[AutomaticScaling] = Field(default=None, alias="automaticScaling")
    basic_scaling: Optional[BasicScaling] = Field(default=None, alias="basicScaling")
    beta_settings: Optional[Dict[str, StrictStr]] = Field(default=None, description="Metadata settings that are supplied to this version to enable beta runtime features.", alias="betaSettings")
    build_env_variables: Optional[Dict[str, StrictStr]] = Field(default=None, description="Environment variables available to the build environment.Only returned in GET requests if view=FULL is set.", alias="buildEnvVariables")
    create_time: Optional[StrictStr] = Field(default=None, description="Time that this version was created.@OutputOnly", alias="createTime")
    created_by: Optional[StrictStr] = Field(default=None, description="Email address of the user who created this version.@OutputOnly", alias="createdBy")
    default_expiration: Optional[StrictStr] = Field(default=None, description="Duration that static files should be cached by web proxies and browsers. Only applicable if the corresponding StaticFilesHandler (https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StaticFilesHandler) does not specify its own expiration time.Only returned in GET requests if view=FULL is set.", alias="defaultExpiration")
    deployment: Optional[Deployment] = None
    disk_usage_bytes: Optional[StrictStr] = Field(default=None, description="Total size in bytes of all the files that are included in this version and currently hosted on the App Engine disk.@OutputOnly", alias="diskUsageBytes")
    endpoints_api_service: Optional[EndpointsApiService] = Field(default=None, alias="endpointsApiService")
    entrypoint: Optional[Entrypoint] = None
    env: Optional[StrictStr] = Field(default=None, description="App Engine execution environment for this version.Defaults to standard.")
    env_variables: Optional[Dict[str, StrictStr]] = Field(default=None, description="Environment variables available to the application.Only returned in GET requests if view=FULL is set.", alias="envVariables")
    error_handlers: Optional[List[ErrorHandler]] = Field(default=None, description="Custom static error pages. Limited to 10KB per page.Only returned in GET requests if view=FULL is set.", alias="errorHandlers")
    flexible_runtime_settings: Optional[FlexibleRuntimeSettings] = Field(default=None, alias="flexibleRuntimeSettings")
    generated_customer_metadata: Optional[Dict[str, Any]] = Field(default=None, description="Additional Google Generated Customer Metadata, this field won't be provided by default and can be requested by setting the IncludeExtraData field in GetVersionRequest", alias="generatedCustomerMetadata")
    handlers: Optional[List[UrlMap]] = Field(default=None, description="An ordered list of URL-matching patterns that should be applied to incoming requests. The first matching URL handles the request and other request handlers are not attempted.Only returned in GET requests if view=FULL is set.")
    health_check: Optional[HealthCheck] = Field(default=None, alias="healthCheck")
    id: Optional[StrictStr] = Field(default=None, description="Relative name of the version within the service. Example: v1. Version names can contain only lowercase letters, numbers, or hyphens. Reserved names: \"default\", \"latest\", and any name with the prefix \"ah-\".")
    inbound_services: Optional[List[StrictStr]] = Field(default=None, description="Before an application can receive email or XMPP messages, the application must be configured to enable the service.", alias="inboundServices")
    instance_class: Optional[StrictStr] = Field(default=None, description="Instance class that is used to run this version. Valid values are: AutomaticScaling: F1, F2, F4, F4_1G ManualScaling or BasicScaling: B1, B2, B4, B8, B4_1GDefaults to F1 for AutomaticScaling and B1 for ManualScaling or BasicScaling.", alias="instanceClass")
    libraries: Optional[List[Library]] = Field(default=None, description="Configuration for third-party Python runtime libraries that are required by the application.Only returned in GET requests if view=FULL is set.")
    liveness_check: Optional[LivenessCheck] = Field(default=None, alias="livenessCheck")
    manual_scaling: Optional[ManualScaling] = Field(default=None, alias="manualScaling")
    name: Optional[StrictStr] = Field(default=None, description="Full path to the Version resource in the API. Example: apps/myapp/services/default/versions/v1.@OutputOnly")
    network: Optional[Network] = None
    nobuild_files_regex: Optional[StrictStr] = Field(default=None, description="Files that match this pattern will not be built into this version. Only applicable for Go runtimes.Only returned in GET requests if view=FULL is set.", alias="nobuildFilesRegex")
    readiness_check: Optional[ReadinessCheck] = Field(default=None, alias="readinessCheck")
    resources: Optional[Resources] = None
    runtime: Optional[StrictStr] = Field(default=None, description="Desired runtime. Example: python27.")
    runtime_api_version: Optional[StrictStr] = Field(default=None, description="The version of the API in the given runtime environment. Please see the app.yaml reference for valid values at https://cloud.google.com/appengine/docs/standard//config/appref", alias="runtimeApiVersion")
    runtime_channel: Optional[StrictStr] = Field(default=None, description="The channel of the runtime to use. Only available for some runtimes. Defaults to the default channel.", alias="runtimeChannel")
    runtime_main_executable_path: Optional[StrictStr] = Field(default=None, description="The path or name of the app's main executable.", alias="runtimeMainExecutablePath")
    service_account: Optional[StrictStr] = Field(default=None, description="The identity that the deployed version will run as. Admin API will use the App Engine Appspot service account as default if this field is neither provided in app.yaml file nor through CLI flag.", alias="serviceAccount")
    serving_status: Optional[StrictStr] = Field(default=None, description="Current serving status of this version. Only the versions with a SERVING status create instances and can be billed.SERVING_STATUS_UNSPECIFIED is an invalid value. Defaults to SERVING.", alias="servingStatus")
    threadsafe: Optional[StrictBool] = Field(default=None, description="Whether multiple requests can be dispatched to this version at once.")
    version_url: Optional[StrictStr] = Field(default=None, description="Serving URL for this version. Example: \"https://myversion-dot-myservice-dot-myapp.appspot.com\"@OutputOnly", alias="versionUrl")
    vm: Optional[StrictBool] = Field(default=None, description="Whether to deploy this version in a container on a virtual machine.")
    vpc_access_connector: Optional[VpcAccessConnector] = Field(default=None, alias="vpcAccessConnector")
    zones: Optional[List[StrictStr]] = Field(default=None, description="The Google Compute Engine zones that are supported by this version in the App Engine flexible environment. Deprecated.")
    __properties: ClassVar[List[str]] = ["apiConfig", "appEngineApis", "automaticScaling", "basicScaling", "betaSettings", "buildEnvVariables", "createTime", "createdBy", "defaultExpiration", "deployment", "diskUsageBytes", "endpointsApiService", "entrypoint", "env", "envVariables", "errorHandlers", "flexibleRuntimeSettings", "generatedCustomerMetadata", "handlers", "healthCheck", "id", "inboundServices", "instanceClass", "libraries", "livenessCheck", "manualScaling", "name", "network", "nobuildFilesRegex", "readinessCheck", "resources", "runtime", "runtimeApiVersion", "runtimeChannel", "runtimeMainExecutablePath", "serviceAccount", "servingStatus", "threadsafe", "versionUrl", "vm", "vpcAccessConnector", "zones"]

    @field_validator('inbound_services')
    def inbound_services_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['INBOUND_SERVICE_UNSPECIFIED', 'INBOUND_SERVICE_MAIL', 'INBOUND_SERVICE_MAIL_BOUNCE', 'INBOUND_SERVICE_XMPP_ERROR', 'INBOUND_SERVICE_XMPP_MESSAGE', 'INBOUND_SERVICE_XMPP_SUBSCRIBE', 'INBOUND_SERVICE_XMPP_PRESENCE', 'INBOUND_SERVICE_CHANNEL_PRESENCE', 'INBOUND_SERVICE_WARMUP']):
                raise ValueError("each list item must be one of ('INBOUND_SERVICE_UNSPECIFIED', 'INBOUND_SERVICE_MAIL', 'INBOUND_SERVICE_MAIL_BOUNCE', 'INBOUND_SERVICE_XMPP_ERROR', 'INBOUND_SERVICE_XMPP_MESSAGE', 'INBOUND_SERVICE_XMPP_SUBSCRIBE', 'INBOUND_SERVICE_XMPP_PRESENCE', 'INBOUND_SERVICE_CHANNEL_PRESENCE', 'INBOUND_SERVICE_WARMUP')")
        return value

    @field_validator('serving_status')
    def serving_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SERVING_STATUS_UNSPECIFIED', 'SERVING', 'STOPPED']):
            raise ValueError("must be one of enum values ('SERVING_STATUS_UNSPECIFIED', 'SERVING', 'STOPPED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Version from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of api_config
        if self.api_config:
            _dict['apiConfig'] = self.api_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of automatic_scaling
        if self.automatic_scaling:
            _dict['automaticScaling'] = self.automatic_scaling.to_dict()
        # override the default output from pydantic by calling `to_dict()` of basic_scaling
        if self.basic_scaling:
            _dict['basicScaling'] = self.basic_scaling.to_dict()
        # override the default output from pydantic by calling `to_dict()` of deployment
        if self.deployment:
            _dict['deployment'] = self.deployment.to_dict()
        # override the default output from pydantic by calling `to_dict()` of endpoints_api_service
        if self.endpoints_api_service:
            _dict['endpointsApiService'] = self.endpoints_api_service.to_dict()
        # override the default output from pydantic by calling `to_dict()` of entrypoint
        if self.entrypoint:
            _dict['entrypoint'] = self.entrypoint.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in error_handlers (list)
        _items = []
        if self.error_handlers:
            for _item_error_handlers in self.error_handlers:
                if _item_error_handlers:
                    _items.append(_item_error_handlers.to_dict())
            _dict['errorHandlers'] = _items
        # override the default output from pydantic by calling `to_dict()` of flexible_runtime_settings
        if self.flexible_runtime_settings:
            _dict['flexibleRuntimeSettings'] = self.flexible_runtime_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in handlers (list)
        _items = []
        if self.handlers:
            for _item_handlers in self.handlers:
                if _item_handlers:
                    _items.append(_item_handlers.to_dict())
            _dict['handlers'] = _items
        # override the default output from pydantic by calling `to_dict()` of health_check
        if self.health_check:
            _dict['healthCheck'] = self.health_check.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in libraries (list)
        _items = []
        if self.libraries:
            for _item_libraries in self.libraries:
                if _item_libraries:
                    _items.append(_item_libraries.to_dict())
            _dict['libraries'] = _items
        # override the default output from pydantic by calling `to_dict()` of liveness_check
        if self.liveness_check:
            _dict['livenessCheck'] = self.liveness_check.to_dict()
        # override the default output from pydantic by calling `to_dict()` of manual_scaling
        if self.manual_scaling:
            _dict['manualScaling'] = self.manual_scaling.to_dict()
        # override the default output from pydantic by calling `to_dict()` of network
        if self.network:
            _dict['network'] = self.network.to_dict()
        # override the default output from pydantic by calling `to_dict()` of readiness_check
        if self.readiness_check:
            _dict['readinessCheck'] = self.readiness_check.to_dict()
        # override the default output from pydantic by calling `to_dict()` of resources
        if self.resources:
            _dict['resources'] = self.resources.to_dict()
        # override the default output from pydantic by calling `to_dict()` of vpc_access_connector
        if self.vpc_access_connector:
            _dict['vpcAccessConnector'] = self.vpc_access_connector.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Version from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "apiConfig": ApiConfigHandler.from_dict(obj["apiConfig"]) if obj.get("apiConfig") is not None else None,
            "appEngineApis": obj.get("appEngineApis"),
            "automaticScaling": AutomaticScaling.from_dict(obj["automaticScaling"]) if obj.get("automaticScaling") is not None else None,
            "basicScaling": BasicScaling.from_dict(obj["basicScaling"]) if obj.get("basicScaling") is not None else None,
            "betaSettings": obj.get("betaSettings"),
            "buildEnvVariables": obj.get("buildEnvVariables"),
            "createTime": obj.get("createTime"),
            "createdBy": obj.get("createdBy"),
            "defaultExpiration": obj.get("defaultExpiration"),
            "deployment": Deployment.from_dict(obj["deployment"]) if obj.get("deployment") is not None else None,
            "diskUsageBytes": obj.get("diskUsageBytes"),
            "endpointsApiService": EndpointsApiService.from_dict(obj["endpointsApiService"]) if obj.get("endpointsApiService") is not None else None,
            "entrypoint": Entrypoint.from_dict(obj["entrypoint"]) if obj.get("entrypoint") is not None else None,
            "env": obj.get("env"),
            "envVariables": obj.get("envVariables"),
            "errorHandlers": [ErrorHandler.from_dict(_item) for _item in obj["errorHandlers"]] if obj.get("errorHandlers") is not None else None,
            "flexibleRuntimeSettings": FlexibleRuntimeSettings.from_dict(obj["flexibleRuntimeSettings"]) if obj.get("flexibleRuntimeSettings") is not None else None,
            "generatedCustomerMetadata": obj.get("generatedCustomerMetadata"),
            "handlers": [UrlMap.from_dict(_item) for _item in obj["handlers"]] if obj.get("handlers") is not None else None,
            "healthCheck": HealthCheck.from_dict(obj["healthCheck"]) if obj.get("healthCheck") is not None else None,
            "id": obj.get("id"),
            "inboundServices": obj.get("inboundServices"),
            "instanceClass": obj.get("instanceClass"),
            "libraries": [Library.from_dict(_item) for _item in obj["libraries"]] if obj.get("libraries") is not None else None,
            "livenessCheck": LivenessCheck.from_dict(obj["livenessCheck"]) if obj.get("livenessCheck") is not None else None,
            "manualScaling": ManualScaling.from_dict(obj["manualScaling"]) if obj.get("manualScaling") is not None else None,
            "name": obj.get("name"),
            "network": Network.from_dict(obj["network"]) if obj.get("network") is not None else None,
            "nobuildFilesRegex": obj.get("nobuildFilesRegex"),
            "readinessCheck": ReadinessCheck.from_dict(obj["readinessCheck"]) if obj.get("readinessCheck") is not None else None,
            "resources": Resources.from_dict(obj["resources"]) if obj.get("resources") is not None else None,
            "runtime": obj.get("runtime"),
            "runtimeApiVersion": obj.get("runtimeApiVersion"),
            "runtimeChannel": obj.get("runtimeChannel"),
            "runtimeMainExecutablePath": obj.get("runtimeMainExecutablePath"),
            "serviceAccount": obj.get("serviceAccount"),
            "servingStatus": obj.get("servingStatus"),
            "threadsafe": obj.get("threadsafe"),
            "versionUrl": obj.get("versionUrl"),
            "vm": obj.get("vm"),
            "vpcAccessConnector": VpcAccessConnector.from_dict(obj["vpcAccessConnector"]) if obj.get("vpcAccessConnector") is not None else None,
            "zones": obj.get("zones")
        })
        return _obj


