# coding: utf-8

"""
    Service Usage API

    Enables services that service consumers want to use on Google Cloud Platform, lists the available or enabled services, or disables services that service consumers no longer use.

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.logging_destination import LoggingDestination
from typing import Optional, Set
from typing_extensions import Self

class Logging(BaseModel):
    """
    Logging configuration of the service. The following example shows how to configure logs to be sent to the producer and consumer projects. In the example, the `activity_history` log is sent to both the producer and consumer projects, whereas the `purchase_history` log is only sent to the producer project. monitored_resources: - type: library.googleapis.com/branch labels: - key: /city description: The city where the library branch is located in. - key: /name description: The name of the branch. logs: - name: activity_history labels: - key: /customer_id - name: purchase_history logging: producer_destinations: - monitored_resource: library.googleapis.com/branch logs: - activity_history - purchase_history consumer_destinations: - monitored_resource: library.googleapis.com/branch logs: - activity_history
    """ # noqa: E501
    consumer_destinations: Optional[List[LoggingDestination]] = Field(default=None, description="Logging configurations for sending logs to the consumer project. There can be multiple consumer destinations, each one must have a different monitored resource type. A log can be used in at most one consumer destination.", alias="consumerDestinations")
    producer_destinations: Optional[List[LoggingDestination]] = Field(default=None, description="Logging configurations for sending logs to the producer project. There can be multiple producer destinations, each one must have a different monitored resource type. A log can be used in at most one producer destination.", alias="producerDestinations")
    __properties: ClassVar[List[str]] = ["consumerDestinations", "producerDestinations"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Logging from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in consumer_destinations (list)
        _items = []
        if self.consumer_destinations:
            for _item_consumer_destinations in self.consumer_destinations:
                if _item_consumer_destinations:
                    _items.append(_item_consumer_destinations.to_dict())
            _dict['consumerDestinations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in producer_destinations (list)
        _items = []
        if self.producer_destinations:
            for _item_producer_destinations in self.producer_destinations:
                if _item_producer_destinations:
                    _items.append(_item_producer_destinations.to_dict())
            _dict['producerDestinations'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Logging from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "consumerDestinations": [LoggingDestination.from_dict(_item) for _item in obj["consumerDestinations"]] if obj.get("consumerDestinations") is not None else None,
            "producerDestinations": [LoggingDestination.from_dict(_item) for _item in obj["producerDestinations"]] if obj.get("producerDestinations") is not None else None
        })
        return _obj


