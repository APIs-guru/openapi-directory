# coding: utf-8

"""
    Service Usage API

    Enables services that service consumers want to use on Google Cloud Platform, lists the available or enabled services, or disables services that service consumers no longer use.

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class BackendRule(BaseModel):
    """
    A backend rule provides configuration for an individual API element.
    """ # noqa: E501
    address: Optional[StrictStr] = Field(default=None, description="The address of the API backend. The scheme is used to determine the backend protocol and security. The following schemes are accepted: SCHEME PROTOCOL SECURITY http:// HTTP None https:// HTTP TLS grpc:// gRPC None grpcs:// gRPC TLS It is recommended to explicitly include a scheme. Leaving out the scheme may cause constrasting behaviors across platforms. If the port is unspecified, the default is: - 80 for schemes without TLS - 443 for schemes with TLS For HTTP backends, use protocol to specify the protocol version.")
    deadline: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The number of seconds to wait for a response from a request. The default varies based on the request protocol and deployment environment.")
    disable_auth: Optional[StrictBool] = Field(default=None, description="When disable_auth is true, a JWT ID token won't be generated and the original \"Authorization\" HTTP header will be preserved. If the header is used to carry the original token and is expected by the backend, this field must be set to true to preserve the header.", alias="disableAuth")
    jwt_audience: Optional[StrictStr] = Field(default=None, description="The JWT audience is used when generating a JWT ID token for the backend. This ID token will be added in the HTTP \"authorization\" header, and sent to the backend.", alias="jwtAudience")
    min_deadline: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Deprecated, do not use.", alias="minDeadline")
    operation_deadline: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The number of seconds to wait for the completion of a long running operation. The default is no deadline.", alias="operationDeadline")
    overrides_by_request_protocol: Optional[Dict[str, BackendRule]] = Field(default=None, description="The map between request protocol and the backend address.", alias="overridesByRequestProtocol")
    path_translation: Optional[StrictStr] = Field(default=None, alias="pathTranslation")
    protocol: Optional[StrictStr] = Field(default=None, description="The protocol used for sending a request to the backend. The supported values are \"http/1.1\" and \"h2\". The default value is inferred from the scheme in the address field: SCHEME PROTOCOL http:// http/1.1 https:// http/1.1 grpc:// h2 grpcs:// h2 For secure HTTP backends (https://) that support HTTP/2, set this field to \"h2\" for improved performance. Configuring this field to non-default values is only supported for secure HTTP backends. This field will be ignored for all other backends. See https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids for more details on the supported values.")
    selector: Optional[StrictStr] = Field(default=None, description="Selects the methods to which this rule applies. Refer to selector for syntax details.")
    __properties: ClassVar[List[str]] = ["address", "deadline", "disableAuth", "jwtAudience", "minDeadline", "operationDeadline", "overridesByRequestProtocol", "pathTranslation", "protocol", "selector"]

    @field_validator('path_translation')
    def path_translation_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PATH_TRANSLATION_UNSPECIFIED', 'CONSTANT_ADDRESS', 'APPEND_PATH_TO_ADDRESS']):
            raise ValueError("must be one of enum values ('PATH_TRANSLATION_UNSPECIFIED', 'CONSTANT_ADDRESS', 'APPEND_PATH_TO_ADDRESS')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of BackendRule from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in overrides_by_request_protocol (dict)
        _field_dict = {}
        if self.overrides_by_request_protocol:
            for _key_overrides_by_request_protocol in self.overrides_by_request_protocol:
                if self.overrides_by_request_protocol[_key_overrides_by_request_protocol]:
                    _field_dict[_key_overrides_by_request_protocol] = self.overrides_by_request_protocol[_key_overrides_by_request_protocol].to_dict()
            _dict['overridesByRequestProtocol'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of BackendRule from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "address": obj.get("address"),
            "deadline": obj.get("deadline"),
            "disableAuth": obj.get("disableAuth"),
            "jwtAudience": obj.get("jwtAudience"),
            "minDeadline": obj.get("minDeadline"),
            "operationDeadline": obj.get("operationDeadline"),
            "overridesByRequestProtocol": dict(
                (_k, BackendRule.from_dict(_v))
                for _k, _v in obj["overridesByRequestProtocol"].items()
            )
            if obj.get("overridesByRequestProtocol") is not None
            else None,
            "pathTranslation": obj.get("pathTranslation"),
            "protocol": obj.get("protocol"),
            "selector": obj.get("selector")
        })
        return _obj

# TODO: Rewrite to not use raise_errors
BackendRule.model_rebuild(raise_errors=False)

