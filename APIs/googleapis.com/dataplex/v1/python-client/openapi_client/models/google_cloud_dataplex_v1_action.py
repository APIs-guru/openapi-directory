# coding: utf-8

"""
    Cloud Dataplex API

    Dataplex API is used to manage the lifecycle of data lakes.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_dataplex_v1_action_failed_security_policy_apply import GoogleCloudDataplexV1ActionFailedSecurityPolicyApply
from openapi_client.models.google_cloud_dataplex_v1_action_incompatible_data_schema import GoogleCloudDataplexV1ActionIncompatibleDataSchema
from openapi_client.models.google_cloud_dataplex_v1_action_invalid_data_format import GoogleCloudDataplexV1ActionInvalidDataFormat
from openapi_client.models.google_cloud_dataplex_v1_action_invalid_data_partition import GoogleCloudDataplexV1ActionInvalidDataPartition
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudDataplexV1Action(BaseModel):
    """
    Action represents an issue requiring administrator action for resolution.
    """ # noqa: E501
    asset: Optional[StrictStr] = Field(default=None, description="Output only. The relative resource name of the asset, of the form: projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}.")
    category: Optional[StrictStr] = Field(default=None, description="The category of issue associated with the action.")
    data_locations: Optional[List[StrictStr]] = Field(default=None, description="The list of data locations associated with this action. Cloud Storage locations are represented as URI paths(E.g. gs://bucket/table1/year=2020/month=Jan/). BigQuery locations refer to resource names(E.g. bigquery.googleapis.com/projects/project-id/datasets/dataset-id).", alias="dataLocations")
    detect_time: Optional[StrictStr] = Field(default=None, description="The time that the issue was detected.", alias="detectTime")
    failed_security_policy_apply: Optional[GoogleCloudDataplexV1ActionFailedSecurityPolicyApply] = Field(default=None, alias="failedSecurityPolicyApply")
    incompatible_data_schema: Optional[GoogleCloudDataplexV1ActionIncompatibleDataSchema] = Field(default=None, alias="incompatibleDataSchema")
    invalid_data_format: Optional[GoogleCloudDataplexV1ActionInvalidDataFormat] = Field(default=None, alias="invalidDataFormat")
    invalid_data_organization: Optional[Dict[str, Any]] = Field(default=None, description="Action details for invalid data arrangement.", alias="invalidDataOrganization")
    invalid_data_partition: Optional[GoogleCloudDataplexV1ActionInvalidDataPartition] = Field(default=None, alias="invalidDataPartition")
    issue: Optional[StrictStr] = Field(default=None, description="Detailed description of the issue requiring action.")
    lake: Optional[StrictStr] = Field(default=None, description="Output only. The relative resource name of the lake, of the form: projects/{project_number}/locations/{location_id}/lakes/{lake_id}.")
    missing_data: Optional[Dict[str, Any]] = Field(default=None, description="Action details for absence of data detected by discovery.", alias="missingData")
    missing_resource: Optional[Dict[str, Any]] = Field(default=None, description="Action details for resource references in assets that cannot be located.", alias="missingResource")
    name: Optional[StrictStr] = Field(default=None, description="Output only. The relative resource name of the action, of the form: projects/{project}/locations/{location}/lakes/{lake}/actions/{action} projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/actions/{action} projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/assets/{asset}/actions/{action}.")
    unauthorized_resource: Optional[Dict[str, Any]] = Field(default=None, description="Action details for unauthorized resource issues raised to indicate that the service account associated with the lake instance is not authorized to access or manage the resource associated with an asset.", alias="unauthorizedResource")
    zone: Optional[StrictStr] = Field(default=None, description="Output only. The relative resource name of the zone, of the form: projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}.")
    __properties: ClassVar[List[str]] = ["asset", "category", "dataLocations", "detectTime", "failedSecurityPolicyApply", "incompatibleDataSchema", "invalidDataFormat", "invalidDataOrganization", "invalidDataPartition", "issue", "lake", "missingData", "missingResource", "name", "unauthorizedResource", "zone"]

    @field_validator('category')
    def category_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CATEGORY_UNSPECIFIED', 'RESOURCE_MANAGEMENT', 'SECURITY_POLICY', 'DATA_DISCOVERY']):
            raise ValueError("must be one of enum values ('CATEGORY_UNSPECIFIED', 'RESOURCE_MANAGEMENT', 'SECURITY_POLICY', 'DATA_DISCOVERY')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudDataplexV1Action from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "asset",
            "lake",
            "name",
            "zone",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of failed_security_policy_apply
        if self.failed_security_policy_apply:
            _dict['failedSecurityPolicyApply'] = self.failed_security_policy_apply.to_dict()
        # override the default output from pydantic by calling `to_dict()` of incompatible_data_schema
        if self.incompatible_data_schema:
            _dict['incompatibleDataSchema'] = self.incompatible_data_schema.to_dict()
        # override the default output from pydantic by calling `to_dict()` of invalid_data_format
        if self.invalid_data_format:
            _dict['invalidDataFormat'] = self.invalid_data_format.to_dict()
        # override the default output from pydantic by calling `to_dict()` of invalid_data_partition
        if self.invalid_data_partition:
            _dict['invalidDataPartition'] = self.invalid_data_partition.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudDataplexV1Action from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "asset": obj.get("asset"),
            "category": obj.get("category"),
            "dataLocations": obj.get("dataLocations"),
            "detectTime": obj.get("detectTime"),
            "failedSecurityPolicyApply": GoogleCloudDataplexV1ActionFailedSecurityPolicyApply.from_dict(obj["failedSecurityPolicyApply"]) if obj.get("failedSecurityPolicyApply") is not None else None,
            "incompatibleDataSchema": GoogleCloudDataplexV1ActionIncompatibleDataSchema.from_dict(obj["incompatibleDataSchema"]) if obj.get("incompatibleDataSchema") is not None else None,
            "invalidDataFormat": GoogleCloudDataplexV1ActionInvalidDataFormat.from_dict(obj["invalidDataFormat"]) if obj.get("invalidDataFormat") is not None else None,
            "invalidDataOrganization": obj.get("invalidDataOrganization"),
            "invalidDataPartition": GoogleCloudDataplexV1ActionInvalidDataPartition.from_dict(obj["invalidDataPartition"]) if obj.get("invalidDataPartition") is not None else None,
            "issue": obj.get("issue"),
            "lake": obj.get("lake"),
            "missingData": obj.get("missingData"),
            "missingResource": obj.get("missingResource"),
            "name": obj.get("name"),
            "unauthorizedResource": obj.get("unauthorizedResource"),
            "zone": obj.get("zone")
        })
        return _obj


