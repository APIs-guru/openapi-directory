# coding: utf-8

"""
    Vertex AI API

    Train high-quality custom machine learning models with minimal machine learning expertise and effort.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_aiplatform_v1_explanation_metadata_input_metadata import GoogleCloudAiplatformV1ExplanationMetadataInputMetadata
from openapi_client.models.google_cloud_aiplatform_v1_explanation_metadata_output_metadata import GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudAiplatformV1ExplanationMetadata(BaseModel):
    """
    Metadata describing the Model's input and output for explanation.
    """ # noqa: E501
    feature_attributions_schema_uri: Optional[StrictStr] = Field(default=None, description="Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.", alias="featureAttributionsSchemaUri")
    inputs: Optional[Dict[str, GoogleCloudAiplatformV1ExplanationMetadataInputMetadata]] = Field(default=None, description="Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.")
    latent_space_source: Optional[StrictStr] = Field(default=None, description="Name of the source to generate embeddings for example based explanations.", alias="latentSpaceSource")
    outputs: Optional[Dict[str, GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata]] = Field(default=None, description="Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.")
    __properties: ClassVar[List[str]] = ["featureAttributionsSchemaUri", "inputs", "latentSpaceSource", "outputs"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudAiplatformV1ExplanationMetadata from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in inputs (dict)
        _field_dict = {}
        if self.inputs:
            for _key_inputs in self.inputs:
                if self.inputs[_key_inputs]:
                    _field_dict[_key_inputs] = self.inputs[_key_inputs].to_dict()
            _dict['inputs'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in outputs (dict)
        _field_dict = {}
        if self.outputs:
            for _key_outputs in self.outputs:
                if self.outputs[_key_outputs]:
                    _field_dict[_key_outputs] = self.outputs[_key_outputs].to_dict()
            _dict['outputs'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudAiplatformV1ExplanationMetadata from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "featureAttributionsSchemaUri": obj.get("featureAttributionsSchemaUri"),
            "inputs": dict(
                (_k, GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.from_dict(_v))
                for _k, _v in obj["inputs"].items()
            )
            if obj.get("inputs") is not None
            else None,
            "latentSpaceSource": obj.get("latentSpaceSource"),
            "outputs": dict(
                (_k, GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata.from_dict(_v))
                for _k, _v in obj["outputs"].items()
            )
            if obj.get("outputs") is not None
            else None
        })
        return _obj


