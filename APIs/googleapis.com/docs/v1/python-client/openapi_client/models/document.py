# coding: utf-8

"""
    Google Docs API

    Reads and writes Google Docs documents.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.body import Body
from openapi_client.models.document_style import DocumentStyle
from openapi_client.models.footer import Footer
from openapi_client.models.footnote import Footnote
from openapi_client.models.header import Header
from openapi_client.models.inline_object import InlineObject
from openapi_client.models.list import List
from openapi_client.models.named_ranges import NamedRanges
from openapi_client.models.named_styles import NamedStyles
from openapi_client.models.positioned_object import PositionedObject
from openapi_client.models.suggested_document_style import SuggestedDocumentStyle
from openapi_client.models.suggested_named_styles import SuggestedNamedStyles
from typing import Optional, Set
from typing_extensions import Self

class Document(BaseModel):
    """
    A Google Docs document.
    """ # noqa: E501
    body: Optional[Body] = None
    document_id: Optional[StrictStr] = Field(default=None, description="Output only. The ID of the document.", alias="documentId")
    document_style: Optional[DocumentStyle] = Field(default=None, alias="documentStyle")
    footers: Optional[Dict[str, Footer]] = Field(default=None, description="Output only. The footers in the document, keyed by footer ID.")
    footnotes: Optional[Dict[str, Footnote]] = Field(default=None, description="Output only. The footnotes in the document, keyed by footnote ID.")
    headers: Optional[Dict[str, Header]] = Field(default=None, description="Output only. The headers in the document, keyed by header ID.")
    inline_objects: Optional[Dict[str, InlineObject]] = Field(default=None, description="Output only. The inline objects in the document, keyed by object ID.", alias="inlineObjects")
    lists: Optional[Dict[str, List]] = Field(default=None, description="Output only. The lists in the document, keyed by list ID.")
    named_ranges: Optional[Dict[str, NamedRanges]] = Field(default=None, description="Output only. The named ranges in the document, keyed by name.", alias="namedRanges")
    named_styles: Optional[NamedStyles] = Field(default=None, alias="namedStyles")
    positioned_objects: Optional[Dict[str, PositionedObject]] = Field(default=None, description="Output only. The positioned objects in the document, keyed by object ID.", alias="positionedObjects")
    revision_id: Optional[StrictStr] = Field(default=None, description="Output only. The revision ID of the document. Can be used in update requests to specify which revision of a document to apply updates to and how the request should behave if the document has been edited since that revision. Only populated if the user has edit access to the document. The revision ID is not a sequential number but an opaque string. The format of the revision ID might change over time. A returned revision ID is only guaranteed to be valid for 24 hours after it has been returned and cannot be shared across users. If the revision ID is unchanged between calls, then the document has not changed. Conversely, a changed ID (for the same document and user) usually means the document has been updated. However, a changed ID can also be due to internal factors such as ID format changes.", alias="revisionId")
    suggested_document_style_changes: Optional[Dict[str, SuggestedDocumentStyle]] = Field(default=None, description="Output only. The suggested changes to the style of the document, keyed by suggestion ID.", alias="suggestedDocumentStyleChanges")
    suggested_named_styles_changes: Optional[Dict[str, SuggestedNamedStyles]] = Field(default=None, description="Output only. The suggested changes to the named styles of the document, keyed by suggestion ID.", alias="suggestedNamedStylesChanges")
    suggestions_view_mode: Optional[StrictStr] = Field(default=None, description="Output only. The suggestions view mode applied to the document. Note: When editing a document, changes must be based on a document with SUGGESTIONS_INLINE.", alias="suggestionsViewMode")
    title: Optional[StrictStr] = Field(default=None, description="The title of the document.")
    __properties: ClassVar[List[str]] = ["body", "documentId", "documentStyle", "footers", "footnotes", "headers", "inlineObjects", "lists", "namedRanges", "namedStyles", "positionedObjects", "revisionId", "suggestedDocumentStyleChanges", "suggestedNamedStylesChanges", "suggestionsViewMode", "title"]

    @field_validator('suggestions_view_mode')
    def suggestions_view_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DEFAULT_FOR_CURRENT_ACCESS', 'SUGGESTIONS_INLINE', 'PREVIEW_SUGGESTIONS_ACCEPTED', 'PREVIEW_WITHOUT_SUGGESTIONS']):
            raise ValueError("must be one of enum values ('DEFAULT_FOR_CURRENT_ACCESS', 'SUGGESTIONS_INLINE', 'PREVIEW_SUGGESTIONS_ACCEPTED', 'PREVIEW_WITHOUT_SUGGESTIONS')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Document from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of body
        if self.body:
            _dict['body'] = self.body.to_dict()
        # override the default output from pydantic by calling `to_dict()` of document_style
        if self.document_style:
            _dict['documentStyle'] = self.document_style.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in footers (dict)
        _field_dict = {}
        if self.footers:
            for _key_footers in self.footers:
                if self.footers[_key_footers]:
                    _field_dict[_key_footers] = self.footers[_key_footers].to_dict()
            _dict['footers'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in footnotes (dict)
        _field_dict = {}
        if self.footnotes:
            for _key_footnotes in self.footnotes:
                if self.footnotes[_key_footnotes]:
                    _field_dict[_key_footnotes] = self.footnotes[_key_footnotes].to_dict()
            _dict['footnotes'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in headers (dict)
        _field_dict = {}
        if self.headers:
            for _key_headers in self.headers:
                if self.headers[_key_headers]:
                    _field_dict[_key_headers] = self.headers[_key_headers].to_dict()
            _dict['headers'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in inline_objects (dict)
        _field_dict = {}
        if self.inline_objects:
            for _key_inline_objects in self.inline_objects:
                if self.inline_objects[_key_inline_objects]:
                    _field_dict[_key_inline_objects] = self.inline_objects[_key_inline_objects].to_dict()
            _dict['inlineObjects'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in named_ranges (dict)
        _field_dict = {}
        if self.named_ranges:
            for _key_named_ranges in self.named_ranges:
                if self.named_ranges[_key_named_ranges]:
                    _field_dict[_key_named_ranges] = self.named_ranges[_key_named_ranges].to_dict()
            _dict['namedRanges'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of named_styles
        if self.named_styles:
            _dict['namedStyles'] = self.named_styles.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in positioned_objects (dict)
        _field_dict = {}
        if self.positioned_objects:
            for _key_positioned_objects in self.positioned_objects:
                if self.positioned_objects[_key_positioned_objects]:
                    _field_dict[_key_positioned_objects] = self.positioned_objects[_key_positioned_objects].to_dict()
            _dict['positionedObjects'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in suggested_document_style_changes (dict)
        _field_dict = {}
        if self.suggested_document_style_changes:
            for _key_suggested_document_style_changes in self.suggested_document_style_changes:
                if self.suggested_document_style_changes[_key_suggested_document_style_changes]:
                    _field_dict[_key_suggested_document_style_changes] = self.suggested_document_style_changes[_key_suggested_document_style_changes].to_dict()
            _dict['suggestedDocumentStyleChanges'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in suggested_named_styles_changes (dict)
        _field_dict = {}
        if self.suggested_named_styles_changes:
            for _key_suggested_named_styles_changes in self.suggested_named_styles_changes:
                if self.suggested_named_styles_changes[_key_suggested_named_styles_changes]:
                    _field_dict[_key_suggested_named_styles_changes] = self.suggested_named_styles_changes[_key_suggested_named_styles_changes].to_dict()
            _dict['suggestedNamedStylesChanges'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Document from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "body": Body.from_dict(obj["body"]) if obj.get("body") is not None else None,
            "documentId": obj.get("documentId"),
            "documentStyle": DocumentStyle.from_dict(obj["documentStyle"]) if obj.get("documentStyle") is not None else None,
            "footers": dict(
                (_k, Footer.from_dict(_v))
                for _k, _v in obj["footers"].items()
            )
            if obj.get("footers") is not None
            else None,
            "footnotes": dict(
                (_k, Footnote.from_dict(_v))
                for _k, _v in obj["footnotes"].items()
            )
            if obj.get("footnotes") is not None
            else None,
            "headers": dict(
                (_k, Header.from_dict(_v))
                for _k, _v in obj["headers"].items()
            )
            if obj.get("headers") is not None
            else None,
            "inlineObjects": dict(
                (_k, InlineObject.from_dict(_v))
                for _k, _v in obj["inlineObjects"].items()
            )
            if obj.get("inlineObjects") is not None
            else None,
            "lists": obj.get("lists"),
            "namedRanges": dict(
                (_k, NamedRanges.from_dict(_v))
                for _k, _v in obj["namedRanges"].items()
            )
            if obj.get("namedRanges") is not None
            else None,
            "namedStyles": NamedStyles.from_dict(obj["namedStyles"]) if obj.get("namedStyles") is not None else None,
            "positionedObjects": dict(
                (_k, PositionedObject.from_dict(_v))
                for _k, _v in obj["positionedObjects"].items()
            )
            if obj.get("positionedObjects") is not None
            else None,
            "revisionId": obj.get("revisionId"),
            "suggestedDocumentStyleChanges": dict(
                (_k, SuggestedDocumentStyle.from_dict(_v))
                for _k, _v in obj["suggestedDocumentStyleChanges"].items()
            )
            if obj.get("suggestedDocumentStyleChanges") is not None
            else None,
            "suggestedNamedStylesChanges": dict(
                (_k, SuggestedNamedStyles.from_dict(_v))
                for _k, _v in obj["suggestedNamedStylesChanges"].items()
            )
            if obj.get("suggestedNamedStylesChanges") is not None
            else None,
            "suggestionsViewMode": obj.get("suggestionsViewMode"),
            "title": obj.get("title")
        })
        return _obj


