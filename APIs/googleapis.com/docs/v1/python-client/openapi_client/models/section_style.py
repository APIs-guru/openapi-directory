# coding: utf-8

"""
    Google Docs API

    Reads and writes Google Docs documents.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.dimension import Dimension
from openapi_client.models.section_column_properties import SectionColumnProperties
from typing import Optional, Set
from typing_extensions import Self

class SectionStyle(BaseModel):
    """
    The styling that applies to a section.
    """ # noqa: E501
    column_properties: Optional[List[SectionColumnProperties]] = Field(default=None, description="The section's columns properties. If empty, the section contains one column with the default properties in the Docs editor. A section can be updated to have no more than 3 columns. When updating this property, setting a concrete value is required. Unsetting this property will result in a 400 bad request error.", alias="columnProperties")
    column_separator_style: Optional[StrictStr] = Field(default=None, description="The style of column separators. This style can be set even when there's one column in the section. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.", alias="columnSeparatorStyle")
    content_direction: Optional[StrictStr] = Field(default=None, description="The content direction of this section. If unset, the value defaults to LEFT_TO_RIGHT. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.", alias="contentDirection")
    default_footer_id: Optional[StrictStr] = Field(default=None, description="The ID of the default footer. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's default_footer_id. This property is read-only.", alias="defaultFooterId")
    default_header_id: Optional[StrictStr] = Field(default=None, description="The ID of the default header. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's default_header_id. This property is read-only.", alias="defaultHeaderId")
    even_page_footer_id: Optional[StrictStr] = Field(default=None, description="The ID of the footer used only for even pages. If the value of DocumentStyle's use_even_page_header_footer is true, this value is used for the footers on even pages in the section. If it is false, the footers on even pages use the default_footer_id. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's even_page_footer_id. This property is read-only.", alias="evenPageFooterId")
    even_page_header_id: Optional[StrictStr] = Field(default=None, description="The ID of the header used only for even pages. If the value of DocumentStyle's use_even_page_header_footer is true, this value is used for the headers on even pages in the section. If it is false, the headers on even pages use the default_header_id. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's even_page_header_id. This property is read-only.", alias="evenPageHeaderId")
    first_page_footer_id: Optional[StrictStr] = Field(default=None, description="The ID of the footer used only for the first page of the section. If use_first_page_header_footer is true, this value is used for the footer on the first page of the section. If it's false, the footer on the first page of the section uses the default_footer_id. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's first_page_footer_id. This property is read-only.", alias="firstPageFooterId")
    first_page_header_id: Optional[StrictStr] = Field(default=None, description="The ID of the header used only for the first page of the section. If use_first_page_header_footer is true, this value is used for the header on the first page of the section. If it's false, the header on the first page of the section uses the default_header_id. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's first_page_header_id. This property is read-only.", alias="firstPageHeaderId")
    flip_page_orientation: Optional[StrictBool] = Field(default=None, description="Optional. Indicates whether to flip the dimensions of DocumentStyle's page_size for this section, which allows changing the page orientation between portrait and landscape. If unset, the value inherits from DocumentStyle's flip_page_orientation. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.", alias="flipPageOrientation")
    margin_bottom: Optional[Dimension] = Field(default=None, alias="marginBottom")
    margin_footer: Optional[Dimension] = Field(default=None, alias="marginFooter")
    margin_header: Optional[Dimension] = Field(default=None, alias="marginHeader")
    margin_left: Optional[Dimension] = Field(default=None, alias="marginLeft")
    margin_right: Optional[Dimension] = Field(default=None, alias="marginRight")
    margin_top: Optional[Dimension] = Field(default=None, alias="marginTop")
    page_number_start: Optional[StrictInt] = Field(default=None, description="The page number from which to start counting the number of pages for this section. If unset, page numbering continues from the previous section. If the value is unset in the first SectionBreak, refer to DocumentStyle's page_number_start. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.", alias="pageNumberStart")
    section_type: Optional[StrictStr] = Field(default=None, description="Output only. The type of section.", alias="sectionType")
    use_first_page_header_footer: Optional[StrictBool] = Field(default=None, description="Indicates whether to use the first page header / footer IDs for the first page of the section. If unset, it inherits from DocumentStyle's use_first_page_header_footer for the first section. If the value is unset for subsequent sectors, it should be interpreted as false. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.", alias="useFirstPageHeaderFooter")
    __properties: ClassVar[List[str]] = ["columnProperties", "columnSeparatorStyle", "contentDirection", "defaultFooterId", "defaultHeaderId", "evenPageFooterId", "evenPageHeaderId", "firstPageFooterId", "firstPageHeaderId", "flipPageOrientation", "marginBottom", "marginFooter", "marginHeader", "marginLeft", "marginRight", "marginTop", "pageNumberStart", "sectionType", "useFirstPageHeaderFooter"]

    @field_validator('column_separator_style')
    def column_separator_style_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['COLUMN_SEPARATOR_STYLE_UNSPECIFIED', 'NONE', 'BETWEEN_EACH_COLUMN']):
            raise ValueError("must be one of enum values ('COLUMN_SEPARATOR_STYLE_UNSPECIFIED', 'NONE', 'BETWEEN_EACH_COLUMN')")
        return value

    @field_validator('content_direction')
    def content_direction_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CONTENT_DIRECTION_UNSPECIFIED', 'LEFT_TO_RIGHT', 'RIGHT_TO_LEFT']):
            raise ValueError("must be one of enum values ('CONTENT_DIRECTION_UNSPECIFIED', 'LEFT_TO_RIGHT', 'RIGHT_TO_LEFT')")
        return value

    @field_validator('section_type')
    def section_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SECTION_TYPE_UNSPECIFIED', 'CONTINUOUS', 'NEXT_PAGE']):
            raise ValueError("must be one of enum values ('SECTION_TYPE_UNSPECIFIED', 'CONTINUOUS', 'NEXT_PAGE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SectionStyle from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in column_properties (list)
        _items = []
        if self.column_properties:
            for _item_column_properties in self.column_properties:
                if _item_column_properties:
                    _items.append(_item_column_properties.to_dict())
            _dict['columnProperties'] = _items
        # override the default output from pydantic by calling `to_dict()` of margin_bottom
        if self.margin_bottom:
            _dict['marginBottom'] = self.margin_bottom.to_dict()
        # override the default output from pydantic by calling `to_dict()` of margin_footer
        if self.margin_footer:
            _dict['marginFooter'] = self.margin_footer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of margin_header
        if self.margin_header:
            _dict['marginHeader'] = self.margin_header.to_dict()
        # override the default output from pydantic by calling `to_dict()` of margin_left
        if self.margin_left:
            _dict['marginLeft'] = self.margin_left.to_dict()
        # override the default output from pydantic by calling `to_dict()` of margin_right
        if self.margin_right:
            _dict['marginRight'] = self.margin_right.to_dict()
        # override the default output from pydantic by calling `to_dict()` of margin_top
        if self.margin_top:
            _dict['marginTop'] = self.margin_top.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SectionStyle from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "columnProperties": [SectionColumnProperties.from_dict(_item) for _item in obj["columnProperties"]] if obj.get("columnProperties") is not None else None,
            "columnSeparatorStyle": obj.get("columnSeparatorStyle"),
            "contentDirection": obj.get("contentDirection"),
            "defaultFooterId": obj.get("defaultFooterId"),
            "defaultHeaderId": obj.get("defaultHeaderId"),
            "evenPageFooterId": obj.get("evenPageFooterId"),
            "evenPageHeaderId": obj.get("evenPageHeaderId"),
            "firstPageFooterId": obj.get("firstPageFooterId"),
            "firstPageHeaderId": obj.get("firstPageHeaderId"),
            "flipPageOrientation": obj.get("flipPageOrientation"),
            "marginBottom": Dimension.from_dict(obj["marginBottom"]) if obj.get("marginBottom") is not None else None,
            "marginFooter": Dimension.from_dict(obj["marginFooter"]) if obj.get("marginFooter") is not None else None,
            "marginHeader": Dimension.from_dict(obj["marginHeader"]) if obj.get("marginHeader") is not None else None,
            "marginLeft": Dimension.from_dict(obj["marginLeft"]) if obj.get("marginLeft") is not None else None,
            "marginRight": Dimension.from_dict(obj["marginRight"]) if obj.get("marginRight") is not None else None,
            "marginTop": Dimension.from_dict(obj["marginTop"]) if obj.get("marginTop") is not None else None,
            "pageNumberStart": obj.get("pageNumberStart"),
            "sectionType": obj.get("sectionType"),
            "useFirstPageHeaderFooter": obj.get("useFirstPageHeaderFooter")
        })
        return _obj


