# coding: utf-8

"""
    Google Docs API

    Reads and writes Google Docs documents.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.dimension import Dimension
from openapi_client.models.paragraph_border import ParagraphBorder
from openapi_client.models.shading import Shading
from openapi_client.models.tab_stop import TabStop
from typing import Optional, Set
from typing_extensions import Self

class ParagraphStyle(BaseModel):
    """
    Styles that apply to a whole paragraph. Inherited paragraph styles are represented as unset fields in this message. A paragraph style's parent depends on where the paragraph style is defined: * The ParagraphStyle on a Paragraph inherits from the paragraph's corresponding named style type. * The ParagraphStyle on a named style inherits from the normal text named style. * The ParagraphStyle of the normal text named style inherits from the default paragraph style in the Docs editor. * The ParagraphStyle on a Paragraph element that's contained in a table may inherit its paragraph style from the table style. If the paragraph style does not inherit from a parent, unsetting fields will revert the style to a value matching the defaults in the Docs editor.
    """ # noqa: E501
    alignment: Optional[StrictStr] = Field(default=None, description="The text alignment for this paragraph.")
    avoid_widow_and_orphan: Optional[StrictBool] = Field(default=None, description="Whether to avoid widows and orphans for the paragraph. If unset, the value is inherited from the parent.", alias="avoidWidowAndOrphan")
    border_between: Optional[ParagraphBorder] = Field(default=None, alias="borderBetween")
    border_bottom: Optional[ParagraphBorder] = Field(default=None, alias="borderBottom")
    border_left: Optional[ParagraphBorder] = Field(default=None, alias="borderLeft")
    border_right: Optional[ParagraphBorder] = Field(default=None, alias="borderRight")
    border_top: Optional[ParagraphBorder] = Field(default=None, alias="borderTop")
    direction: Optional[StrictStr] = Field(default=None, description="The text direction of this paragraph. If unset, the value defaults to LEFT_TO_RIGHT since paragraph direction is not inherited.")
    heading_id: Optional[StrictStr] = Field(default=None, description="The heading ID of the paragraph. If empty, then this paragraph is not a heading. This property is read-only.", alias="headingId")
    indent_end: Optional[Dimension] = Field(default=None, alias="indentEnd")
    indent_first_line: Optional[Dimension] = Field(default=None, alias="indentFirstLine")
    indent_start: Optional[Dimension] = Field(default=None, alias="indentStart")
    keep_lines_together: Optional[StrictBool] = Field(default=None, description="Whether all lines of the paragraph should be laid out on the same page or column if possible. If unset, the value is inherited from the parent.", alias="keepLinesTogether")
    keep_with_next: Optional[StrictBool] = Field(default=None, description="Whether at least a part of this paragraph should be laid out on the same page or column as the next paragraph if possible. If unset, the value is inherited from the parent.", alias="keepWithNext")
    line_spacing: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The amount of space between lines, as a percentage of normal, where normal is represented as 100.0. If unset, the value is inherited from the parent.", alias="lineSpacing")
    named_style_type: Optional[StrictStr] = Field(default=None, description="The named style type of the paragraph. Since updating the named style type affects other properties within ParagraphStyle, the named style type is applied before the other properties are updated.", alias="namedStyleType")
    page_break_before: Optional[StrictBool] = Field(default=None, description="Whether the current paragraph should always start at the beginning of a page. If unset, the value is inherited from the parent. Attempting to update page_break_before for paragraphs in unsupported regions, including Table, Header, Footer and Footnote, can result in an invalid document state that returns a 400 bad request error.", alias="pageBreakBefore")
    shading: Optional[Shading] = None
    space_above: Optional[Dimension] = Field(default=None, alias="spaceAbove")
    space_below: Optional[Dimension] = Field(default=None, alias="spaceBelow")
    spacing_mode: Optional[StrictStr] = Field(default=None, description="The spacing mode for the paragraph.", alias="spacingMode")
    tab_stops: Optional[List[TabStop]] = Field(default=None, description="A list of the tab stops for this paragraph. The list of tab stops is not inherited. This property is read-only.", alias="tabStops")
    __properties: ClassVar[List[str]] = ["alignment", "avoidWidowAndOrphan", "borderBetween", "borderBottom", "borderLeft", "borderRight", "borderTop", "direction", "headingId", "indentEnd", "indentFirstLine", "indentStart", "keepLinesTogether", "keepWithNext", "lineSpacing", "namedStyleType", "pageBreakBefore", "shading", "spaceAbove", "spaceBelow", "spacingMode", "tabStops"]

    @field_validator('alignment')
    def alignment_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ALIGNMENT_UNSPECIFIED', 'START', 'CENTER', 'END', 'JUSTIFIED']):
            raise ValueError("must be one of enum values ('ALIGNMENT_UNSPECIFIED', 'START', 'CENTER', 'END', 'JUSTIFIED')")
        return value

    @field_validator('direction')
    def direction_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CONTENT_DIRECTION_UNSPECIFIED', 'LEFT_TO_RIGHT', 'RIGHT_TO_LEFT']):
            raise ValueError("must be one of enum values ('CONTENT_DIRECTION_UNSPECIFIED', 'LEFT_TO_RIGHT', 'RIGHT_TO_LEFT')")
        return value

    @field_validator('named_style_type')
    def named_style_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NAMED_STYLE_TYPE_UNSPECIFIED', 'NORMAL_TEXT', 'TITLE', 'SUBTITLE', 'HEADING_1', 'HEADING_2', 'HEADING_3', 'HEADING_4', 'HEADING_5', 'HEADING_6']):
            raise ValueError("must be one of enum values ('NAMED_STYLE_TYPE_UNSPECIFIED', 'NORMAL_TEXT', 'TITLE', 'SUBTITLE', 'HEADING_1', 'HEADING_2', 'HEADING_3', 'HEADING_4', 'HEADING_5', 'HEADING_6')")
        return value

    @field_validator('spacing_mode')
    def spacing_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SPACING_MODE_UNSPECIFIED', 'NEVER_COLLAPSE', 'COLLAPSE_LISTS']):
            raise ValueError("must be one of enum values ('SPACING_MODE_UNSPECIFIED', 'NEVER_COLLAPSE', 'COLLAPSE_LISTS')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ParagraphStyle from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of border_between
        if self.border_between:
            _dict['borderBetween'] = self.border_between.to_dict()
        # override the default output from pydantic by calling `to_dict()` of border_bottom
        if self.border_bottom:
            _dict['borderBottom'] = self.border_bottom.to_dict()
        # override the default output from pydantic by calling `to_dict()` of border_left
        if self.border_left:
            _dict['borderLeft'] = self.border_left.to_dict()
        # override the default output from pydantic by calling `to_dict()` of border_right
        if self.border_right:
            _dict['borderRight'] = self.border_right.to_dict()
        # override the default output from pydantic by calling `to_dict()` of border_top
        if self.border_top:
            _dict['borderTop'] = self.border_top.to_dict()
        # override the default output from pydantic by calling `to_dict()` of indent_end
        if self.indent_end:
            _dict['indentEnd'] = self.indent_end.to_dict()
        # override the default output from pydantic by calling `to_dict()` of indent_first_line
        if self.indent_first_line:
            _dict['indentFirstLine'] = self.indent_first_line.to_dict()
        # override the default output from pydantic by calling `to_dict()` of indent_start
        if self.indent_start:
            _dict['indentStart'] = self.indent_start.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shading
        if self.shading:
            _dict['shading'] = self.shading.to_dict()
        # override the default output from pydantic by calling `to_dict()` of space_above
        if self.space_above:
            _dict['spaceAbove'] = self.space_above.to_dict()
        # override the default output from pydantic by calling `to_dict()` of space_below
        if self.space_below:
            _dict['spaceBelow'] = self.space_below.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in tab_stops (list)
        _items = []
        if self.tab_stops:
            for _item_tab_stops in self.tab_stops:
                if _item_tab_stops:
                    _items.append(_item_tab_stops.to_dict())
            _dict['tabStops'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ParagraphStyle from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "alignment": obj.get("alignment"),
            "avoidWidowAndOrphan": obj.get("avoidWidowAndOrphan"),
            "borderBetween": ParagraphBorder.from_dict(obj["borderBetween"]) if obj.get("borderBetween") is not None else None,
            "borderBottom": ParagraphBorder.from_dict(obj["borderBottom"]) if obj.get("borderBottom") is not None else None,
            "borderLeft": ParagraphBorder.from_dict(obj["borderLeft"]) if obj.get("borderLeft") is not None else None,
            "borderRight": ParagraphBorder.from_dict(obj["borderRight"]) if obj.get("borderRight") is not None else None,
            "borderTop": ParagraphBorder.from_dict(obj["borderTop"]) if obj.get("borderTop") is not None else None,
            "direction": obj.get("direction"),
            "headingId": obj.get("headingId"),
            "indentEnd": Dimension.from_dict(obj["indentEnd"]) if obj.get("indentEnd") is not None else None,
            "indentFirstLine": Dimension.from_dict(obj["indentFirstLine"]) if obj.get("indentFirstLine") is not None else None,
            "indentStart": Dimension.from_dict(obj["indentStart"]) if obj.get("indentStart") is not None else None,
            "keepLinesTogether": obj.get("keepLinesTogether"),
            "keepWithNext": obj.get("keepWithNext"),
            "lineSpacing": obj.get("lineSpacing"),
            "namedStyleType": obj.get("namedStyleType"),
            "pageBreakBefore": obj.get("pageBreakBefore"),
            "shading": Shading.from_dict(obj["shading"]) if obj.get("shading") is not None else None,
            "spaceAbove": Dimension.from_dict(obj["spaceAbove"]) if obj.get("spaceAbove") is not None else None,
            "spaceBelow": Dimension.from_dict(obj["spaceBelow"]) if obj.get("spaceBelow") is not None else None,
            "spacingMode": obj.get("spacingMode"),
            "tabStops": [TabStop.from_dict(_item) for _item in obj["tabStops"]] if obj.get("tabStops") is not None else None
        })
        return _obj


