# coding: utf-8

"""
    Identity and Access Management (IAM) API

    Manages identity and access control for Google Cloud Platform resources, including the creation of service accounts, which you can use to authenticate to Google and make API calls. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictBytes, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class ServiceAccountKey(BaseModel):
    """
    Represents a service account key. A service account has two sets of key-pairs: user-managed, and system-managed. User-managed key-pairs can be created and deleted by users. Users are responsible for rotating these keys periodically to ensure security of their service accounts. Users retain the private key of these key-pairs, and Google retains ONLY the public key. System-managed keys are automatically rotated by Google, and are used for signing for a maximum of two weeks. The rotation process is probabilistic, and usage of the new key will gradually ramp up and down over the key's lifetime. If you cache the public key set for a service account, we recommend that you update the cache every 15 minutes. User-managed keys can be added and removed at any time, so it is important to update the cache frequently. For Google-managed keys, Google will publish a key at least 6 hours before it is first used for signing and will keep publishing it for at least 6 hours after it was last used for signing. Public keys for all service accounts are also published at the OAuth2 Service Account API.
    """ # noqa: E501
    disabled: Optional[StrictBool] = Field(default=None, description="The key status.")
    key_algorithm: Optional[StrictStr] = Field(default=None, description="Specifies the algorithm (and possibly key size) for the key.", alias="keyAlgorithm")
    key_origin: Optional[StrictStr] = Field(default=None, description="The key origin.", alias="keyOrigin")
    key_type: Optional[StrictStr] = Field(default=None, description="The key type.", alias="keyType")
    name: Optional[StrictStr] = Field(default=None, description="The resource name of the service account key in the following format `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}`.")
    private_key_data: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="The private key data. Only provided in `CreateServiceAccountKey` responses. Make sure to keep the private key data secure because it allows for the assertion of the service account identity. When base64 decoded, the private key data can be used to authenticate with Google API client libraries and with gcloud auth activate-service-account.", alias="privateKeyData")
    private_key_type: Optional[StrictStr] = Field(default=None, description="The output format for the private key. Only provided in `CreateServiceAccountKey` responses, not in `GetServiceAccountKey` or `ListServiceAccountKey` responses. Google never exposes system-managed private keys, and never retains user-managed private keys.", alias="privateKeyType")
    public_key_data: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="The public key data. Only provided in `GetServiceAccountKey` responses.", alias="publicKeyData")
    valid_after_time: Optional[StrictStr] = Field(default=None, description="The key can be used after this timestamp.", alias="validAfterTime")
    valid_before_time: Optional[StrictStr] = Field(default=None, description="The key can be used before this timestamp. For system-managed key pairs, this timestamp is the end time for the private key signing operation. The public key could still be used for verification for a few hours after this time.", alias="validBeforeTime")
    __properties: ClassVar[List[str]] = ["disabled", "keyAlgorithm", "keyOrigin", "keyType", "name", "privateKeyData", "privateKeyType", "publicKeyData", "validAfterTime", "validBeforeTime"]

    @field_validator('key_algorithm')
    def key_algorithm_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['KEY_ALG_UNSPECIFIED', 'KEY_ALG_RSA_1024', 'KEY_ALG_RSA_2048']):
            raise ValueError("must be one of enum values ('KEY_ALG_UNSPECIFIED', 'KEY_ALG_RSA_1024', 'KEY_ALG_RSA_2048')")
        return value

    @field_validator('key_origin')
    def key_origin_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ORIGIN_UNSPECIFIED', 'USER_PROVIDED', 'GOOGLE_PROVIDED']):
            raise ValueError("must be one of enum values ('ORIGIN_UNSPECIFIED', 'USER_PROVIDED', 'GOOGLE_PROVIDED')")
        return value

    @field_validator('key_type')
    def key_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['KEY_TYPE_UNSPECIFIED', 'USER_MANAGED', 'SYSTEM_MANAGED']):
            raise ValueError("must be one of enum values ('KEY_TYPE_UNSPECIFIED', 'USER_MANAGED', 'SYSTEM_MANAGED')")
        return value

    @field_validator('private_key_type')
    def private_key_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['TYPE_UNSPECIFIED', 'TYPE_PKCS12_FILE', 'TYPE_GOOGLE_CREDENTIALS_FILE']):
            raise ValueError("must be one of enum values ('TYPE_UNSPECIFIED', 'TYPE_PKCS12_FILE', 'TYPE_GOOGLE_CREDENTIALS_FILE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ServiceAccountKey from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ServiceAccountKey from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "disabled": obj.get("disabled"),
            "keyAlgorithm": obj.get("keyAlgorithm"),
            "keyOrigin": obj.get("keyOrigin"),
            "keyType": obj.get("keyType"),
            "name": obj.get("name"),
            "privateKeyData": obj.get("privateKeyData"),
            "privateKeyType": obj.get("privateKeyType"),
            "publicKeyData": obj.get("publicKeyData"),
            "validAfterTime": obj.get("validAfterTime"),
            "validBeforeTime": obj.get("validBeforeTime")
        })
        return _obj


