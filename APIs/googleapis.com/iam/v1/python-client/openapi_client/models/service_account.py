# coding: utf-8

"""
    Identity and Access Management (IAM) API

    Manages identity and access control for Google Cloud Platform resources, including the creation of service accounts, which you can use to authenticate to Google and make API calls. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictBytes, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class ServiceAccount(BaseModel):
    """
    An IAM service account. A service account is an account for an application or a virtual machine (VM) instance, not a person. You can use a service account to call Google APIs. To learn more, read the [overview of service accounts](https://cloud.google.com/iam/help/service-accounts/overview). When you create a service account, you specify the project ID that owns the service account, as well as a name that must be unique within the project. IAM uses these values to create an email address that identifies the service account. //
    """ # noqa: E501
    description: Optional[StrictStr] = Field(default=None, description="Optional. A user-specified, human-readable description of the service account. The maximum length is 256 UTF-8 bytes.")
    disabled: Optional[StrictBool] = Field(default=None, description="Output only. Whether the service account is disabled.")
    display_name: Optional[StrictStr] = Field(default=None, description="Optional. A user-specified, human-readable name for the service account. The maximum length is 100 UTF-8 bytes.", alias="displayName")
    email: Optional[StrictStr] = Field(default=None, description="Output only. The email address of the service account.")
    etag: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="Deprecated. Do not use.")
    name: Optional[StrictStr] = Field(default=None, description="The resource name of the service account. Use one of the following formats: * `projects/{PROJECT_ID}/serviceAccounts/{EMAIL_ADDRESS}` * `projects/{PROJECT_ID}/serviceAccounts/{UNIQUE_ID}` As an alternative, you can use the `-` wildcard character instead of the project ID: * `projects/-/serviceAccounts/{EMAIL_ADDRESS}` * `projects/-/serviceAccounts/{UNIQUE_ID}` When possible, avoid using the `-` wildcard character, because it can cause response messages to contain misleading error codes. For example, if you try to access the service account `projects/-/serviceAccounts/fake@example.com`, which does not exist, the response contains an HTTP `403 Forbidden` error instead of a `404 Not Found` error.")
    oauth2_client_id: Optional[StrictStr] = Field(default=None, description="Output only. The OAuth 2.0 client ID for the service account.", alias="oauth2ClientId")
    project_id: Optional[StrictStr] = Field(default=None, description="Output only. The ID of the project that owns the service account.", alias="projectId")
    unique_id: Optional[StrictStr] = Field(default=None, description="Output only. The unique, stable numeric ID for the service account. Each service account retains its unique ID even if you delete the service account. For example, if you delete a service account, then create a new service account with the same name, the new service account has a different unique ID than the deleted service account.", alias="uniqueId")
    __properties: ClassVar[List[str]] = ["description", "disabled", "displayName", "email", "etag", "name", "oauth2ClientId", "projectId", "uniqueId"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ServiceAccount from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "disabled",
            "email",
            "oauth2_client_id",
            "project_id",
            "unique_id",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ServiceAccount from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "description": obj.get("description"),
            "disabled": obj.get("disabled"),
            "displayName": obj.get("displayName"),
            "email": obj.get("email"),
            "etag": obj.get("etag"),
            "name": obj.get("name"),
            "oauth2ClientId": obj.get("oauth2ClientId"),
            "projectId": obj.get("projectId"),
            "uniqueId": obj.get("uniqueId")
        })
        return _obj


