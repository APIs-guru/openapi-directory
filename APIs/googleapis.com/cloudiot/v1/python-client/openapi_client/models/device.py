# coding: utf-8

"""
    Cloud IoT API

    Registers and manages IoT (Internet of Things) devices that connect to the Google Cloud Platform. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.device_config import DeviceConfig
from openapi_client.models.device_credential import DeviceCredential
from openapi_client.models.device_state import DeviceState
from openapi_client.models.gateway_config import GatewayConfig
from openapi_client.models.status import Status
from typing import Optional, Set
from typing_extensions import Self

class Device(BaseModel):
    """
    The device resource.
    """ # noqa: E501
    blocked: Optional[StrictBool] = Field(default=None, description="If a device is blocked, connections or requests from this device will fail. Can be used to temporarily prevent the device from connecting if, for example, the sensor is generating bad data and needs maintenance.")
    config: Optional[DeviceConfig] = None
    credentials: Optional[List[DeviceCredential]] = Field(default=None, description="The credentials used to authenticate this device. To allow credential rotation without interruption, multiple device credentials can be bound to this device. No more than 3 credentials can be bound to a single device at a time. When new credentials are added to a device, they are verified against the registry credentials. For details, see the description of the `DeviceRegistry.credentials` field.")
    gateway_config: Optional[GatewayConfig] = Field(default=None, alias="gatewayConfig")
    id: Optional[StrictStr] = Field(default=None, description="The user-defined device identifier. The device ID must be unique within a device registry.")
    last_config_ack_time: Optional[StrictStr] = Field(default=None, description="[Output only] The last time a cloud-to-device config version acknowledgment was received from the device. This field is only for configurations sent through MQTT.", alias="lastConfigAckTime")
    last_config_send_time: Optional[StrictStr] = Field(default=None, description="[Output only] The last time a cloud-to-device config version was sent to the device.", alias="lastConfigSendTime")
    last_error_status: Optional[Status] = Field(default=None, alias="lastErrorStatus")
    last_error_time: Optional[StrictStr] = Field(default=None, description="[Output only] The time the most recent error occurred, such as a failure to publish to Cloud Pub/Sub. This field is the timestamp of 'last_error_status'.", alias="lastErrorTime")
    last_event_time: Optional[StrictStr] = Field(default=None, description="[Output only] The last time a telemetry event was received. Timestamps are periodically collected and written to storage; they may be stale by a few minutes.", alias="lastEventTime")
    last_heartbeat_time: Optional[StrictStr] = Field(default=None, description="[Output only] The last time an MQTT `PINGREQ` was received. This field applies only to devices connecting through MQTT. MQTT clients usually only send `PINGREQ` messages if the connection is idle, and no other messages have been sent. Timestamps are periodically collected and written to storage; they may be stale by a few minutes.", alias="lastHeartbeatTime")
    last_state_time: Optional[StrictStr] = Field(default=None, description="[Output only] The last time a state event was received. Timestamps are periodically collected and written to storage; they may be stale by a few minutes.", alias="lastStateTime")
    log_level: Optional[StrictStr] = Field(default=None, description="**Beta Feature** The logging verbosity for device activity. If unspecified, DeviceRegistry.log_level will be used.", alias="logLevel")
    metadata: Optional[Dict[str, StrictStr]] = Field(default=None, description="The metadata key-value pairs assigned to the device. This metadata is not interpreted or indexed by Cloud IoT Core. It can be used to add contextual information for the device. Keys must conform to the regular expression a-zA-Z+ and be less than 128 bytes in length. Values are free-form strings. Each value must be less than or equal to 32 KB in size. The total size of all keys and values must be less than 256 KB, and the maximum number of key-value pairs is 500.")
    name: Optional[StrictStr] = Field(default=None, description="The resource path name. For example, `projects/p1/locations/us-central1/registries/registry0/devices/dev0` or `projects/p1/locations/us-central1/registries/registry0/devices/{num_id}`. When `name` is populated as a response from the service, it always ends in the device numeric ID.")
    num_id: Optional[StrictStr] = Field(default=None, description="[Output only] A server-defined unique numeric ID for the device. This is a more compact way to identify devices, and it is globally unique.", alias="numId")
    state: Optional[DeviceState] = None
    __properties: ClassVar[List[str]] = ["blocked", "config", "credentials", "gatewayConfig", "id", "lastConfigAckTime", "lastConfigSendTime", "lastErrorStatus", "lastErrorTime", "lastEventTime", "lastHeartbeatTime", "lastStateTime", "logLevel", "metadata", "name", "numId", "state"]

    @field_validator('log_level')
    def log_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['LOG_LEVEL_UNSPECIFIED', 'NONE', 'ERROR', 'INFO', 'DEBUG']):
            raise ValueError("must be one of enum values ('LOG_LEVEL_UNSPECIFIED', 'NONE', 'ERROR', 'INFO', 'DEBUG')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Device from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of config
        if self.config:
            _dict['config'] = self.config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in credentials (list)
        _items = []
        if self.credentials:
            for _item_credentials in self.credentials:
                if _item_credentials:
                    _items.append(_item_credentials.to_dict())
            _dict['credentials'] = _items
        # override the default output from pydantic by calling `to_dict()` of gateway_config
        if self.gateway_config:
            _dict['gatewayConfig'] = self.gateway_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of last_error_status
        if self.last_error_status:
            _dict['lastErrorStatus'] = self.last_error_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of state
        if self.state:
            _dict['state'] = self.state.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Device from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "blocked": obj.get("blocked"),
            "config": DeviceConfig.from_dict(obj["config"]) if obj.get("config") is not None else None,
            "credentials": [DeviceCredential.from_dict(_item) for _item in obj["credentials"]] if obj.get("credentials") is not None else None,
            "gatewayConfig": GatewayConfig.from_dict(obj["gatewayConfig"]) if obj.get("gatewayConfig") is not None else None,
            "id": obj.get("id"),
            "lastConfigAckTime": obj.get("lastConfigAckTime"),
            "lastConfigSendTime": obj.get("lastConfigSendTime"),
            "lastErrorStatus": Status.from_dict(obj["lastErrorStatus"]) if obj.get("lastErrorStatus") is not None else None,
            "lastErrorTime": obj.get("lastErrorTime"),
            "lastEventTime": obj.get("lastEventTime"),
            "lastHeartbeatTime": obj.get("lastHeartbeatTime"),
            "lastStateTime": obj.get("lastStateTime"),
            "logLevel": obj.get("logLevel"),
            "metadata": obj.get("metadata"),
            "name": obj.get("name"),
            "numId": obj.get("numId"),
            "state": DeviceState.from_dict(obj["state"]) if obj.get("state") is not None else None
        })
        return _obj


