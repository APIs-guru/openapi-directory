# coding: utf-8

"""
    Google+ API

    Builds on top of the Google+ platform.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.person_age_range import PersonAgeRange
from openapi_client.models.person_cover import PersonCover
from openapi_client.models.person_emails_inner import PersonEmailsInner
from openapi_client.models.person_image import PersonImage
from openapi_client.models.person_name import PersonName
from openapi_client.models.person_organizations_inner import PersonOrganizationsInner
from openapi_client.models.person_places_lived_inner import PersonPlacesLivedInner
from openapi_client.models.person_urls_inner import PersonUrlsInner
from typing import Optional, Set
from typing_extensions import Self

class Person(BaseModel):
    """
    Person
    """ # noqa: E501
    about_me: Optional[StrictStr] = Field(default=None, description="A short biography for this person.", alias="aboutMe")
    age_range: Optional[PersonAgeRange] = Field(default=None, alias="ageRange")
    birthday: Optional[StrictStr] = Field(default=None, description="The person's date of birth, represented as YYYY-MM-DD.")
    bragging_rights: Optional[StrictStr] = Field(default=None, description="The \"bragging rights\" line of this person.", alias="braggingRights")
    circled_by_count: Optional[StrictInt] = Field(default=None, description="For followers who are visible, the number of people who have added this person or page to a circle.", alias="circledByCount")
    cover: Optional[PersonCover] = None
    current_location: Optional[StrictStr] = Field(default=None, description="(this field is not currently used)", alias="currentLocation")
    display_name: Optional[StrictStr] = Field(default=None, description="The name of this person, which is suitable for display.", alias="displayName")
    domain: Optional[StrictStr] = Field(default=None, description="The hosted domain name for the user's Google Apps account. For instance, example.com. The plus.profile.emails.read or email scope is needed to get this domain name.")
    emails: Optional[List[PersonEmailsInner]] = Field(default=None, description="A list of email addresses that this person has, including their Google account email address, and the public verified email addresses on their Google+ profile. The plus.profile.emails.read scope is needed to retrieve these email addresses, or the email scope can be used to retrieve just the Google account email address.")
    etag: Optional[StrictStr] = Field(default=None, description="ETag of this response for caching purposes.")
    gender: Optional[StrictStr] = Field(default=None, description="The person's gender. Possible values include, but are not limited to, the following values:   - \"male\" - Male gender.  - \"female\" - Female gender.  - \"other\" - Other.")
    id: Optional[StrictStr] = Field(default=None, description="The ID of this person.")
    image: Optional[PersonImage] = None
    is_plus_user: Optional[StrictBool] = Field(default=None, description="Whether this user has signed up for Google+.", alias="isPlusUser")
    kind: Optional[StrictStr] = Field(default='plus#person', description="Identifies this resource as a person. Value: \"plus#person\".")
    language: Optional[StrictStr] = Field(default=None, description="The user's preferred language for rendering.")
    name: Optional[PersonName] = None
    nickname: Optional[StrictStr] = Field(default=None, description="The nickname of this person.")
    object_type: Optional[StrictStr] = Field(default=None, description="Type of person within Google+. Possible values include, but are not limited to, the following values:   - \"person\" - represents an actual person.  - \"page\" - represents a page.", alias="objectType")
    occupation: Optional[StrictStr] = Field(default=None, description="The occupation of this person.")
    organizations: Optional[List[PersonOrganizationsInner]] = Field(default=None, description="A list of current or past organizations with which this person is associated.")
    places_lived: Optional[List[PersonPlacesLivedInner]] = Field(default=None, description="A list of places where this person has lived.", alias="placesLived")
    plus_one_count: Optional[StrictInt] = Field(default=None, description="If a Google+ Page, the number of people who have +1'd this page.", alias="plusOneCount")
    relationship_status: Optional[StrictStr] = Field(default=None, description="The person's relationship status. Possible values include, but are not limited to, the following values:   - \"single\" - Person is single.  - \"in_a_relationship\" - Person is in a relationship.  - \"engaged\" - Person is engaged.  - \"married\" - Person is married.  - \"its_complicated\" - The relationship is complicated.  - \"open_relationship\" - Person is in an open relationship.  - \"widowed\" - Person is widowed.  - \"in_domestic_partnership\" - Person is in a domestic partnership.  - \"in_civil_union\" - Person is in a civil union.", alias="relationshipStatus")
    skills: Optional[StrictStr] = Field(default=None, description="The person's skills.")
    tagline: Optional[StrictStr] = Field(default=None, description="The brief description (tagline) of this person.")
    url: Optional[StrictStr] = Field(default=None, description="The URL of this person's profile.")
    urls: Optional[List[PersonUrlsInner]] = Field(default=None, description="A list of URLs for this person.")
    verified: Optional[StrictBool] = Field(default=None, description="Whether the person or Google+ Page has been verified.")
    __properties: ClassVar[List[str]] = ["aboutMe", "ageRange", "birthday", "braggingRights", "circledByCount", "cover", "currentLocation", "displayName", "domain", "emails", "etag", "gender", "id", "image", "isPlusUser", "kind", "language", "name", "nickname", "objectType", "occupation", "organizations", "placesLived", "plusOneCount", "relationshipStatus", "skills", "tagline", "url", "urls", "verified"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Person from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of age_range
        if self.age_range:
            _dict['ageRange'] = self.age_range.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cover
        if self.cover:
            _dict['cover'] = self.cover.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in emails (list)
        _items = []
        if self.emails:
            for _item_emails in self.emails:
                if _item_emails:
                    _items.append(_item_emails.to_dict())
            _dict['emails'] = _items
        # override the default output from pydantic by calling `to_dict()` of image
        if self.image:
            _dict['image'] = self.image.to_dict()
        # override the default output from pydantic by calling `to_dict()` of name
        if self.name:
            _dict['name'] = self.name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in organizations (list)
        _items = []
        if self.organizations:
            for _item_organizations in self.organizations:
                if _item_organizations:
                    _items.append(_item_organizations.to_dict())
            _dict['organizations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in places_lived (list)
        _items = []
        if self.places_lived:
            for _item_places_lived in self.places_lived:
                if _item_places_lived:
                    _items.append(_item_places_lived.to_dict())
            _dict['placesLived'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in urls (list)
        _items = []
        if self.urls:
            for _item_urls in self.urls:
                if _item_urls:
                    _items.append(_item_urls.to_dict())
            _dict['urls'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Person from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "aboutMe": obj.get("aboutMe"),
            "ageRange": PersonAgeRange.from_dict(obj["ageRange"]) if obj.get("ageRange") is not None else None,
            "birthday": obj.get("birthday"),
            "braggingRights": obj.get("braggingRights"),
            "circledByCount": obj.get("circledByCount"),
            "cover": PersonCover.from_dict(obj["cover"]) if obj.get("cover") is not None else None,
            "currentLocation": obj.get("currentLocation"),
            "displayName": obj.get("displayName"),
            "domain": obj.get("domain"),
            "emails": [PersonEmailsInner.from_dict(_item) for _item in obj["emails"]] if obj.get("emails") is not None else None,
            "etag": obj.get("etag"),
            "gender": obj.get("gender"),
            "id": obj.get("id"),
            "image": PersonImage.from_dict(obj["image"]) if obj.get("image") is not None else None,
            "isPlusUser": obj.get("isPlusUser"),
            "kind": obj.get("kind") if obj.get("kind") is not None else 'plus#person',
            "language": obj.get("language"),
            "name": PersonName.from_dict(obj["name"]) if obj.get("name") is not None else None,
            "nickname": obj.get("nickname"),
            "objectType": obj.get("objectType"),
            "occupation": obj.get("occupation"),
            "organizations": [PersonOrganizationsInner.from_dict(_item) for _item in obj["organizations"]] if obj.get("organizations") is not None else None,
            "placesLived": [PersonPlacesLivedInner.from_dict(_item) for _item in obj["placesLived"]] if obj.get("placesLived") is not None else None,
            "plusOneCount": obj.get("plusOneCount"),
            "relationshipStatus": obj.get("relationshipStatus"),
            "skills": obj.get("skills"),
            "tagline": obj.get("tagline"),
            "url": obj.get("url"),
            "urls": [PersonUrlsInner.from_dict(_item) for _item in obj["urls"]] if obj.get("urls") is not None else None,
            "verified": obj.get("verified")
        })
        return _obj


