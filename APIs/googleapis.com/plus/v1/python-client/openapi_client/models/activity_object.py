# coding: utf-8

"""
    Google+ API

    Builds on top of the Google+ platform.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.activity_object_actor import ActivityObjectActor
from openapi_client.models.activity_object_attachments_inner import ActivityObjectAttachmentsInner
from openapi_client.models.activity_object_plusoners import ActivityObjectPlusoners
from openapi_client.models.activity_object_replies import ActivityObjectReplies
from openapi_client.models.activity_object_resharers import ActivityObjectResharers
from typing import Optional, Set
from typing_extensions import Self

class ActivityObject(BaseModel):
    """
    The object of this activity.
    """ # noqa: E501
    actor: Optional[ActivityObjectActor] = None
    attachments: Optional[List[ActivityObjectAttachmentsInner]] = Field(default=None, description="The media objects attached to this activity.")
    content: Optional[StrictStr] = Field(default=None, description="The HTML-formatted content, which is suitable for display.")
    id: Optional[StrictStr] = Field(default=None, description="The ID of the object. When resharing an activity, this is the ID of the activity that is being reshared.")
    object_type: Optional[StrictStr] = Field(default=None, description="The type of the object. Possible values include, but are not limited to, the following values:   - \"note\" - Textual content.  - \"activity\" - A Google+ activity.", alias="objectType")
    original_content: Optional[StrictStr] = Field(default=None, description="The content (text) as provided by the author, which is stored without any HTML formatting. When creating or updating an activity, this value must be supplied as plain text in the request.", alias="originalContent")
    plusoners: Optional[ActivityObjectPlusoners] = None
    replies: Optional[ActivityObjectReplies] = None
    resharers: Optional[ActivityObjectResharers] = None
    url: Optional[StrictStr] = Field(default=None, description="The URL that points to the linked resource.")
    __properties: ClassVar[List[str]] = ["actor", "attachments", "content", "id", "objectType", "originalContent", "plusoners", "replies", "resharers", "url"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ActivityObject from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of actor
        if self.actor:
            _dict['actor'] = self.actor.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in attachments (list)
        _items = []
        if self.attachments:
            for _item_attachments in self.attachments:
                if _item_attachments:
                    _items.append(_item_attachments.to_dict())
            _dict['attachments'] = _items
        # override the default output from pydantic by calling `to_dict()` of plusoners
        if self.plusoners:
            _dict['plusoners'] = self.plusoners.to_dict()
        # override the default output from pydantic by calling `to_dict()` of replies
        if self.replies:
            _dict['replies'] = self.replies.to_dict()
        # override the default output from pydantic by calling `to_dict()` of resharers
        if self.resharers:
            _dict['resharers'] = self.resharers.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ActivityObject from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "actor": ActivityObjectActor.from_dict(obj["actor"]) if obj.get("actor") is not None else None,
            "attachments": [ActivityObjectAttachmentsInner.from_dict(_item) for _item in obj["attachments"]] if obj.get("attachments") is not None else None,
            "content": obj.get("content"),
            "id": obj.get("id"),
            "objectType": obj.get("objectType"),
            "originalContent": obj.get("originalContent"),
            "plusoners": ActivityObjectPlusoners.from_dict(obj["plusoners"]) if obj.get("plusoners") is not None else None,
            "replies": ActivityObjectReplies.from_dict(obj["replies"]) if obj.get("replies") is not None else None,
            "resharers": ActivityObjectResharers.from_dict(obj["resharers"]) if obj.get("resharers") is not None else None,
            "url": obj.get("url")
        })
        return _obj


