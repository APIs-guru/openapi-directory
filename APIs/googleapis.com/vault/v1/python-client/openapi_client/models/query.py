# coding: utf-8

"""
    Google Vault API

    Retention and eDiscovery for Google Workspace. To work with Vault resources, the account must have the [required Vault privileges](https://support.google.com/vault/answer/2799699) and access to the matter. To access a matter, the account must have created the matter, have the matter shared with them, or have the **View All Matters** privilege. For example, to download an export, an account needs the **Manage Exports** privilege and the matter shared with them. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.account_info import AccountInfo
from openapi_client.models.calendar_options import CalendarOptions
from openapi_client.models.drive_options import DriveOptions
from openapi_client.models.hangouts_chat_info import HangoutsChatInfo
from openapi_client.models.hangouts_chat_options import HangoutsChatOptions
from openapi_client.models.mail_options import MailOptions
from openapi_client.models.org_unit_info import OrgUnitInfo
from openapi_client.models.shared_drive_info import SharedDriveInfo
from openapi_client.models.sites_url_info import SitesUrlInfo
from openapi_client.models.team_drive_info import TeamDriveInfo
from openapi_client.models.voice_options import VoiceOptions
from typing import Optional, Set
from typing_extensions import Self

class Query(BaseModel):
    """
    The query definition used for search and export.
    """ # noqa: E501
    account_info: Optional[AccountInfo] = Field(default=None, alias="accountInfo")
    calendar_options: Optional[CalendarOptions] = Field(default=None, alias="calendarOptions")
    corpus: Optional[StrictStr] = Field(default=None, description="The Google Workspace service to search.")
    data_scope: Optional[StrictStr] = Field(default=None, description="The data source to search.", alias="dataScope")
    drive_options: Optional[DriveOptions] = Field(default=None, alias="driveOptions")
    end_time: Optional[StrictStr] = Field(default=None, description="The end time for the search query. Specify in GMT. The value is rounded to 12 AM on the specified date.", alias="endTime")
    hangouts_chat_info: Optional[HangoutsChatInfo] = Field(default=None, alias="hangoutsChatInfo")
    hangouts_chat_options: Optional[HangoutsChatOptions] = Field(default=None, alias="hangoutsChatOptions")
    mail_options: Optional[MailOptions] = Field(default=None, alias="mailOptions")
    method: Optional[StrictStr] = Field(default=None, description="The entity to search. This field replaces **searchMethod** to support shared drives. When **searchMethod** is **TEAM_DRIVE**, the response of this field is **SHARED_DRIVE**.")
    org_unit_info: Optional[OrgUnitInfo] = Field(default=None, alias="orgUnitInfo")
    search_method: Optional[StrictStr] = Field(default=None, description="The search method to use.", alias="searchMethod")
    shared_drive_info: Optional[SharedDriveInfo] = Field(default=None, alias="sharedDriveInfo")
    sites_url_info: Optional[SitesUrlInfo] = Field(default=None, alias="sitesUrlInfo")
    start_time: Optional[StrictStr] = Field(default=None, description="The start time for the search query. Specify in GMT. The value is rounded to 12 AM on the specified date.", alias="startTime")
    team_drive_info: Optional[TeamDriveInfo] = Field(default=None, alias="teamDriveInfo")
    terms: Optional[StrictStr] = Field(default=None, description="Service-specific [search operators](https://support.google.com/vault/answer/2474474) to filter search results.")
    time_zone: Optional[StrictStr] = Field(default=None, description="The time zone name. It should be an IANA TZ name, such as \"America/Los_Angeles\". For a list of time zone names, see [Time Zone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For more information about how Vault uses time zones, see [the Vault help center](https://support.google.com/vault/answer/6092995#time).", alias="timeZone")
    voice_options: Optional[VoiceOptions] = Field(default=None, alias="voiceOptions")
    __properties: ClassVar[List[str]] = ["accountInfo", "calendarOptions", "corpus", "dataScope", "driveOptions", "endTime", "hangoutsChatInfo", "hangoutsChatOptions", "mailOptions", "method", "orgUnitInfo", "searchMethod", "sharedDriveInfo", "sitesUrlInfo", "startTime", "teamDriveInfo", "terms", "timeZone", "voiceOptions"]

    @field_validator('corpus')
    def corpus_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CORPUS_TYPE_UNSPECIFIED', 'DRIVE', 'MAIL', 'GROUPS', 'HANGOUTS_CHAT', 'VOICE', 'CALENDAR']):
            raise ValueError("must be one of enum values ('CORPUS_TYPE_UNSPECIFIED', 'DRIVE', 'MAIL', 'GROUPS', 'HANGOUTS_CHAT', 'VOICE', 'CALENDAR')")
        return value

    @field_validator('data_scope')
    def data_scope_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DATA_SCOPE_UNSPECIFIED', 'ALL_DATA', 'HELD_DATA', 'UNPROCESSED_DATA']):
            raise ValueError("must be one of enum values ('DATA_SCOPE_UNSPECIFIED', 'ALL_DATA', 'HELD_DATA', 'UNPROCESSED_DATA')")
        return value

    @field_validator('method')
    def method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SEARCH_METHOD_UNSPECIFIED', 'ACCOUNT', 'ORG_UNIT', 'TEAM_DRIVE', 'ENTIRE_ORG', 'ROOM', 'SITES_URL', 'SHARED_DRIVE']):
            raise ValueError("must be one of enum values ('SEARCH_METHOD_UNSPECIFIED', 'ACCOUNT', 'ORG_UNIT', 'TEAM_DRIVE', 'ENTIRE_ORG', 'ROOM', 'SITES_URL', 'SHARED_DRIVE')")
        return value

    @field_validator('search_method')
    def search_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SEARCH_METHOD_UNSPECIFIED', 'ACCOUNT', 'ORG_UNIT', 'TEAM_DRIVE', 'ENTIRE_ORG', 'ROOM', 'SITES_URL', 'SHARED_DRIVE']):
            raise ValueError("must be one of enum values ('SEARCH_METHOD_UNSPECIFIED', 'ACCOUNT', 'ORG_UNIT', 'TEAM_DRIVE', 'ENTIRE_ORG', 'ROOM', 'SITES_URL', 'SHARED_DRIVE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Query from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of account_info
        if self.account_info:
            _dict['accountInfo'] = self.account_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of calendar_options
        if self.calendar_options:
            _dict['calendarOptions'] = self.calendar_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of drive_options
        if self.drive_options:
            _dict['driveOptions'] = self.drive_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of hangouts_chat_info
        if self.hangouts_chat_info:
            _dict['hangoutsChatInfo'] = self.hangouts_chat_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of hangouts_chat_options
        if self.hangouts_chat_options:
            _dict['hangoutsChatOptions'] = self.hangouts_chat_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mail_options
        if self.mail_options:
            _dict['mailOptions'] = self.mail_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of org_unit_info
        if self.org_unit_info:
            _dict['orgUnitInfo'] = self.org_unit_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shared_drive_info
        if self.shared_drive_info:
            _dict['sharedDriveInfo'] = self.shared_drive_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sites_url_info
        if self.sites_url_info:
            _dict['sitesUrlInfo'] = self.sites_url_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of team_drive_info
        if self.team_drive_info:
            _dict['teamDriveInfo'] = self.team_drive_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of voice_options
        if self.voice_options:
            _dict['voiceOptions'] = self.voice_options.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Query from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accountInfo": AccountInfo.from_dict(obj["accountInfo"]) if obj.get("accountInfo") is not None else None,
            "calendarOptions": CalendarOptions.from_dict(obj["calendarOptions"]) if obj.get("calendarOptions") is not None else None,
            "corpus": obj.get("corpus"),
            "dataScope": obj.get("dataScope"),
            "driveOptions": DriveOptions.from_dict(obj["driveOptions"]) if obj.get("driveOptions") is not None else None,
            "endTime": obj.get("endTime"),
            "hangoutsChatInfo": HangoutsChatInfo.from_dict(obj["hangoutsChatInfo"]) if obj.get("hangoutsChatInfo") is not None else None,
            "hangoutsChatOptions": HangoutsChatOptions.from_dict(obj["hangoutsChatOptions"]) if obj.get("hangoutsChatOptions") is not None else None,
            "mailOptions": MailOptions.from_dict(obj["mailOptions"]) if obj.get("mailOptions") is not None else None,
            "method": obj.get("method"),
            "orgUnitInfo": OrgUnitInfo.from_dict(obj["orgUnitInfo"]) if obj.get("orgUnitInfo") is not None else None,
            "searchMethod": obj.get("searchMethod"),
            "sharedDriveInfo": SharedDriveInfo.from_dict(obj["sharedDriveInfo"]) if obj.get("sharedDriveInfo") is not None else None,
            "sitesUrlInfo": SitesUrlInfo.from_dict(obj["sitesUrlInfo"]) if obj.get("sitesUrlInfo") is not None else None,
            "startTime": obj.get("startTime"),
            "teamDriveInfo": TeamDriveInfo.from_dict(obj["teamDriveInfo"]) if obj.get("teamDriveInfo") is not None else None,
            "terms": obj.get("terms"),
            "timeZone": obj.get("timeZone"),
            "voiceOptions": VoiceOptions.from_dict(obj["voiceOptions"]) if obj.get("voiceOptions") is not None else None
        })
        return _obj


