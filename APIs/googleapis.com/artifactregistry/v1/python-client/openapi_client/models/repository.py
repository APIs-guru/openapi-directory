# coding: utf-8

"""
    Artifact Registry API

    Store and manage build artifacts in a scalable and integrated service built on Google infrastructure.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.cleanup_policy import CleanupPolicy
from openapi_client.models.docker_repository_config import DockerRepositoryConfig
from openapi_client.models.maven_repository_config import MavenRepositoryConfig
from openapi_client.models.remote_repository_config import RemoteRepositoryConfig
from openapi_client.models.virtual_repository_config import VirtualRepositoryConfig
from typing import Optional, Set
from typing_extensions import Self

class Repository(BaseModel):
    """
    A Repository for storing artifacts with a specific format.
    """ # noqa: E501
    cleanup_policies: Optional[Dict[str, CleanupPolicy]] = Field(default=None, description="Optional. Cleanup policies for this repository. Cleanup policies indicate when certain package versions can be automatically deleted. Map keys are policy IDs supplied by users during policy creation. They must unique within a repository and be under 128 characters in length.", alias="cleanupPolicies")
    cleanup_policy_dry_run: Optional[StrictBool] = Field(default=None, description="Optional. If true, the cleanup pipeline is prevented from deleting versions in this repository.", alias="cleanupPolicyDryRun")
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. The time when the repository was created.", alias="createTime")
    description: Optional[StrictStr] = Field(default=None, description="The user-provided description of the repository.")
    disallow_unspecified_mode: Optional[StrictBool] = Field(default=None, description="Optional. If this is true, aunspecified repo type will be treated as error. Is used for new repo types that don't have any specific fields. Right now is used by AOSS team when creating repos for customers.", alias="disallowUnspecifiedMode")
    docker_config: Optional[DockerRepositoryConfig] = Field(default=None, alias="dockerConfig")
    format: Optional[StrictStr] = Field(default=None, description="Optional. The format of packages that are stored in the repository.")
    kms_key_name: Optional[StrictStr] = Field(default=None, description="The Cloud KMS resource name of the customer managed encryption key that's used to encrypt the contents of the Repository. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. This value may not be changed after the Repository has been created.", alias="kmsKeyName")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Labels with user-defined metadata. This field may contain up to 64 entries. Label keys and values may be no longer than 63 characters. Label keys must begin with a lowercase letter and may only contain lowercase letters, numeric characters, underscores, and dashes.")
    maven_config: Optional[MavenRepositoryConfig] = Field(default=None, alias="mavenConfig")
    mode: Optional[StrictStr] = Field(default=None, description="Optional. The mode of the repository.")
    name: Optional[StrictStr] = Field(default=None, description="The name of the repository, for example: `projects/p1/locations/us-central1/repositories/repo1`.")
    remote_repository_config: Optional[RemoteRepositoryConfig] = Field(default=None, alias="remoteRepositoryConfig")
    satisfies_pzs: Optional[StrictBool] = Field(default=None, description="Output only. If set, the repository satisfies physical zone separation.", alias="satisfiesPzs")
    size_bytes: Optional[StrictStr] = Field(default=None, description="Output only. The size, in bytes, of all artifact storage in this repository. Repositories that are generally available or in public preview use this to calculate storage costs.", alias="sizeBytes")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. The time when the repository was last updated.", alias="updateTime")
    virtual_repository_config: Optional[VirtualRepositoryConfig] = Field(default=None, alias="virtualRepositoryConfig")
    __properties: ClassVar[List[str]] = ["cleanupPolicies", "cleanupPolicyDryRun", "createTime", "description", "disallowUnspecifiedMode", "dockerConfig", "format", "kmsKeyName", "labels", "mavenConfig", "mode", "name", "remoteRepositoryConfig", "satisfiesPzs", "sizeBytes", "updateTime", "virtualRepositoryConfig"]

    @field_validator('format')
    def format_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['FORMAT_UNSPECIFIED', 'DOCKER', 'MAVEN', 'NPM', 'APT', 'YUM', 'GOOGET', 'PYTHON', 'KFP', 'GO']):
            raise ValueError("must be one of enum values ('FORMAT_UNSPECIFIED', 'DOCKER', 'MAVEN', 'NPM', 'APT', 'YUM', 'GOOGET', 'PYTHON', 'KFP', 'GO')")
        return value

    @field_validator('mode')
    def mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MODE_UNSPECIFIED', 'STANDARD_REPOSITORY', 'VIRTUAL_REPOSITORY', 'REMOTE_REPOSITORY']):
            raise ValueError("must be one of enum values ('MODE_UNSPECIFIED', 'STANDARD_REPOSITORY', 'VIRTUAL_REPOSITORY', 'REMOTE_REPOSITORY')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Repository from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "satisfies_pzs",
            "size_bytes",
            "update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in cleanup_policies (dict)
        _field_dict = {}
        if self.cleanup_policies:
            for _key_cleanup_policies in self.cleanup_policies:
                if self.cleanup_policies[_key_cleanup_policies]:
                    _field_dict[_key_cleanup_policies] = self.cleanup_policies[_key_cleanup_policies].to_dict()
            _dict['cleanupPolicies'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of docker_config
        if self.docker_config:
            _dict['dockerConfig'] = self.docker_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of maven_config
        if self.maven_config:
            _dict['mavenConfig'] = self.maven_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of remote_repository_config
        if self.remote_repository_config:
            _dict['remoteRepositoryConfig'] = self.remote_repository_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of virtual_repository_config
        if self.virtual_repository_config:
            _dict['virtualRepositoryConfig'] = self.virtual_repository_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Repository from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "cleanupPolicies": dict(
                (_k, CleanupPolicy.from_dict(_v))
                for _k, _v in obj["cleanupPolicies"].items()
            )
            if obj.get("cleanupPolicies") is not None
            else None,
            "cleanupPolicyDryRun": obj.get("cleanupPolicyDryRun"),
            "createTime": obj.get("createTime"),
            "description": obj.get("description"),
            "disallowUnspecifiedMode": obj.get("disallowUnspecifiedMode"),
            "dockerConfig": DockerRepositoryConfig.from_dict(obj["dockerConfig"]) if obj.get("dockerConfig") is not None else None,
            "format": obj.get("format"),
            "kmsKeyName": obj.get("kmsKeyName"),
            "labels": obj.get("labels"),
            "mavenConfig": MavenRepositoryConfig.from_dict(obj["mavenConfig"]) if obj.get("mavenConfig") is not None else None,
            "mode": obj.get("mode"),
            "name": obj.get("name"),
            "remoteRepositoryConfig": RemoteRepositoryConfig.from_dict(obj["remoteRepositoryConfig"]) if obj.get("remoteRepositoryConfig") is not None else None,
            "satisfiesPzs": obj.get("satisfiesPzs"),
            "sizeBytes": obj.get("sizeBytes"),
            "updateTime": obj.get("updateTime"),
            "virtualRepositoryConfig": VirtualRepositoryConfig.from_dict(obj["virtualRepositoryConfig"]) if obj.get("virtualRepositoryConfig") is not None else None
        })
        return _obj


