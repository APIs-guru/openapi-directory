# coding: utf-8

"""
    Content API for Shopping

    Manage your product listings and accounts for Google Shopping

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.account_adwords_link import AccountAdwordsLink
from openapi_client.models.account_business_information import AccountBusinessInformation
from openapi_client.models.account_google_my_business_link import AccountGoogleMyBusinessLink
from openapi_client.models.account_user import AccountUser
from openapi_client.models.account_you_tube_channel_link import AccountYouTubeChannelLink
from typing import Optional, Set
from typing_extensions import Self

class Account(BaseModel):
    """
    Account data. After the creation of a new account it may take a few minutes before it is fully operational. The methods delete, insert, and update require the admin role.
    """ # noqa: E501
    adult_content: Optional[StrictBool] = Field(default=None, description="Indicates whether the merchant sells adult content.", alias="adultContent")
    adwords_links: Optional[List[AccountAdwordsLink]] = Field(default=None, description="List of linked AdWords accounts that are active or pending approval. To create a new link request, add a new link with status `active` to the list. It will remain in a `pending` state until approved or rejected either in the AdWords interface or through the AdWords API. To delete an active link, or to cancel a link request, remove it from the list.", alias="adwordsLinks")
    business_information: Optional[AccountBusinessInformation] = Field(default=None, alias="businessInformation")
    google_my_business_link: Optional[AccountGoogleMyBusinessLink] = Field(default=None, alias="googleMyBusinessLink")
    id: Optional[StrictStr] = Field(default=None, description="Required for update. Merchant Center account ID.")
    kind: Optional[StrictStr] = Field(default=None, description="Identifies what kind of resource this is. Value: the fixed string \"`content#account`\"")
    name: Optional[StrictStr] = Field(default=None, description="Required. Display name for the account.")
    reviews_url: Optional[StrictStr] = Field(default=None, description="[DEPRECATED] This field is never returned and will be ignored if provided.", alias="reviewsUrl")
    seller_id: Optional[StrictStr] = Field(default=None, description="Client-specific, locally-unique, internal ID for the child account.", alias="sellerId")
    users: Optional[List[AccountUser]] = Field(default=None, description="Users with access to the account. Every account (except for subaccounts) must have at least one admin user.")
    website_url: Optional[StrictStr] = Field(default=None, description="The merchant's website.", alias="websiteUrl")
    youtube_channel_links: Optional[List[AccountYouTubeChannelLink]] = Field(default=None, description="List of linked YouTube channels that are active or pending approval. To create a new link request, add a new link with status `active` to the list. It will remain in a `pending` state until approved or rejected in the YT Creator Studio interface. To delete an active link, or to cancel a link request, remove it from the list.", alias="youtubeChannelLinks")
    __properties: ClassVar[List[str]] = ["adultContent", "adwordsLinks", "businessInformation", "googleMyBusinessLink", "id", "kind", "name", "reviewsUrl", "sellerId", "users", "websiteUrl", "youtubeChannelLinks"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Account from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in adwords_links (list)
        _items = []
        if self.adwords_links:
            for _item_adwords_links in self.adwords_links:
                if _item_adwords_links:
                    _items.append(_item_adwords_links.to_dict())
            _dict['adwordsLinks'] = _items
        # override the default output from pydantic by calling `to_dict()` of business_information
        if self.business_information:
            _dict['businessInformation'] = self.business_information.to_dict()
        # override the default output from pydantic by calling `to_dict()` of google_my_business_link
        if self.google_my_business_link:
            _dict['googleMyBusinessLink'] = self.google_my_business_link.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in users (list)
        _items = []
        if self.users:
            for _item_users in self.users:
                if _item_users:
                    _items.append(_item_users.to_dict())
            _dict['users'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in youtube_channel_links (list)
        _items = []
        if self.youtube_channel_links:
            for _item_youtube_channel_links in self.youtube_channel_links:
                if _item_youtube_channel_links:
                    _items.append(_item_youtube_channel_links.to_dict())
            _dict['youtubeChannelLinks'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Account from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "adultContent": obj.get("adultContent"),
            "adwordsLinks": [AccountAdwordsLink.from_dict(_item) for _item in obj["adwordsLinks"]] if obj.get("adwordsLinks") is not None else None,
            "businessInformation": AccountBusinessInformation.from_dict(obj["businessInformation"]) if obj.get("businessInformation") is not None else None,
            "googleMyBusinessLink": AccountGoogleMyBusinessLink.from_dict(obj["googleMyBusinessLink"]) if obj.get("googleMyBusinessLink") is not None else None,
            "id": obj.get("id"),
            "kind": obj.get("kind"),
            "name": obj.get("name"),
            "reviewsUrl": obj.get("reviewsUrl"),
            "sellerId": obj.get("sellerId"),
            "users": [AccountUser.from_dict(_item) for _item in obj["users"]] if obj.get("users") is not None else None,
            "websiteUrl": obj.get("websiteUrl"),
            "youtubeChannelLinks": [AccountYouTubeChannelLink.from_dict(_item) for _item in obj["youtubeChannelLinks"]] if obj.get("youtubeChannelLinks") is not None else None
        })
        return _obj


