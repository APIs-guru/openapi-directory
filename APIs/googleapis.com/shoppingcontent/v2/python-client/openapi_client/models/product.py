# coding: utf-8

"""
    Content API for Shopping

    Manage your product listings and accounts for Google Shopping

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.custom_attribute import CustomAttribute
from openapi_client.models.custom_group import CustomGroup
from openapi_client.models.error import Error
from openapi_client.models.installment import Installment
from openapi_client.models.loyalty_points import LoyaltyPoints
from openapi_client.models.price import Price
from openapi_client.models.product_aspect import ProductAspect
from openapi_client.models.product_destination import ProductDestination
from openapi_client.models.product_shipping import ProductShipping
from openapi_client.models.product_shipping_dimension import ProductShippingDimension
from openapi_client.models.product_shipping_weight import ProductShippingWeight
from openapi_client.models.product_tax import ProductTax
from openapi_client.models.product_unit_pricing_base_measure import ProductUnitPricingBaseMeasure
from openapi_client.models.product_unit_pricing_measure import ProductUnitPricingMeasure
from typing import Optional, Set
from typing_extensions import Self

class Product(BaseModel):
    """
     Required product attributes are primarily defined by the products data specification. See the Products Data Specification Help Center article for information. Product data. After inserting, updating, or deleting a product, it may take several minutes before changes take effect.
    """ # noqa: E501
    additional_image_links: Optional[List[StrictStr]] = Field(default=None, description="Additional URLs of images of the item.", alias="additionalImageLinks")
    additional_product_types: Optional[List[StrictStr]] = Field(default=None, description="Additional categories of the item (formatted as in products data specification).", alias="additionalProductTypes")
    adult: Optional[StrictBool] = Field(default=None, description="Should be set to true if the item is targeted towards adults.")
    adwords_grouping: Optional[StrictStr] = Field(default=None, description="Used to group items in an arbitrary way. Only for CPA%, discouraged otherwise.", alias="adwordsGrouping")
    adwords_labels: Optional[List[StrictStr]] = Field(default=None, description="Similar to adwords_grouping, but only works on CPC.", alias="adwordsLabels")
    adwords_redirect: Optional[StrictStr] = Field(default=None, description="Allows advertisers to override the item URL when the product is shown within the context of Product Ads.", alias="adwordsRedirect")
    age_group: Optional[StrictStr] = Field(default=None, description="Target age group of the item. Acceptable values are: - \"`adult`\" - \"`infant`\" - \"`kids`\" - \"`newborn`\" - \"`toddler`\" - \"`youngAdult`\" ", alias="ageGroup")
    aspects: Optional[List[ProductAspect]] = Field(default=None, description="Deprecated. Do not use.")
    availability: Optional[StrictStr] = Field(default=None, description="Availability status of the item. Acceptable values are: - \"`in stock`\" - \"`out of stock`\" - \"`preorder`\" ")
    availability_date: Optional[StrictStr] = Field(default=None, description="The day a pre-ordered product becomes available for delivery, in ISO 8601 format.", alias="availabilityDate")
    brand: Optional[StrictStr] = Field(default=None, description="Brand of the item.")
    canonical_link: Optional[StrictStr] = Field(default=None, description="URL for the canonical version of your item's landing page.", alias="canonicalLink")
    channel: Optional[StrictStr] = Field(default=None, description="Required. The item's channel (online or local). Acceptable values are: - \"`local`\" - \"`online`\" ")
    color: Optional[StrictStr] = Field(default=None, description="Color of the item.")
    condition: Optional[StrictStr] = Field(default=None, description="Condition or state of the item. Acceptable values are: - \"`new`\" - \"`refurbished`\" - \"`used`\" ")
    content_language: Optional[StrictStr] = Field(default=None, description="Required. The two-letter ISO 639-1 language code for the item.", alias="contentLanguage")
    cost_of_goods_sold: Optional[Price] = Field(default=None, alias="costOfGoodsSold")
    custom_attributes: Optional[List[CustomAttribute]] = Field(default=None, description="A list of custom (merchant-provided) attributes. It can also be used for submitting any attribute of the feed specification in its generic form (e.g., `{ \"name\": \"size type\", \"value\": \"regular\" }`). This is useful for submitting attributes not explicitly exposed by the API, such as additional attributes used for Buy on Google (formerly known as Shopping Actions).", alias="customAttributes")
    custom_groups: Optional[List[CustomGroup]] = Field(default=None, description="A list of custom (merchant-provided) custom attribute groups.", alias="customGroups")
    custom_label0: Optional[StrictStr] = Field(default=None, description="Custom label 0 for custom grouping of items in a Shopping campaign.", alias="customLabel0")
    custom_label1: Optional[StrictStr] = Field(default=None, description="Custom label 1 for custom grouping of items in a Shopping campaign.", alias="customLabel1")
    custom_label2: Optional[StrictStr] = Field(default=None, description="Custom label 2 for custom grouping of items in a Shopping campaign.", alias="customLabel2")
    custom_label3: Optional[StrictStr] = Field(default=None, description="Custom label 3 for custom grouping of items in a Shopping campaign.", alias="customLabel3")
    custom_label4: Optional[StrictStr] = Field(default=None, description="Custom label 4 for custom grouping of items in a Shopping campaign.", alias="customLabel4")
    description: Optional[StrictStr] = Field(default=None, description="Description of the item.")
    destinations: Optional[List[ProductDestination]] = Field(default=None, description="Specifies the intended destinations for the product.")
    display_ads_id: Optional[StrictStr] = Field(default=None, description="An identifier for an item for dynamic remarketing campaigns.", alias="displayAdsId")
    display_ads_link: Optional[StrictStr] = Field(default=None, description="URL directly to your item's landing page for dynamic remarketing campaigns.", alias="displayAdsLink")
    display_ads_similar_ids: Optional[List[StrictStr]] = Field(default=None, description="Advertiser-specified recommendations.", alias="displayAdsSimilarIds")
    display_ads_title: Optional[StrictStr] = Field(default=None, description="Title of an item for dynamic remarketing campaigns.", alias="displayAdsTitle")
    display_ads_value: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Offer margin for dynamic remarketing campaigns.", alias="displayAdsValue")
    energy_efficiency_class: Optional[StrictStr] = Field(default=None, description="The energy efficiency class as defined in EU directive 2010/30/EU. Acceptable values are: - \"`A`\" - \"`A+`\" - \"`A++`\" - \"`A+++`\" - \"`B`\" - \"`C`\" - \"`D`\" - \"`E`\" - \"`F`\" - \"`G`\" ", alias="energyEfficiencyClass")
    expiration_date: Optional[StrictStr] = Field(default=None, description="Date on which the item should expire, as specified upon insertion, in ISO 8601 format. The actual expiration date in Google Shopping is exposed in `productstatuses` as `googleExpirationDate` and might be earlier if `expirationDate` is too far in the future.", alias="expirationDate")
    gender: Optional[StrictStr] = Field(default=None, description="Target gender of the item. Acceptable values are: - \"`female`\" - \"`male`\" - \"`unisex`\" ")
    google_product_category: Optional[StrictStr] = Field(default=None, description="Google's category of the item (see [Google product taxonomy](https://support.google.com/merchants/answer/1705911)). When querying products, this field will contain the user provided value. There is currently no way to get back the auto assigned google product categories through the API.", alias="googleProductCategory")
    gtin: Optional[StrictStr] = Field(default=None, description="Global Trade Item Number (GTIN) of the item.")
    id: Optional[StrictStr] = Field(default=None, description="The REST ID of the product. Content API methods that operate on products take this as their `productId` parameter. The REST ID for a product is of the form channel:contentLanguage: targetCountry: offerId.")
    identifier_exists: Optional[StrictBool] = Field(default=None, description="False when the item does not have unique product identifiers appropriate to its category, such as GTIN, MPN, and brand. Required according to the Unique Product Identifier Rules for all target countries except for Canada.", alias="identifierExists")
    image_link: Optional[StrictStr] = Field(default=None, description="URL of an image of the item.", alias="imageLink")
    installment: Optional[Installment] = None
    is_bundle: Optional[StrictBool] = Field(default=None, description="Whether the item is a merchant-defined bundle. A bundle is a custom grouping of different products sold by a merchant for a single price.", alias="isBundle")
    item_group_id: Optional[StrictStr] = Field(default=None, description="Shared identifier for all variants of the same product.", alias="itemGroupId")
    kind: Optional[StrictStr] = Field(default=None, description="Identifies what kind of resource this is. Value: the fixed string \"`content#product`\"")
    link: Optional[StrictStr] = Field(default=None, description="URL directly linking to your item's page on your website.")
    loyalty_points: Optional[LoyaltyPoints] = Field(default=None, alias="loyaltyPoints")
    material: Optional[StrictStr] = Field(default=None, description="The material of which the item is made.")
    max_energy_efficiency_class: Optional[StrictStr] = Field(default=None, description="The energy efficiency class as defined in EU directive 2010/30/EU. Acceptable values are: - \"`A`\" - \"`A+`\" - \"`A++`\" - \"`A+++`\" - \"`B`\" - \"`C`\" - \"`D`\" - \"`E`\" - \"`F`\" - \"`G`\" ", alias="maxEnergyEfficiencyClass")
    max_handling_time: Optional[StrictStr] = Field(default=None, description="Maximal product handling time (in business days).", alias="maxHandlingTime")
    min_energy_efficiency_class: Optional[StrictStr] = Field(default=None, description="The energy efficiency class as defined in EU directive 2010/30/EU. Acceptable values are: - \"`A`\" - \"`A+`\" - \"`A++`\" - \"`A+++`\" - \"`B`\" - \"`C`\" - \"`D`\" - \"`E`\" - \"`F`\" - \"`G`\" ", alias="minEnergyEfficiencyClass")
    min_handling_time: Optional[StrictStr] = Field(default=None, description="Minimal product handling time (in business days).", alias="minHandlingTime")
    mobile_link: Optional[StrictStr] = Field(default=None, description="URL for the mobile-optimized version of your item's landing page.", alias="mobileLink")
    mpn: Optional[StrictStr] = Field(default=None, description="Manufacturer Part Number (MPN) of the item.")
    multipack: Optional[StrictStr] = Field(default=None, description="The number of identical products in a merchant-defined multipack.")
    offer_id: Optional[StrictStr] = Field(default=None, description="Required. A unique identifier for the item. Leading and trailing whitespaces are stripped and multiple whitespaces are replaced by a single whitespace upon submission. Only valid unicode characters are accepted. See the products feed specification for details. *Note:* Content API methods that operate on products take the REST ID of the product, *not* this identifier.", alias="offerId")
    online_only: Optional[StrictBool] = Field(default=None, description="Deprecated.", alias="onlineOnly")
    pattern: Optional[StrictStr] = Field(default=None, description="The item's pattern (e.g. polka dots).")
    price: Optional[Price] = None
    product_type: Optional[StrictStr] = Field(default=None, description="Your category of the item (formatted as in products data specification).", alias="productType")
    promotion_ids: Optional[List[StrictStr]] = Field(default=None, description="The unique ID of a promotion.", alias="promotionIds")
    sale_price: Optional[Price] = Field(default=None, alias="salePrice")
    sale_price_effective_date: Optional[StrictStr] = Field(default=None, description="Date range during which the item is on sale (see products data specification ).", alias="salePriceEffectiveDate")
    sell_on_google_quantity: Optional[StrictStr] = Field(default=None, description="The quantity of the product that is available for selling on Google. Supported only for online products.", alias="sellOnGoogleQuantity")
    shipping: Optional[List[ProductShipping]] = Field(default=None, description="Shipping rules.")
    shipping_height: Optional[ProductShippingDimension] = Field(default=None, alias="shippingHeight")
    shipping_label: Optional[StrictStr] = Field(default=None, description="The shipping label of the product, used to group product in account-level shipping rules.", alias="shippingLabel")
    shipping_length: Optional[ProductShippingDimension] = Field(default=None, alias="shippingLength")
    shipping_weight: Optional[ProductShippingWeight] = Field(default=None, alias="shippingWeight")
    shipping_width: Optional[ProductShippingDimension] = Field(default=None, alias="shippingWidth")
    size_system: Optional[StrictStr] = Field(default=None, description="System in which the size is specified. Recommended for apparel items. Acceptable values are: - \"`AU`\" - \"`BR`\" - \"`CN`\" - \"`DE`\" - \"`EU`\" - \"`FR`\" - \"`IT`\" - \"`JP`\" - \"`MEX`\" - \"`UK`\" - \"`US`\" ", alias="sizeSystem")
    size_type: Optional[StrictStr] = Field(default=None, description="The cut of the item. Recommended for apparel items. Acceptable values are: - \"`big and tall`\" - \"`maternity`\" - \"`oversize`\" - \"`petite`\" - \"`plus`\" - \"`regular`\" ", alias="sizeType")
    sizes: Optional[List[StrictStr]] = Field(default=None, description="Size of the item. Only one value is allowed. For variants with different sizes, insert a separate product for each size with the same `itemGroupId` value (see size definition).")
    source: Optional[StrictStr] = Field(default=None, description="The source of the offer, i.e., how the offer was created. Acceptable values are: - \"`api`\" - \"`crawl`\" - \"`feed`\" ")
    target_country: Optional[StrictStr] = Field(default=None, description="Required. The CLDR territory code for the item.", alias="targetCountry")
    taxes: Optional[List[ProductTax]] = Field(default=None, description="Tax information.")
    title: Optional[StrictStr] = Field(default=None, description="Title of the item.")
    unit_pricing_base_measure: Optional[ProductUnitPricingBaseMeasure] = Field(default=None, alias="unitPricingBaseMeasure")
    unit_pricing_measure: Optional[ProductUnitPricingMeasure] = Field(default=None, alias="unitPricingMeasure")
    validated_destinations: Optional[List[StrictStr]] = Field(default=None, description="Deprecated. The read-only list of intended destinations which passed validation.", alias="validatedDestinations")
    warnings: Optional[List[Error]] = Field(default=None, description="Read-only warnings.")
    __properties: ClassVar[List[str]] = ["additionalImageLinks", "additionalProductTypes", "adult", "adwordsGrouping", "adwordsLabels", "adwordsRedirect", "ageGroup", "aspects", "availability", "availabilityDate", "brand", "canonicalLink", "channel", "color", "condition", "contentLanguage", "costOfGoodsSold", "customAttributes", "customGroups", "customLabel0", "customLabel1", "customLabel2", "customLabel3", "customLabel4", "description", "destinations", "displayAdsId", "displayAdsLink", "displayAdsSimilarIds", "displayAdsTitle", "displayAdsValue", "energyEfficiencyClass", "expirationDate", "gender", "googleProductCategory", "gtin", "id", "identifierExists", "imageLink", "installment", "isBundle", "itemGroupId", "kind", "link", "loyaltyPoints", "material", "maxEnergyEfficiencyClass", "maxHandlingTime", "minEnergyEfficiencyClass", "minHandlingTime", "mobileLink", "mpn", "multipack", "offerId", "onlineOnly", "pattern", "price", "productType", "promotionIds", "salePrice", "salePriceEffectiveDate", "sellOnGoogleQuantity", "shipping", "shippingHeight", "shippingLabel", "shippingLength", "shippingWeight", "shippingWidth", "sizeSystem", "sizeType", "sizes", "source", "targetCountry", "taxes", "title", "unitPricingBaseMeasure", "unitPricingMeasure", "validatedDestinations", "warnings"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Product from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in aspects (list)
        _items = []
        if self.aspects:
            for _item_aspects in self.aspects:
                if _item_aspects:
                    _items.append(_item_aspects.to_dict())
            _dict['aspects'] = _items
        # override the default output from pydantic by calling `to_dict()` of cost_of_goods_sold
        if self.cost_of_goods_sold:
            _dict['costOfGoodsSold'] = self.cost_of_goods_sold.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in custom_attributes (list)
        _items = []
        if self.custom_attributes:
            for _item_custom_attributes in self.custom_attributes:
                if _item_custom_attributes:
                    _items.append(_item_custom_attributes.to_dict())
            _dict['customAttributes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in custom_groups (list)
        _items = []
        if self.custom_groups:
            for _item_custom_groups in self.custom_groups:
                if _item_custom_groups:
                    _items.append(_item_custom_groups.to_dict())
            _dict['customGroups'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in destinations (list)
        _items = []
        if self.destinations:
            for _item_destinations in self.destinations:
                if _item_destinations:
                    _items.append(_item_destinations.to_dict())
            _dict['destinations'] = _items
        # override the default output from pydantic by calling `to_dict()` of installment
        if self.installment:
            _dict['installment'] = self.installment.to_dict()
        # override the default output from pydantic by calling `to_dict()` of loyalty_points
        if self.loyalty_points:
            _dict['loyaltyPoints'] = self.loyalty_points.to_dict()
        # override the default output from pydantic by calling `to_dict()` of price
        if self.price:
            _dict['price'] = self.price.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sale_price
        if self.sale_price:
            _dict['salePrice'] = self.sale_price.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in shipping (list)
        _items = []
        if self.shipping:
            for _item_shipping in self.shipping:
                if _item_shipping:
                    _items.append(_item_shipping.to_dict())
            _dict['shipping'] = _items
        # override the default output from pydantic by calling `to_dict()` of shipping_height
        if self.shipping_height:
            _dict['shippingHeight'] = self.shipping_height.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shipping_length
        if self.shipping_length:
            _dict['shippingLength'] = self.shipping_length.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shipping_weight
        if self.shipping_weight:
            _dict['shippingWeight'] = self.shipping_weight.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shipping_width
        if self.shipping_width:
            _dict['shippingWidth'] = self.shipping_width.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in taxes (list)
        _items = []
        if self.taxes:
            for _item_taxes in self.taxes:
                if _item_taxes:
                    _items.append(_item_taxes.to_dict())
            _dict['taxes'] = _items
        # override the default output from pydantic by calling `to_dict()` of unit_pricing_base_measure
        if self.unit_pricing_base_measure:
            _dict['unitPricingBaseMeasure'] = self.unit_pricing_base_measure.to_dict()
        # override the default output from pydantic by calling `to_dict()` of unit_pricing_measure
        if self.unit_pricing_measure:
            _dict['unitPricingMeasure'] = self.unit_pricing_measure.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in warnings (list)
        _items = []
        if self.warnings:
            for _item_warnings in self.warnings:
                if _item_warnings:
                    _items.append(_item_warnings.to_dict())
            _dict['warnings'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Product from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "additionalImageLinks": obj.get("additionalImageLinks"),
            "additionalProductTypes": obj.get("additionalProductTypes"),
            "adult": obj.get("adult"),
            "adwordsGrouping": obj.get("adwordsGrouping"),
            "adwordsLabels": obj.get("adwordsLabels"),
            "adwordsRedirect": obj.get("adwordsRedirect"),
            "ageGroup": obj.get("ageGroup"),
            "aspects": [ProductAspect.from_dict(_item) for _item in obj["aspects"]] if obj.get("aspects") is not None else None,
            "availability": obj.get("availability"),
            "availabilityDate": obj.get("availabilityDate"),
            "brand": obj.get("brand"),
            "canonicalLink": obj.get("canonicalLink"),
            "channel": obj.get("channel"),
            "color": obj.get("color"),
            "condition": obj.get("condition"),
            "contentLanguage": obj.get("contentLanguage"),
            "costOfGoodsSold": Price.from_dict(obj["costOfGoodsSold"]) if obj.get("costOfGoodsSold") is not None else None,
            "customAttributes": [CustomAttribute.from_dict(_item) for _item in obj["customAttributes"]] if obj.get("customAttributes") is not None else None,
            "customGroups": [CustomGroup.from_dict(_item) for _item in obj["customGroups"]] if obj.get("customGroups") is not None else None,
            "customLabel0": obj.get("customLabel0"),
            "customLabel1": obj.get("customLabel1"),
            "customLabel2": obj.get("customLabel2"),
            "customLabel3": obj.get("customLabel3"),
            "customLabel4": obj.get("customLabel4"),
            "description": obj.get("description"),
            "destinations": [ProductDestination.from_dict(_item) for _item in obj["destinations"]] if obj.get("destinations") is not None else None,
            "displayAdsId": obj.get("displayAdsId"),
            "displayAdsLink": obj.get("displayAdsLink"),
            "displayAdsSimilarIds": obj.get("displayAdsSimilarIds"),
            "displayAdsTitle": obj.get("displayAdsTitle"),
            "displayAdsValue": obj.get("displayAdsValue"),
            "energyEfficiencyClass": obj.get("energyEfficiencyClass"),
            "expirationDate": obj.get("expirationDate"),
            "gender": obj.get("gender"),
            "googleProductCategory": obj.get("googleProductCategory"),
            "gtin": obj.get("gtin"),
            "id": obj.get("id"),
            "identifierExists": obj.get("identifierExists"),
            "imageLink": obj.get("imageLink"),
            "installment": Installment.from_dict(obj["installment"]) if obj.get("installment") is not None else None,
            "isBundle": obj.get("isBundle"),
            "itemGroupId": obj.get("itemGroupId"),
            "kind": obj.get("kind"),
            "link": obj.get("link"),
            "loyaltyPoints": LoyaltyPoints.from_dict(obj["loyaltyPoints"]) if obj.get("loyaltyPoints") is not None else None,
            "material": obj.get("material"),
            "maxEnergyEfficiencyClass": obj.get("maxEnergyEfficiencyClass"),
            "maxHandlingTime": obj.get("maxHandlingTime"),
            "minEnergyEfficiencyClass": obj.get("minEnergyEfficiencyClass"),
            "minHandlingTime": obj.get("minHandlingTime"),
            "mobileLink": obj.get("mobileLink"),
            "mpn": obj.get("mpn"),
            "multipack": obj.get("multipack"),
            "offerId": obj.get("offerId"),
            "onlineOnly": obj.get("onlineOnly"),
            "pattern": obj.get("pattern"),
            "price": Price.from_dict(obj["price"]) if obj.get("price") is not None else None,
            "productType": obj.get("productType"),
            "promotionIds": obj.get("promotionIds"),
            "salePrice": Price.from_dict(obj["salePrice"]) if obj.get("salePrice") is not None else None,
            "salePriceEffectiveDate": obj.get("salePriceEffectiveDate"),
            "sellOnGoogleQuantity": obj.get("sellOnGoogleQuantity"),
            "shipping": [ProductShipping.from_dict(_item) for _item in obj["shipping"]] if obj.get("shipping") is not None else None,
            "shippingHeight": ProductShippingDimension.from_dict(obj["shippingHeight"]) if obj.get("shippingHeight") is not None else None,
            "shippingLabel": obj.get("shippingLabel"),
            "shippingLength": ProductShippingDimension.from_dict(obj["shippingLength"]) if obj.get("shippingLength") is not None else None,
            "shippingWeight": ProductShippingWeight.from_dict(obj["shippingWeight"]) if obj.get("shippingWeight") is not None else None,
            "shippingWidth": ProductShippingDimension.from_dict(obj["shippingWidth"]) if obj.get("shippingWidth") is not None else None,
            "sizeSystem": obj.get("sizeSystem"),
            "sizeType": obj.get("sizeType"),
            "sizes": obj.get("sizes"),
            "source": obj.get("source"),
            "targetCountry": obj.get("targetCountry"),
            "taxes": [ProductTax.from_dict(_item) for _item in obj["taxes"]] if obj.get("taxes") is not None else None,
            "title": obj.get("title"),
            "unitPricingBaseMeasure": ProductUnitPricingBaseMeasure.from_dict(obj["unitPricingBaseMeasure"]) if obj.get("unitPricingBaseMeasure") is not None else None,
            "unitPricingMeasure": ProductUnitPricingMeasure.from_dict(obj["unitPricingMeasure"]) if obj.get("unitPricingMeasure") is not None else None,
            "validatedDestinations": obj.get("validatedDestinations"),
            "warnings": [Error.from_dict(_item) for _item in obj["warnings"]] if obj.get("warnings") is not None else None
        })
        return _obj


