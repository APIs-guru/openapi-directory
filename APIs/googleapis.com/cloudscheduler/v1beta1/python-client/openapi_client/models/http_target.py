# coding: utf-8

"""
    Cloud Scheduler API

    Creates and manages jobs run on a regular recurring schedule.

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBytes, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.o_auth_token import OAuthToken
from openapi_client.models.oidc_token import OidcToken
from typing import Optional, Set
from typing_extensions import Self

class HttpTarget(BaseModel):
    """
    Http target. The job will be pushed to the job handler by means of an HTTP request via an http_method such as HTTP POST, HTTP GET, etc. The job is acknowledged by means of an HTTP response code in the range [200 - 299]. A failure to receive a response constitutes a failed execution. For a redirected request, the response returned by the redirected request is considered.
    """ # noqa: E501
    body: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="HTTP request body. A request body is allowed only if the HTTP method is POST, PUT, or PATCH. It is an error to set body on a job with an incompatible HttpMethod.")
    headers: Optional[Dict[str, StrictStr]] = Field(default=None, description="HTTP request headers. This map contains the header field names and values. The user can specify HTTP request headers to send with the job's HTTP request. Repeated headers are not supported, but a header value can contain commas. The following headers represent a subset of the headers that accompany the job's HTTP request. Some HTTP request headers are ignored or replaced. A partial list of headers that are ignored or replaced is below: * Host: This will be computed by Cloud Scheduler and derived from uri. * `Content-Length`: This will be computed by Cloud Scheduler. * `User-Agent`: This will be set to `\"Google-Cloud-Scheduler\"`. * `X-Google-*`: Google internal use only. * `X-AppEngine-*`: Google internal use only. * `X-CloudScheduler`: This header will be set to true. * `X-CloudScheduler-JobName`: This header will contain the job name. * `X-CloudScheduler-ScheduleTime`: For Cloud Scheduler jobs specified in the unix-cron format, this header will contain the job schedule as an offset of UTC parsed according to RFC3339. If the job has a body and the following headers are not set by the user, Cloud Scheduler sets default values: * `Content-Type`: This will be set to `\"application/octet-stream\"`. You can override this default by explicitly setting `Content-Type` to a particular media type when creating the job. For example, you can set `Content-Type` to `\"application/json\"`. The total size of headers must be less than 80KB.")
    http_method: Optional[StrictStr] = Field(default=None, description="Which HTTP method to use for the request.", alias="httpMethod")
    oauth_token: Optional[OAuthToken] = Field(default=None, alias="oauthToken")
    oidc_token: Optional[OidcToken] = Field(default=None, alias="oidcToken")
    uri: Optional[StrictStr] = Field(default=None, description="Required. The full URI path that the request will be sent to. This string must begin with either \"http://\" or \"https://\". Some examples of valid values for uri are: `http://acme.com` and `https://acme.com/sales:8080`. Cloud Scheduler will encode some characters for safety and compatibility. The maximum allowed URL length is 2083 characters after encoding.")
    __properties: ClassVar[List[str]] = ["body", "headers", "httpMethod", "oauthToken", "oidcToken", "uri"]

    @field_validator('http_method')
    def http_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['HTTP_METHOD_UNSPECIFIED', 'POST', 'GET', 'HEAD', 'PUT', 'DELETE', 'PATCH', 'OPTIONS']):
            raise ValueError("must be one of enum values ('HTTP_METHOD_UNSPECIFIED', 'POST', 'GET', 'HEAD', 'PUT', 'DELETE', 'PATCH', 'OPTIONS')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of HttpTarget from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of oauth_token
        if self.oauth_token:
            _dict['oauthToken'] = self.oauth_token.to_dict()
        # override the default output from pydantic by calling `to_dict()` of oidc_token
        if self.oidc_token:
            _dict['oidcToken'] = self.oidc_token.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of HttpTarget from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "body": obj.get("body"),
            "headers": obj.get("headers"),
            "httpMethod": obj.get("httpMethod"),
            "oauthToken": OAuthToken.from_dict(obj["oauthToken"]) if obj.get("oauthToken") is not None else None,
            "oidcToken": OidcToken.from_dict(obj["oidcToken"]) if obj.get("oidcToken") is not None else None,
            "uri": obj.get("uri")
        })
        return _obj


