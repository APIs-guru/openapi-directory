# coding: utf-8

"""
    Cloud Scheduler API

    Creates and manages jobs run on a regular recurring schedule.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.app_engine_http_target import AppEngineHttpTarget
from openapi_client.models.http_target import HttpTarget
from openapi_client.models.pubsub_target import PubsubTarget
from openapi_client.models.retry_config import RetryConfig
from openapi_client.models.status import Status
from typing import Optional, Set
from typing_extensions import Self

class Job(BaseModel):
    """
    Configuration for a job. The maximum allowed size for a job is 1MB.
    """ # noqa: E501
    app_engine_http_target: Optional[AppEngineHttpTarget] = Field(default=None, alias="appEngineHttpTarget")
    attempt_deadline: Optional[StrictStr] = Field(default=None, description="The deadline for job attempts. If the request handler does not respond by this deadline then the request is cancelled and the attempt is marked as a `DEADLINE_EXCEEDED` failure. The failed attempt can be viewed in execution logs. Cloud Scheduler will retry the job according to the RetryConfig. The default and the allowed values depend on the type of target: * For HTTP targets, the default is 3 minutes. The deadline must be in the interval [15 seconds, 30 minutes]. * For App Engine HTTP targets, 0 indicates that the request has the default deadline. The default deadline depends on the scaling type of the service: 10 minutes for standard apps with automatic scaling, 24 hours for standard apps with manual and basic scaling, and 60 minutes for flex apps. If the request deadline is set, it must be in the interval [15 seconds, 24 hours 15 seconds]. * For Pub/Sub targets, this field is ignored.", alias="attemptDeadline")
    description: Optional[StrictStr] = Field(default=None, description="Optionally caller-specified in CreateJob or UpdateJob. A human-readable description for the job. This string must not contain more than 500 characters.")
    http_target: Optional[HttpTarget] = Field(default=None, alias="httpTarget")
    last_attempt_time: Optional[StrictStr] = Field(default=None, description="Output only. The time the last job attempt started.", alias="lastAttemptTime")
    name: Optional[StrictStr] = Field(default=None, description="Optionally caller-specified in CreateJob, after which it becomes output only. The job name. For example: `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`. * `PROJECT_ID` can contain letters ([A-Za-z]), numbers ([0-9]), hyphens (-), colons (:), or periods (.). For more information, see [Identifying projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects) * `LOCATION_ID` is the canonical ID for the job's location. The list of available locations can be obtained by calling ListLocations. For more information, see https://cloud.google.com/about/locations/. * `JOB_ID` can contain only letters ([A-Za-z]), numbers ([0-9]), hyphens (-), or underscores (_). The maximum length is 500 characters.")
    pubsub_target: Optional[PubsubTarget] = Field(default=None, alias="pubsubTarget")
    retry_config: Optional[RetryConfig] = Field(default=None, alias="retryConfig")
    schedule: Optional[StrictStr] = Field(default=None, description="Required, except when used with UpdateJob. Describes the schedule on which the job will be executed. The schedule can be either of the following types: * [Crontab](https://en.wikipedia.org/wiki/Cron#Overview) * English-like [schedule](https://cloud.google.com/scheduler/docs/configuring/cron-job-schedules) As a general rule, execution `n + 1` of a job will not begin until execution `n` has finished. Cloud Scheduler will never allow two simultaneously outstanding executions. For example, this implies that if the `n+1`th execution is scheduled to run at 16:00 but the `n`th execution takes until 16:15, the `n+1`th execution will not start until `16:15`. A scheduled start time will be delayed if the previous execution has not ended when its scheduled time occurs. If retry_count > 0 and a job attempt fails, the job will be tried a total of retry_count times, with exponential backoff, until the next scheduled start time. If retry_count is 0, a job attempt will not be retried if it fails. Instead the Cloud Scheduler system will wait for the next scheduled execution time. Setting retry_count to 0 does not prevent failed jobs from running according to schedule after the failure.")
    schedule_time: Optional[StrictStr] = Field(default=None, description="Output only. The next time the job is scheduled. Note that this may be a retry of a previously failed attempt or the next execution time according to the schedule.", alias="scheduleTime")
    state: Optional[StrictStr] = Field(default=None, description="Output only. State of the job.")
    status: Optional[Status] = None
    time_zone: Optional[StrictStr] = Field(default=None, description="Specifies the time zone to be used in interpreting schedule. The value of this field must be a time zone name from the [tz database](http://en.wikipedia.org/wiki/Tz_database). Note that some time zones include a provision for daylight savings time. The rules for daylight saving time are determined by the chosen tz. For UTC use the string \"utc\". If a time zone is not specified, the default will be in UTC (also known as GMT).", alias="timeZone")
    user_update_time: Optional[StrictStr] = Field(default=None, description="Output only. The creation time of the job.", alias="userUpdateTime")
    __properties: ClassVar[List[str]] = ["appEngineHttpTarget", "attemptDeadline", "description", "httpTarget", "lastAttemptTime", "name", "pubsubTarget", "retryConfig", "schedule", "scheduleTime", "state", "status", "timeZone", "userUpdateTime"]

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'ENABLED', 'PAUSED', 'DISABLED', 'UPDATE_FAILED']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'ENABLED', 'PAUSED', 'DISABLED', 'UPDATE_FAILED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Job from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "last_attempt_time",
            "schedule_time",
            "state",
            "user_update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of app_engine_http_target
        if self.app_engine_http_target:
            _dict['appEngineHttpTarget'] = self.app_engine_http_target.to_dict()
        # override the default output from pydantic by calling `to_dict()` of http_target
        if self.http_target:
            _dict['httpTarget'] = self.http_target.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pubsub_target
        if self.pubsub_target:
            _dict['pubsubTarget'] = self.pubsub_target.to_dict()
        # override the default output from pydantic by calling `to_dict()` of retry_config
        if self.retry_config:
            _dict['retryConfig'] = self.retry_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of status
        if self.status:
            _dict['status'] = self.status.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Job from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "appEngineHttpTarget": AppEngineHttpTarget.from_dict(obj["appEngineHttpTarget"]) if obj.get("appEngineHttpTarget") is not None else None,
            "attemptDeadline": obj.get("attemptDeadline"),
            "description": obj.get("description"),
            "httpTarget": HttpTarget.from_dict(obj["httpTarget"]) if obj.get("httpTarget") is not None else None,
            "lastAttemptTime": obj.get("lastAttemptTime"),
            "name": obj.get("name"),
            "pubsubTarget": PubsubTarget.from_dict(obj["pubsubTarget"]) if obj.get("pubsubTarget") is not None else None,
            "retryConfig": RetryConfig.from_dict(obj["retryConfig"]) if obj.get("retryConfig") is not None else None,
            "schedule": obj.get("schedule"),
            "scheduleTime": obj.get("scheduleTime"),
            "state": obj.get("state"),
            "status": Status.from_dict(obj["status"]) if obj.get("status") is not None else None,
            "timeZone": obj.get("timeZone"),
            "userUpdateTime": obj.get("userUpdateTime")
        })
        return _obj


