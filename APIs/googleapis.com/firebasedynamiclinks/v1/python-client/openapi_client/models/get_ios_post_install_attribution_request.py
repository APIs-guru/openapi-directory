# coding: utf-8

"""
    Firebase Dynamic Links API

    Programmatically creates and manages Firebase Dynamic Links.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.device_info import DeviceInfo
from typing import Optional, Set
from typing_extensions import Self

class GetIosPostInstallAttributionRequest(BaseModel):
    """
    Request for iSDK to execute strong match flow for post-install attribution. This is meant for iOS requests only. Requests from other platforms will not be honored.
    """ # noqa: E501
    app_installation_time: Optional[StrictStr] = Field(default=None, description="App installation epoch time (https://en.wikipedia.org/wiki/Unix_time). This is a client signal for a more accurate weak match.", alias="appInstallationTime")
    bundle_id: Optional[StrictStr] = Field(default=None, description="APP bundle ID.", alias="bundleId")
    device: Optional[DeviceInfo] = None
    ios_version: Optional[StrictStr] = Field(default=None, description="iOS version, ie: 9.3.5. Consider adding \"build\".", alias="iosVersion")
    retrieval_method: Optional[StrictStr] = Field(default=None, description="App post install attribution retrieval information. Disambiguates mechanism (iSDK or developer invoked) to retrieve payload from clicked link.", alias="retrievalMethod")
    sdk_version: Optional[StrictStr] = Field(default=None, description="Google SDK version. Version takes the form \"$major.$minor.$patch\"", alias="sdkVersion")
    unique_match_link_to_check: Optional[StrictStr] = Field(default=None, description="Possible unique matched link that server need to check before performing device heuristics match. If passed link is short server need to expand the link. If link is long server need to vslidate the link.", alias="uniqueMatchLinkToCheck")
    visual_style: Optional[StrictStr] = Field(default=None, description="Strong match page information. Disambiguates between default UI and custom page to present when strong match succeeds/fails to find cookie.", alias="visualStyle")
    __properties: ClassVar[List[str]] = ["appInstallationTime", "bundleId", "device", "iosVersion", "retrievalMethod", "sdkVersion", "uniqueMatchLinkToCheck", "visualStyle"]

    @field_validator('retrieval_method')
    def retrieval_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNKNOWN_PAYLOAD_RETRIEVAL_METHOD', 'IMPLICIT_WEAK_MATCH', 'EXPLICIT_WEAK_MATCH', 'EXPLICIT_STRONG_AFTER_WEAK_MATCH']):
            raise ValueError("must be one of enum values ('UNKNOWN_PAYLOAD_RETRIEVAL_METHOD', 'IMPLICIT_WEAK_MATCH', 'EXPLICIT_WEAK_MATCH', 'EXPLICIT_STRONG_AFTER_WEAK_MATCH')")
        return value

    @field_validator('visual_style')
    def visual_style_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNKNOWN_VISUAL_STYLE', 'DEFAULT_STYLE', 'CUSTOM_STYLE']):
            raise ValueError("must be one of enum values ('UNKNOWN_VISUAL_STYLE', 'DEFAULT_STYLE', 'CUSTOM_STYLE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GetIosPostInstallAttributionRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of device
        if self.device:
            _dict['device'] = self.device.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GetIosPostInstallAttributionRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "appInstallationTime": obj.get("appInstallationTime"),
            "bundleId": obj.get("bundleId"),
            "device": DeviceInfo.from_dict(obj["device"]) if obj.get("device") is not None else None,
            "iosVersion": obj.get("iosVersion"),
            "retrievalMethod": obj.get("retrievalMethod"),
            "sdkVersion": obj.get("sdkVersion"),
            "uniqueMatchLinkToCheck": obj.get("uniqueMatchLinkToCheck"),
            "visualStyle": obj.get("visualStyle")
        })
        return _obj


