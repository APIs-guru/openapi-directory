# coding: utf-8

"""
    Analytics Reporting API

    Accesses Analytics report data.

    The version of the OpenAPI document: v4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.custom_dimension import CustomDimension
from openapi_client.models.ecommerce_data import EcommerceData
from openapi_client.models.event_data import EventData
from openapi_client.models.goal_set_data import GoalSetData
from openapi_client.models.pageview_data import PageviewData
from openapi_client.models.screenview_data import ScreenviewData
from typing import Optional, Set
from typing_extensions import Self

class Activity(BaseModel):
    """
    An Activity represents data for an activity of a user. Note that an Activity is different from a hit. A hit might result in multiple Activity's. For example, if a hit includes a transaction and a goal completion, there will be two Activity protos for this hit, one for ECOMMERCE and one for GOAL. Conversely, multiple hits can also construct one Activity. In classic e-commerce, data for one transaction might be sent through multiple hits. These hits will be merged into one ECOMMERCE Activity.
    """ # noqa: E501
    activity_time: Optional[StrictStr] = Field(default=None, description="Timestamp of the activity. If activities for a visit cross midnight and occur in two separate dates, then two sessions (one per date) share the session identifier. For example, say session ID 113472 has activity within 2019-08-20, and session ID 243742 has activity within 2019-08-25 and 2019-08-26. Session ID 113472 is one session, and session ID 243742 is two sessions.", alias="activityTime")
    activity_type: Optional[StrictStr] = Field(default=None, description="Type of this activity.", alias="activityType")
    appview: Optional[ScreenviewData] = None
    campaign: Optional[StrictStr] = Field(default=None, description="For manual campaign tracking, it is the value of the utm_campaign campaign tracking parameter. For AdWords autotagging, it is the name(s) of the online ad campaign(s) you use for the property. If you use neither, its value is (not set).")
    channel_grouping: Optional[StrictStr] = Field(default=None, description="The Channel Group associated with an end user's session for this View (defined by the View's Channel Groupings).", alias="channelGrouping")
    custom_dimension: Optional[List[CustomDimension]] = Field(default=None, description="A list of all custom dimensions associated with this activity.", alias="customDimension")
    ecommerce: Optional[EcommerceData] = None
    event: Optional[EventData] = None
    goals: Optional[GoalSetData] = None
    hostname: Optional[StrictStr] = Field(default=None, description="The hostname from which the tracking request was made.")
    keyword: Optional[StrictStr] = Field(default=None, description="For manual campaign tracking, it is the value of the utm_term campaign tracking parameter. For AdWords traffic, it contains the best matching targeting criteria. For the display network, where multiple targeting criteria could have caused the ad to show up, it returns the best matching targeting criteria as selected by Ads. This could be display_keyword, site placement, boomuserlist, user_interest, age, or gender. Otherwise its value is (not set).")
    landing_page_path: Optional[StrictStr] = Field(default=None, description="The first page in users' sessions, or the landing page.", alias="landingPagePath")
    medium: Optional[StrictStr] = Field(default=None, description="The type of referrals. For manual campaign tracking, it is the value of the utm_medium campaign tracking parameter. For AdWords autotagging, it is cpc. If users came from a search engine detected by Google Analytics, it is organic. If the referrer is not a search engine, it is referral. If users came directly to the property and document.referrer is empty, its value is (none).")
    pageview: Optional[PageviewData] = None
    source: Optional[StrictStr] = Field(default=None, description="The source of referrals. For manual campaign tracking, it is the value of the utm_source campaign tracking parameter. For AdWords autotagging, it is google. If you use neither, it is the domain of the source (e.g., document.referrer) referring the users. It may also contain a port address. If users arrived without a referrer, its value is (direct).")
    __properties: ClassVar[List[str]] = ["activityTime", "activityType", "appview", "campaign", "channelGrouping", "customDimension", "ecommerce", "event", "goals", "hostname", "keyword", "landingPagePath", "medium", "pageview", "source"]

    @field_validator('activity_type')
    def activity_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ACTIVITY_TYPE_UNSPECIFIED', 'PAGEVIEW', 'SCREENVIEW', 'GOAL', 'ECOMMERCE', 'EVENT']):
            raise ValueError("must be one of enum values ('ACTIVITY_TYPE_UNSPECIFIED', 'PAGEVIEW', 'SCREENVIEW', 'GOAL', 'ECOMMERCE', 'EVENT')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Activity from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of appview
        if self.appview:
            _dict['appview'] = self.appview.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in custom_dimension (list)
        _items = []
        if self.custom_dimension:
            for _item_custom_dimension in self.custom_dimension:
                if _item_custom_dimension:
                    _items.append(_item_custom_dimension.to_dict())
            _dict['customDimension'] = _items
        # override the default output from pydantic by calling `to_dict()` of ecommerce
        if self.ecommerce:
            _dict['ecommerce'] = self.ecommerce.to_dict()
        # override the default output from pydantic by calling `to_dict()` of event
        if self.event:
            _dict['event'] = self.event.to_dict()
        # override the default output from pydantic by calling `to_dict()` of goals
        if self.goals:
            _dict['goals'] = self.goals.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pageview
        if self.pageview:
            _dict['pageview'] = self.pageview.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Activity from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "activityTime": obj.get("activityTime"),
            "activityType": obj.get("activityType"),
            "appview": ScreenviewData.from_dict(obj["appview"]) if obj.get("appview") is not None else None,
            "campaign": obj.get("campaign"),
            "channelGrouping": obj.get("channelGrouping"),
            "customDimension": [CustomDimension.from_dict(_item) for _item in obj["customDimension"]] if obj.get("customDimension") is not None else None,
            "ecommerce": EcommerceData.from_dict(obj["ecommerce"]) if obj.get("ecommerce") is not None else None,
            "event": EventData.from_dict(obj["event"]) if obj.get("event") is not None else None,
            "goals": GoalSetData.from_dict(obj["goals"]) if obj.get("goals") is not None else None,
            "hostname": obj.get("hostname"),
            "keyword": obj.get("keyword"),
            "landingPagePath": obj.get("landingPagePath"),
            "medium": obj.get("medium"),
            "pageview": PageviewData.from_dict(obj["pageview"]) if obj.get("pageview") is not None else None,
            "source": obj.get("source")
        })
        return _obj


