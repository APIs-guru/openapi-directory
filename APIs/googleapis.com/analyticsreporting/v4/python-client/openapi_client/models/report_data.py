# coding: utf-8

"""
    Analytics Reporting API

    Accesses Analytics report data.

    The version of the OpenAPI document: v4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.date_range_values import DateRangeValues
from openapi_client.models.report_row import ReportRow
from typing import Optional, Set
from typing_extensions import Self

class ReportData(BaseModel):
    """
    The data part of the report.
    """ # noqa: E501
    data_last_refreshed: Optional[StrictStr] = Field(default=None, description="The last time the data in the report was refreshed. All the hits received before this timestamp are included in the calculation of the report.", alias="dataLastRefreshed")
    empty_reason: Optional[StrictStr] = Field(default=None, description="If empty reason is specified, the report is empty for this reason.", alias="emptyReason")
    is_data_golden: Optional[StrictBool] = Field(default=None, description="Indicates if response to this request is golden or not. Data is golden when the exact same request will not produce any new results if asked at a later point in time.", alias="isDataGolden")
    maximums: Optional[List[DateRangeValues]] = Field(default=None, description="Minimum and maximum values seen over all matching rows. These are both empty when `hideValueRanges` in the request is false, or when rowCount is zero.")
    minimums: Optional[List[DateRangeValues]] = Field(default=None, description="Minimum and maximum values seen over all matching rows. These are both empty when `hideValueRanges` in the request is false, or when rowCount is zero.")
    row_count: Optional[StrictInt] = Field(default=None, description="Total number of matching rows for this query.", alias="rowCount")
    rows: Optional[List[ReportRow]] = Field(default=None, description="There's one ReportRow for every unique combination of dimensions.")
    samples_read_counts: Optional[List[StrictStr]] = Field(default=None, description="If the results are [sampled](https://support.google.com/analytics/answer/2637192), this returns the total number of samples read, one entry per date range. If the results are not sampled this field will not be defined. See [developer guide](/analytics/devguides/reporting/core/v4/basics#sampling) for details.", alias="samplesReadCounts")
    sampling_space_sizes: Optional[List[StrictStr]] = Field(default=None, description="If the results are [sampled](https://support.google.com/analytics/answer/2637192), this returns the total number of samples present, one entry per date range. If the results are not sampled this field will not be defined. See [developer guide](/analytics/devguides/reporting/core/v4/basics#sampling) for details.", alias="samplingSpaceSizes")
    totals: Optional[List[DateRangeValues]] = Field(default=None, description="For each requested date range, for the set of all rows that match the query, every requested value format gets a total. The total for a value format is computed by first totaling the metrics mentioned in the value format and then evaluating the value format as a scalar expression. E.g., The \"totals\" for `3 / (ga:sessions + 2)` we compute `3 / ((sum of all relevant ga:sessions) + 2)`. Totals are computed before pagination.")
    __properties: ClassVar[List[str]] = ["dataLastRefreshed", "emptyReason", "isDataGolden", "maximums", "minimums", "rowCount", "rows", "samplesReadCounts", "samplingSpaceSizes", "totals"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReportData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in maximums (list)
        _items = []
        if self.maximums:
            for _item_maximums in self.maximums:
                if _item_maximums:
                    _items.append(_item_maximums.to_dict())
            _dict['maximums'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in minimums (list)
        _items = []
        if self.minimums:
            for _item_minimums in self.minimums:
                if _item_minimums:
                    _items.append(_item_minimums.to_dict())
            _dict['minimums'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in rows (list)
        _items = []
        if self.rows:
            for _item_rows in self.rows:
                if _item_rows:
                    _items.append(_item_rows.to_dict())
            _dict['rows'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in totals (list)
        _items = []
        if self.totals:
            for _item_totals in self.totals:
                if _item_totals:
                    _items.append(_item_totals.to_dict())
            _dict['totals'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReportData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "dataLastRefreshed": obj.get("dataLastRefreshed"),
            "emptyReason": obj.get("emptyReason"),
            "isDataGolden": obj.get("isDataGolden"),
            "maximums": [DateRangeValues.from_dict(_item) for _item in obj["maximums"]] if obj.get("maximums") is not None else None,
            "minimums": [DateRangeValues.from_dict(_item) for _item in obj["minimums"]] if obj.get("minimums") is not None else None,
            "rowCount": obj.get("rowCount"),
            "rows": [ReportRow.from_dict(_item) for _item in obj["rows"]] if obj.get("rows") is not None else None,
            "samplesReadCounts": obj.get("samplesReadCounts"),
            "samplingSpaceSizes": obj.get("samplingSpaceSizes"),
            "totals": [DateRangeValues.from_dict(_item) for _item in obj["totals"]] if obj.get("totals") is not None else None
        })
        return _obj


