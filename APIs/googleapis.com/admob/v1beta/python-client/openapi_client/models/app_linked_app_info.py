# coding: utf-8

"""
    AdMob API

    The AdMob API allows publishers to programmatically get information about their AdMob account. 

    The version of the OpenAPI document: v1beta
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class AppLinkedAppInfo(BaseModel):
    """
    Information from the app store if the app is linked to an app store.
    """ # noqa: E501
    android_app_stores: Optional[List[StrictStr]] = Field(default=None, description="Optional. The app store information for published Android apps. This field is only used for apps on the Android platform and will be ignored if the PLATFORM is set to iOS. The default value is the Google Play App store. This field can be updated after app is created. If the app is not published, this field will not be included in the response.", alias="androidAppStores")
    app_store_id: Optional[StrictStr] = Field(default=None, description="The app store ID of the app; present if and only if the app is linked to an app store. If the app is added to the Google Play store, it will be the application ID of the app. For example: \"com.example.myapp\". See https://developer.android.com/studio/build/application-id. If the app is added to the Apple App Store, it will be app store ID. For example \"105169111\". Note that setting the app store id is considered an irreversible action. Once an app is linked, it cannot be unlinked.", alias="appStoreId")
    display_name: Optional[StrictStr] = Field(default=None, description="Output only. Display name of the app as it appears in the app store. This is an output-only field, and may be empty if the app cannot be found in the store.", alias="displayName")
    __properties: ClassVar[List[str]] = ["androidAppStores", "appStoreId", "displayName"]

    @field_validator('android_app_stores')
    def android_app_stores_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['ANDROID_APP_STORE_UNSPECIFIED', 'GOOGLE_PLAY_APP_STORE', 'AMAZON_APP_STORE', 'OPPO_APP_STORE', 'SAMSUNG_APP_STORE', 'VIVO_APP_STORE', 'XIAOMI_APP_STORE']):
                raise ValueError("each list item must be one of ('ANDROID_APP_STORE_UNSPECIFIED', 'GOOGLE_PLAY_APP_STORE', 'AMAZON_APP_STORE', 'OPPO_APP_STORE', 'SAMSUNG_APP_STORE', 'VIVO_APP_STORE', 'XIAOMI_APP_STORE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AppLinkedAppInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "display_name",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AppLinkedAppInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "androidAppStores": obj.get("androidAppStores"),
            "appStoreId": obj.get("appStoreId"),
            "displayName": obj.get("displayName")
        })
        return _obj


