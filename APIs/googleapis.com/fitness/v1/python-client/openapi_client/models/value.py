# coding: utf-8

"""
    Fitness API

    The Fitness API for managing users' fitness tracking data.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.value_map_val_entry import ValueMapValEntry
from typing import Optional, Set
from typing_extensions import Self

class Value(BaseModel):
    """
    Holder object for the value of a single field in a data point. A field value has a particular format and is only ever set to one of an integer or a floating point value.
    """ # noqa: E501
    fp_val: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Floating point value. When this is set, other values must not be set.", alias="fpVal")
    int_val: Optional[StrictInt] = Field(default=None, description="Integer value. When this is set, other values must not be set.", alias="intVal")
    map_val: Optional[List[ValueMapValEntry]] = Field(default=None, description="Map value. The valid key space and units for the corresponding value of each entry should be documented as part of the data type definition. Keys should be kept small whenever possible. Data streams with large keys and high data frequency may be down sampled.", alias="mapVal")
    string_val: Optional[StrictStr] = Field(default=None, description="String value. When this is set, other values must not be set. Strings should be kept small whenever possible. Data streams with large string values and high data frequency may be down sampled.", alias="stringVal")
    __properties: ClassVar[List[str]] = ["fpVal", "intVal", "mapVal", "stringVal"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Value from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in map_val (list)
        _items = []
        if self.map_val:
            for _item_map_val in self.map_val:
                if _item_map_val:
                    _items.append(_item_map_val.to_dict())
            _dict['mapVal'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Value from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "fpVal": obj.get("fpVal"),
            "intVal": obj.get("intVal"),
            "mapVal": [ValueMapValEntry.from_dict(_item) for _item in obj["mapVal"]] if obj.get("mapVal") is not None else None,
            "stringVal": obj.get("stringVal")
        })
        return _obj


