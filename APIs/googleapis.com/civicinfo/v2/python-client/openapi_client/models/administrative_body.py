# coding: utf-8

"""
    Google Civic Information API

    Provides polling places, early vote locations, contest data, election officials, and government representatives for U.S. residential addresses.

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.election_official import ElectionOfficial
from openapi_client.models.simple_address_type import SimpleAddressType
from typing import Optional, Set
from typing_extensions import Self

class AdministrativeBody(BaseModel):
    """
    Information about an election administrative body (e.g. County Board of Elections).
    """ # noqa: E501
    absentee_voting_info_url: Optional[StrictStr] = Field(default=None, description="A URL provided by this administrative body for information on absentee voting.", alias="absenteeVotingInfoUrl")
    ballot_info_url: Optional[StrictStr] = Field(default=None, description="A URL provided by this administrative body to give contest information to the voter.", alias="ballotInfoUrl")
    correspondence_address: Optional[SimpleAddressType] = Field(default=None, alias="correspondenceAddress")
    election_info_url: Optional[StrictStr] = Field(default=None, description="A URL provided by this administrative body for looking up general election information.", alias="electionInfoUrl")
    election_notice_text: Optional[StrictStr] = Field(default=None, description="A last minute or emergency notification text provided by this administrative body.", alias="electionNoticeText")
    election_notice_url: Optional[StrictStr] = Field(default=None, description="A URL provided by this administrative body for additional information related to the last minute or emergency notification.", alias="electionNoticeUrl")
    election_officials: Optional[List[ElectionOfficial]] = Field(default=None, description="The election officials for this election administrative body.", alias="electionOfficials")
    election_registration_confirmation_url: Optional[StrictStr] = Field(default=None, description="A URL provided by this administrative body for confirming that the voter is registered to vote.", alias="electionRegistrationConfirmationUrl")
    election_registration_url: Optional[StrictStr] = Field(default=None, description="A URL provided by this administrative body for looking up how to register to vote.", alias="electionRegistrationUrl")
    election_rules_url: Optional[StrictStr] = Field(default=None, description="A URL provided by this administrative body describing election rules to the voter.", alias="electionRulesUrl")
    hours_of_operation: Optional[StrictStr] = Field(default=None, description="A description of the hours of operation for this administrative body.", alias="hoursOfOperation")
    name: Optional[StrictStr] = Field(default=None, description="The name of this election administrative body.")
    physical_address: Optional[SimpleAddressType] = Field(default=None, alias="physicalAddress")
    voter_services: Optional[List[StrictStr]] = Field(default=None, description="A description of the services this administrative body may provide.")
    voting_location_finder_url: Optional[StrictStr] = Field(default=None, description="A URL provided by this administrative body for looking up where to vote.", alias="votingLocationFinderUrl")
    __properties: ClassVar[List[str]] = ["absenteeVotingInfoUrl", "ballotInfoUrl", "correspondenceAddress", "electionInfoUrl", "electionNoticeText", "electionNoticeUrl", "electionOfficials", "electionRegistrationConfirmationUrl", "electionRegistrationUrl", "electionRulesUrl", "hoursOfOperation", "name", "physicalAddress", "voter_services", "votingLocationFinderUrl"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AdministrativeBody from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of correspondence_address
        if self.correspondence_address:
            _dict['correspondenceAddress'] = self.correspondence_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in election_officials (list)
        _items = []
        if self.election_officials:
            for _item_election_officials in self.election_officials:
                if _item_election_officials:
                    _items.append(_item_election_officials.to_dict())
            _dict['electionOfficials'] = _items
        # override the default output from pydantic by calling `to_dict()` of physical_address
        if self.physical_address:
            _dict['physicalAddress'] = self.physical_address.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AdministrativeBody from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "absenteeVotingInfoUrl": obj.get("absenteeVotingInfoUrl"),
            "ballotInfoUrl": obj.get("ballotInfoUrl"),
            "correspondenceAddress": SimpleAddressType.from_dict(obj["correspondenceAddress"]) if obj.get("correspondenceAddress") is not None else None,
            "electionInfoUrl": obj.get("electionInfoUrl"),
            "electionNoticeText": obj.get("electionNoticeText"),
            "electionNoticeUrl": obj.get("electionNoticeUrl"),
            "electionOfficials": [ElectionOfficial.from_dict(_item) for _item in obj["electionOfficials"]] if obj.get("electionOfficials") is not None else None,
            "electionRegistrationConfirmationUrl": obj.get("electionRegistrationConfirmationUrl"),
            "electionRegistrationUrl": obj.get("electionRegistrationUrl"),
            "electionRulesUrl": obj.get("electionRulesUrl"),
            "hoursOfOperation": obj.get("hoursOfOperation"),
            "name": obj.get("name"),
            "physicalAddress": SimpleAddressType.from_dict(obj["physicalAddress"]) if obj.get("physicalAddress") is not None else None,
            "voter_services": obj.get("voter_services"),
            "votingLocationFinderUrl": obj.get("votingLocationFinderUrl")
        })
        return _obj


