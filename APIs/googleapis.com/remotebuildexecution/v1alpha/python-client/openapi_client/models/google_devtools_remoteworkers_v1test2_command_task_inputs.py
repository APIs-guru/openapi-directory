# coding: utf-8

"""
    Remote Build Execution API

    Supplies a Remote Execution API service for tools such as bazel.

    The version of the OpenAPI document: v1alpha
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_devtools_remoteworkers_v1test2_blob import GoogleDevtoolsRemoteworkersV1test2Blob
from openapi_client.models.google_devtools_remoteworkers_v1test2_command_task_inputs_environment_variable import GoogleDevtoolsRemoteworkersV1test2CommandTaskInputsEnvironmentVariable
from openapi_client.models.google_devtools_remoteworkers_v1test2_digest import GoogleDevtoolsRemoteworkersV1test2Digest
from typing import Optional, Set
from typing_extensions import Self

class GoogleDevtoolsRemoteworkersV1test2CommandTaskInputs(BaseModel):
    """
    Describes the inputs to a shell-style task.
    """ # noqa: E501
    arguments: Optional[List[StrictStr]] = Field(default=None, description="The command itself to run (e.g., argv). This field should be passed directly to the underlying operating system, and so it must be sensible to that operating system. For example, on Windows, the first argument might be \"C:\\Windows\\System32\\ping.exe\" - that is, using drive letters and backslashes. A command for a *nix system, on the other hand, would use forward slashes. All other fields in the RWAPI must consistently use forward slashes, since those fields may be interpretted by both the service and the bot.")
    environment_variables: Optional[List[GoogleDevtoolsRemoteworkersV1test2CommandTaskInputsEnvironmentVariable]] = Field(default=None, description="All environment variables required by the task.", alias="environmentVariables")
    files: Optional[List[GoogleDevtoolsRemoteworkersV1test2Digest]] = Field(default=None, description="The input filesystem to be set up prior to the task beginning. The contents should be a repeated set of FileMetadata messages though other formats are allowed if better for the implementation (eg, a LUCI-style .isolated file). This field is repeated since implementations might want to cache the metadata, in which case it may be useful to break up portions of the filesystem that change frequently (eg, specific input files) from those that don't (eg, standard header files).")
    inline_blobs: Optional[List[GoogleDevtoolsRemoteworkersV1test2Blob]] = Field(default=None, description="Inline contents for blobs expected to be needed by the bot to execute the task. For example, contents of entries in `files` or blobs that are indirectly referenced by an entry there. The bot should check against this list before downloading required task inputs to reduce the number of communications between itself and the remote CAS server.", alias="inlineBlobs")
    working_directory: Optional[StrictStr] = Field(default=None, description="Directory from which a command is executed. It is a relative directory with respect to the bot's working directory (i.e., \"./\"). If it is non-empty, then it must exist under \"./\". Otherwise, \"./\" will be used.", alias="workingDirectory")
    __properties: ClassVar[List[str]] = ["arguments", "environmentVariables", "files", "inlineBlobs", "workingDirectory"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleDevtoolsRemoteworkersV1test2CommandTaskInputs from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in environment_variables (list)
        _items = []
        if self.environment_variables:
            for _item_environment_variables in self.environment_variables:
                if _item_environment_variables:
                    _items.append(_item_environment_variables.to_dict())
            _dict['environmentVariables'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in files (list)
        _items = []
        if self.files:
            for _item_files in self.files:
                if _item_files:
                    _items.append(_item_files.to_dict())
            _dict['files'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in inline_blobs (list)
        _items = []
        if self.inline_blobs:
            for _item_inline_blobs in self.inline_blobs:
                if _item_inline_blobs:
                    _items.append(_item_inline_blobs.to_dict())
            _dict['inlineBlobs'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleDevtoolsRemoteworkersV1test2CommandTaskInputs from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "arguments": obj.get("arguments"),
            "environmentVariables": [GoogleDevtoolsRemoteworkersV1test2CommandTaskInputsEnvironmentVariable.from_dict(_item) for _item in obj["environmentVariables"]] if obj.get("environmentVariables") is not None else None,
            "files": [GoogleDevtoolsRemoteworkersV1test2Digest.from_dict(_item) for _item in obj["files"]] if obj.get("files") is not None else None,
            "inlineBlobs": [GoogleDevtoolsRemoteworkersV1test2Blob.from_dict(_item) for _item in obj["inlineBlobs"]] if obj.get("inlineBlobs") is not None else None,
            "workingDirectory": obj.get("workingDirectory")
        })
        return _obj


