# coding: utf-8

"""
    Cloud Billing API

    Allows developers to manage billing for their Google Cloud Platform projects programmatically.

    The version of the OpenAPI document: v1beta
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.cloud_cdn_egress_workload import CloudCdnEgressWorkload
from openapi_client.models.cloud_cdn_workload import CloudCdnWorkload
from openapi_client.models.cloud_interconnect_egress_workload import CloudInterconnectEgressWorkload
from openapi_client.models.cloud_interconnect_workload import CloudInterconnectWorkload
from openapi_client.models.cloud_storage_egress_workload import CloudStorageEgressWorkload
from openapi_client.models.cloud_storage_workload import CloudStorageWorkload
from openapi_client.models.compute_vm_workload import ComputeVmWorkload
from openapi_client.models.premium_tier_egress_workload import PremiumTierEgressWorkload
from openapi_client.models.standard_tier_egress_workload import StandardTierEgressWorkload
from openapi_client.models.vm_to_vm_egress_workload import VmToVmEgressWorkload
from typing import Optional, Set
from typing_extensions import Self

class Workload(BaseModel):
    """
    Specifies usage on a single Google Cloud product over a time frame. Each Google Cloud product has its own message, containing specific product configuration parameters of the product usage amounts along each dimension in which the product is billed.
    """ # noqa: E501
    cloud_cdn_egress_workload: Optional[CloudCdnEgressWorkload] = Field(default=None, alias="cloudCdnEgressWorkload")
    cloud_cdn_workload: Optional[CloudCdnWorkload] = Field(default=None, alias="cloudCdnWorkload")
    cloud_interconnect_egress_workload: Optional[CloudInterconnectEgressWorkload] = Field(default=None, alias="cloudInterconnectEgressWorkload")
    cloud_interconnect_workload: Optional[CloudInterconnectWorkload] = Field(default=None, alias="cloudInterconnectWorkload")
    cloud_storage_egress_workload: Optional[CloudStorageEgressWorkload] = Field(default=None, alias="cloudStorageEgressWorkload")
    cloud_storage_workload: Optional[CloudStorageWorkload] = Field(default=None, alias="cloudStorageWorkload")
    compute_vm_workload: Optional[ComputeVmWorkload] = Field(default=None, alias="computeVmWorkload")
    name: Optional[StrictStr] = Field(default=None, description="Required. A name for this workload. All workloads in a `CostScenario` must have a unique `name`. Each `name` may be at most 128 characters long.")
    premium_tier_egress_workload: Optional[PremiumTierEgressWorkload] = Field(default=None, alias="premiumTierEgressWorkload")
    standard_tier_egress_workload: Optional[StandardTierEgressWorkload] = Field(default=None, alias="standardTierEgressWorkload")
    vm_to_vm_egress_workload: Optional[VmToVmEgressWorkload] = Field(default=None, alias="vmToVmEgressWorkload")
    __properties: ClassVar[List[str]] = ["cloudCdnEgressWorkload", "cloudCdnWorkload", "cloudInterconnectEgressWorkload", "cloudInterconnectWorkload", "cloudStorageEgressWorkload", "cloudStorageWorkload", "computeVmWorkload", "name", "premiumTierEgressWorkload", "standardTierEgressWorkload", "vmToVmEgressWorkload"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Workload from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of cloud_cdn_egress_workload
        if self.cloud_cdn_egress_workload:
            _dict['cloudCdnEgressWorkload'] = self.cloud_cdn_egress_workload.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_cdn_workload
        if self.cloud_cdn_workload:
            _dict['cloudCdnWorkload'] = self.cloud_cdn_workload.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_interconnect_egress_workload
        if self.cloud_interconnect_egress_workload:
            _dict['cloudInterconnectEgressWorkload'] = self.cloud_interconnect_egress_workload.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_interconnect_workload
        if self.cloud_interconnect_workload:
            _dict['cloudInterconnectWorkload'] = self.cloud_interconnect_workload.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_storage_egress_workload
        if self.cloud_storage_egress_workload:
            _dict['cloudStorageEgressWorkload'] = self.cloud_storage_egress_workload.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cloud_storage_workload
        if self.cloud_storage_workload:
            _dict['cloudStorageWorkload'] = self.cloud_storage_workload.to_dict()
        # override the default output from pydantic by calling `to_dict()` of compute_vm_workload
        if self.compute_vm_workload:
            _dict['computeVmWorkload'] = self.compute_vm_workload.to_dict()
        # override the default output from pydantic by calling `to_dict()` of premium_tier_egress_workload
        if self.premium_tier_egress_workload:
            _dict['premiumTierEgressWorkload'] = self.premium_tier_egress_workload.to_dict()
        # override the default output from pydantic by calling `to_dict()` of standard_tier_egress_workload
        if self.standard_tier_egress_workload:
            _dict['standardTierEgressWorkload'] = self.standard_tier_egress_workload.to_dict()
        # override the default output from pydantic by calling `to_dict()` of vm_to_vm_egress_workload
        if self.vm_to_vm_egress_workload:
            _dict['vmToVmEgressWorkload'] = self.vm_to_vm_egress_workload.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Workload from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "cloudCdnEgressWorkload": CloudCdnEgressWorkload.from_dict(obj["cloudCdnEgressWorkload"]) if obj.get("cloudCdnEgressWorkload") is not None else None,
            "cloudCdnWorkload": CloudCdnWorkload.from_dict(obj["cloudCdnWorkload"]) if obj.get("cloudCdnWorkload") is not None else None,
            "cloudInterconnectEgressWorkload": CloudInterconnectEgressWorkload.from_dict(obj["cloudInterconnectEgressWorkload"]) if obj.get("cloudInterconnectEgressWorkload") is not None else None,
            "cloudInterconnectWorkload": CloudInterconnectWorkload.from_dict(obj["cloudInterconnectWorkload"]) if obj.get("cloudInterconnectWorkload") is not None else None,
            "cloudStorageEgressWorkload": CloudStorageEgressWorkload.from_dict(obj["cloudStorageEgressWorkload"]) if obj.get("cloudStorageEgressWorkload") is not None else None,
            "cloudStorageWorkload": CloudStorageWorkload.from_dict(obj["cloudStorageWorkload"]) if obj.get("cloudStorageWorkload") is not None else None,
            "computeVmWorkload": ComputeVmWorkload.from_dict(obj["computeVmWorkload"]) if obj.get("computeVmWorkload") is not None else None,
            "name": obj.get("name"),
            "premiumTierEgressWorkload": PremiumTierEgressWorkload.from_dict(obj["premiumTierEgressWorkload"]) if obj.get("premiumTierEgressWorkload") is not None else None,
            "standardTierEgressWorkload": StandardTierEgressWorkload.from_dict(obj["standardTierEgressWorkload"]) if obj.get("standardTierEgressWorkload") is not None else None,
            "vmToVmEgressWorkload": VmToVmEgressWorkload.from_dict(obj["vmToVmEgressWorkload"]) if obj.get("vmToVmEgressWorkload") is not None else None
        })
        return _obj


