# coding: utf-8

"""
    On-Demand Scanning API

    A service to scan container images for vulnerabilities.

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.binary_source_info import BinarySourceInfo
from openapi_client.models.file_location import FileLocation
from openapi_client.models.language_package_dependency import LanguagePackageDependency
from openapi_client.models.maintainer import Maintainer
from openapi_client.models.package_version import PackageVersion
from typing import Optional, Set
from typing_extensions import Self

class PackageData(BaseModel):
    """
    PackageData
    """ # noqa: E501
    architecture: Optional[StrictStr] = Field(default=None, description="The architecture of the package.")
    binary_source_info: Optional[List[BinarySourceInfo]] = Field(default=None, description="A bundle containing the binary and source information.", alias="binarySourceInfo")
    binary_version: Optional[PackageVersion] = Field(default=None, alias="binaryVersion")
    cpe_uri: Optional[StrictStr] = Field(default=None, description="The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in which the vulnerability may manifest. Examples include distro or storage location for vulnerable jar.", alias="cpeUri")
    dependency_chain: Optional[List[LanguagePackageDependency]] = Field(default=None, description="The dependency chain between this package and the user's artifact. List in order from the customer's package under review first, to the current package last. Inclusive of the original package and the current package.", alias="dependencyChain")
    file_location: Optional[List[FileLocation]] = Field(default=None, description="The path to the jar file / go binary file.", alias="fileLocation")
    hash_digest: Optional[StrictStr] = Field(default=None, description="HashDigest stores the SHA512 hash digest of the jar file if the package is of type Maven. This field will be unset for non Maven packages.", alias="hashDigest")
    licenses: Optional[List[StrictStr]] = Field(default=None, description="The list of licenses found that are related to a given package. Note that licenses may also be stored on the BinarySourceInfo. If there is no BinarySourceInfo (because there's no concept of source vs binary), then it will be stored here, while if there are BinarySourceInfos, it will be stored there, as one source can have multiple binaries with different licenses.")
    maintainer: Optional[Maintainer] = None
    os: Optional[StrictStr] = Field(default=None, description="The OS affected by a vulnerability Used to generate the cpe_uri for OS packages")
    os_version: Optional[StrictStr] = Field(default=None, description="The version of the OS Used to generate the cpe_uri for OS packages", alias="osVersion")
    package: Optional[StrictStr] = Field(default=None, description="The package being analysed for vulnerabilities")
    package_type: Optional[StrictStr] = Field(default=None, description="The type of package: os, maven, go, etc.", alias="packageType")
    patched_cve: Optional[List[StrictStr]] = Field(default=None, description="CVEs that this package is no longer vulnerable to go/drydock-dd-custom-binary-scanning", alias="patchedCve")
    source_version: Optional[PackageVersion] = Field(default=None, alias="sourceVersion")
    unused: Optional[StrictStr] = None
    version: Optional[StrictStr] = Field(default=None, description="The version of the package being analysed")
    __properties: ClassVar[List[str]] = ["architecture", "binarySourceInfo", "binaryVersion", "cpeUri", "dependencyChain", "fileLocation", "hashDigest", "licenses", "maintainer", "os", "osVersion", "package", "packageType", "patchedCve", "sourceVersion", "unused", "version"]

    @field_validator('package_type')
    def package_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PACKAGE_TYPE_UNSPECIFIED', 'OS', 'MAVEN', 'GO', 'GO_STDLIB', 'PYPI', 'NPM', 'NUGET', 'RUBYGEMS', 'RUST', 'COMPOSER']):
            raise ValueError("must be one of enum values ('PACKAGE_TYPE_UNSPECIFIED', 'OS', 'MAVEN', 'GO', 'GO_STDLIB', 'PYPI', 'NPM', 'NUGET', 'RUBYGEMS', 'RUST', 'COMPOSER')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PackageData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in binary_source_info (list)
        _items = []
        if self.binary_source_info:
            for _item_binary_source_info in self.binary_source_info:
                if _item_binary_source_info:
                    _items.append(_item_binary_source_info.to_dict())
            _dict['binarySourceInfo'] = _items
        # override the default output from pydantic by calling `to_dict()` of binary_version
        if self.binary_version:
            _dict['binaryVersion'] = self.binary_version.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in dependency_chain (list)
        _items = []
        if self.dependency_chain:
            for _item_dependency_chain in self.dependency_chain:
                if _item_dependency_chain:
                    _items.append(_item_dependency_chain.to_dict())
            _dict['dependencyChain'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in file_location (list)
        _items = []
        if self.file_location:
            for _item_file_location in self.file_location:
                if _item_file_location:
                    _items.append(_item_file_location.to_dict())
            _dict['fileLocation'] = _items
        # override the default output from pydantic by calling `to_dict()` of maintainer
        if self.maintainer:
            _dict['maintainer'] = self.maintainer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source_version
        if self.source_version:
            _dict['sourceVersion'] = self.source_version.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PackageData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "architecture": obj.get("architecture"),
            "binarySourceInfo": [BinarySourceInfo.from_dict(_item) for _item in obj["binarySourceInfo"]] if obj.get("binarySourceInfo") is not None else None,
            "binaryVersion": PackageVersion.from_dict(obj["binaryVersion"]) if obj.get("binaryVersion") is not None else None,
            "cpeUri": obj.get("cpeUri"),
            "dependencyChain": [LanguagePackageDependency.from_dict(_item) for _item in obj["dependencyChain"]] if obj.get("dependencyChain") is not None else None,
            "fileLocation": [FileLocation.from_dict(_item) for _item in obj["fileLocation"]] if obj.get("fileLocation") is not None else None,
            "hashDigest": obj.get("hashDigest"),
            "licenses": obj.get("licenses"),
            "maintainer": Maintainer.from_dict(obj["maintainer"]) if obj.get("maintainer") is not None else None,
            "os": obj.get("os"),
            "osVersion": obj.get("osVersion"),
            "package": obj.get("package"),
            "packageType": obj.get("packageType"),
            "patchedCve": obj.get("patchedCve"),
            "sourceVersion": PackageVersion.from_dict(obj["sourceVersion"]) if obj.get("sourceVersion") is not None else None,
            "unused": obj.get("unused"),
            "version": obj.get("version")
        })
        return _obj


