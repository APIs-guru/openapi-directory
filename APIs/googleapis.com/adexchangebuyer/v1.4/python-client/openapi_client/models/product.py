# coding: utf-8

"""
    Ad Exchange Buyer API

    Accesses your bidding-account information, submits creatives for validation, finds available direct deals, and retrieves performance reports.

    The version of the OpenAPI document: v1.4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.buyer import Buyer
from openapi_client.models.contact_information import ContactInformation
from openapi_client.models.deal_terms import DealTerms
from openapi_client.models.delivery_control import DeliveryControl
from openapi_client.models.marketplace_label import MarketplaceLabel
from openapi_client.models.publisher_provided_forecast import PublisherProvidedForecast
from openapi_client.models.seller import Seller
from openapi_client.models.shared_targeting import SharedTargeting
from typing import Optional, Set
from typing_extensions import Self

class Product(BaseModel):
    """
    A product is segment of inventory that a seller wishes to sell. It is associated with certain terms and targeting information which helps buyer know more about the inventory. Each field in a product can have one of the following setting:  (readonly) - It is an error to try and set this field. (buyer-readonly) - Only the seller can set this field. (seller-readonly) - Only the buyer can set this field. (updatable) - The field is updatable at all times by either buyer or the seller.
    """ # noqa: E501
    billed_buyer: Optional[Buyer] = Field(default=None, alias="billedBuyer")
    buyer: Optional[Buyer] = None
    creation_time_ms: Optional[StrictStr] = Field(default=None, description="Creation time in ms. since epoch (readonly)", alias="creationTimeMs")
    creator_contacts: Optional[List[ContactInformation]] = Field(default=None, description="Optional contact information for the creator of this product. (buyer-readonly)", alias="creatorContacts")
    creator_role: Optional[StrictStr] = Field(default=None, description="The role that created the offer. Set to BUYER for buyer initiated offers.", alias="creatorRole")
    delivery_control: Optional[DeliveryControl] = Field(default=None, alias="deliveryControl")
    flight_end_time_ms: Optional[StrictStr] = Field(default=None, description="The proposed end time for the deal (ms since epoch) (buyer-readonly)", alias="flightEndTimeMs")
    flight_start_time_ms: Optional[StrictStr] = Field(default=None, description="Inventory availability dates. (times are in ms since epoch) The granularity is generally in the order of seconds. (buyer-readonly)", alias="flightStartTimeMs")
    has_creator_signed_off: Optional[StrictBool] = Field(default=None, description="If the creator has already signed off on the product, then the buyer can finalize the deal by accepting the product as is. When copying to a proposal, if any of the terms are changed, then auto_finalize is automatically set to false.", alias="hasCreatorSignedOff")
    inventory_source: Optional[StrictStr] = Field(default=None, description="What exchange will provide this inventory (readonly, except on create).", alias="inventorySource")
    kind: Optional[StrictStr] = Field(default='adexchangebuyer#product', description="Identifies what kind of resource this is. Value: the fixed string \"adexchangebuyer#product\".")
    labels: Optional[List[MarketplaceLabel]] = Field(default=None, description="Optional List of labels for the product (optional, buyer-readonly).")
    last_update_time_ms: Optional[StrictStr] = Field(default=None, description="Time of last update in ms. since epoch (readonly)", alias="lastUpdateTimeMs")
    legacy_offer_id: Optional[StrictStr] = Field(default=None, description="Optional legacy offer id if this offer is a preferred deal offer.", alias="legacyOfferId")
    marketplace_publisher_profile_id: Optional[StrictStr] = Field(default=None, description="Marketplace publisher profile Id. This Id differs from the regular publisher_profile_id in that 1. This is a new id, the old Id will be deprecated in 2017. 2. This id uniquely identifies a publisher profile by itself.", alias="marketplacePublisherProfileId")
    name: Optional[StrictStr] = Field(default=None, description="The name for this product as set by the seller. (buyer-readonly)")
    private_auction_id: Optional[StrictStr] = Field(default=None, description="Optional private auction id if this offer is a private auction offer.", alias="privateAuctionId")
    product_id: Optional[StrictStr] = Field(default=None, description="The unique id for the product (readonly)", alias="productId")
    publisher_profile_id: Optional[StrictStr] = Field(default=None, description="Id of the publisher profile for a given seller. A (seller.account_id, publisher_profile_id) pair uniquely identifies a publisher profile. Buyers can call the PublisherProfiles::List endpoint to get a list of publisher profiles for a given seller.", alias="publisherProfileId")
    publisher_provided_forecast: Optional[PublisherProvidedForecast] = Field(default=None, alias="publisherProvidedForecast")
    revision_number: Optional[StrictStr] = Field(default=None, description="The revision number of the product. (readonly)", alias="revisionNumber")
    seller: Optional[Seller] = None
    shared_targetings: Optional[List[SharedTargeting]] = Field(default=None, description="Targeting that is shared between the buyer and the seller. Each targeting criteria has a specified key and for each key there is a list of inclusion value or exclusion values. (buyer-readonly)", alias="sharedTargetings")
    state: Optional[StrictStr] = Field(default=None, description="The state of the product. (buyer-readonly)")
    syndication_product: Optional[StrictStr] = Field(default=None, description="The syndication product associated with the deal. (readonly, except on create)", alias="syndicationProduct")
    terms: Optional[DealTerms] = None
    web_property_code: Optional[StrictStr] = Field(default=None, description="The web property code for the seller. This field is meant to be copied over as is when creating deals.", alias="webPropertyCode")
    __properties: ClassVar[List[str]] = ["billedBuyer", "buyer", "creationTimeMs", "creatorContacts", "creatorRole", "deliveryControl", "flightEndTimeMs", "flightStartTimeMs", "hasCreatorSignedOff", "inventorySource", "kind", "labels", "lastUpdateTimeMs", "legacyOfferId", "marketplacePublisherProfileId", "name", "privateAuctionId", "productId", "publisherProfileId", "publisherProvidedForecast", "revisionNumber", "seller", "sharedTargetings", "state", "syndicationProduct", "terms", "webPropertyCode"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Product from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of billed_buyer
        if self.billed_buyer:
            _dict['billedBuyer'] = self.billed_buyer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of buyer
        if self.buyer:
            _dict['buyer'] = self.buyer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in creator_contacts (list)
        _items = []
        if self.creator_contacts:
            for _item_creator_contacts in self.creator_contacts:
                if _item_creator_contacts:
                    _items.append(_item_creator_contacts.to_dict())
            _dict['creatorContacts'] = _items
        # override the default output from pydantic by calling `to_dict()` of delivery_control
        if self.delivery_control:
            _dict['deliveryControl'] = self.delivery_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in labels (list)
        _items = []
        if self.labels:
            for _item_labels in self.labels:
                if _item_labels:
                    _items.append(_item_labels.to_dict())
            _dict['labels'] = _items
        # override the default output from pydantic by calling `to_dict()` of publisher_provided_forecast
        if self.publisher_provided_forecast:
            _dict['publisherProvidedForecast'] = self.publisher_provided_forecast.to_dict()
        # override the default output from pydantic by calling `to_dict()` of seller
        if self.seller:
            _dict['seller'] = self.seller.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in shared_targetings (list)
        _items = []
        if self.shared_targetings:
            for _item_shared_targetings in self.shared_targetings:
                if _item_shared_targetings:
                    _items.append(_item_shared_targetings.to_dict())
            _dict['sharedTargetings'] = _items
        # override the default output from pydantic by calling `to_dict()` of terms
        if self.terms:
            _dict['terms'] = self.terms.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Product from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "billedBuyer": Buyer.from_dict(obj["billedBuyer"]) if obj.get("billedBuyer") is not None else None,
            "buyer": Buyer.from_dict(obj["buyer"]) if obj.get("buyer") is not None else None,
            "creationTimeMs": obj.get("creationTimeMs"),
            "creatorContacts": [ContactInformation.from_dict(_item) for _item in obj["creatorContacts"]] if obj.get("creatorContacts") is not None else None,
            "creatorRole": obj.get("creatorRole"),
            "deliveryControl": DeliveryControl.from_dict(obj["deliveryControl"]) if obj.get("deliveryControl") is not None else None,
            "flightEndTimeMs": obj.get("flightEndTimeMs"),
            "flightStartTimeMs": obj.get("flightStartTimeMs"),
            "hasCreatorSignedOff": obj.get("hasCreatorSignedOff"),
            "inventorySource": obj.get("inventorySource"),
            "kind": obj.get("kind") if obj.get("kind") is not None else 'adexchangebuyer#product',
            "labels": [MarketplaceLabel.from_dict(_item) for _item in obj["labels"]] if obj.get("labels") is not None else None,
            "lastUpdateTimeMs": obj.get("lastUpdateTimeMs"),
            "legacyOfferId": obj.get("legacyOfferId"),
            "marketplacePublisherProfileId": obj.get("marketplacePublisherProfileId"),
            "name": obj.get("name"),
            "privateAuctionId": obj.get("privateAuctionId"),
            "productId": obj.get("productId"),
            "publisherProfileId": obj.get("publisherProfileId"),
            "publisherProvidedForecast": PublisherProvidedForecast.from_dict(obj["publisherProvidedForecast"]) if obj.get("publisherProvidedForecast") is not None else None,
            "revisionNumber": obj.get("revisionNumber"),
            "seller": Seller.from_dict(obj["seller"]) if obj.get("seller") is not None else None,
            "sharedTargetings": [SharedTargeting.from_dict(_item) for _item in obj["sharedTargetings"]] if obj.get("sharedTargetings") is not None else None,
            "state": obj.get("state"),
            "syndicationProduct": obj.get("syndicationProduct"),
            "terms": DealTerms.from_dict(obj["terms"]) if obj.get("terms") is not None else None,
            "webPropertyCode": obj.get("webPropertyCode")
        })
        return _obj


