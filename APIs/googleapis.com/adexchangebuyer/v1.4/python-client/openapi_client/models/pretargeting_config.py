# coding: utf-8

"""
    Ad Exchange Buyer API

    Accesses your bidding-account information, submits creatives for validation, finds available direct deals, and retrieves performance reports.

    The version of the OpenAPI document: v1.4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.pretargeting_config_dimensions_inner import PretargetingConfigDimensionsInner
from openapi_client.models.pretargeting_config_excluded_placements_inner import PretargetingConfigExcludedPlacementsInner
from openapi_client.models.pretargeting_config_video_player_sizes_inner import PretargetingConfigVideoPlayerSizesInner
from typing import Optional, Set
from typing_extensions import Self

class PretargetingConfig(BaseModel):
    """
    PretargetingConfig
    """ # noqa: E501
    billing_id: Optional[StrictStr] = Field(default=None, description="The id for billing purposes, provided for reference. Leave this field blank for insert requests; the id will be generated automatically.", alias="billingId")
    config_id: Optional[StrictStr] = Field(default=None, description="The config id; generated automatically. Leave this field blank for insert requests.", alias="configId")
    config_name: Optional[StrictStr] = Field(default=None, description="The name of the config. Must be unique. Required for all requests.", alias="configName")
    creative_type: Optional[List[StrictStr]] = Field(default=None, description="List must contain exactly one of PRETARGETING_CREATIVE_TYPE_HTML or PRETARGETING_CREATIVE_TYPE_VIDEO.", alias="creativeType")
    dimensions: Optional[List[PretargetingConfigDimensionsInner]] = Field(default=None, description="Requests which allow one of these (width, height) pairs will match. All pairs must be supported ad dimensions.")
    excluded_content_labels: Optional[List[StrictStr]] = Field(default=None, description="Requests with any of these content labels will not match. Values are from content-labels.txt in the downloadable files section.", alias="excludedContentLabels")
    excluded_geo_criteria_ids: Optional[List[StrictStr]] = Field(default=None, description="Requests containing any of these geo criteria ids will not match.", alias="excludedGeoCriteriaIds")
    excluded_placements: Optional[List[PretargetingConfigExcludedPlacementsInner]] = Field(default=None, description="Requests containing any of these placements will not match.", alias="excludedPlacements")
    excluded_user_lists: Optional[List[StrictStr]] = Field(default=None, description="Requests containing any of these users list ids will not match.", alias="excludedUserLists")
    excluded_verticals: Optional[List[StrictStr]] = Field(default=None, description="Requests containing any of these vertical ids will not match. Values are from the publisher-verticals.txt file in the downloadable files section.", alias="excludedVerticals")
    geo_criteria_ids: Optional[List[StrictStr]] = Field(default=None, description="Requests containing any of these geo criteria ids will match.", alias="geoCriteriaIds")
    is_active: Optional[StrictBool] = Field(default=None, description="Whether this config is active. Required for all requests.", alias="isActive")
    kind: Optional[StrictStr] = Field(default='adexchangebuyer#pretargetingConfig', description="The kind of the resource, i.e. \"adexchangebuyer#pretargetingConfig\".")
    languages: Optional[List[StrictStr]] = Field(default=None, description="Request containing any of these language codes will match.")
    maximum_qps: Optional[StrictStr] = Field(default=None, description="The maximum QPS allocated to this pretargeting configuration, used for pretargeting-level QPS limits. By default, this is not set, which indicates that there is no QPS limit at the configuration level (a global or account-level limit may still be imposed).", alias="maximumQps")
    minimum_viewability_decile: Optional[StrictInt] = Field(default=None, description="Requests where the predicted viewability is below the specified decile will not match. E.g. if the buyer sets this value to 5, requests from slots where the predicted viewability is below 50% will not match. If the predicted viewability is unknown this field will be ignored.", alias="minimumViewabilityDecile")
    mobile_carriers: Optional[List[StrictStr]] = Field(default=None, description="Requests containing any of these mobile carrier ids will match. Values are from mobile-carriers.csv in the downloadable files section.", alias="mobileCarriers")
    mobile_devices: Optional[List[StrictStr]] = Field(default=None, description="Requests containing any of these mobile device ids will match. Values are from mobile-devices.csv in the downloadable files section.", alias="mobileDevices")
    mobile_operating_system_versions: Optional[List[StrictStr]] = Field(default=None, description="Requests containing any of these mobile operating system version ids will match. Values are from mobile-os.csv in the downloadable files section.", alias="mobileOperatingSystemVersions")
    placements: Optional[List[PretargetingConfigExcludedPlacementsInner]] = Field(default=None, description="Requests containing any of these placements will match.")
    platforms: Optional[List[StrictStr]] = Field(default=None, description="Requests matching any of these platforms will match. Possible values are PRETARGETING_PLATFORM_MOBILE, PRETARGETING_PLATFORM_DESKTOP, and PRETARGETING_PLATFORM_TABLET.")
    supported_creative_attributes: Optional[List[StrictStr]] = Field(default=None, description="Creative attributes should be declared here if all creatives corresponding to this pretargeting configuration have that creative attribute. Values are from pretargetable-creative-attributes.txt in the downloadable files section.", alias="supportedCreativeAttributes")
    user_identifier_data_required: Optional[List[StrictStr]] = Field(default=None, description="Requests containing the specified type of user data will match. Possible values are HOSTED_MATCH_DATA, which means the request is cookie-targetable and has a match in the buyer's hosted match table, and COOKIE_OR_IDFA, which means the request has either a targetable cookie or an iOS IDFA.", alias="userIdentifierDataRequired")
    user_lists: Optional[List[StrictStr]] = Field(default=None, description="Requests containing any of these user list ids will match.", alias="userLists")
    vendor_types: Optional[List[StrictStr]] = Field(default=None, description="Requests that allow any of these vendor ids will match. Values are from vendors.txt in the downloadable files section.", alias="vendorTypes")
    verticals: Optional[List[StrictStr]] = Field(default=None, description="Requests containing any of these vertical ids will match.")
    video_player_sizes: Optional[List[PretargetingConfigVideoPlayerSizesInner]] = Field(default=None, description="Video requests satisfying any of these player size constraints will match.", alias="videoPlayerSizes")
    __properties: ClassVar[List[str]] = ["billingId", "configId", "configName", "creativeType", "dimensions", "excludedContentLabels", "excludedGeoCriteriaIds", "excludedPlacements", "excludedUserLists", "excludedVerticals", "geoCriteriaIds", "isActive", "kind", "languages", "maximumQps", "minimumViewabilityDecile", "mobileCarriers", "mobileDevices", "mobileOperatingSystemVersions", "placements", "platforms", "supportedCreativeAttributes", "userIdentifierDataRequired", "userLists", "vendorTypes", "verticals", "videoPlayerSizes"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PretargetingConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in dimensions (list)
        _items = []
        if self.dimensions:
            for _item_dimensions in self.dimensions:
                if _item_dimensions:
                    _items.append(_item_dimensions.to_dict())
            _dict['dimensions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in excluded_placements (list)
        _items = []
        if self.excluded_placements:
            for _item_excluded_placements in self.excluded_placements:
                if _item_excluded_placements:
                    _items.append(_item_excluded_placements.to_dict())
            _dict['excludedPlacements'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in placements (list)
        _items = []
        if self.placements:
            for _item_placements in self.placements:
                if _item_placements:
                    _items.append(_item_placements.to_dict())
            _dict['placements'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in video_player_sizes (list)
        _items = []
        if self.video_player_sizes:
            for _item_video_player_sizes in self.video_player_sizes:
                if _item_video_player_sizes:
                    _items.append(_item_video_player_sizes.to_dict())
            _dict['videoPlayerSizes'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PretargetingConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "billingId": obj.get("billingId"),
            "configId": obj.get("configId"),
            "configName": obj.get("configName"),
            "creativeType": obj.get("creativeType"),
            "dimensions": [PretargetingConfigDimensionsInner.from_dict(_item) for _item in obj["dimensions"]] if obj.get("dimensions") is not None else None,
            "excludedContentLabels": obj.get("excludedContentLabels"),
            "excludedGeoCriteriaIds": obj.get("excludedGeoCriteriaIds"),
            "excludedPlacements": [PretargetingConfigExcludedPlacementsInner.from_dict(_item) for _item in obj["excludedPlacements"]] if obj.get("excludedPlacements") is not None else None,
            "excludedUserLists": obj.get("excludedUserLists"),
            "excludedVerticals": obj.get("excludedVerticals"),
            "geoCriteriaIds": obj.get("geoCriteriaIds"),
            "isActive": obj.get("isActive"),
            "kind": obj.get("kind") if obj.get("kind") is not None else 'adexchangebuyer#pretargetingConfig',
            "languages": obj.get("languages"),
            "maximumQps": obj.get("maximumQps"),
            "minimumViewabilityDecile": obj.get("minimumViewabilityDecile"),
            "mobileCarriers": obj.get("mobileCarriers"),
            "mobileDevices": obj.get("mobileDevices"),
            "mobileOperatingSystemVersions": obj.get("mobileOperatingSystemVersions"),
            "placements": [PretargetingConfigExcludedPlacementsInner.from_dict(_item) for _item in obj["placements"]] if obj.get("placements") is not None else None,
            "platforms": obj.get("platforms"),
            "supportedCreativeAttributes": obj.get("supportedCreativeAttributes"),
            "userIdentifierDataRequired": obj.get("userIdentifierDataRequired"),
            "userLists": obj.get("userLists"),
            "vendorTypes": obj.get("vendorTypes"),
            "verticals": obj.get("verticals"),
            "videoPlayerSizes": [PretargetingConfigVideoPlayerSizesInner.from_dict(_item) for _item in obj["videoPlayerSizes"]] if obj.get("videoPlayerSizes") is not None else None
        })
        return _obj


