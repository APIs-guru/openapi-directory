# coding: utf-8

"""
    Ad Exchange Buyer API

    Accesses your bidding-account information, submits creatives for validation, finds available direct deals, and retrieves performance reports.

    The version of the OpenAPI document: v1.2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.creative_corrections_inner import CreativeCorrectionsInner
from openapi_client.models.creative_disapproval_reasons_inner import CreativeDisapprovalReasonsInner
from openapi_client.models.creative_filtering_reasons import CreativeFilteringReasons
from typing import Optional, Set
from typing_extensions import Self

class Creative(BaseModel):
    """
    A creative and its classification data.
    """ # noqa: E501
    html_snippet: Optional[StrictStr] = Field(default=None, description="The HTML snippet that displays the ad when inserted in the web page. If set, videoURL should not be set.", alias="HTMLSnippet")
    account_id: Optional[StrictInt] = Field(default=None, description="Account id.", alias="accountId")
    advertiser_id: Optional[List[StrictStr]] = Field(default=None, description="Detected advertiser id, if any. Read-only. This field should not be set in requests.", alias="advertiserId")
    advertiser_name: Optional[StrictStr] = Field(default=None, description="The name of the company being advertised in the creative.", alias="advertiserName")
    agency_id: Optional[StrictStr] = Field(default=None, description="The agency id for this creative.", alias="agencyId")
    api_upload_timestamp: Optional[datetime] = Field(default=None, description="The last upload timestamp of this creative if it was uploaded via API. Read-only. The value of this field is generated, and will be ignored for uploads. (formatted RFC 3339 timestamp).", alias="apiUploadTimestamp")
    attribute: Optional[List[StrictInt]] = Field(default=None, description="All attributes for the ads that may be shown from this snippet.")
    buyer_creative_id: Optional[StrictStr] = Field(default=None, description="A buyer-specific id identifying the creative in this ad.", alias="buyerCreativeId")
    click_through_url: Optional[List[StrictStr]] = Field(default=None, description="The set of destination urls for the snippet.", alias="clickThroughUrl")
    corrections: Optional[List[CreativeCorrectionsInner]] = Field(default=None, description="Shows any corrections that were applied to this creative. Read-only. This field should not be set in requests.")
    disapproval_reasons: Optional[List[CreativeDisapprovalReasonsInner]] = Field(default=None, description="The reasons for disapproval, if any. Note that not all disapproval reasons may be categorized, so it is possible for the creative to have a status of DISAPPROVED with an empty list for disapproval_reasons. In this case, please reach out to your TAM to help debug the issue. Read-only. This field should not be set in requests.", alias="disapprovalReasons")
    filtering_reasons: Optional[CreativeFilteringReasons] = Field(default=None, alias="filteringReasons")
    height: Optional[StrictInt] = Field(default=None, description="Ad height.")
    impression_tracking_url: Optional[List[StrictStr]] = Field(default=None, description="The set of urls to be called to record an impression.", alias="impressionTrackingUrl")
    kind: Optional[StrictStr] = Field(default='adexchangebuyer#creative', description="Resource type.")
    product_categories: Optional[List[StrictInt]] = Field(default=None, description="Detected product categories, if any. Read-only. This field should not be set in requests.", alias="productCategories")
    restricted_categories: Optional[List[StrictInt]] = Field(default=None, description="All restricted categories for the ads that may be shown from this snippet.", alias="restrictedCategories")
    sensitive_categories: Optional[List[StrictInt]] = Field(default=None, description="Detected sensitive categories, if any. Read-only. This field should not be set in requests.", alias="sensitiveCategories")
    status: Optional[StrictStr] = Field(default=None, description="Creative serving status. Read-only. This field should not be set in requests.")
    vendor_type: Optional[List[StrictInt]] = Field(default=None, description="All vendor types for the ads that may be shown from this snippet.", alias="vendorType")
    version: Optional[StrictInt] = Field(default=None, description="The version for this creative. Read-only. This field should not be set in requests.")
    video_url: Optional[StrictStr] = Field(default=None, description="The url to fetch a video ad. If set, HTMLSnippet should not be set.", alias="videoURL")
    width: Optional[StrictInt] = Field(default=None, description="Ad width.")
    __properties: ClassVar[List[str]] = ["HTMLSnippet", "accountId", "advertiserId", "advertiserName", "agencyId", "apiUploadTimestamp", "attribute", "buyerCreativeId", "clickThroughUrl", "corrections", "disapprovalReasons", "filteringReasons", "height", "impressionTrackingUrl", "kind", "productCategories", "restrictedCategories", "sensitiveCategories", "status", "vendorType", "version", "videoURL", "width"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Creative from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in corrections (list)
        _items = []
        if self.corrections:
            for _item_corrections in self.corrections:
                if _item_corrections:
                    _items.append(_item_corrections.to_dict())
            _dict['corrections'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in disapproval_reasons (list)
        _items = []
        if self.disapproval_reasons:
            for _item_disapproval_reasons in self.disapproval_reasons:
                if _item_disapproval_reasons:
                    _items.append(_item_disapproval_reasons.to_dict())
            _dict['disapprovalReasons'] = _items
        # override the default output from pydantic by calling `to_dict()` of filtering_reasons
        if self.filtering_reasons:
            _dict['filteringReasons'] = self.filtering_reasons.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Creative from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "HTMLSnippet": obj.get("HTMLSnippet"),
            "accountId": obj.get("accountId"),
            "advertiserId": obj.get("advertiserId"),
            "advertiserName": obj.get("advertiserName"),
            "agencyId": obj.get("agencyId"),
            "apiUploadTimestamp": obj.get("apiUploadTimestamp"),
            "attribute": obj.get("attribute"),
            "buyerCreativeId": obj.get("buyerCreativeId"),
            "clickThroughUrl": obj.get("clickThroughUrl"),
            "corrections": [CreativeCorrectionsInner.from_dict(_item) for _item in obj["corrections"]] if obj.get("corrections") is not None else None,
            "disapprovalReasons": [CreativeDisapprovalReasonsInner.from_dict(_item) for _item in obj["disapprovalReasons"]] if obj.get("disapprovalReasons") is not None else None,
            "filteringReasons": CreativeFilteringReasons.from_dict(obj["filteringReasons"]) if obj.get("filteringReasons") is not None else None,
            "height": obj.get("height"),
            "impressionTrackingUrl": obj.get("impressionTrackingUrl"),
            "kind": obj.get("kind") if obj.get("kind") is not None else 'adexchangebuyer#creative',
            "productCategories": obj.get("productCategories"),
            "restrictedCategories": obj.get("restrictedCategories"),
            "sensitiveCategories": obj.get("sensitiveCategories"),
            "status": obj.get("status"),
            "vendorType": obj.get("vendorType"),
            "version": obj.get("version"),
            "videoURL": obj.get("videoURL"),
            "width": obj.get("width")
        })
        return _obj


