# coding: utf-8

"""
    Cloud Spanner API

    Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictBytes, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.directed_read_options import DirectedReadOptions
from openapi_client.models.query_options import QueryOptions
from openapi_client.models.request_options import RequestOptions
from openapi_client.models.transaction_selector import TransactionSelector
from openapi_client.models.type import Type
from typing import Optional, Set
from typing_extensions import Self

class ExecuteSqlRequest(BaseModel):
    """
    The request for ExecuteSql and ExecuteStreamingSql.
    """ # noqa: E501
    data_boost_enabled: Optional[StrictBool] = Field(default=None, description="If this is for a partitioned query and this field is set to `true`, the request is executed with Spanner Data Boost independent compute resources. If the field is set to `true` but the request does not set `partition_token`, the API returns an `INVALID_ARGUMENT` error.", alias="dataBoostEnabled")
    directed_read_options: Optional[DirectedReadOptions] = Field(default=None, alias="directedReadOptions")
    param_types: Optional[Dict[str, Type]] = Field(default=None, description="It is not always possible for Cloud Spanner to infer the right SQL type from a JSON value. For example, values of type `BYTES` and values of type `STRING` both appear in params as JSON strings. In these cases, `param_types` can be used to specify the exact SQL type for some or all of the SQL statement parameters. See the definition of Type for more information about SQL types.", alias="paramTypes")
    params: Optional[Dict[str, Any]] = Field(default=None, description="Parameter names and values that bind to placeholders in the SQL string. A parameter placeholder consists of the `@` character followed by the parameter name (for example, `@firstName`). Parameter names must conform to the naming requirements of identifiers as specified at https://cloud.google.com/spanner/docs/lexical#identifiers. Parameters can appear anywhere that a literal value is expected. The same parameter name can be used more than once, for example: `\"WHERE id > @msg_id AND id < @msg_id + 100\"` It is an error to execute a SQL statement with unbound parameters.")
    partition_token: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="If present, results will be restricted to the specified partition previously created using PartitionQuery(). There must be an exact match for the values of fields common to this message and the PartitionQueryRequest message used to create this partition_token.", alias="partitionToken")
    query_mode: Optional[StrictStr] = Field(default=None, description="Used to control the amount of debugging information returned in ResultSetStats. If partition_token is set, query_mode can only be set to QueryMode.NORMAL.", alias="queryMode")
    query_options: Optional[QueryOptions] = Field(default=None, alias="queryOptions")
    request_options: Optional[RequestOptions] = Field(default=None, alias="requestOptions")
    resume_token: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="If this request is resuming a previously interrupted SQL statement execution, `resume_token` should be copied from the last PartialResultSet yielded before the interruption. Doing this enables the new SQL statement execution to resume where the last one left off. The rest of the request parameters must exactly match the request that yielded this token.", alias="resumeToken")
    seqno: Optional[StrictStr] = Field(default=None, description="A per-transaction sequence number used to identify this request. This field makes each request idempotent such that if the request is received multiple times, at most one will succeed. The sequence number must be monotonically increasing within the transaction. If a request arrives for the first time with an out-of-order sequence number, the transaction may be aborted. Replays of previously handled requests will yield the same response as the first execution. Required for DML statements. Ignored for queries.")
    sql: Optional[StrictStr] = Field(default=None, description="Required. The SQL string.")
    transaction: Optional[TransactionSelector] = None
    __properties: ClassVar[List[str]] = ["dataBoostEnabled", "directedReadOptions", "paramTypes", "params", "partitionToken", "queryMode", "queryOptions", "requestOptions", "resumeToken", "seqno", "sql", "transaction"]

    @field_validator('query_mode')
    def query_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NORMAL', 'PLAN', 'PROFILE']):
            raise ValueError("must be one of enum values ('NORMAL', 'PLAN', 'PROFILE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ExecuteSqlRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of directed_read_options
        if self.directed_read_options:
            _dict['directedReadOptions'] = self.directed_read_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in param_types (dict)
        _field_dict = {}
        if self.param_types:
            for _key_param_types in self.param_types:
                if self.param_types[_key_param_types]:
                    _field_dict[_key_param_types] = self.param_types[_key_param_types].to_dict()
            _dict['paramTypes'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of query_options
        if self.query_options:
            _dict['queryOptions'] = self.query_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of request_options
        if self.request_options:
            _dict['requestOptions'] = self.request_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of transaction
        if self.transaction:
            _dict['transaction'] = self.transaction.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ExecuteSqlRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "dataBoostEnabled": obj.get("dataBoostEnabled"),
            "directedReadOptions": DirectedReadOptions.from_dict(obj["directedReadOptions"]) if obj.get("directedReadOptions") is not None else None,
            "paramTypes": dict(
                (_k, Type.from_dict(_v))
                for _k, _v in obj["paramTypes"].items()
            )
            if obj.get("paramTypes") is not None
            else None,
            "params": obj.get("params"),
            "partitionToken": obj.get("partitionToken"),
            "queryMode": obj.get("queryMode"),
            "queryOptions": QueryOptions.from_dict(obj["queryOptions"]) if obj.get("queryOptions") is not None else None,
            "requestOptions": RequestOptions.from_dict(obj["requestOptions"]) if obj.get("requestOptions") is not None else None,
            "resumeToken": obj.get("resumeToken"),
            "seqno": obj.get("seqno"),
            "sql": obj.get("sql"),
            "transaction": TransactionSelector.from_dict(obj["transaction"]) if obj.get("transaction") is not None else None
        })
        return _obj


