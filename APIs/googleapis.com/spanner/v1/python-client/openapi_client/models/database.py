# coding: utf-8

"""
    Cloud Spanner API

    Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.encryption_config import EncryptionConfig
from openapi_client.models.encryption_info import EncryptionInfo
from openapi_client.models.restore_info import RestoreInfo
from typing import Optional, Set
from typing_extensions import Self

class Database(BaseModel):
    """
    A Cloud Spanner database.
    """ # noqa: E501
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. If exists, the time at which the database creation started.", alias="createTime")
    database_dialect: Optional[StrictStr] = Field(default=None, description="Output only. The dialect of the Cloud Spanner Database.", alias="databaseDialect")
    default_leader: Optional[StrictStr] = Field(default=None, description="Output only. The read-write region which contains the database's leader replicas. This is the same as the value of default_leader database option set using DatabaseAdmin.CreateDatabase or DatabaseAdmin.UpdateDatabaseDdl. If not explicitly set, this is empty.", alias="defaultLeader")
    earliest_version_time: Optional[StrictStr] = Field(default=None, description="Output only. Earliest timestamp at which older versions of the data can be read. This value is continuously updated by Cloud Spanner and becomes stale the moment it is queried. If you are using this value to recover data, make sure to account for the time from the moment when the value is queried to the moment when you initiate the recovery.", alias="earliestVersionTime")
    enable_drop_protection: Optional[StrictBool] = Field(default=None, description="Whether drop protection is enabled for this database. Defaults to false, if not set. For more details, please see how to [prevent accidental database deletion](https://cloud.google.com/spanner/docs/prevent-database-deletion).", alias="enableDropProtection")
    encryption_config: Optional[EncryptionConfig] = Field(default=None, alias="encryptionConfig")
    encryption_info: Optional[List[EncryptionInfo]] = Field(default=None, description="Output only. For databases that are using customer managed encryption, this field contains the encryption information for the database, such as all Cloud KMS key versions that are in use. The `encryption_status' field inside of each `EncryptionInfo` is not populated. For databases that are using Google default or other types of encryption, this field is empty. This field is propagated lazily from the backend. There might be a delay from when a key version is being used and when it appears in this field.", alias="encryptionInfo")
    name: Optional[StrictStr] = Field(default=None, description="Required. The name of the database. Values are of the form `projects//instances//databases/`, where `` is as specified in the `CREATE DATABASE` statement. This name can be passed to other API methods to identify the database.")
    reconciling: Optional[StrictBool] = Field(default=None, description="Output only. If true, the database is being updated. If false, there are no ongoing update operations for the database.")
    restore_info: Optional[RestoreInfo] = Field(default=None, alias="restoreInfo")
    state: Optional[StrictStr] = Field(default=None, description="Output only. The current database state.")
    version_retention_period: Optional[StrictStr] = Field(default=None, description="Output only. The period in which Cloud Spanner retains all versions of data for the database. This is the same as the value of version_retention_period database option set using UpdateDatabaseDdl. Defaults to 1 hour, if not set.", alias="versionRetentionPeriod")
    __properties: ClassVar[List[str]] = ["createTime", "databaseDialect", "defaultLeader", "earliestVersionTime", "enableDropProtection", "encryptionConfig", "encryptionInfo", "name", "reconciling", "restoreInfo", "state", "versionRetentionPeriod"]

    @field_validator('database_dialect')
    def database_dialect_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DATABASE_DIALECT_UNSPECIFIED', 'GOOGLE_STANDARD_SQL', 'POSTGRESQL']):
            raise ValueError("must be one of enum values ('DATABASE_DIALECT_UNSPECIFIED', 'GOOGLE_STANDARD_SQL', 'POSTGRESQL')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'CREATING', 'READY', 'READY_OPTIMIZING']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'CREATING', 'READY', 'READY_OPTIMIZING')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Database from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "database_dialect",
            "default_leader",
            "earliest_version_time",
            "encryption_info",
            "reconciling",
            "state",
            "version_retention_period",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of encryption_config
        if self.encryption_config:
            _dict['encryptionConfig'] = self.encryption_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in encryption_info (list)
        _items = []
        if self.encryption_info:
            for _item_encryption_info in self.encryption_info:
                if _item_encryption_info:
                    _items.append(_item_encryption_info.to_dict())
            _dict['encryptionInfo'] = _items
        # override the default output from pydantic by calling `to_dict()` of restore_info
        if self.restore_info:
            _dict['restoreInfo'] = self.restore_info.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Database from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "createTime": obj.get("createTime"),
            "databaseDialect": obj.get("databaseDialect"),
            "defaultLeader": obj.get("defaultLeader"),
            "earliestVersionTime": obj.get("earliestVersionTime"),
            "enableDropProtection": obj.get("enableDropProtection"),
            "encryptionConfig": EncryptionConfig.from_dict(obj["encryptionConfig"]) if obj.get("encryptionConfig") is not None else None,
            "encryptionInfo": [EncryptionInfo.from_dict(_item) for _item in obj["encryptionInfo"]] if obj.get("encryptionInfo") is not None else None,
            "name": obj.get("name"),
            "reconciling": obj.get("reconciling"),
            "restoreInfo": RestoreInfo.from_dict(obj["restoreInfo"]) if obj.get("restoreInfo") is not None else None,
            "state": obj.get("state"),
            "versionRetentionPeriod": obj.get("versionRetentionPeriod")
        })
        return _obj


