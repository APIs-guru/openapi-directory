# coding: utf-8

"""
    Cloud Spanner API

    Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictBytes, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.directed_read_options import DirectedReadOptions
from openapi_client.models.key_set import KeySet
from openapi_client.models.request_options import RequestOptions
from openapi_client.models.transaction_selector import TransactionSelector
from typing import Optional, Set
from typing_extensions import Self

class ReadRequest(BaseModel):
    """
    The request for Read and StreamingRead.
    """ # noqa: E501
    columns: Optional[List[StrictStr]] = Field(default=None, description="Required. The columns of table to be returned for each row matching this request.")
    data_boost_enabled: Optional[StrictBool] = Field(default=None, description="If this is for a partitioned read and this field is set to `true`, the request is executed with Spanner Data Boost independent compute resources. If the field is set to `true` but the request does not set `partition_token`, the API returns an `INVALID_ARGUMENT` error.", alias="dataBoostEnabled")
    directed_read_options: Optional[DirectedReadOptions] = Field(default=None, alias="directedReadOptions")
    index: Optional[StrictStr] = Field(default=None, description="If non-empty, the name of an index on table. This index is used instead of the table primary key when interpreting key_set and sorting result rows. See key_set for further information.")
    key_set: Optional[KeySet] = Field(default=None, alias="keySet")
    limit: Optional[StrictStr] = Field(default=None, description="If greater than zero, only the first `limit` rows are yielded. If `limit` is zero, the default is no limit. A limit cannot be specified if `partition_token` is set.")
    partition_token: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="If present, results will be restricted to the specified partition previously created using PartitionRead(). There must be an exact match for the values of fields common to this message and the PartitionReadRequest message used to create this partition_token.", alias="partitionToken")
    request_options: Optional[RequestOptions] = Field(default=None, alias="requestOptions")
    resume_token: Optional[Union[StrictBytes, StrictStr]] = Field(default=None, description="If this request is resuming a previously interrupted read, `resume_token` should be copied from the last PartialResultSet yielded before the interruption. Doing this enables the new read to resume where the last read left off. The rest of the request parameters must exactly match the request that yielded this token.", alias="resumeToken")
    table: Optional[StrictStr] = Field(default=None, description="Required. The name of the table in the database to be read.")
    transaction: Optional[TransactionSelector] = None
    __properties: ClassVar[List[str]] = ["columns", "dataBoostEnabled", "directedReadOptions", "index", "keySet", "limit", "partitionToken", "requestOptions", "resumeToken", "table", "transaction"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReadRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of directed_read_options
        if self.directed_read_options:
            _dict['directedReadOptions'] = self.directed_read_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of key_set
        if self.key_set:
            _dict['keySet'] = self.key_set.to_dict()
        # override the default output from pydantic by calling `to_dict()` of request_options
        if self.request_options:
            _dict['requestOptions'] = self.request_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of transaction
        if self.transaction:
            _dict['transaction'] = self.transaction.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReadRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "columns": obj.get("columns"),
            "dataBoostEnabled": obj.get("dataBoostEnabled"),
            "directedReadOptions": DirectedReadOptions.from_dict(obj["directedReadOptions"]) if obj.get("directedReadOptions") is not None else None,
            "index": obj.get("index"),
            "keySet": KeySet.from_dict(obj["keySet"]) if obj.get("keySet") is not None else None,
            "limit": obj.get("limit"),
            "partitionToken": obj.get("partitionToken"),
            "requestOptions": RequestOptions.from_dict(obj["requestOptions"]) if obj.get("requestOptions") is not None else None,
            "resumeToken": obj.get("resumeToken"),
            "table": obj.get("table"),
            "transaction": TransactionSelector.from_dict(obj["transaction"]) if obj.get("transaction") is not None else None
        })
        return _obj


