# coding: utf-8

"""
    Kubernetes Engine API

    Builds and manages container-based applications, powered by the open source Kubernetes technology.

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.node_management import NodeManagement
from openapi_client.models.shielded_instance_config import ShieldedInstanceConfig
from openapi_client.models.upgrade_settings import UpgradeSettings
from typing import Optional, Set
from typing_extensions import Self

class AutoprovisioningNodePoolDefaults(BaseModel):
    """
    AutoprovisioningNodePoolDefaults contains defaults for a node pool created by NAP.
    """ # noqa: E501
    boot_disk_kms_key: Optional[StrictStr] = Field(default=None, description=" The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption", alias="bootDiskKmsKey")
    disk_size_gb: Optional[StrictInt] = Field(default=None, description="Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. If unspecified, the default disk size is 100GB.", alias="diskSizeGb")
    disk_type: Optional[StrictStr] = Field(default=None, description="Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or 'pd-balanced') If unspecified, the default disk type is 'pd-standard'", alias="diskType")
    image_type: Optional[StrictStr] = Field(default=None, description="The image type to use for NAP created node. Please see https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for available image types.", alias="imageType")
    insecure_kubelet_readonly_port_enabled: Optional[StrictBool] = Field(default=None, description="Enable or disable Kubelet read only port.", alias="insecureKubeletReadonlyPortEnabled")
    management: Optional[NodeManagement] = None
    min_cpu_platform: Optional[StrictStr] = Field(default=None, description="Deprecated. Minimum CPU platform to be used for NAP created node pools. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as minCpuPlatform: Intel Haswell or minCpuPlatform: Intel Sandy Bridge. For more information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform). This field is deprecated, min_cpu_platform should be specified using `cloud.google.com/requested-min-cpu-platform` label selector on the pod. To unset the min cpu platform field pass \"automatic\" as field value.", alias="minCpuPlatform")
    oauth_scopes: Optional[List[StrictStr]] = Field(default=None, description="The set of Google API scopes to be made available on all of the node VMs under the \"default\" service account. The following scopes are recommended, but not required, and by default are not included: * `https://www.googleapis.com/auth/compute` is required for mounting persistent storage on your nodes. * `https://www.googleapis.com/auth/devstorage.read_only` is required for communicating with **gcr.io** (the [Google Container Registry](https://cloud.google.com/container-registry/)). If unspecified, no scopes are added, unless Cloud Logging or Cloud Monitoring are enabled, in which case their required scopes will be added.", alias="oauthScopes")
    service_account: Optional[StrictStr] = Field(default=None, description="The Google Cloud Platform Service Account to be used by the node VMs. Specify the email address of the Service Account; otherwise, if no Service Account is specified, the \"default\" service account is used.", alias="serviceAccount")
    shielded_instance_config: Optional[ShieldedInstanceConfig] = Field(default=None, alias="shieldedInstanceConfig")
    upgrade_settings: Optional[UpgradeSettings] = Field(default=None, alias="upgradeSettings")
    __properties: ClassVar[List[str]] = ["bootDiskKmsKey", "diskSizeGb", "diskType", "imageType", "insecureKubeletReadonlyPortEnabled", "management", "minCpuPlatform", "oauthScopes", "serviceAccount", "shieldedInstanceConfig", "upgradeSettings"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AutoprovisioningNodePoolDefaults from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of management
        if self.management:
            _dict['management'] = self.management.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shielded_instance_config
        if self.shielded_instance_config:
            _dict['shieldedInstanceConfig'] = self.shielded_instance_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of upgrade_settings
        if self.upgrade_settings:
            _dict['upgradeSettings'] = self.upgrade_settings.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AutoprovisioningNodePoolDefaults from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "bootDiskKmsKey": obj.get("bootDiskKmsKey"),
            "diskSizeGb": obj.get("diskSizeGb"),
            "diskType": obj.get("diskType"),
            "imageType": obj.get("imageType"),
            "insecureKubeletReadonlyPortEnabled": obj.get("insecureKubeletReadonlyPortEnabled"),
            "management": NodeManagement.from_dict(obj["management"]) if obj.get("management") is not None else None,
            "minCpuPlatform": obj.get("minCpuPlatform"),
            "oauthScopes": obj.get("oauthScopes"),
            "serviceAccount": obj.get("serviceAccount"),
            "shieldedInstanceConfig": ShieldedInstanceConfig.from_dict(obj["shieldedInstanceConfig"]) if obj.get("shieldedInstanceConfig") is not None else None,
            "upgradeSettings": UpgradeSettings.from_dict(obj["upgradeSettings"]) if obj.get("upgradeSettings") is not None else None
        })
        return _obj


