# coding: utf-8

"""
    Kubernetes Engine API

    Builds and manages container-based applications, powered by the open source Kubernetes technology.

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.additional_pod_ranges_config import AdditionalPodRangesConfig
from openapi_client.models.addons_config import AddonsConfig
from openapi_client.models.authenticator_groups_config import AuthenticatorGroupsConfig
from openapi_client.models.binary_authorization import BinaryAuthorization
from openapi_client.models.cluster_autoscaling import ClusterAutoscaling
from openapi_client.models.cluster_network_performance_config import ClusterNetworkPerformanceConfig
from openapi_client.models.cluster_telemetry import ClusterTelemetry
from openapi_client.models.cost_management_config import CostManagementConfig
from openapi_client.models.database_encryption import DatabaseEncryption
from openapi_client.models.default_snat_status import DefaultSnatStatus
from openapi_client.models.dns_config import DNSConfig
from openapi_client.models.fleet import Fleet
from openapi_client.models.gateway_api_config import GatewayAPIConfig
from openapi_client.models.gcfs_config import GcfsConfig
from openapi_client.models.host_maintenance_policy import HostMaintenancePolicy
from openapi_client.models.identity_service_config import IdentityServiceConfig
from openapi_client.models.ilb_subsetting_config import ILBSubsettingConfig
from openapi_client.models.intra_node_visibility_config import IntraNodeVisibilityConfig
from openapi_client.models.k8s_beta_api_config import K8sBetaAPIConfig
from openapi_client.models.logging_config import LoggingConfig
from openapi_client.models.master_authorized_networks_config import MasterAuthorizedNetworksConfig
from openapi_client.models.mesh_certificates import MeshCertificates
from openapi_client.models.monitoring_config import MonitoringConfig
from openapi_client.models.network_tags import NetworkTags
from openapi_client.models.node_pool_autoscaling import NodePoolAutoscaling
from openapi_client.models.node_pool_logging_config import NodePoolLoggingConfig
from openapi_client.models.notification_config import NotificationConfig
from openapi_client.models.parent_product_config import ParentProductConfig
from openapi_client.models.pod_security_policy_config import PodSecurityPolicyConfig
from openapi_client.models.private_cluster_config import PrivateClusterConfig
from openapi_client.models.protect_config import ProtectConfig
from openapi_client.models.release_channel import ReleaseChannel
from openapi_client.models.resource_manager_tags import ResourceManagerTags
from openapi_client.models.resource_usage_export_config import ResourceUsageExportConfig
from openapi_client.models.security_posture_config import SecurityPostureConfig
from openapi_client.models.service_external_ips_config import ServiceExternalIPsConfig
from openapi_client.models.shielded_nodes import ShieldedNodes
from openapi_client.models.tpu_config import TpuConfig
from openapi_client.models.vertical_pod_autoscaling import VerticalPodAutoscaling
from openapi_client.models.workload_alts_config import WorkloadALTSConfig
from openapi_client.models.workload_certificates import WorkloadCertificates
from openapi_client.models.workload_identity_config import WorkloadIdentityConfig
from openapi_client.models.workload_policy_config import WorkloadPolicyConfig
from typing import Optional, Set
from typing_extensions import Self

class ClusterUpdate(BaseModel):
    """
    ClusterUpdate describes an update to the cluster. Exactly one update can be applied to a cluster with each request, so at most one field can be provided.
    """ # noqa: E501
    additional_pod_ranges_config: Optional[AdditionalPodRangesConfig] = Field(default=None, alias="additionalPodRangesConfig")
    desired_addons_config: Optional[AddonsConfig] = Field(default=None, alias="desiredAddonsConfig")
    desired_authenticator_groups_config: Optional[AuthenticatorGroupsConfig] = Field(default=None, alias="desiredAuthenticatorGroupsConfig")
    desired_autopilot_workload_policy_config: Optional[WorkloadPolicyConfig] = Field(default=None, alias="desiredAutopilotWorkloadPolicyConfig")
    desired_binary_authorization: Optional[BinaryAuthorization] = Field(default=None, alias="desiredBinaryAuthorization")
    desired_cluster_autoscaling: Optional[ClusterAutoscaling] = Field(default=None, alias="desiredClusterAutoscaling")
    desired_cluster_telemetry: Optional[ClusterTelemetry] = Field(default=None, alias="desiredClusterTelemetry")
    desired_cost_management_config: Optional[CostManagementConfig] = Field(default=None, alias="desiredCostManagementConfig")
    desired_database_encryption: Optional[DatabaseEncryption] = Field(default=None, alias="desiredDatabaseEncryption")
    desired_datapath_provider: Optional[StrictStr] = Field(default=None, description="The desired datapath provider for the cluster.", alias="desiredDatapathProvider")
    desired_default_snat_status: Optional[DefaultSnatStatus] = Field(default=None, alias="desiredDefaultSnatStatus")
    desired_dns_config: Optional[DNSConfig] = Field(default=None, alias="desiredDnsConfig")
    desired_enable_fqdn_network_policy: Optional[StrictBool] = Field(default=None, description="Enable/Disable FQDN Network Policy for the cluster.", alias="desiredEnableFqdnNetworkPolicy")
    desired_enable_private_endpoint: Optional[StrictBool] = Field(default=None, description="Enable/Disable private endpoint for the cluster's master.", alias="desiredEnablePrivateEndpoint")
    desired_fleet: Optional[Fleet] = Field(default=None, alias="desiredFleet")
    desired_gateway_api_config: Optional[GatewayAPIConfig] = Field(default=None, alias="desiredGatewayApiConfig")
    desired_gcfs_config: Optional[GcfsConfig] = Field(default=None, alias="desiredGcfsConfig")
    desired_host_maintenance_policy: Optional[HostMaintenancePolicy] = Field(default=None, alias="desiredHostMaintenancePolicy")
    desired_identity_service_config: Optional[IdentityServiceConfig] = Field(default=None, alias="desiredIdentityServiceConfig")
    desired_image_type: Optional[StrictStr] = Field(default=None, description="The desired image type for the node pool. NOTE: Set the \"desired_node_pool\" field as well.", alias="desiredImageType")
    desired_in_transit_encryption_config: Optional[StrictStr] = Field(default=None, description="Specify the details of in-transit encryption.", alias="desiredInTransitEncryptionConfig")
    desired_intra_node_visibility_config: Optional[IntraNodeVisibilityConfig] = Field(default=None, alias="desiredIntraNodeVisibilityConfig")
    desired_k8s_beta_apis: Optional[K8sBetaAPIConfig] = Field(default=None, alias="desiredK8sBetaApis")
    desired_l4ilb_subsetting_config: Optional[ILBSubsettingConfig] = Field(default=None, alias="desiredL4ilbSubsettingConfig")
    desired_locations: Optional[List[StrictStr]] = Field(default=None, description="The desired list of Google Compute Engine [zones](https://cloud.google.com/compute/docs/zones#available) in which the cluster's nodes should be located. This list must always include the cluster's primary zone. Warning: changing cluster locations will update the locations of all node pools and will result in nodes being added and/or removed.", alias="desiredLocations")
    desired_logging_config: Optional[LoggingConfig] = Field(default=None, alias="desiredLoggingConfig")
    desired_logging_service: Optional[StrictStr] = Field(default=None, description="The logging service the cluster should use to write logs. Currently available options: * `logging.googleapis.com/kubernetes` - The Cloud Logging service with a Kubernetes-native resource model * `logging.googleapis.com` - The legacy Cloud Logging service (no longer available as of GKE 1.15). * `none` - no logs will be exported from the cluster. If left as an empty string,`logging.googleapis.com/kubernetes` will be used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.", alias="desiredLoggingService")
    desired_master: Optional[Dict[str, Any]] = Field(default=None, description="Master is the configuration for components on master.", alias="desiredMaster")
    desired_master_authorized_networks_config: Optional[MasterAuthorizedNetworksConfig] = Field(default=None, alias="desiredMasterAuthorizedNetworksConfig")
    desired_master_version: Optional[StrictStr] = Field(default=None, description="The Kubernetes version to change the master to. The only valid value is the latest supported version. Users may specify either explicit versions offered by Kubernetes Engine or version aliases, which have the following behavior: - \"latest\": picks the highest valid Kubernetes version - \"1.X\": picks the highest valid patch+gke.N patch in the 1.X version - \"1.X.Y\": picks the highest valid gke.N patch in the 1.X.Y version - \"1.X.Y-gke.N\": picks an explicit Kubernetes version - \"-\": picks the default Kubernetes version", alias="desiredMasterVersion")
    desired_mesh_certificates: Optional[MeshCertificates] = Field(default=None, alias="desiredMeshCertificates")
    desired_monitoring_config: Optional[MonitoringConfig] = Field(default=None, alias="desiredMonitoringConfig")
    desired_monitoring_service: Optional[StrictStr] = Field(default=None, description="The monitoring service the cluster should use to write metrics. Currently available options: * \"monitoring.googleapis.com/kubernetes\" - The Cloud Monitoring service with a Kubernetes-native resource model * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no longer available as of GKE 1.15). * `none` - No metrics will be exported from the cluster. If left as an empty string,`monitoring.googleapis.com/kubernetes` will be used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.", alias="desiredMonitoringService")
    desired_network_performance_config: Optional[ClusterNetworkPerformanceConfig] = Field(default=None, alias="desiredNetworkPerformanceConfig")
    desired_node_pool_auto_config_network_tags: Optional[NetworkTags] = Field(default=None, alias="desiredNodePoolAutoConfigNetworkTags")
    desired_node_pool_auto_config_resource_manager_tags: Optional[ResourceManagerTags] = Field(default=None, alias="desiredNodePoolAutoConfigResourceManagerTags")
    desired_node_pool_autoscaling: Optional[NodePoolAutoscaling] = Field(default=None, alias="desiredNodePoolAutoscaling")
    desired_node_pool_id: Optional[StrictStr] = Field(default=None, description="The node pool to be upgraded. This field is mandatory if \"desired_node_version\", \"desired_image_family\", \"desired_node_pool_autoscaling\", or \"desired_workload_metadata_config\" is specified and there is more than one node pool on the cluster.", alias="desiredNodePoolId")
    desired_node_pool_logging_config: Optional[NodePoolLoggingConfig] = Field(default=None, alias="desiredNodePoolLoggingConfig")
    desired_node_version: Optional[StrictStr] = Field(default=None, description="The Kubernetes version to change the nodes to (typically an upgrade). Users may specify either explicit versions offered by Kubernetes Engine or version aliases, which have the following behavior: - \"latest\": picks the highest valid Kubernetes version - \"1.X\": picks the highest valid patch+gke.N patch in the 1.X version - \"1.X.Y\": picks the highest valid gke.N patch in the 1.X.Y version - \"1.X.Y-gke.N\": picks an explicit Kubernetes version - \"-\": picks the Kubernetes master version", alias="desiredNodeVersion")
    desired_notification_config: Optional[NotificationConfig] = Field(default=None, alias="desiredNotificationConfig")
    desired_parent_product_config: Optional[ParentProductConfig] = Field(default=None, alias="desiredParentProductConfig")
    desired_pod_security_policy_config: Optional[PodSecurityPolicyConfig] = Field(default=None, alias="desiredPodSecurityPolicyConfig")
    desired_private_cluster_config: Optional[PrivateClusterConfig] = Field(default=None, alias="desiredPrivateClusterConfig")
    desired_private_ipv6_google_access: Optional[StrictStr] = Field(default=None, description="The desired state of IPv6 connectivity to Google Services.", alias="desiredPrivateIpv6GoogleAccess")
    desired_protect_config: Optional[ProtectConfig] = Field(default=None, alias="desiredProtectConfig")
    desired_release_channel: Optional[ReleaseChannel] = Field(default=None, alias="desiredReleaseChannel")
    desired_resource_usage_export_config: Optional[ResourceUsageExportConfig] = Field(default=None, alias="desiredResourceUsageExportConfig")
    desired_security_posture_config: Optional[SecurityPostureConfig] = Field(default=None, alias="desiredSecurityPostureConfig")
    desired_service_external_ips_config: Optional[ServiceExternalIPsConfig] = Field(default=None, alias="desiredServiceExternalIpsConfig")
    desired_shielded_nodes: Optional[ShieldedNodes] = Field(default=None, alias="desiredShieldedNodes")
    desired_stack_type: Optional[StrictStr] = Field(default=None, description="The desired stack type of the cluster. If a stack type is provided and does not match the current stack type of the cluster, update will attempt to change the stack type to the new type.", alias="desiredStackType")
    desired_tpu_config: Optional[TpuConfig] = Field(default=None, alias="desiredTpuConfig")
    desired_vertical_pod_autoscaling: Optional[VerticalPodAutoscaling] = Field(default=None, alias="desiredVerticalPodAutoscaling")
    desired_workload_alts_config: Optional[WorkloadALTSConfig] = Field(default=None, alias="desiredWorkloadAltsConfig")
    desired_workload_certificates: Optional[WorkloadCertificates] = Field(default=None, alias="desiredWorkloadCertificates")
    desired_workload_identity_config: Optional[WorkloadIdentityConfig] = Field(default=None, alias="desiredWorkloadIdentityConfig")
    enable_k8s_beta_apis: Optional[K8sBetaAPIConfig] = Field(default=None, alias="enableK8sBetaApis")
    etag: Optional[StrictStr] = Field(default=None, description="The current etag of the cluster. If an etag is provided and does not match the current etag of the cluster, update will be blocked and an ABORTED error will be returned.")
    removed_additional_pod_ranges_config: Optional[AdditionalPodRangesConfig] = Field(default=None, alias="removedAdditionalPodRangesConfig")
    __properties: ClassVar[List[str]] = ["additionalPodRangesConfig", "desiredAddonsConfig", "desiredAuthenticatorGroupsConfig", "desiredAutopilotWorkloadPolicyConfig", "desiredBinaryAuthorization", "desiredClusterAutoscaling", "desiredClusterTelemetry", "desiredCostManagementConfig", "desiredDatabaseEncryption", "desiredDatapathProvider", "desiredDefaultSnatStatus", "desiredDnsConfig", "desiredEnableFqdnNetworkPolicy", "desiredEnablePrivateEndpoint", "desiredFleet", "desiredGatewayApiConfig", "desiredGcfsConfig", "desiredHostMaintenancePolicy", "desiredIdentityServiceConfig", "desiredImageType", "desiredInTransitEncryptionConfig", "desiredIntraNodeVisibilityConfig", "desiredK8sBetaApis", "desiredL4ilbSubsettingConfig", "desiredLocations", "desiredLoggingConfig", "desiredLoggingService", "desiredMaster", "desiredMasterAuthorizedNetworksConfig", "desiredMasterVersion", "desiredMeshCertificates", "desiredMonitoringConfig", "desiredMonitoringService", "desiredNetworkPerformanceConfig", "desiredNodePoolAutoConfigNetworkTags", "desiredNodePoolAutoConfigResourceManagerTags", "desiredNodePoolAutoscaling", "desiredNodePoolId", "desiredNodePoolLoggingConfig", "desiredNodeVersion", "desiredNotificationConfig", "desiredParentProductConfig", "desiredPodSecurityPolicyConfig", "desiredPrivateClusterConfig", "desiredPrivateIpv6GoogleAccess", "desiredProtectConfig", "desiredReleaseChannel", "desiredResourceUsageExportConfig", "desiredSecurityPostureConfig", "desiredServiceExternalIpsConfig", "desiredShieldedNodes", "desiredStackType", "desiredTpuConfig", "desiredVerticalPodAutoscaling", "desiredWorkloadAltsConfig", "desiredWorkloadCertificates", "desiredWorkloadIdentityConfig", "enableK8sBetaApis", "etag", "removedAdditionalPodRangesConfig"]

    @field_validator('desired_datapath_provider')
    def desired_datapath_provider_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DATAPATH_PROVIDER_UNSPECIFIED', 'LEGACY_DATAPATH', 'ADVANCED_DATAPATH']):
            raise ValueError("must be one of enum values ('DATAPATH_PROVIDER_UNSPECIFIED', 'LEGACY_DATAPATH', 'ADVANCED_DATAPATH')")
        return value

    @field_validator('desired_in_transit_encryption_config')
    def desired_in_transit_encryption_config_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED', 'IN_TRANSIT_ENCRYPTION_DISABLED', 'IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT']):
            raise ValueError("must be one of enum values ('IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED', 'IN_TRANSIT_ENCRYPTION_DISABLED', 'IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT')")
        return value

    @field_validator('desired_private_ipv6_google_access')
    def desired_private_ipv6_google_access_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED', 'PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED', 'PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE', 'PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL']):
            raise ValueError("must be one of enum values ('PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED', 'PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED', 'PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE', 'PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL')")
        return value

    @field_validator('desired_stack_type')
    def desired_stack_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STACK_TYPE_UNSPECIFIED', 'IPV4', 'IPV4_IPV6']):
            raise ValueError("must be one of enum values ('STACK_TYPE_UNSPECIFIED', 'IPV4', 'IPV4_IPV6')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ClusterUpdate from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of additional_pod_ranges_config
        if self.additional_pod_ranges_config:
            _dict['additionalPodRangesConfig'] = self.additional_pod_ranges_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_addons_config
        if self.desired_addons_config:
            _dict['desiredAddonsConfig'] = self.desired_addons_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_authenticator_groups_config
        if self.desired_authenticator_groups_config:
            _dict['desiredAuthenticatorGroupsConfig'] = self.desired_authenticator_groups_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_autopilot_workload_policy_config
        if self.desired_autopilot_workload_policy_config:
            _dict['desiredAutopilotWorkloadPolicyConfig'] = self.desired_autopilot_workload_policy_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_binary_authorization
        if self.desired_binary_authorization:
            _dict['desiredBinaryAuthorization'] = self.desired_binary_authorization.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_cluster_autoscaling
        if self.desired_cluster_autoscaling:
            _dict['desiredClusterAutoscaling'] = self.desired_cluster_autoscaling.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_cluster_telemetry
        if self.desired_cluster_telemetry:
            _dict['desiredClusterTelemetry'] = self.desired_cluster_telemetry.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_cost_management_config
        if self.desired_cost_management_config:
            _dict['desiredCostManagementConfig'] = self.desired_cost_management_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_database_encryption
        if self.desired_database_encryption:
            _dict['desiredDatabaseEncryption'] = self.desired_database_encryption.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_default_snat_status
        if self.desired_default_snat_status:
            _dict['desiredDefaultSnatStatus'] = self.desired_default_snat_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_dns_config
        if self.desired_dns_config:
            _dict['desiredDnsConfig'] = self.desired_dns_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_fleet
        if self.desired_fleet:
            _dict['desiredFleet'] = self.desired_fleet.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_gateway_api_config
        if self.desired_gateway_api_config:
            _dict['desiredGatewayApiConfig'] = self.desired_gateway_api_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_gcfs_config
        if self.desired_gcfs_config:
            _dict['desiredGcfsConfig'] = self.desired_gcfs_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_host_maintenance_policy
        if self.desired_host_maintenance_policy:
            _dict['desiredHostMaintenancePolicy'] = self.desired_host_maintenance_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_identity_service_config
        if self.desired_identity_service_config:
            _dict['desiredIdentityServiceConfig'] = self.desired_identity_service_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_intra_node_visibility_config
        if self.desired_intra_node_visibility_config:
            _dict['desiredIntraNodeVisibilityConfig'] = self.desired_intra_node_visibility_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_k8s_beta_apis
        if self.desired_k8s_beta_apis:
            _dict['desiredK8sBetaApis'] = self.desired_k8s_beta_apis.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_l4ilb_subsetting_config
        if self.desired_l4ilb_subsetting_config:
            _dict['desiredL4ilbSubsettingConfig'] = self.desired_l4ilb_subsetting_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_logging_config
        if self.desired_logging_config:
            _dict['desiredLoggingConfig'] = self.desired_logging_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_master_authorized_networks_config
        if self.desired_master_authorized_networks_config:
            _dict['desiredMasterAuthorizedNetworksConfig'] = self.desired_master_authorized_networks_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_mesh_certificates
        if self.desired_mesh_certificates:
            _dict['desiredMeshCertificates'] = self.desired_mesh_certificates.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_monitoring_config
        if self.desired_monitoring_config:
            _dict['desiredMonitoringConfig'] = self.desired_monitoring_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_network_performance_config
        if self.desired_network_performance_config:
            _dict['desiredNetworkPerformanceConfig'] = self.desired_network_performance_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_node_pool_auto_config_network_tags
        if self.desired_node_pool_auto_config_network_tags:
            _dict['desiredNodePoolAutoConfigNetworkTags'] = self.desired_node_pool_auto_config_network_tags.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_node_pool_auto_config_resource_manager_tags
        if self.desired_node_pool_auto_config_resource_manager_tags:
            _dict['desiredNodePoolAutoConfigResourceManagerTags'] = self.desired_node_pool_auto_config_resource_manager_tags.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_node_pool_autoscaling
        if self.desired_node_pool_autoscaling:
            _dict['desiredNodePoolAutoscaling'] = self.desired_node_pool_autoscaling.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_node_pool_logging_config
        if self.desired_node_pool_logging_config:
            _dict['desiredNodePoolLoggingConfig'] = self.desired_node_pool_logging_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_notification_config
        if self.desired_notification_config:
            _dict['desiredNotificationConfig'] = self.desired_notification_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_parent_product_config
        if self.desired_parent_product_config:
            _dict['desiredParentProductConfig'] = self.desired_parent_product_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_pod_security_policy_config
        if self.desired_pod_security_policy_config:
            _dict['desiredPodSecurityPolicyConfig'] = self.desired_pod_security_policy_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_private_cluster_config
        if self.desired_private_cluster_config:
            _dict['desiredPrivateClusterConfig'] = self.desired_private_cluster_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_protect_config
        if self.desired_protect_config:
            _dict['desiredProtectConfig'] = self.desired_protect_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_release_channel
        if self.desired_release_channel:
            _dict['desiredReleaseChannel'] = self.desired_release_channel.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_resource_usage_export_config
        if self.desired_resource_usage_export_config:
            _dict['desiredResourceUsageExportConfig'] = self.desired_resource_usage_export_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_security_posture_config
        if self.desired_security_posture_config:
            _dict['desiredSecurityPostureConfig'] = self.desired_security_posture_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_service_external_ips_config
        if self.desired_service_external_ips_config:
            _dict['desiredServiceExternalIpsConfig'] = self.desired_service_external_ips_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_shielded_nodes
        if self.desired_shielded_nodes:
            _dict['desiredShieldedNodes'] = self.desired_shielded_nodes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_tpu_config
        if self.desired_tpu_config:
            _dict['desiredTpuConfig'] = self.desired_tpu_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_vertical_pod_autoscaling
        if self.desired_vertical_pod_autoscaling:
            _dict['desiredVerticalPodAutoscaling'] = self.desired_vertical_pod_autoscaling.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_workload_alts_config
        if self.desired_workload_alts_config:
            _dict['desiredWorkloadAltsConfig'] = self.desired_workload_alts_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_workload_certificates
        if self.desired_workload_certificates:
            _dict['desiredWorkloadCertificates'] = self.desired_workload_certificates.to_dict()
        # override the default output from pydantic by calling `to_dict()` of desired_workload_identity_config
        if self.desired_workload_identity_config:
            _dict['desiredWorkloadIdentityConfig'] = self.desired_workload_identity_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of enable_k8s_beta_apis
        if self.enable_k8s_beta_apis:
            _dict['enableK8sBetaApis'] = self.enable_k8s_beta_apis.to_dict()
        # override the default output from pydantic by calling `to_dict()` of removed_additional_pod_ranges_config
        if self.removed_additional_pod_ranges_config:
            _dict['removedAdditionalPodRangesConfig'] = self.removed_additional_pod_ranges_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ClusterUpdate from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "additionalPodRangesConfig": AdditionalPodRangesConfig.from_dict(obj["additionalPodRangesConfig"]) if obj.get("additionalPodRangesConfig") is not None else None,
            "desiredAddonsConfig": AddonsConfig.from_dict(obj["desiredAddonsConfig"]) if obj.get("desiredAddonsConfig") is not None else None,
            "desiredAuthenticatorGroupsConfig": AuthenticatorGroupsConfig.from_dict(obj["desiredAuthenticatorGroupsConfig"]) if obj.get("desiredAuthenticatorGroupsConfig") is not None else None,
            "desiredAutopilotWorkloadPolicyConfig": WorkloadPolicyConfig.from_dict(obj["desiredAutopilotWorkloadPolicyConfig"]) if obj.get("desiredAutopilotWorkloadPolicyConfig") is not None else None,
            "desiredBinaryAuthorization": BinaryAuthorization.from_dict(obj["desiredBinaryAuthorization"]) if obj.get("desiredBinaryAuthorization") is not None else None,
            "desiredClusterAutoscaling": ClusterAutoscaling.from_dict(obj["desiredClusterAutoscaling"]) if obj.get("desiredClusterAutoscaling") is not None else None,
            "desiredClusterTelemetry": ClusterTelemetry.from_dict(obj["desiredClusterTelemetry"]) if obj.get("desiredClusterTelemetry") is not None else None,
            "desiredCostManagementConfig": CostManagementConfig.from_dict(obj["desiredCostManagementConfig"]) if obj.get("desiredCostManagementConfig") is not None else None,
            "desiredDatabaseEncryption": DatabaseEncryption.from_dict(obj["desiredDatabaseEncryption"]) if obj.get("desiredDatabaseEncryption") is not None else None,
            "desiredDatapathProvider": obj.get("desiredDatapathProvider"),
            "desiredDefaultSnatStatus": DefaultSnatStatus.from_dict(obj["desiredDefaultSnatStatus"]) if obj.get("desiredDefaultSnatStatus") is not None else None,
            "desiredDnsConfig": DNSConfig.from_dict(obj["desiredDnsConfig"]) if obj.get("desiredDnsConfig") is not None else None,
            "desiredEnableFqdnNetworkPolicy": obj.get("desiredEnableFqdnNetworkPolicy"),
            "desiredEnablePrivateEndpoint": obj.get("desiredEnablePrivateEndpoint"),
            "desiredFleet": Fleet.from_dict(obj["desiredFleet"]) if obj.get("desiredFleet") is not None else None,
            "desiredGatewayApiConfig": GatewayAPIConfig.from_dict(obj["desiredGatewayApiConfig"]) if obj.get("desiredGatewayApiConfig") is not None else None,
            "desiredGcfsConfig": GcfsConfig.from_dict(obj["desiredGcfsConfig"]) if obj.get("desiredGcfsConfig") is not None else None,
            "desiredHostMaintenancePolicy": HostMaintenancePolicy.from_dict(obj["desiredHostMaintenancePolicy"]) if obj.get("desiredHostMaintenancePolicy") is not None else None,
            "desiredIdentityServiceConfig": IdentityServiceConfig.from_dict(obj["desiredIdentityServiceConfig"]) if obj.get("desiredIdentityServiceConfig") is not None else None,
            "desiredImageType": obj.get("desiredImageType"),
            "desiredInTransitEncryptionConfig": obj.get("desiredInTransitEncryptionConfig"),
            "desiredIntraNodeVisibilityConfig": IntraNodeVisibilityConfig.from_dict(obj["desiredIntraNodeVisibilityConfig"]) if obj.get("desiredIntraNodeVisibilityConfig") is not None else None,
            "desiredK8sBetaApis": K8sBetaAPIConfig.from_dict(obj["desiredK8sBetaApis"]) if obj.get("desiredK8sBetaApis") is not None else None,
            "desiredL4ilbSubsettingConfig": ILBSubsettingConfig.from_dict(obj["desiredL4ilbSubsettingConfig"]) if obj.get("desiredL4ilbSubsettingConfig") is not None else None,
            "desiredLocations": obj.get("desiredLocations"),
            "desiredLoggingConfig": LoggingConfig.from_dict(obj["desiredLoggingConfig"]) if obj.get("desiredLoggingConfig") is not None else None,
            "desiredLoggingService": obj.get("desiredLoggingService"),
            "desiredMaster": obj.get("desiredMaster"),
            "desiredMasterAuthorizedNetworksConfig": MasterAuthorizedNetworksConfig.from_dict(obj["desiredMasterAuthorizedNetworksConfig"]) if obj.get("desiredMasterAuthorizedNetworksConfig") is not None else None,
            "desiredMasterVersion": obj.get("desiredMasterVersion"),
            "desiredMeshCertificates": MeshCertificates.from_dict(obj["desiredMeshCertificates"]) if obj.get("desiredMeshCertificates") is not None else None,
            "desiredMonitoringConfig": MonitoringConfig.from_dict(obj["desiredMonitoringConfig"]) if obj.get("desiredMonitoringConfig") is not None else None,
            "desiredMonitoringService": obj.get("desiredMonitoringService"),
            "desiredNetworkPerformanceConfig": ClusterNetworkPerformanceConfig.from_dict(obj["desiredNetworkPerformanceConfig"]) if obj.get("desiredNetworkPerformanceConfig") is not None else None,
            "desiredNodePoolAutoConfigNetworkTags": NetworkTags.from_dict(obj["desiredNodePoolAutoConfigNetworkTags"]) if obj.get("desiredNodePoolAutoConfigNetworkTags") is not None else None,
            "desiredNodePoolAutoConfigResourceManagerTags": ResourceManagerTags.from_dict(obj["desiredNodePoolAutoConfigResourceManagerTags"]) if obj.get("desiredNodePoolAutoConfigResourceManagerTags") is not None else None,
            "desiredNodePoolAutoscaling": NodePoolAutoscaling.from_dict(obj["desiredNodePoolAutoscaling"]) if obj.get("desiredNodePoolAutoscaling") is not None else None,
            "desiredNodePoolId": obj.get("desiredNodePoolId"),
            "desiredNodePoolLoggingConfig": NodePoolLoggingConfig.from_dict(obj["desiredNodePoolLoggingConfig"]) if obj.get("desiredNodePoolLoggingConfig") is not None else None,
            "desiredNodeVersion": obj.get("desiredNodeVersion"),
            "desiredNotificationConfig": NotificationConfig.from_dict(obj["desiredNotificationConfig"]) if obj.get("desiredNotificationConfig") is not None else None,
            "desiredParentProductConfig": ParentProductConfig.from_dict(obj["desiredParentProductConfig"]) if obj.get("desiredParentProductConfig") is not None else None,
            "desiredPodSecurityPolicyConfig": PodSecurityPolicyConfig.from_dict(obj["desiredPodSecurityPolicyConfig"]) if obj.get("desiredPodSecurityPolicyConfig") is not None else None,
            "desiredPrivateClusterConfig": PrivateClusterConfig.from_dict(obj["desiredPrivateClusterConfig"]) if obj.get("desiredPrivateClusterConfig") is not None else None,
            "desiredPrivateIpv6GoogleAccess": obj.get("desiredPrivateIpv6GoogleAccess"),
            "desiredProtectConfig": ProtectConfig.from_dict(obj["desiredProtectConfig"]) if obj.get("desiredProtectConfig") is not None else None,
            "desiredReleaseChannel": ReleaseChannel.from_dict(obj["desiredReleaseChannel"]) if obj.get("desiredReleaseChannel") is not None else None,
            "desiredResourceUsageExportConfig": ResourceUsageExportConfig.from_dict(obj["desiredResourceUsageExportConfig"]) if obj.get("desiredResourceUsageExportConfig") is not None else None,
            "desiredSecurityPostureConfig": SecurityPostureConfig.from_dict(obj["desiredSecurityPostureConfig"]) if obj.get("desiredSecurityPostureConfig") is not None else None,
            "desiredServiceExternalIpsConfig": ServiceExternalIPsConfig.from_dict(obj["desiredServiceExternalIpsConfig"]) if obj.get("desiredServiceExternalIpsConfig") is not None else None,
            "desiredShieldedNodes": ShieldedNodes.from_dict(obj["desiredShieldedNodes"]) if obj.get("desiredShieldedNodes") is not None else None,
            "desiredStackType": obj.get("desiredStackType"),
            "desiredTpuConfig": TpuConfig.from_dict(obj["desiredTpuConfig"]) if obj.get("desiredTpuConfig") is not None else None,
            "desiredVerticalPodAutoscaling": VerticalPodAutoscaling.from_dict(obj["desiredVerticalPodAutoscaling"]) if obj.get("desiredVerticalPodAutoscaling") is not None else None,
            "desiredWorkloadAltsConfig": WorkloadALTSConfig.from_dict(obj["desiredWorkloadAltsConfig"]) if obj.get("desiredWorkloadAltsConfig") is not None else None,
            "desiredWorkloadCertificates": WorkloadCertificates.from_dict(obj["desiredWorkloadCertificates"]) if obj.get("desiredWorkloadCertificates") is not None else None,
            "desiredWorkloadIdentityConfig": WorkloadIdentityConfig.from_dict(obj["desiredWorkloadIdentityConfig"]) if obj.get("desiredWorkloadIdentityConfig") is not None else None,
            "enableK8sBetaApis": K8sBetaAPIConfig.from_dict(obj["enableK8sBetaApis"]) if obj.get("enableK8sBetaApis") is not None else None,
            "etag": obj.get("etag"),
            "removedAdditionalPodRangesConfig": AdditionalPodRangesConfig.from_dict(obj["removedAdditionalPodRangesConfig"]) if obj.get("removedAdditionalPodRangesConfig") is not None else None
        })
        return _obj


