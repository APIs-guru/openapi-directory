# coding: utf-8

"""
    Kubernetes Engine API

    Builds and manages container-based applications, powered by the open source Kubernetes technology.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.addons_config import AddonsConfig
from openapi_client.models.authenticator_groups_config import AuthenticatorGroupsConfig
from openapi_client.models.autopilot import Autopilot
from openapi_client.models.binary_authorization import BinaryAuthorization
from openapi_client.models.cluster_autoscaling import ClusterAutoscaling
from openapi_client.models.confidential_nodes import ConfidentialNodes
from openapi_client.models.cost_management_config import CostManagementConfig
from openapi_client.models.database_encryption import DatabaseEncryption
from openapi_client.models.enterprise_config import EnterpriseConfig
from openapi_client.models.fleet import Fleet
from openapi_client.models.identity_service_config import IdentityServiceConfig
from openapi_client.models.ip_allocation_policy import IPAllocationPolicy
from openapi_client.models.k8s_beta_api_config import K8sBetaAPIConfig
from openapi_client.models.legacy_abac import LegacyAbac
from openapi_client.models.logging_config import LoggingConfig
from openapi_client.models.maintenance_policy import MaintenancePolicy
from openapi_client.models.master_auth import MasterAuth
from openapi_client.models.master_authorized_networks_config import MasterAuthorizedNetworksConfig
from openapi_client.models.max_pods_constraint import MaxPodsConstraint
from openapi_client.models.mesh_certificates import MeshCertificates
from openapi_client.models.monitoring_config import MonitoringConfig
from openapi_client.models.network_config import NetworkConfig
from openapi_client.models.network_policy import NetworkPolicy
from openapi_client.models.node_config import NodeConfig
from openapi_client.models.node_pool import NodePool
from openapi_client.models.node_pool_auto_config import NodePoolAutoConfig
from openapi_client.models.node_pool_defaults import NodePoolDefaults
from openapi_client.models.notification_config import NotificationConfig
from openapi_client.models.parent_product_config import ParentProductConfig
from openapi_client.models.private_cluster_config import PrivateClusterConfig
from openapi_client.models.release_channel import ReleaseChannel
from openapi_client.models.resource_usage_export_config import ResourceUsageExportConfig
from openapi_client.models.security_posture_config import SecurityPostureConfig
from openapi_client.models.shielded_nodes import ShieldedNodes
from openapi_client.models.status_condition import StatusCondition
from openapi_client.models.vertical_pod_autoscaling import VerticalPodAutoscaling
from openapi_client.models.workload_identity_config import WorkloadIdentityConfig
from typing import Optional, Set
from typing_extensions import Self

class Cluster(BaseModel):
    """
    A Google Kubernetes Engine cluster.
    """ # noqa: E501
    addons_config: Optional[AddonsConfig] = Field(default=None, alias="addonsConfig")
    authenticator_groups_config: Optional[AuthenticatorGroupsConfig] = Field(default=None, alias="authenticatorGroupsConfig")
    autopilot: Optional[Autopilot] = None
    autoscaling: Optional[ClusterAutoscaling] = None
    binary_authorization: Optional[BinaryAuthorization] = Field(default=None, alias="binaryAuthorization")
    cluster_ipv4_cidr: Optional[StrictStr] = Field(default=None, description="The IP address range of the container pods in this cluster, in [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation (e.g. `10.96.0.0/14`). Leave blank to have one automatically chosen or specify a `/14` block in `10.0.0.0/8`.", alias="clusterIpv4Cidr")
    conditions: Optional[List[StatusCondition]] = Field(default=None, description="Which conditions caused the current cluster state.")
    confidential_nodes: Optional[ConfidentialNodes] = Field(default=None, alias="confidentialNodes")
    cost_management_config: Optional[CostManagementConfig] = Field(default=None, alias="costManagementConfig")
    create_time: Optional[StrictStr] = Field(default=None, description="[Output only] The time the cluster was created, in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.", alias="createTime")
    current_master_version: Optional[StrictStr] = Field(default=None, description="[Output only] The current software version of the master endpoint.", alias="currentMasterVersion")
    current_node_count: Optional[StrictInt] = Field(default=None, description="[Output only] The number of nodes currently in the cluster. Deprecated. Call Kubernetes API directly to retrieve node information.", alias="currentNodeCount")
    current_node_version: Optional[StrictStr] = Field(default=None, description="[Output only] Deprecated, use [NodePools.version](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools) instead. The current version of the node software components. If they are currently at multiple versions because they're in the process of being upgraded, this reflects the minimum version of all nodes.", alias="currentNodeVersion")
    database_encryption: Optional[DatabaseEncryption] = Field(default=None, alias="databaseEncryption")
    default_max_pods_constraint: Optional[MaxPodsConstraint] = Field(default=None, alias="defaultMaxPodsConstraint")
    description: Optional[StrictStr] = Field(default=None, description="An optional description of this cluster.")
    enable_k8s_beta_apis: Optional[K8sBetaAPIConfig] = Field(default=None, alias="enableK8sBetaApis")
    enable_kubernetes_alpha: Optional[StrictBool] = Field(default=None, description="Kubernetes alpha features are enabled on this cluster. This includes alpha API groups (e.g. v1alpha1) and features that may not be production ready in the kubernetes version of the master and nodes. The cluster has no SLA for uptime and master/node upgrades are disabled. Alpha enabled clusters are automatically deleted thirty days after creation.", alias="enableKubernetesAlpha")
    enable_tpu: Optional[StrictBool] = Field(default=None, description="Enable the ability to use Cloud TPUs in this cluster.", alias="enableTpu")
    endpoint: Optional[StrictStr] = Field(default=None, description="[Output only] The IP address of this cluster's master endpoint. The endpoint can be accessed from the internet at `https://username:password@endpoint/`. See the `masterAuth` property of this resource for username and password information.")
    enterprise_config: Optional[EnterpriseConfig] = Field(default=None, alias="enterpriseConfig")
    etag: Optional[StrictStr] = Field(default=None, description="This checksum is computed by the server based on the value of cluster fields, and may be sent on update requests to ensure the client has an up-to-date value before proceeding.")
    expire_time: Optional[StrictStr] = Field(default=None, description="[Output only] The time the cluster will be automatically deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.", alias="expireTime")
    fleet: Optional[Fleet] = None
    id: Optional[StrictStr] = Field(default=None, description="Output only. Unique id for the cluster.")
    identity_service_config: Optional[IdentityServiceConfig] = Field(default=None, alias="identityServiceConfig")
    initial_cluster_version: Optional[StrictStr] = Field(default=None, description="The initial Kubernetes version for this cluster. Valid versions are those found in validMasterVersions returned by getServerConfig. The version can be upgraded over time; such upgrades are reflected in currentMasterVersion and currentNodeVersion. Users may specify either explicit versions offered by Kubernetes Engine or version aliases, which have the following behavior: - \"latest\": picks the highest valid Kubernetes version - \"1.X\": picks the highest valid patch+gke.N patch in the 1.X version - \"1.X.Y\": picks the highest valid gke.N patch in the 1.X.Y version - \"1.X.Y-gke.N\": picks an explicit Kubernetes version - \"\",\"-\": picks the default Kubernetes version", alias="initialClusterVersion")
    initial_node_count: Optional[StrictInt] = Field(default=None, description="The number of nodes to create in this cluster. You must ensure that your Compute Engine [resource quota](https://cloud.google.com/compute/quotas) is sufficient for this number of instances. You must also have available firewall and routes quota. For requests, this field should only be used in lieu of a \"node_pool\" object, since this configuration (along with the \"node_config\") will be used to create a \"NodePool\" object with an auto-generated name. Do not use this and a node_pool at the same time. This field is deprecated, use node_pool.initial_node_count instead.", alias="initialNodeCount")
    instance_group_urls: Optional[List[StrictStr]] = Field(default=None, description="Deprecated. Use node_pools.instance_group_urls.", alias="instanceGroupUrls")
    ip_allocation_policy: Optional[IPAllocationPolicy] = Field(default=None, alias="ipAllocationPolicy")
    label_fingerprint: Optional[StrictStr] = Field(default=None, description="The fingerprint of the set of labels for this cluster.", alias="labelFingerprint")
    legacy_abac: Optional[LegacyAbac] = Field(default=None, alias="legacyAbac")
    location: Optional[StrictStr] = Field(default=None, description="[Output only] The name of the Google Compute Engine [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available) or [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available) in which the cluster resides.")
    locations: Optional[List[StrictStr]] = Field(default=None, description="The list of Google Compute Engine [zones](https://cloud.google.com/compute/docs/zones#available) in which the cluster's nodes should be located. This field provides a default value if [NodePool.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations) are not specified during node pool creation. Warning: changing cluster locations will update the [NodePool.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations) of all node pools and will result in nodes being added and/or removed.")
    logging_config: Optional[LoggingConfig] = Field(default=None, alias="loggingConfig")
    logging_service: Optional[StrictStr] = Field(default=None, description="The logging service the cluster should use to write logs. Currently available options: * `logging.googleapis.com/kubernetes` - The Cloud Logging service with a Kubernetes-native resource model * `logging.googleapis.com` - The legacy Cloud Logging service (no longer available as of GKE 1.15). * `none` - no logs will be exported from the cluster. If left as an empty string,`logging.googleapis.com/kubernetes` will be used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.", alias="loggingService")
    maintenance_policy: Optional[MaintenancePolicy] = Field(default=None, alias="maintenancePolicy")
    master_auth: Optional[MasterAuth] = Field(default=None, alias="masterAuth")
    master_authorized_networks_config: Optional[MasterAuthorizedNetworksConfig] = Field(default=None, alias="masterAuthorizedNetworksConfig")
    mesh_certificates: Optional[MeshCertificates] = Field(default=None, alias="meshCertificates")
    monitoring_config: Optional[MonitoringConfig] = Field(default=None, alias="monitoringConfig")
    monitoring_service: Optional[StrictStr] = Field(default=None, description="The monitoring service the cluster should use to write metrics. Currently available options: * \"monitoring.googleapis.com/kubernetes\" - The Cloud Monitoring service with a Kubernetes-native resource model * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no longer available as of GKE 1.15). * `none` - No metrics will be exported from the cluster. If left as an empty string,`monitoring.googleapis.com/kubernetes` will be used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.", alias="monitoringService")
    name: Optional[StrictStr] = Field(default=None, description="The name of this cluster. The name must be unique within this project and location (e.g. zone or region), and can be up to 40 characters with the following restrictions: * Lowercase letters, numbers, and hyphens only. * Must start with a letter. * Must end with a number or a letter.")
    network: Optional[StrictStr] = Field(default=None, description="The name of the Google Compute Engine [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks) to which the cluster is connected. If left unspecified, the `default` network will be used.")
    network_config: Optional[NetworkConfig] = Field(default=None, alias="networkConfig")
    network_policy: Optional[NetworkPolicy] = Field(default=None, alias="networkPolicy")
    node_config: Optional[NodeConfig] = Field(default=None, alias="nodeConfig")
    node_ipv4_cidr_size: Optional[StrictInt] = Field(default=None, description="[Output only] The size of the address space on each node for hosting containers. This is provisioned from within the `container_ipv4_cidr` range. This field will only be set when cluster is in route-based network mode.", alias="nodeIpv4CidrSize")
    node_pool_auto_config: Optional[NodePoolAutoConfig] = Field(default=None, alias="nodePoolAutoConfig")
    node_pool_defaults: Optional[NodePoolDefaults] = Field(default=None, alias="nodePoolDefaults")
    node_pools: Optional[List[NodePool]] = Field(default=None, description="The node pools associated with this cluster. This field should not be set if \"node_config\" or \"initial_node_count\" are specified.", alias="nodePools")
    notification_config: Optional[NotificationConfig] = Field(default=None, alias="notificationConfig")
    parent_product_config: Optional[ParentProductConfig] = Field(default=None, alias="parentProductConfig")
    private_cluster_config: Optional[PrivateClusterConfig] = Field(default=None, alias="privateClusterConfig")
    release_channel: Optional[ReleaseChannel] = Field(default=None, alias="releaseChannel")
    resource_labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="The resource labels for the cluster to use to annotate any related Google Compute Engine resources.", alias="resourceLabels")
    resource_usage_export_config: Optional[ResourceUsageExportConfig] = Field(default=None, alias="resourceUsageExportConfig")
    security_posture_config: Optional[SecurityPostureConfig] = Field(default=None, alias="securityPostureConfig")
    self_link: Optional[StrictStr] = Field(default=None, description="[Output only] Server-defined URL for the resource.", alias="selfLink")
    services_ipv4_cidr: Optional[StrictStr] = Field(default=None, description="[Output only] The IP address range of the Kubernetes services in this cluster, in [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation (e.g. `1.2.3.4/29`). Service addresses are typically put in the last `/16` from the container CIDR.", alias="servicesIpv4Cidr")
    shielded_nodes: Optional[ShieldedNodes] = Field(default=None, alias="shieldedNodes")
    status: Optional[StrictStr] = Field(default=None, description="[Output only] The current status of this cluster.")
    status_message: Optional[StrictStr] = Field(default=None, description="[Output only] Deprecated. Use conditions instead. Additional information about the current status of this cluster, if available.", alias="statusMessage")
    subnetwork: Optional[StrictStr] = Field(default=None, description="The name of the Google Compute Engine [subnetwork](https://cloud.google.com/compute/docs/subnetworks) to which the cluster is connected.")
    tpu_ipv4_cidr_block: Optional[StrictStr] = Field(default=None, description="[Output only] The IP address range of the Cloud TPUs in this cluster, in [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation (e.g. `1.2.3.4/29`).", alias="tpuIpv4CidrBlock")
    vertical_pod_autoscaling: Optional[VerticalPodAutoscaling] = Field(default=None, alias="verticalPodAutoscaling")
    workload_identity_config: Optional[WorkloadIdentityConfig] = Field(default=None, alias="workloadIdentityConfig")
    zone: Optional[StrictStr] = Field(default=None, description="[Output only] The name of the Google Compute Engine [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster resides. This field is deprecated, use location instead.")
    __properties: ClassVar[List[str]] = ["addonsConfig", "authenticatorGroupsConfig", "autopilot", "autoscaling", "binaryAuthorization", "clusterIpv4Cidr", "conditions", "confidentialNodes", "costManagementConfig", "createTime", "currentMasterVersion", "currentNodeCount", "currentNodeVersion", "databaseEncryption", "defaultMaxPodsConstraint", "description", "enableK8sBetaApis", "enableKubernetesAlpha", "enableTpu", "endpoint", "enterpriseConfig", "etag", "expireTime", "fleet", "id", "identityServiceConfig", "initialClusterVersion", "initialNodeCount", "instanceGroupUrls", "ipAllocationPolicy", "labelFingerprint", "legacyAbac", "location", "locations", "loggingConfig", "loggingService", "maintenancePolicy", "masterAuth", "masterAuthorizedNetworksConfig", "meshCertificates", "monitoringConfig", "monitoringService", "name", "network", "networkConfig", "networkPolicy", "nodeConfig", "nodeIpv4CidrSize", "nodePoolAutoConfig", "nodePoolDefaults", "nodePools", "notificationConfig", "parentProductConfig", "privateClusterConfig", "releaseChannel", "resourceLabels", "resourceUsageExportConfig", "securityPostureConfig", "selfLink", "servicesIpv4Cidr", "shieldedNodes", "status", "statusMessage", "subnetwork", "tpuIpv4CidrBlock", "verticalPodAutoscaling", "workloadIdentityConfig", "zone"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATUS_UNSPECIFIED', 'PROVISIONING', 'RUNNING', 'RECONCILING', 'STOPPING', 'ERROR', 'DEGRADED']):
            raise ValueError("must be one of enum values ('STATUS_UNSPECIFIED', 'PROVISIONING', 'RUNNING', 'RECONCILING', 'STOPPING', 'ERROR', 'DEGRADED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Cluster from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "id",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of addons_config
        if self.addons_config:
            _dict['addonsConfig'] = self.addons_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of authenticator_groups_config
        if self.authenticator_groups_config:
            _dict['authenticatorGroupsConfig'] = self.authenticator_groups_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of autopilot
        if self.autopilot:
            _dict['autopilot'] = self.autopilot.to_dict()
        # override the default output from pydantic by calling `to_dict()` of autoscaling
        if self.autoscaling:
            _dict['autoscaling'] = self.autoscaling.to_dict()
        # override the default output from pydantic by calling `to_dict()` of binary_authorization
        if self.binary_authorization:
            _dict['binaryAuthorization'] = self.binary_authorization.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in conditions (list)
        _items = []
        if self.conditions:
            for _item_conditions in self.conditions:
                if _item_conditions:
                    _items.append(_item_conditions.to_dict())
            _dict['conditions'] = _items
        # override the default output from pydantic by calling `to_dict()` of confidential_nodes
        if self.confidential_nodes:
            _dict['confidentialNodes'] = self.confidential_nodes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cost_management_config
        if self.cost_management_config:
            _dict['costManagementConfig'] = self.cost_management_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of database_encryption
        if self.database_encryption:
            _dict['databaseEncryption'] = self.database_encryption.to_dict()
        # override the default output from pydantic by calling `to_dict()` of default_max_pods_constraint
        if self.default_max_pods_constraint:
            _dict['defaultMaxPodsConstraint'] = self.default_max_pods_constraint.to_dict()
        # override the default output from pydantic by calling `to_dict()` of enable_k8s_beta_apis
        if self.enable_k8s_beta_apis:
            _dict['enableK8sBetaApis'] = self.enable_k8s_beta_apis.to_dict()
        # override the default output from pydantic by calling `to_dict()` of enterprise_config
        if self.enterprise_config:
            _dict['enterpriseConfig'] = self.enterprise_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of fleet
        if self.fleet:
            _dict['fleet'] = self.fleet.to_dict()
        # override the default output from pydantic by calling `to_dict()` of identity_service_config
        if self.identity_service_config:
            _dict['identityServiceConfig'] = self.identity_service_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ip_allocation_policy
        if self.ip_allocation_policy:
            _dict['ipAllocationPolicy'] = self.ip_allocation_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of legacy_abac
        if self.legacy_abac:
            _dict['legacyAbac'] = self.legacy_abac.to_dict()
        # override the default output from pydantic by calling `to_dict()` of logging_config
        if self.logging_config:
            _dict['loggingConfig'] = self.logging_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of maintenance_policy
        if self.maintenance_policy:
            _dict['maintenancePolicy'] = self.maintenance_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of master_auth
        if self.master_auth:
            _dict['masterAuth'] = self.master_auth.to_dict()
        # override the default output from pydantic by calling `to_dict()` of master_authorized_networks_config
        if self.master_authorized_networks_config:
            _dict['masterAuthorizedNetworksConfig'] = self.master_authorized_networks_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mesh_certificates
        if self.mesh_certificates:
            _dict['meshCertificates'] = self.mesh_certificates.to_dict()
        # override the default output from pydantic by calling `to_dict()` of monitoring_config
        if self.monitoring_config:
            _dict['monitoringConfig'] = self.monitoring_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of network_config
        if self.network_config:
            _dict['networkConfig'] = self.network_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of network_policy
        if self.network_policy:
            _dict['networkPolicy'] = self.network_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of node_config
        if self.node_config:
            _dict['nodeConfig'] = self.node_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of node_pool_auto_config
        if self.node_pool_auto_config:
            _dict['nodePoolAutoConfig'] = self.node_pool_auto_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of node_pool_defaults
        if self.node_pool_defaults:
            _dict['nodePoolDefaults'] = self.node_pool_defaults.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in node_pools (list)
        _items = []
        if self.node_pools:
            for _item_node_pools in self.node_pools:
                if _item_node_pools:
                    _items.append(_item_node_pools.to_dict())
            _dict['nodePools'] = _items
        # override the default output from pydantic by calling `to_dict()` of notification_config
        if self.notification_config:
            _dict['notificationConfig'] = self.notification_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of parent_product_config
        if self.parent_product_config:
            _dict['parentProductConfig'] = self.parent_product_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of private_cluster_config
        if self.private_cluster_config:
            _dict['privateClusterConfig'] = self.private_cluster_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of release_channel
        if self.release_channel:
            _dict['releaseChannel'] = self.release_channel.to_dict()
        # override the default output from pydantic by calling `to_dict()` of resource_usage_export_config
        if self.resource_usage_export_config:
            _dict['resourceUsageExportConfig'] = self.resource_usage_export_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of security_posture_config
        if self.security_posture_config:
            _dict['securityPostureConfig'] = self.security_posture_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shielded_nodes
        if self.shielded_nodes:
            _dict['shieldedNodes'] = self.shielded_nodes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of vertical_pod_autoscaling
        if self.vertical_pod_autoscaling:
            _dict['verticalPodAutoscaling'] = self.vertical_pod_autoscaling.to_dict()
        # override the default output from pydantic by calling `to_dict()` of workload_identity_config
        if self.workload_identity_config:
            _dict['workloadIdentityConfig'] = self.workload_identity_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Cluster from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "addonsConfig": AddonsConfig.from_dict(obj["addonsConfig"]) if obj.get("addonsConfig") is not None else None,
            "authenticatorGroupsConfig": AuthenticatorGroupsConfig.from_dict(obj["authenticatorGroupsConfig"]) if obj.get("authenticatorGroupsConfig") is not None else None,
            "autopilot": Autopilot.from_dict(obj["autopilot"]) if obj.get("autopilot") is not None else None,
            "autoscaling": ClusterAutoscaling.from_dict(obj["autoscaling"]) if obj.get("autoscaling") is not None else None,
            "binaryAuthorization": BinaryAuthorization.from_dict(obj["binaryAuthorization"]) if obj.get("binaryAuthorization") is not None else None,
            "clusterIpv4Cidr": obj.get("clusterIpv4Cidr"),
            "conditions": [StatusCondition.from_dict(_item) for _item in obj["conditions"]] if obj.get("conditions") is not None else None,
            "confidentialNodes": ConfidentialNodes.from_dict(obj["confidentialNodes"]) if obj.get("confidentialNodes") is not None else None,
            "costManagementConfig": CostManagementConfig.from_dict(obj["costManagementConfig"]) if obj.get("costManagementConfig") is not None else None,
            "createTime": obj.get("createTime"),
            "currentMasterVersion": obj.get("currentMasterVersion"),
            "currentNodeCount": obj.get("currentNodeCount"),
            "currentNodeVersion": obj.get("currentNodeVersion"),
            "databaseEncryption": DatabaseEncryption.from_dict(obj["databaseEncryption"]) if obj.get("databaseEncryption") is not None else None,
            "defaultMaxPodsConstraint": MaxPodsConstraint.from_dict(obj["defaultMaxPodsConstraint"]) if obj.get("defaultMaxPodsConstraint") is not None else None,
            "description": obj.get("description"),
            "enableK8sBetaApis": K8sBetaAPIConfig.from_dict(obj["enableK8sBetaApis"]) if obj.get("enableK8sBetaApis") is not None else None,
            "enableKubernetesAlpha": obj.get("enableKubernetesAlpha"),
            "enableTpu": obj.get("enableTpu"),
            "endpoint": obj.get("endpoint"),
            "enterpriseConfig": EnterpriseConfig.from_dict(obj["enterpriseConfig"]) if obj.get("enterpriseConfig") is not None else None,
            "etag": obj.get("etag"),
            "expireTime": obj.get("expireTime"),
            "fleet": Fleet.from_dict(obj["fleet"]) if obj.get("fleet") is not None else None,
            "id": obj.get("id"),
            "identityServiceConfig": IdentityServiceConfig.from_dict(obj["identityServiceConfig"]) if obj.get("identityServiceConfig") is not None else None,
            "initialClusterVersion": obj.get("initialClusterVersion"),
            "initialNodeCount": obj.get("initialNodeCount"),
            "instanceGroupUrls": obj.get("instanceGroupUrls"),
            "ipAllocationPolicy": IPAllocationPolicy.from_dict(obj["ipAllocationPolicy"]) if obj.get("ipAllocationPolicy") is not None else None,
            "labelFingerprint": obj.get("labelFingerprint"),
            "legacyAbac": LegacyAbac.from_dict(obj["legacyAbac"]) if obj.get("legacyAbac") is not None else None,
            "location": obj.get("location"),
            "locations": obj.get("locations"),
            "loggingConfig": LoggingConfig.from_dict(obj["loggingConfig"]) if obj.get("loggingConfig") is not None else None,
            "loggingService": obj.get("loggingService"),
            "maintenancePolicy": MaintenancePolicy.from_dict(obj["maintenancePolicy"]) if obj.get("maintenancePolicy") is not None else None,
            "masterAuth": MasterAuth.from_dict(obj["masterAuth"]) if obj.get("masterAuth") is not None else None,
            "masterAuthorizedNetworksConfig": MasterAuthorizedNetworksConfig.from_dict(obj["masterAuthorizedNetworksConfig"]) if obj.get("masterAuthorizedNetworksConfig") is not None else None,
            "meshCertificates": MeshCertificates.from_dict(obj["meshCertificates"]) if obj.get("meshCertificates") is not None else None,
            "monitoringConfig": MonitoringConfig.from_dict(obj["monitoringConfig"]) if obj.get("monitoringConfig") is not None else None,
            "monitoringService": obj.get("monitoringService"),
            "name": obj.get("name"),
            "network": obj.get("network"),
            "networkConfig": NetworkConfig.from_dict(obj["networkConfig"]) if obj.get("networkConfig") is not None else None,
            "networkPolicy": NetworkPolicy.from_dict(obj["networkPolicy"]) if obj.get("networkPolicy") is not None else None,
            "nodeConfig": NodeConfig.from_dict(obj["nodeConfig"]) if obj.get("nodeConfig") is not None else None,
            "nodeIpv4CidrSize": obj.get("nodeIpv4CidrSize"),
            "nodePoolAutoConfig": NodePoolAutoConfig.from_dict(obj["nodePoolAutoConfig"]) if obj.get("nodePoolAutoConfig") is not None else None,
            "nodePoolDefaults": NodePoolDefaults.from_dict(obj["nodePoolDefaults"]) if obj.get("nodePoolDefaults") is not None else None,
            "nodePools": [NodePool.from_dict(_item) for _item in obj["nodePools"]] if obj.get("nodePools") is not None else None,
            "notificationConfig": NotificationConfig.from_dict(obj["notificationConfig"]) if obj.get("notificationConfig") is not None else None,
            "parentProductConfig": ParentProductConfig.from_dict(obj["parentProductConfig"]) if obj.get("parentProductConfig") is not None else None,
            "privateClusterConfig": PrivateClusterConfig.from_dict(obj["privateClusterConfig"]) if obj.get("privateClusterConfig") is not None else None,
            "releaseChannel": ReleaseChannel.from_dict(obj["releaseChannel"]) if obj.get("releaseChannel") is not None else None,
            "resourceLabels": obj.get("resourceLabels"),
            "resourceUsageExportConfig": ResourceUsageExportConfig.from_dict(obj["resourceUsageExportConfig"]) if obj.get("resourceUsageExportConfig") is not None else None,
            "securityPostureConfig": SecurityPostureConfig.from_dict(obj["securityPostureConfig"]) if obj.get("securityPostureConfig") is not None else None,
            "selfLink": obj.get("selfLink"),
            "servicesIpv4Cidr": obj.get("servicesIpv4Cidr"),
            "shieldedNodes": ShieldedNodes.from_dict(obj["shieldedNodes"]) if obj.get("shieldedNodes") is not None else None,
            "status": obj.get("status"),
            "statusMessage": obj.get("statusMessage"),
            "subnetwork": obj.get("subnetwork"),
            "tpuIpv4CidrBlock": obj.get("tpuIpv4CidrBlock"),
            "verticalPodAutoscaling": VerticalPodAutoscaling.from_dict(obj["verticalPodAutoscaling"]) if obj.get("verticalPodAutoscaling") is not None else None,
            "workloadIdentityConfig": WorkloadIdentityConfig.from_dict(obj["workloadIdentityConfig"]) if obj.get("workloadIdentityConfig") is not None else None,
            "zone": obj.get("zone")
        })
        return _obj


