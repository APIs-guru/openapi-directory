# coding: utf-8

"""
    Cloud Deploy API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.automation_rule_condition import AutomationRuleCondition
from openapi_client.models.repair_mode import RepairMode
from typing import Optional, Set
from typing_extensions import Self

class RepairRolloutRule(BaseModel):
    """
    The `RepairRolloutRule` automation rule will automatically repair a failed `Rollout`.
    """ # noqa: E501
    condition: Optional[AutomationRuleCondition] = None
    id: Optional[StrictStr] = Field(default=None, description="Required. ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.")
    jobs: Optional[List[StrictStr]] = Field(default=None, description="Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in `source_phase`. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.")
    repair_modes: Optional[List[RepairMode]] = Field(default=None, description="Required. Defines the types of automatic repair actions for failed jobs.", alias="repairModes")
    source_phases: Optional[List[StrictStr]] = Field(default=None, description="Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.", alias="sourcePhases")
    __properties: ClassVar[List[str]] = ["condition", "id", "jobs", "repairModes", "sourcePhases"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RepairRolloutRule from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of condition
        if self.condition:
            _dict['condition'] = self.condition.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in repair_modes (list)
        _items = []
        if self.repair_modes:
            for _item_repair_modes in self.repair_modes:
                if _item_repair_modes:
                    _items.append(_item_repair_modes.to_dict())
            _dict['repairModes'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RepairRolloutRule from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "condition": AutomationRuleCondition.from_dict(obj["condition"]) if obj.get("condition") is not None else None,
            "id": obj.get("id"),
            "jobs": obj.get("jobs"),
            "repairModes": [RepairMode.from_dict(_item) for _item in obj["repairModes"]] if obj.get("repairModes") is not None else None,
            "sourcePhases": obj.get("sourcePhases")
        })
        return _obj


