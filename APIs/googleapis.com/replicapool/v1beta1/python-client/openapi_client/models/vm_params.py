# coding: utf-8

"""
    Replica Pool

    The Replica Pool API allows users to declaratively provision and manage groups of Google Compute Engine instances based on a common template.

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.existing_disk import ExistingDisk
from openapi_client.models.metadata import Metadata
from openapi_client.models.network_interface import NetworkInterface
from openapi_client.models.new_disk import NewDisk
from openapi_client.models.service_account import ServiceAccount
from openapi_client.models.tag import Tag
from typing import Optional, Set
from typing_extensions import Self

class VmParams(BaseModel):
    """
    Parameters for creating a Compute Engine Instance resource. Most fields are identical to the corresponding Compute Engine resource.
    """ # noqa: E501
    base_instance_name: Optional[StrictStr] = Field(default=None, description="Deprecated. Please use baseInstanceName instead.", alias="baseInstanceName")
    can_ip_forward: Optional[StrictBool] = Field(default=None, description="Enables IP Forwarding, which allows this instance to receive packets destined for a different IP address, and send packets with a different source IP. See IP Forwarding for more information.", alias="canIpForward")
    description: Optional[StrictStr] = Field(default=None, description="An optional textual description of the instance.")
    disks_to_attach: Optional[List[ExistingDisk]] = Field(default=None, description="A list of existing Persistent Disk resources to attach to each replica in the pool. Each disk will be attached in read-only mode to every replica.", alias="disksToAttach")
    disks_to_create: Optional[List[NewDisk]] = Field(default=None, description="A list of Disk resources to create and attach to each Replica in the Pool. Currently, you can only define one disk and it must be a root persistent disk. Note that Replica Pool will create a root persistent disk for each replica.", alias="disksToCreate")
    machine_type: Optional[StrictStr] = Field(default=None, description="The machine type for this instance. The resource name (e.g. n1-standard-1).", alias="machineType")
    metadata: Optional[Metadata] = None
    network_interfaces: Optional[List[NetworkInterface]] = Field(default=None, description="A list of network interfaces for the instance. Currently only one interface is supported by Google Compute Engine, ONE_TO_ONE_NAT.", alias="networkInterfaces")
    on_host_maintenance: Optional[StrictStr] = Field(default=None, alias="onHostMaintenance")
    service_accounts: Optional[List[ServiceAccount]] = Field(default=None, description="A list of Service Accounts to enable for this instance.", alias="serviceAccounts")
    tags: Optional[Tag] = None
    __properties: ClassVar[List[str]] = ["baseInstanceName", "canIpForward", "description", "disksToAttach", "disksToCreate", "machineType", "metadata", "networkInterfaces", "onHostMaintenance", "serviceAccounts", "tags"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VmParams from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in disks_to_attach (list)
        _items = []
        if self.disks_to_attach:
            for _item_disks_to_attach in self.disks_to_attach:
                if _item_disks_to_attach:
                    _items.append(_item_disks_to_attach.to_dict())
            _dict['disksToAttach'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in disks_to_create (list)
        _items = []
        if self.disks_to_create:
            for _item_disks_to_create in self.disks_to_create:
                if _item_disks_to_create:
                    _items.append(_item_disks_to_create.to_dict())
            _dict['disksToCreate'] = _items
        # override the default output from pydantic by calling `to_dict()` of metadata
        if self.metadata:
            _dict['metadata'] = self.metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in network_interfaces (list)
        _items = []
        if self.network_interfaces:
            for _item_network_interfaces in self.network_interfaces:
                if _item_network_interfaces:
                    _items.append(_item_network_interfaces.to_dict())
            _dict['networkInterfaces'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in service_accounts (list)
        _items = []
        if self.service_accounts:
            for _item_service_accounts in self.service_accounts:
                if _item_service_accounts:
                    _items.append(_item_service_accounts.to_dict())
            _dict['serviceAccounts'] = _items
        # override the default output from pydantic by calling `to_dict()` of tags
        if self.tags:
            _dict['tags'] = self.tags.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VmParams from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "baseInstanceName": obj.get("baseInstanceName"),
            "canIpForward": obj.get("canIpForward"),
            "description": obj.get("description"),
            "disksToAttach": [ExistingDisk.from_dict(_item) for _item in obj["disksToAttach"]] if obj.get("disksToAttach") is not None else None,
            "disksToCreate": [NewDisk.from_dict(_item) for _item in obj["disksToCreate"]] if obj.get("disksToCreate") is not None else None,
            "machineType": obj.get("machineType"),
            "metadata": Metadata.from_dict(obj["metadata"]) if obj.get("metadata") is not None else None,
            "networkInterfaces": [NetworkInterface.from_dict(_item) for _item in obj["networkInterfaces"]] if obj.get("networkInterfaces") is not None else None,
            "onHostMaintenance": obj.get("onHostMaintenance"),
            "serviceAccounts": [ServiceAccount.from_dict(_item) for _item in obj["serviceAccounts"]] if obj.get("serviceAccounts") is not None else None,
            "tags": Tag.from_dict(obj["tags"]) if obj.get("tags") is not None else None
        })
        return _obj


