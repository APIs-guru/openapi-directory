# coding: utf-8

"""
    Cloud Firestore API

    Accesses the NoSQL document database built for automatic scaling, high performance, and ease of application development. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.collection_selector import CollectionSelector
from openapi_client.models.cursor import Cursor
from openapi_client.models.filter import Filter
from openapi_client.models.order import Order
from openapi_client.models.projection import Projection
from typing import Optional, Set
from typing_extensions import Self

class StructuredQuery(BaseModel):
    """
    A Firestore query. The query stages are executed in the following order: 1. from 2. where 3. select 4. order_by + start_at + end_at 5. offset 6. limit
    """ # noqa: E501
    end_at: Optional[Cursor] = Field(default=None, alias="endAt")
    var_from: Optional[List[CollectionSelector]] = Field(default=None, description="The collections to query.", alias="from")
    limit: Optional[StrictInt] = Field(default=None, description="The maximum number of results to return. Applies after all other constraints. Requires: * The value must be greater than or equal to zero if specified.")
    offset: Optional[StrictInt] = Field(default=None, description="The number of documents to skip before returning the first result. This applies after the constraints specified by the `WHERE`, `START AT`, & `END AT` but before the `LIMIT` clause. Requires: * The value must be greater than or equal to zero if specified.")
    order_by: Optional[List[Order]] = Field(default=None, description="The order to apply to the query results. Firestore allows callers to provide a full ordering, a partial ordering, or no ordering at all. In all cases, Firestore guarantees a stable ordering through the following rules: * The `order_by` is required to reference all fields used with an inequality filter. * All fields that are required to be in the `order_by` but are not already present are appended in lexicographical ordering of the field name. * If an order on `__name__` is not specified, it is appended by default. Fields are appended with the same sort direction as the last order specified, or 'ASCENDING' if no order was specified. For example: * `ORDER BY a` becomes `ORDER BY a ASC, __name__ ASC` * `ORDER BY a DESC` becomes `ORDER BY a DESC, __name__ DESC` * `WHERE a > 1` becomes `WHERE a > 1 ORDER BY a ASC, __name__ ASC` * `WHERE __name__ > ... AND a > 1` becomes `WHERE __name__ > ... AND a > 1 ORDER BY a ASC, __name__ ASC`", alias="orderBy")
    select: Optional[Projection] = None
    start_at: Optional[Cursor] = Field(default=None, alias="startAt")
    where: Optional[Filter] = None
    __properties: ClassVar[List[str]] = ["endAt", "from", "limit", "offset", "orderBy", "select", "startAt", "where"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of StructuredQuery from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of end_at
        if self.end_at:
            _dict['endAt'] = self.end_at.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in var_from (list)
        _items = []
        if self.var_from:
            for _item_var_from in self.var_from:
                if _item_var_from:
                    _items.append(_item_var_from.to_dict())
            _dict['from'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in order_by (list)
        _items = []
        if self.order_by:
            for _item_order_by in self.order_by:
                if _item_order_by:
                    _items.append(_item_order_by.to_dict())
            _dict['orderBy'] = _items
        # override the default output from pydantic by calling `to_dict()` of select
        if self.select:
            _dict['select'] = self.select.to_dict()
        # override the default output from pydantic by calling `to_dict()` of start_at
        if self.start_at:
            _dict['startAt'] = self.start_at.to_dict()
        # override the default output from pydantic by calling `to_dict()` of where
        if self.where:
            _dict['where'] = self.where.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of StructuredQuery from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "endAt": Cursor.from_dict(obj["endAt"]) if obj.get("endAt") is not None else None,
            "from": [CollectionSelector.from_dict(_item) for _item in obj["from"]] if obj.get("from") is not None else None,
            "limit": obj.get("limit"),
            "offset": obj.get("offset"),
            "orderBy": [Order.from_dict(_item) for _item in obj["orderBy"]] if obj.get("orderBy") is not None else None,
            "select": Projection.from_dict(obj["select"]) if obj.get("select") is not None else None,
            "startAt": Cursor.from_dict(obj["startAt"]) if obj.get("startAt") is not None else None,
            "where": Filter.from_dict(obj["where"]) if obj.get("where") is not None else None
        })
        return _obj


