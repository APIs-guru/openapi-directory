# coding: utf-8

"""
    Display & Video 360 API

    Display & Video 360 API allows users to automate complex Display & Video 360 workflows, such as creating insertion orders and setting targeting options for individual line items.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.budget_summary import BudgetSummary
from openapi_client.models.date_range import DateRange
from openapi_client.models.model_date import ModelDate
from typing import Optional, Set
from typing_extensions import Self

class Invoice(BaseModel):
    """
    A single invoice.
    """ # noqa: E501
    budget_invoice_grouping_id: Optional[StrictStr] = Field(default=None, description="The budget grouping ID for this invoice. This field will only be set if the invoice level of the corresponding billing profile was set to \"Budget invoice grouping ID\".", alias="budgetInvoiceGroupingId")
    budget_summaries: Optional[List[BudgetSummary]] = Field(default=None, description="The list of summarized information for each budget associated with this invoice. This field will only be set if the invoice detail level of the corresponding billing profile was set to \"Budget level PO\".", alias="budgetSummaries")
    corrected_invoice_id: Optional[StrictStr] = Field(default=None, description="The ID of the original invoice being adjusted by this invoice, if applicable. May appear on the invoice PDF as `Reference invoice number`. If replaced_invoice_ids is set, this field will be empty.", alias="correctedInvoiceId")
    currency_code: Optional[StrictStr] = Field(default=None, description="The currency used in the invoice in ISO 4217 format.", alias="currencyCode")
    display_name: Optional[StrictStr] = Field(default=None, description="The display name of the invoice.", alias="displayName")
    due_date: Optional[ModelDate] = Field(default=None, alias="dueDate")
    invoice_id: Optional[StrictStr] = Field(default=None, description="The unique ID of the invoice.", alias="invoiceId")
    invoice_type: Optional[StrictStr] = Field(default=None, description="The type of invoice document.", alias="invoiceType")
    issue_date: Optional[ModelDate] = Field(default=None, alias="issueDate")
    name: Optional[StrictStr] = Field(default=None, description="The resource name of the invoice.")
    non_budget_micros: Optional[StrictStr] = Field(default=None, description="The total amount of costs or adjustments not tied to a particular budget, in micros of the invoice's currency. For example, if currency_code is `USD`, then 1000000 represents one US dollar.", alias="nonBudgetMicros")
    payments_account_id: Optional[StrictStr] = Field(default=None, description="The ID of the payments account the invoice belongs to. Appears on the invoice PDF as `Billing Account Number`.", alias="paymentsAccountId")
    payments_profile_id: Optional[StrictStr] = Field(default=None, description="The ID of the payments profile the invoice belongs to. Appears on the invoice PDF as `Billing ID`.", alias="paymentsProfileId")
    pdf_url: Optional[StrictStr] = Field(default=None, description="The URL to download a PDF copy of the invoice. This URL is user specific and requires a valid OAuth 2.0 access token to access. The access token must be provided in an `Authorization: Bearer` HTTP header and be authorized for one of the following scopes: * `https://www.googleapis.com/auth/display-video-mediaplanning` * `https://www.googleapis.com/auth/display-video` The URL will be valid for 7 days after retrieval of this invoice object or until this invoice is retrieved again.", alias="pdfUrl")
    purchase_order_number: Optional[StrictStr] = Field(default=None, description="Purchase order number associated with the invoice.", alias="purchaseOrderNumber")
    replaced_invoice_ids: Optional[List[StrictStr]] = Field(default=None, description="The ID(s) of any originally issued invoice that is being cancelled by this invoice, if applicable. Multiple invoices may be listed if those invoices are being consolidated into a single invoice. May appear on invoice PDF as `Replaced invoice numbers`. If corrected_invoice_id is set, this field will be empty.", alias="replacedInvoiceIds")
    service_date_range: Optional[DateRange] = Field(default=None, alias="serviceDateRange")
    subtotal_amount_micros: Optional[StrictStr] = Field(default=None, description="The pre-tax subtotal amount, in micros of the invoice's currency. For example, if currency_code is `USD`, then 1000000 represents one US dollar.", alias="subtotalAmountMicros")
    total_amount_micros: Optional[StrictStr] = Field(default=None, description="The invoice total amount, in micros of the invoice's currency. For example, if currency_code is `USD`, then 1000000 represents one US dollar.", alias="totalAmountMicros")
    total_tax_amount_micros: Optional[StrictStr] = Field(default=None, description="The sum of all taxes in invoice, in micros of the invoice's currency. For example, if currency_code is `USD`, then 1000000 represents one US dollar.", alias="totalTaxAmountMicros")
    __properties: ClassVar[List[str]] = ["budgetInvoiceGroupingId", "budgetSummaries", "correctedInvoiceId", "currencyCode", "displayName", "dueDate", "invoiceId", "invoiceType", "issueDate", "name", "nonBudgetMicros", "paymentsAccountId", "paymentsProfileId", "pdfUrl", "purchaseOrderNumber", "replacedInvoiceIds", "serviceDateRange", "subtotalAmountMicros", "totalAmountMicros", "totalTaxAmountMicros"]

    @field_validator('invoice_type')
    def invoice_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['INVOICE_TYPE_UNSPECIFIED', 'INVOICE_TYPE_CREDIT', 'INVOICE_TYPE_INVOICE']):
            raise ValueError("must be one of enum values ('INVOICE_TYPE_UNSPECIFIED', 'INVOICE_TYPE_CREDIT', 'INVOICE_TYPE_INVOICE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Invoice from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in budget_summaries (list)
        _items = []
        if self.budget_summaries:
            for _item_budget_summaries in self.budget_summaries:
                if _item_budget_summaries:
                    _items.append(_item_budget_summaries.to_dict())
            _dict['budgetSummaries'] = _items
        # override the default output from pydantic by calling `to_dict()` of due_date
        if self.due_date:
            _dict['dueDate'] = self.due_date.to_dict()
        # override the default output from pydantic by calling `to_dict()` of issue_date
        if self.issue_date:
            _dict['issueDate'] = self.issue_date.to_dict()
        # override the default output from pydantic by calling `to_dict()` of service_date_range
        if self.service_date_range:
            _dict['serviceDateRange'] = self.service_date_range.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Invoice from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "budgetInvoiceGroupingId": obj.get("budgetInvoiceGroupingId"),
            "budgetSummaries": [BudgetSummary.from_dict(_item) for _item in obj["budgetSummaries"]] if obj.get("budgetSummaries") is not None else None,
            "correctedInvoiceId": obj.get("correctedInvoiceId"),
            "currencyCode": obj.get("currencyCode"),
            "displayName": obj.get("displayName"),
            "dueDate": ModelDate.from_dict(obj["dueDate"]) if obj.get("dueDate") is not None else None,
            "invoiceId": obj.get("invoiceId"),
            "invoiceType": obj.get("invoiceType"),
            "issueDate": ModelDate.from_dict(obj["issueDate"]) if obj.get("issueDate") is not None else None,
            "name": obj.get("name"),
            "nonBudgetMicros": obj.get("nonBudgetMicros"),
            "paymentsAccountId": obj.get("paymentsAccountId"),
            "paymentsProfileId": obj.get("paymentsProfileId"),
            "pdfUrl": obj.get("pdfUrl"),
            "purchaseOrderNumber": obj.get("purchaseOrderNumber"),
            "replacedInvoiceIds": obj.get("replacedInvoiceIds"),
            "serviceDateRange": DateRange.from_dict(obj["serviceDateRange"]) if obj.get("serviceDateRange") is not None else None,
            "subtotalAmountMicros": obj.get("subtotalAmountMicros"),
            "totalAmountMicros": obj.get("totalAmountMicros"),
            "totalTaxAmountMicros": obj.get("totalTaxAmountMicros")
        })
        return _obj


