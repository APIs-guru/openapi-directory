# coding: utf-8

"""
    Display & Video 360 API

    Display & Video 360 API allows users to automate complex Display & Video 360 workflows, such as creating insertion orders and setting targeting options for individual line items.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.asset_association import AssetAssociation
from openapi_client.models.audio_video_offset import AudioVideoOffset
from openapi_client.models.cm_tracking_ad import CmTrackingAd
from openapi_client.models.counter_event import CounterEvent
from openapi_client.models.dimensions import Dimensions
from openapi_client.models.exit_event import ExitEvent
from openapi_client.models.oba_icon import ObaIcon
from openapi_client.models.review_status_info import ReviewStatusInfo
from openapi_client.models.third_party_url import ThirdPartyUrl
from openapi_client.models.timer_event import TimerEvent
from openapi_client.models.transcode import Transcode
from openapi_client.models.universal_ad_id import UniversalAdId
from typing import Optional, Set
from typing_extensions import Self

class Creative(BaseModel):
    """
    A single Creative.
    """ # noqa: E501
    additional_dimensions: Optional[List[Dimensions]] = Field(default=None, description="Additional dimensions. Applicable when creative_type is one of: * `CREATIVE_TYPE_STANDARD` * `CREATIVE_TYPE_EXPANDABLE` * `CREATIVE_TYPE_NATIVE` * `CREATIVE_TYPE_NATIVE_SITE_SQUARE` * `CREATIVE_TYPE_LIGHTBOX` * `CREATIVE_TYPE_PUBLISHER_HOSTED` If this field is specified, width_pixels and height_pixels are both required and must be greater than or equal to 0.", alias="additionalDimensions")
    advertiser_id: Optional[StrictStr] = Field(default=None, description="Output only. The unique ID of the advertiser the creative belongs to.", alias="advertiserId")
    appended_tag: Optional[StrictStr] = Field(default=None, description="Third-party HTML tracking tag to be appended to the creative tag.", alias="appendedTag")
    assets: Optional[List[AssetAssociation]] = Field(default=None, description="Required. Assets associated to this creative.")
    cm_placement_id: Optional[StrictStr] = Field(default=None, description="Output only. The unique ID of the Campaign Manager 360 placement associated with the creative. This field is only applicable for creatives that are synced from Campaign Manager.", alias="cmPlacementId")
    cm_tracking_ad: Optional[CmTrackingAd] = Field(default=None, alias="cmTrackingAd")
    companion_creative_ids: Optional[List[StrictStr]] = Field(default=None, description="The IDs of companion creatives for a video creative. You can assign existing display creatives (with image or HTML5 assets) to serve surrounding the publisher's video player. Companions display around the video player while the video is playing and remain after the video has completed. Creatives contain additional dimensions can not be companion creatives. This field is only supported for following creative_type: * `CREATIVE_TYPE_AUDIO` * `CREATIVE_TYPE_VIDEO`", alias="companionCreativeIds")
    counter_events: Optional[List[CounterEvent]] = Field(default=None, description="Counter events for a rich media creative. Counters track the number of times that a user interacts with any part of a rich media creative in a specified way (mouse-overs, mouse-outs, clicks, taps, data loading, keyboard entries, etc.). Any event that can be captured in the creative can be recorded as a counter. Leave it empty or unset for creatives containing image assets only.", alias="counterEvents")
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. The timestamp when the creative was created. Assigned by the system.", alias="createTime")
    creative_attributes: Optional[List[StrictStr]] = Field(default=None, description="Output only. A list of attributes of the creative that is generated by the system.", alias="creativeAttributes")
    creative_id: Optional[StrictStr] = Field(default=None, description="Output only. The unique ID of the creative. Assigned by the system.", alias="creativeId")
    creative_type: Optional[StrictStr] = Field(default=None, description="Required. Immutable. The type of the creative.", alias="creativeType")
    dimensions: Optional[Dimensions] = None
    display_name: Optional[StrictStr] = Field(default=None, description="Required. The display name of the creative. Must be UTF-8 encoded with a maximum size of 240 bytes.", alias="displayName")
    dynamic: Optional[StrictBool] = Field(default=None, description="Output only. Indicates whether the creative is dynamic.")
    entity_status: Optional[StrictStr] = Field(default=None, description="Required. Controls whether or not the creative can serve. Accepted values are: * `ENTITY_STATUS_ACTIVE` * `ENTITY_STATUS_ARCHIVED` * `ENTITY_STATUS_PAUSED`", alias="entityStatus")
    exit_events: Optional[List[ExitEvent]] = Field(default=None, description="Required. Exit events for this creative. An exit (also known as a click tag) is any area in your creative that someone can click or tap to open an advertiser's landing page. Every creative must include at least one exit. You can add an exit to your creative in any of the following ways: * Use Google Web Designer's tap area. * Define a JavaScript variable called \"clickTag\". * Use the Enabler (Enabler.exit()) to track exits in rich media formats.", alias="exitEvents")
    expand_on_hover: Optional[StrictBool] = Field(default=None, description="Optional. Indicates the creative will automatically expand on hover. Optional and only valid for third-party expandable creatives. Third-party expandable creatives are creatives with following hosting source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_EXPANDABLE`", alias="expandOnHover")
    expanding_direction: Optional[StrictStr] = Field(default=None, description="Optional. Specifies the expanding direction of the creative. Required and only valid for third-party expandable creatives. Third-party expandable creatives are creatives with following hosting source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_EXPANDABLE`", alias="expandingDirection")
    hosting_source: Optional[StrictStr] = Field(default=None, description="Required. Indicates where the creative is hosted.", alias="hostingSource")
    html5_video: Optional[StrictBool] = Field(default=None, description="Output only. Indicates the third-party VAST tag creative requires HTML5 Video support. Output only and only valid for third-party VAST tag creatives. Third-party VAST tag creatives are creatives with following hosting_source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_VIDEO`", alias="html5Video")
    ias_campaign_monitoring: Optional[StrictBool] = Field(default=None, description="Indicates whether Integral Ad Science (IAS) campaign monitoring is enabled. To enable this for the creative, make sure the Advertiser.creative_config.ias_client_id has been set to your IAS client ID.", alias="iasCampaignMonitoring")
    integration_code: Optional[StrictStr] = Field(default=None, description="ID information used to link this creative to an external system. Must be UTF-8 encoded with a length of no more than 10,000 characters.", alias="integrationCode")
    js_tracker_url: Optional[StrictStr] = Field(default=None, description="JavaScript measurement URL from supported third-party verification providers (ComScore, DoubleVerify, IAS, Moat). HTML script tags are not supported. This field is only writeable in following creative_type: * `CREATIVE_TYPE_NATIVE` * `CREATIVE_TYPE_NATIVE_SITE_SQUARE` * `CREATIVE_TYPE_NATIVE_VIDEO`", alias="jsTrackerUrl")
    line_item_ids: Optional[List[StrictStr]] = Field(default=None, description="Output only. The IDs of the line items this creative is associated with. To associate a creative to a line item, use LineItem.creative_ids instead.", alias="lineItemIds")
    media_duration: Optional[StrictStr] = Field(default=None, description="Output only. Media duration of the creative. Applicable when creative_type is one of: * `CREATIVE_TYPE_VIDEO` * `CREATIVE_TYPE_AUDIO` * `CREATIVE_TYPE_NATIVE_VIDEO` * `CREATIVE_TYPE_PUBLISHER_HOSTED`", alias="mediaDuration")
    mp3_audio: Optional[StrictBool] = Field(default=None, description="Output only. Indicates the third-party audio creative supports MP3. Output only and only valid for third-party audio creatives. Third-party audio creatives are creatives with following hosting_source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_AUDIO`", alias="mp3Audio")
    name: Optional[StrictStr] = Field(default=None, description="Output only. The resource name of the creative.")
    notes: Optional[StrictStr] = Field(default=None, description="User notes for this creative. Must be UTF-8 encoded with a length of no more than 20,000 characters.")
    oba_icon: Optional[ObaIcon] = Field(default=None, alias="obaIcon")
    ogg_audio: Optional[StrictBool] = Field(default=None, description="Output only. Indicates the third-party audio creative supports OGG. Output only and only valid for third-party audio creatives. Third-party audio creatives are creatives with following hosting_source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_AUDIO`", alias="oggAudio")
    progress_offset: Optional[AudioVideoOffset] = Field(default=None, alias="progressOffset")
    require_html5: Optional[StrictBool] = Field(default=None, description="Optional. Indicates that the creative relies on HTML5 to render properly. Optional and only valid for third-party tag creatives. Third-party tag creatives are creatives with following hosting_source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_STANDARD` * `CREATIVE_TYPE_EXPANDABLE`", alias="requireHtml5")
    require_mraid: Optional[StrictBool] = Field(default=None, description="Optional. Indicates that the creative requires MRAID (Mobile Rich Media Ad Interface Definitions system). Set this if the creative relies on mobile gestures for interactivity, such as swiping or tapping. Optional and only valid for third-party tag creatives. Third-party tag creatives are creatives with following hosting_source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_STANDARD` * `CREATIVE_TYPE_EXPANDABLE`", alias="requireMraid")
    require_ping_for_attribution: Optional[StrictBool] = Field(default=None, description="Optional. Indicates that the creative will wait for a return ping for attribution. Only valid when using a Campaign Manager 360 tracking ad with a third-party ad server parameter and the ${DC_DBM_TOKEN} macro. Optional and only valid for third-party tag creatives or third-party VAST tag creatives. Third-party tag creatives are creatives with following hosting_source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_STANDARD` * `CREATIVE_TYPE_EXPANDABLE` Third-party VAST tag creatives are creatives with following hosting_source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_AUDIO` * `CREATIVE_TYPE_VIDEO`", alias="requirePingForAttribution")
    review_status: Optional[ReviewStatusInfo] = Field(default=None, alias="reviewStatus")
    skip_offset: Optional[AudioVideoOffset] = Field(default=None, alias="skipOffset")
    skippable: Optional[StrictBool] = Field(default=None, description="Whether the user can choose to skip a video creative. This field is only supported for the following creative_type: * `CREATIVE_TYPE_VIDEO`")
    third_party_tag: Optional[StrictStr] = Field(default=None, description="Optional. The original third-party tag used for the creative. Required and only valid for third-party tag creatives. Third-party tag creatives are creatives with following hosting_source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_STANDARD` * `CREATIVE_TYPE_EXPANDABLE`", alias="thirdPartyTag")
    third_party_urls: Optional[List[ThirdPartyUrl]] = Field(default=None, description="Tracking URLs from third parties to track interactions with a video creative. This field is only supported for the following creative_type: * `CREATIVE_TYPE_AUDIO` * `CREATIVE_TYPE_VIDEO` * `CREATIVE_TYPE_NATIVE_VIDEO`", alias="thirdPartyUrls")
    timer_events: Optional[List[TimerEvent]] = Field(default=None, description="Timer custom events for a rich media creative. Timers track the time during which a user views and interacts with a specified part of a rich media creative. A creative can have multiple timer events, each timed independently. Leave it empty or unset for creatives containing image assets only.", alias="timerEvents")
    tracker_urls: Optional[List[StrictStr]] = Field(default=None, description="Tracking URLs for analytics providers or third-party ad technology vendors. The URLs must start with https (except on inventory that doesn't require SSL compliance). If using macros in your URL, use only macros supported by Display & Video 360. Standard URLs only, no IMG or SCRIPT tags. This field is only writeable in following creative_type: * `CREATIVE_TYPE_NATIVE` * `CREATIVE_TYPE_NATIVE_SITE_SQUARE` * `CREATIVE_TYPE_NATIVE_VIDEO`", alias="trackerUrls")
    transcodes: Optional[List[Transcode]] = Field(default=None, description="Output only. Audio/Video transcodes. Display & Video 360 transcodes the main asset into a number of alternative versions that use different file formats or have different properties (resolution, audio bit rate, and video bit rate), each designed for specific video players or bandwidths. These transcodes give a publisher's system more options to choose from for each impression on your video and ensures that the appropriate file serves based on the viewer’s connection and screen size. This field is only supported in following creative_type: * `CREATIVE_TYPE_VIDEO` * `CREATIVE_TYPE_NATIVE_VIDEO` * `CREATIVE_TYPE_AUDIO`")
    universal_ad_id: Optional[UniversalAdId] = Field(default=None, alias="universalAdId")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. The timestamp when the creative was last updated, either by the user or system (e.g. creative review). Assigned by the system.", alias="updateTime")
    vast_tag_url: Optional[StrictStr] = Field(default=None, description="Optional. The URL of the VAST tag for a third-party VAST tag creative. Required and only valid for third-party VAST tag creatives. Third-party VAST tag creatives are creatives with following hosting_source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_AUDIO` * `CREATIVE_TYPE_VIDEO`", alias="vastTagUrl")
    vpaid: Optional[StrictBool] = Field(default=None, description="Output only. Indicates the third-party VAST tag creative requires VPAID (Digital Video Player-Ad Interface). Output only and only valid for third-party VAST tag creatives. Third-party VAST tag creatives are creatives with following hosting_source: * `HOSTING_SOURCE_THIRD_PARTY` combined with following creative_type: * `CREATIVE_TYPE_VIDEO`")
    __properties: ClassVar[List[str]] = ["additionalDimensions", "advertiserId", "appendedTag", "assets", "cmPlacementId", "cmTrackingAd", "companionCreativeIds", "counterEvents", "createTime", "creativeAttributes", "creativeId", "creativeType", "dimensions", "displayName", "dynamic", "entityStatus", "exitEvents", "expandOnHover", "expandingDirection", "hostingSource", "html5Video", "iasCampaignMonitoring", "integrationCode", "jsTrackerUrl", "lineItemIds", "mediaDuration", "mp3Audio", "name", "notes", "obaIcon", "oggAudio", "progressOffset", "requireHtml5", "requireMraid", "requirePingForAttribution", "reviewStatus", "skipOffset", "skippable", "thirdPartyTag", "thirdPartyUrls", "timerEvents", "trackerUrls", "transcodes", "universalAdId", "updateTime", "vastTagUrl", "vpaid"]

    @field_validator('creative_attributes')
    def creative_attributes_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['CREATIVE_ATTRIBUTE_UNSPECIFIED', 'CREATIVE_ATTRIBUTE_VAST', 'CREATIVE_ATTRIBUTE_VPAID_LINEAR', 'CREATIVE_ATTRIBUTE_VPAID_NON_LINEAR']):
                raise ValueError("each list item must be one of ('CREATIVE_ATTRIBUTE_UNSPECIFIED', 'CREATIVE_ATTRIBUTE_VAST', 'CREATIVE_ATTRIBUTE_VPAID_LINEAR', 'CREATIVE_ATTRIBUTE_VPAID_NON_LINEAR')")
        return value

    @field_validator('creative_type')
    def creative_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CREATIVE_TYPE_UNSPECIFIED', 'CREATIVE_TYPE_STANDARD', 'CREATIVE_TYPE_EXPANDABLE', 'CREATIVE_TYPE_VIDEO', 'CREATIVE_TYPE_NATIVE', 'CREATIVE_TYPE_TEMPLATED_APP_INSTALL', 'CREATIVE_TYPE_NATIVE_SITE_SQUARE', 'CREATIVE_TYPE_TEMPLATED_APP_INSTALL_INTERSTITIAL', 'CREATIVE_TYPE_LIGHTBOX', 'CREATIVE_TYPE_NATIVE_APP_INSTALL', 'CREATIVE_TYPE_NATIVE_APP_INSTALL_SQUARE', 'CREATIVE_TYPE_AUDIO', 'CREATIVE_TYPE_PUBLISHER_HOSTED', 'CREATIVE_TYPE_NATIVE_VIDEO', 'CREATIVE_TYPE_TEMPLATED_APP_INSTALL_VIDEO']):
            raise ValueError("must be one of enum values ('CREATIVE_TYPE_UNSPECIFIED', 'CREATIVE_TYPE_STANDARD', 'CREATIVE_TYPE_EXPANDABLE', 'CREATIVE_TYPE_VIDEO', 'CREATIVE_TYPE_NATIVE', 'CREATIVE_TYPE_TEMPLATED_APP_INSTALL', 'CREATIVE_TYPE_NATIVE_SITE_SQUARE', 'CREATIVE_TYPE_TEMPLATED_APP_INSTALL_INTERSTITIAL', 'CREATIVE_TYPE_LIGHTBOX', 'CREATIVE_TYPE_NATIVE_APP_INSTALL', 'CREATIVE_TYPE_NATIVE_APP_INSTALL_SQUARE', 'CREATIVE_TYPE_AUDIO', 'CREATIVE_TYPE_PUBLISHER_HOSTED', 'CREATIVE_TYPE_NATIVE_VIDEO', 'CREATIVE_TYPE_TEMPLATED_APP_INSTALL_VIDEO')")
        return value

    @field_validator('entity_status')
    def entity_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ENTITY_STATUS_UNSPECIFIED', 'ENTITY_STATUS_ACTIVE', 'ENTITY_STATUS_ARCHIVED', 'ENTITY_STATUS_DRAFT', 'ENTITY_STATUS_PAUSED', 'ENTITY_STATUS_SCHEDULED_FOR_DELETION']):
            raise ValueError("must be one of enum values ('ENTITY_STATUS_UNSPECIFIED', 'ENTITY_STATUS_ACTIVE', 'ENTITY_STATUS_ARCHIVED', 'ENTITY_STATUS_DRAFT', 'ENTITY_STATUS_PAUSED', 'ENTITY_STATUS_SCHEDULED_FOR_DELETION')")
        return value

    @field_validator('expanding_direction')
    def expanding_direction_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['EXPANDING_DIRECTION_UNSPECIFIED', 'EXPANDING_DIRECTION_NONE', 'EXPANDING_DIRECTION_UP', 'EXPANDING_DIRECTION_DOWN', 'EXPANDING_DIRECTION_LEFT', 'EXPANDING_DIRECTION_RIGHT', 'EXPANDING_DIRECTION_UP_AND_LEFT', 'EXPANDING_DIRECTION_UP_AND_RIGHT', 'EXPANDING_DIRECTION_DOWN_AND_LEFT', 'EXPANDING_DIRECTION_DOWN_AND_RIGHT', 'EXPANDING_DIRECTION_UP_OR_DOWN', 'EXPANDING_DIRECTION_LEFT_OR_RIGHT', 'EXPANDING_DIRECTION_ANY_DIAGONAL']):
            raise ValueError("must be one of enum values ('EXPANDING_DIRECTION_UNSPECIFIED', 'EXPANDING_DIRECTION_NONE', 'EXPANDING_DIRECTION_UP', 'EXPANDING_DIRECTION_DOWN', 'EXPANDING_DIRECTION_LEFT', 'EXPANDING_DIRECTION_RIGHT', 'EXPANDING_DIRECTION_UP_AND_LEFT', 'EXPANDING_DIRECTION_UP_AND_RIGHT', 'EXPANDING_DIRECTION_DOWN_AND_LEFT', 'EXPANDING_DIRECTION_DOWN_AND_RIGHT', 'EXPANDING_DIRECTION_UP_OR_DOWN', 'EXPANDING_DIRECTION_LEFT_OR_RIGHT', 'EXPANDING_DIRECTION_ANY_DIAGONAL')")
        return value

    @field_validator('hosting_source')
    def hosting_source_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['HOSTING_SOURCE_UNSPECIFIED', 'HOSTING_SOURCE_CM', 'HOSTING_SOURCE_THIRD_PARTY', 'HOSTING_SOURCE_HOSTED', 'HOSTING_SOURCE_RICH_MEDIA']):
            raise ValueError("must be one of enum values ('HOSTING_SOURCE_UNSPECIFIED', 'HOSTING_SOURCE_CM', 'HOSTING_SOURCE_THIRD_PARTY', 'HOSTING_SOURCE_HOSTED', 'HOSTING_SOURCE_RICH_MEDIA')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Creative from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "advertiser_id",
            "cm_placement_id",
            "create_time",
            "creative_attributes",
            "creative_id",
            "dynamic",
            "html5_video",
            "line_item_ids",
            "media_duration",
            "mp3_audio",
            "name",
            "ogg_audio",
            "transcodes",
            "update_time",
            "vpaid",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in additional_dimensions (list)
        _items = []
        if self.additional_dimensions:
            for _item_additional_dimensions in self.additional_dimensions:
                if _item_additional_dimensions:
                    _items.append(_item_additional_dimensions.to_dict())
            _dict['additionalDimensions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in assets (list)
        _items = []
        if self.assets:
            for _item_assets in self.assets:
                if _item_assets:
                    _items.append(_item_assets.to_dict())
            _dict['assets'] = _items
        # override the default output from pydantic by calling `to_dict()` of cm_tracking_ad
        if self.cm_tracking_ad:
            _dict['cmTrackingAd'] = self.cm_tracking_ad.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in counter_events (list)
        _items = []
        if self.counter_events:
            for _item_counter_events in self.counter_events:
                if _item_counter_events:
                    _items.append(_item_counter_events.to_dict())
            _dict['counterEvents'] = _items
        # override the default output from pydantic by calling `to_dict()` of dimensions
        if self.dimensions:
            _dict['dimensions'] = self.dimensions.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in exit_events (list)
        _items = []
        if self.exit_events:
            for _item_exit_events in self.exit_events:
                if _item_exit_events:
                    _items.append(_item_exit_events.to_dict())
            _dict['exitEvents'] = _items
        # override the default output from pydantic by calling `to_dict()` of oba_icon
        if self.oba_icon:
            _dict['obaIcon'] = self.oba_icon.to_dict()
        # override the default output from pydantic by calling `to_dict()` of progress_offset
        if self.progress_offset:
            _dict['progressOffset'] = self.progress_offset.to_dict()
        # override the default output from pydantic by calling `to_dict()` of review_status
        if self.review_status:
            _dict['reviewStatus'] = self.review_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of skip_offset
        if self.skip_offset:
            _dict['skipOffset'] = self.skip_offset.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in third_party_urls (list)
        _items = []
        if self.third_party_urls:
            for _item_third_party_urls in self.third_party_urls:
                if _item_third_party_urls:
                    _items.append(_item_third_party_urls.to_dict())
            _dict['thirdPartyUrls'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in timer_events (list)
        _items = []
        if self.timer_events:
            for _item_timer_events in self.timer_events:
                if _item_timer_events:
                    _items.append(_item_timer_events.to_dict())
            _dict['timerEvents'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in transcodes (list)
        _items = []
        if self.transcodes:
            for _item_transcodes in self.transcodes:
                if _item_transcodes:
                    _items.append(_item_transcodes.to_dict())
            _dict['transcodes'] = _items
        # override the default output from pydantic by calling `to_dict()` of universal_ad_id
        if self.universal_ad_id:
            _dict['universalAdId'] = self.universal_ad_id.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Creative from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "additionalDimensions": [Dimensions.from_dict(_item) for _item in obj["additionalDimensions"]] if obj.get("additionalDimensions") is not None else None,
            "advertiserId": obj.get("advertiserId"),
            "appendedTag": obj.get("appendedTag"),
            "assets": [AssetAssociation.from_dict(_item) for _item in obj["assets"]] if obj.get("assets") is not None else None,
            "cmPlacementId": obj.get("cmPlacementId"),
            "cmTrackingAd": CmTrackingAd.from_dict(obj["cmTrackingAd"]) if obj.get("cmTrackingAd") is not None else None,
            "companionCreativeIds": obj.get("companionCreativeIds"),
            "counterEvents": [CounterEvent.from_dict(_item) for _item in obj["counterEvents"]] if obj.get("counterEvents") is not None else None,
            "createTime": obj.get("createTime"),
            "creativeAttributes": obj.get("creativeAttributes"),
            "creativeId": obj.get("creativeId"),
            "creativeType": obj.get("creativeType"),
            "dimensions": Dimensions.from_dict(obj["dimensions"]) if obj.get("dimensions") is not None else None,
            "displayName": obj.get("displayName"),
            "dynamic": obj.get("dynamic"),
            "entityStatus": obj.get("entityStatus"),
            "exitEvents": [ExitEvent.from_dict(_item) for _item in obj["exitEvents"]] if obj.get("exitEvents") is not None else None,
            "expandOnHover": obj.get("expandOnHover"),
            "expandingDirection": obj.get("expandingDirection"),
            "hostingSource": obj.get("hostingSource"),
            "html5Video": obj.get("html5Video"),
            "iasCampaignMonitoring": obj.get("iasCampaignMonitoring"),
            "integrationCode": obj.get("integrationCode"),
            "jsTrackerUrl": obj.get("jsTrackerUrl"),
            "lineItemIds": obj.get("lineItemIds"),
            "mediaDuration": obj.get("mediaDuration"),
            "mp3Audio": obj.get("mp3Audio"),
            "name": obj.get("name"),
            "notes": obj.get("notes"),
            "obaIcon": ObaIcon.from_dict(obj["obaIcon"]) if obj.get("obaIcon") is not None else None,
            "oggAudio": obj.get("oggAudio"),
            "progressOffset": AudioVideoOffset.from_dict(obj["progressOffset"]) if obj.get("progressOffset") is not None else None,
            "requireHtml5": obj.get("requireHtml5"),
            "requireMraid": obj.get("requireMraid"),
            "requirePingForAttribution": obj.get("requirePingForAttribution"),
            "reviewStatus": ReviewStatusInfo.from_dict(obj["reviewStatus"]) if obj.get("reviewStatus") is not None else None,
            "skipOffset": AudioVideoOffset.from_dict(obj["skipOffset"]) if obj.get("skipOffset") is not None else None,
            "skippable": obj.get("skippable"),
            "thirdPartyTag": obj.get("thirdPartyTag"),
            "thirdPartyUrls": [ThirdPartyUrl.from_dict(_item) for _item in obj["thirdPartyUrls"]] if obj.get("thirdPartyUrls") is not None else None,
            "timerEvents": [TimerEvent.from_dict(_item) for _item in obj["timerEvents"]] if obj.get("timerEvents") is not None else None,
            "trackerUrls": obj.get("trackerUrls"),
            "transcodes": [Transcode.from_dict(_item) for _item in obj["transcodes"]] if obj.get("transcodes") is not None else None,
            "universalAdId": UniversalAdId.from_dict(obj["universalAdId"]) if obj.get("universalAdId") is not None else None,
            "updateTime": obj.get("updateTime"),
            "vastTagUrl": obj.get("vastTagUrl"),
            "vpaid": obj.get("vpaid")
        })
        return _obj


