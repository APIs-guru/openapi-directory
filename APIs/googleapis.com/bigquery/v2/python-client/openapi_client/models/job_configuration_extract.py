# coding: utf-8

"""
    BigQuery API

    A data platform for customers to create, manage, share and query data.

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.model_extract_options import ModelExtractOptions
from openapi_client.models.model_reference import ModelReference
from openapi_client.models.table_reference import TableReference
from typing import Optional, Set
from typing_extensions import Self

class JobConfigurationExtract(BaseModel):
    """
    JobConfigurationExtract configures a job that exports data from a BigQuery table into Google Cloud Storage.
    """ # noqa: E501
    compression: Optional[StrictStr] = Field(default=None, description="Optional. The compression type to use for exported files. Possible values include DEFLATE, GZIP, NONE, SNAPPY, and ZSTD. The default value is NONE. Not all compression formats are support for all file formats. DEFLATE is only supported for Avro. ZSTD is only supported for Parquet. Not applicable when extracting models.")
    destination_format: Optional[StrictStr] = Field(default=None, description="Optional. The exported file format. Possible values include CSV, NEWLINE_DELIMITED_JSON, PARQUET, or AVRO for tables and ML_TF_SAVED_MODEL or ML_XGBOOST_BOOSTER for models. The default value for tables is CSV. Tables with nested or repeated fields cannot be exported as CSV. The default value for models is ML_TF_SAVED_MODEL.", alias="destinationFormat")
    destination_uri: Optional[StrictStr] = Field(default=None, description="[Pick one] DEPRECATED: Use destinationUris instead, passing only one URI as necessary. The fully-qualified Google Cloud Storage URI where the extracted table should be written.", alias="destinationUri")
    destination_uris: Optional[List[StrictStr]] = Field(default=None, description="[Pick one] A list of fully-qualified Google Cloud Storage URIs where the extracted table should be written.", alias="destinationUris")
    field_delimiter: Optional[StrictStr] = Field(default=None, description="Optional. When extracting data in CSV format, this defines the delimiter to use between fields in the exported data. Default is ','. Not applicable when extracting models.", alias="fieldDelimiter")
    model_extract_options: Optional[ModelExtractOptions] = Field(default=None, alias="modelExtractOptions")
    print_header: Optional[StrictBool] = Field(default=True, description="Optional. Whether to print out a header row in the results. Default is true. Not applicable when extracting models.", alias="printHeader")
    source_model: Optional[ModelReference] = Field(default=None, alias="sourceModel")
    source_table: Optional[TableReference] = Field(default=None, alias="sourceTable")
    use_avro_logical_types: Optional[StrictBool] = Field(default=None, description="Whether to use logical types when extracting to AVRO format. Not applicable when extracting models.", alias="useAvroLogicalTypes")
    __properties: ClassVar[List[str]] = ["compression", "destinationFormat", "destinationUri", "destinationUris", "fieldDelimiter", "modelExtractOptions", "printHeader", "sourceModel", "sourceTable", "useAvroLogicalTypes"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of JobConfigurationExtract from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of model_extract_options
        if self.model_extract_options:
            _dict['modelExtractOptions'] = self.model_extract_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source_model
        if self.source_model:
            _dict['sourceModel'] = self.source_model.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source_table
        if self.source_table:
            _dict['sourceTable'] = self.source_table.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of JobConfigurationExtract from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "compression": obj.get("compression"),
            "destinationFormat": obj.get("destinationFormat"),
            "destinationUri": obj.get("destinationUri"),
            "destinationUris": obj.get("destinationUris"),
            "fieldDelimiter": obj.get("fieldDelimiter"),
            "modelExtractOptions": ModelExtractOptions.from_dict(obj["modelExtractOptions"]) if obj.get("modelExtractOptions") is not None else None,
            "printHeader": obj.get("printHeader") if obj.get("printHeader") is not None else True,
            "sourceModel": ModelReference.from_dict(obj["sourceModel"]) if obj.get("sourceModel") is not None else None,
            "sourceTable": TableReference.from_dict(obj["sourceTable"]) if obj.get("sourceTable") is not None else None,
            "useAvroLogicalTypes": obj.get("useAvroLogicalTypes")
        })
        return _obj


