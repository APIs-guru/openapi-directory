# coding: utf-8

"""
    Backup for GKE API

    Backup for GKE is a managed Kubernetes workload backup and restore service for GKE clusters.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.backup_config import BackupConfig
from openapi_client.models.retention_policy import RetentionPolicy
from openapi_client.models.schedule import Schedule
from typing import Optional, Set
from typing_extensions import Self

class BackupPlan(BaseModel):
    """
    Defines the configuration and scheduling for a \"line\" of Backups.
    """ # noqa: E501
    backup_config: Optional[BackupConfig] = Field(default=None, alias="backupConfig")
    backup_schedule: Optional[Schedule] = Field(default=None, alias="backupSchedule")
    cluster: Optional[StrictStr] = Field(default=None, description="Required. Immutable. The source cluster from which Backups will be created via this BackupPlan. Valid formats: - `projects/*/locations/*/clusters/*` - `projects/*/zones/*/clusters/*`")
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. The timestamp when this BackupPlan resource was created.", alias="createTime")
    deactivated: Optional[StrictBool] = Field(default=None, description="Optional. This flag indicates whether this BackupPlan has been deactivated. Setting this field to True locks the BackupPlan such that no further updates will be allowed (except deletes), including the deactivated field itself. It also prevents any new Backups from being created via this BackupPlan (including scheduled Backups). Default: False")
    description: Optional[StrictStr] = Field(default=None, description="Optional. User specified descriptive string for this BackupPlan.")
    etag: Optional[StrictStr] = Field(default=None, description="Output only. `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a backup plan from overwriting each other. It is strongly suggested that systems make use of the 'etag' in the read-modify-write cycle to perform BackupPlan updates in order to avoid race conditions: An `etag` is returned in the response to `GetBackupPlan`, and systems are expected to put that etag in the request to `UpdateBackupPlan` or `DeleteBackupPlan` to ensure that their change will be applied to the same version of the resource.")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Optional. A set of custom labels supplied by user.")
    name: Optional[StrictStr] = Field(default=None, description="Output only. The full name of the BackupPlan resource. Format: `projects/*/locations/*/backupPlans/*`")
    protected_pod_count: Optional[StrictInt] = Field(default=None, description="Output only. The number of Kubernetes Pods backed up in the last successful Backup created via this BackupPlan.", alias="protectedPodCount")
    retention_policy: Optional[RetentionPolicy] = Field(default=None, alias="retentionPolicy")
    state: Optional[StrictStr] = Field(default=None, description="Output only. State of the BackupPlan. This State field reflects the various stages a BackupPlan can be in during the Create operation. It will be set to \"DEACTIVATED\" if the BackupPlan is deactivated on an Update")
    state_reason: Optional[StrictStr] = Field(default=None, description="Output only. Human-readable description of why BackupPlan is in the current `state`", alias="stateReason")
    uid: Optional[StrictStr] = Field(default=None, description="Output only. Server generated global unique identifier of [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. The timestamp when this BackupPlan resource was last updated.", alias="updateTime")
    __properties: ClassVar[List[str]] = ["backupConfig", "backupSchedule", "cluster", "createTime", "deactivated", "description", "etag", "labels", "name", "protectedPodCount", "retentionPolicy", "state", "stateReason", "uid", "updateTime"]

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'CLUSTER_PENDING', 'PROVISIONING', 'READY', 'FAILED', 'DEACTIVATED', 'DELETING']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'CLUSTER_PENDING', 'PROVISIONING', 'READY', 'FAILED', 'DEACTIVATED', 'DELETING')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of BackupPlan from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "etag",
            "name",
            "protected_pod_count",
            "state",
            "state_reason",
            "uid",
            "update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of backup_config
        if self.backup_config:
            _dict['backupConfig'] = self.backup_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of backup_schedule
        if self.backup_schedule:
            _dict['backupSchedule'] = self.backup_schedule.to_dict()
        # override the default output from pydantic by calling `to_dict()` of retention_policy
        if self.retention_policy:
            _dict['retentionPolicy'] = self.retention_policy.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of BackupPlan from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "backupConfig": BackupConfig.from_dict(obj["backupConfig"]) if obj.get("backupConfig") is not None else None,
            "backupSchedule": Schedule.from_dict(obj["backupSchedule"]) if obj.get("backupSchedule") is not None else None,
            "cluster": obj.get("cluster"),
            "createTime": obj.get("createTime"),
            "deactivated": obj.get("deactivated"),
            "description": obj.get("description"),
            "etag": obj.get("etag"),
            "labels": obj.get("labels"),
            "name": obj.get("name"),
            "protectedPodCount": obj.get("protectedPodCount"),
            "retentionPolicy": RetentionPolicy.from_dict(obj["retentionPolicy"]) if obj.get("retentionPolicy") is not None else None,
            "state": obj.get("state"),
            "stateReason": obj.get("stateReason"),
            "uid": obj.get("uid"),
            "updateTime": obj.get("updateTime")
        })
        return _obj


