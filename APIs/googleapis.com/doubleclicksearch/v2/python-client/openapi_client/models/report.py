# coding: utf-8

"""
    Search Ads 360 API

    The Search Ads 360 API allows developers to automate uploading conversions and downloading reports from Search Ads 360.

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.report_files_inner import ReportFilesInner
from openapi_client.models.report_request import ReportRequest
from typing import Optional, Set
from typing_extensions import Self

class Report(BaseModel):
    """
    A DoubleClick Search report. This object contains the report request, some report metadata such as currency code, and the generated report rows or report files.
    """ # noqa: E501
    files: Optional[List[ReportFilesInner]] = Field(default=None, description="Asynchronous report only. Contains a list of generated report files once the report has successfully completed.")
    id: Optional[StrictStr] = Field(default=None, description="Asynchronous report only. Id of the report.")
    is_report_ready: Optional[StrictBool] = Field(default=None, description="Asynchronous report only. True if and only if the report has completed successfully and the report files are ready to be downloaded.", alias="isReportReady")
    kind: Optional[StrictStr] = Field(default=None, description="Identifies this as a Report resource. Value: the fixed string `doubleclicksearch#report`.")
    request: Optional[ReportRequest] = None
    row_count: Optional[StrictInt] = Field(default=None, description="The number of report rows generated by the report, not including headers.", alias="rowCount")
    rows: Optional[List[Dict[str, Any]]] = Field(default=None, description="Synchronous report only. Generated report rows.")
    statistics_currency_code: Optional[StrictStr] = Field(default=None, description="The currency code of all monetary values produced in the report, including values that are set by users (e.g., keyword bid settings) and metrics (e.g., cost and revenue). The currency code of a report is determined by the `statisticsCurrency` field of the report request.", alias="statisticsCurrencyCode")
    statistics_time_zone: Optional[StrictStr] = Field(default=None, description="If all statistics of the report are sourced from the same time zone, this would be it. Otherwise the field is unset.", alias="statisticsTimeZone")
    __properties: ClassVar[List[str]] = ["files", "id", "isReportReady", "kind", "request", "rowCount", "rows", "statisticsCurrencyCode", "statisticsTimeZone"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Report from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in files (list)
        _items = []
        if self.files:
            for _item_files in self.files:
                if _item_files:
                    _items.append(_item_files.to_dict())
            _dict['files'] = _items
        # override the default output from pydantic by calling `to_dict()` of request
        if self.request:
            _dict['request'] = self.request.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Report from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "files": [ReportFilesInner.from_dict(_item) for _item in obj["files"]] if obj.get("files") is not None else None,
            "id": obj.get("id"),
            "isReportReady": obj.get("isReportReady"),
            "kind": obj.get("kind"),
            "request": ReportRequest.from_dict(obj["request"]) if obj.get("request") is not None else None,
            "rowCount": obj.get("rowCount"),
            "rows": obj.get("rows"),
            "statisticsCurrencyCode": obj.get("statisticsCurrencyCode"),
            "statisticsTimeZone": obj.get("statisticsTimeZone")
        })
        return _obj


