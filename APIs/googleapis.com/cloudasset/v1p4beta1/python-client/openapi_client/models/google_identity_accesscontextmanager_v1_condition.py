# coding: utf-8

"""
    Cloud Asset API

    The cloud asset API manages the history and inventory of cloud resources.

    The version of the OpenAPI document: v1p4beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_identity_accesscontextmanager_v1_device_policy import GoogleIdentityAccesscontextmanagerV1DevicePolicy
from typing import Optional, Set
from typing_extensions import Self

class GoogleIdentityAccesscontextmanagerV1Condition(BaseModel):
    """
    A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
    """ # noqa: E501
    device_policy: Optional[GoogleIdentityAccesscontextmanagerV1DevicePolicy] = Field(default=None, alias="devicePolicy")
    ip_subnetworks: Optional[List[StrictStr]] = Field(default=None, description="CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, \"192.0.2.0/24\" is accepted but \"192.0.2.1/24\" is not. Similarly, for IPv6, \"2001:db8::/32\" is accepted whereas \"2001:db8::1/32\" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.", alias="ipSubnetworks")
    members: Optional[List[StrictStr]] = Field(default=None, description="The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.")
    negate: Optional[StrictBool] = Field(default=None, description="Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.")
    regions: Optional[List[StrictStr]] = Field(default=None, description="The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.")
    required_access_levels: Optional[List[StrictStr]] = Field(default=None, description="A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: \"`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME\"`", alias="requiredAccessLevels")
    __properties: ClassVar[List[str]] = ["devicePolicy", "ipSubnetworks", "members", "negate", "regions", "requiredAccessLevels"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleIdentityAccesscontextmanagerV1Condition from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of device_policy
        if self.device_policy:
            _dict['devicePolicy'] = self.device_policy.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleIdentityAccesscontextmanagerV1Condition from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "devicePolicy": GoogleIdentityAccesscontextmanagerV1DevicePolicy.from_dict(obj["devicePolicy"]) if obj.get("devicePolicy") is not None else None,
            "ipSubnetworks": obj.get("ipSubnetworks"),
            "members": obj.get("members"),
            "negate": obj.get("negate"),
            "regions": obj.get("regions"),
            "requiredAccessLevels": obj.get("requiredAccessLevels")
        })
        return _obj


