# coding: utf-8

"""
    Street View Publish API

    Publishes 360 photos to Google Maps, along with position, orientation, and connectivity metadata. Apps can offer an interface for positioning, connecting, and uploading user-generated Street View images. 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.imu import Imu
from openapi_client.models.lat_lng_bounds import LatLngBounds
from openapi_client.models.photo import Photo
from openapi_client.models.pose import Pose
from openapi_client.models.processing_failure_details import ProcessingFailureDetails
from openapi_client.models.upload_ref import UploadRef
from typing import Optional, Set
from typing_extensions import Self

class PhotoSequence(BaseModel):
    """
    A sequence of 360 photos along with metadata.
    """ # noqa: E501
    capture_time_override: Optional[StrictStr] = Field(default=None, description="Optional. Absolute time when the photo sequence starts to be captured. If the photo sequence is a video, this is the start time of the video. If this field is populated in input, it overrides the capture time in the video or XDM file.", alias="captureTimeOverride")
    distance_meters: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Output only. The computed distance of the photo sequence in meters.", alias="distanceMeters")
    failure_details: Optional[ProcessingFailureDetails] = Field(default=None, alias="failureDetails")
    failure_reason: Optional[StrictStr] = Field(default=None, description="Output only. If this sequence has processing_state = FAILED, this will contain the reason why it failed. If the processing_state is any other value, this field will be unset.", alias="failureReason")
    filename: Optional[StrictStr] = Field(default=None, description="Output only. The filename of the upload. Does not include the directory path. Only available if the sequence was uploaded on a platform that provides the filename.")
    gps_source: Optional[StrictStr] = Field(default=None, description="Input only. If both raw_gps_timeline and the Camera Motion Metadata Track (CAMM) contain GPS measurements, indicate which takes precedence.", alias="gpsSource")
    id: Optional[StrictStr] = Field(default=None, description="Output only. Unique identifier for the photo sequence. This also acts as a long running operation ID if uploading is performed asynchronously.")
    imu: Optional[Imu] = None
    photos: Optional[List[Photo]] = Field(default=None, description="Output only. Photos with increasing timestamps.")
    processing_state: Optional[StrictStr] = Field(default=None, description="Output only. The processing state of this sequence.", alias="processingState")
    raw_gps_timeline: Optional[List[Pose]] = Field(default=None, description="Input only. Raw GPS measurements with increasing timestamps from the device that aren't time synced with each photo. These raw measurements will be used to infer the pose of each frame. Required in input when InputType is VIDEO and raw GPS measurements are not in Camera Motion Metadata Track (CAMM). User can indicate which takes precedence using gps_source if raw GPS measurements are provided in both raw_gps_timeline and Camera Motion Metadata Track (CAMM).", alias="rawGpsTimeline")
    sequence_bounds: Optional[LatLngBounds] = Field(default=None, alias="sequenceBounds")
    upload_reference: Optional[UploadRef] = Field(default=None, alias="uploadReference")
    upload_time: Optional[StrictStr] = Field(default=None, description="Output only. The time this photo sequence was created in uSV Store service.", alias="uploadTime")
    view_count: Optional[StrictStr] = Field(default=None, description="Output only. The total number of views that all the published images in this PhotoSequence have received.", alias="viewCount")
    __properties: ClassVar[List[str]] = ["captureTimeOverride", "distanceMeters", "failureDetails", "failureReason", "filename", "gpsSource", "id", "imu", "photos", "processingState", "rawGpsTimeline", "sequenceBounds", "uploadReference", "uploadTime", "viewCount"]

    @field_validator('failure_reason')
    def failure_reason_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PROCESSING_FAILURE_REASON_UNSPECIFIED', 'LOW_RESOLUTION', 'DUPLICATE', 'INSUFFICIENT_GPS', 'NO_OVERLAP_GPS', 'INVALID_GPS', 'FAILED_TO_REFINE_POSITIONS', 'TAKEDOWN', 'CORRUPT_VIDEO', 'INTERNAL', 'INVALID_VIDEO_FORMAT', 'INVALID_VIDEO_DIMENSIONS', 'INVALID_CAPTURE_TIME', 'GPS_DATA_GAP', 'JUMPY_GPS', 'INVALID_IMU', 'INSUFFICIENT_IMU', 'INSUFFICIENT_OVERLAP_TIME_SERIES', 'IMU_DATA_GAP', 'UNSUPPORTED_CAMERA', 'NOT_OUTDOORS', 'INSUFFICIENT_VIDEO_FRAMES', 'INSUFFICIENT_MOVEMENT', 'MAST_DOWN', 'CAMERA_COVERED']):
            raise ValueError("must be one of enum values ('PROCESSING_FAILURE_REASON_UNSPECIFIED', 'LOW_RESOLUTION', 'DUPLICATE', 'INSUFFICIENT_GPS', 'NO_OVERLAP_GPS', 'INVALID_GPS', 'FAILED_TO_REFINE_POSITIONS', 'TAKEDOWN', 'CORRUPT_VIDEO', 'INTERNAL', 'INVALID_VIDEO_FORMAT', 'INVALID_VIDEO_DIMENSIONS', 'INVALID_CAPTURE_TIME', 'GPS_DATA_GAP', 'JUMPY_GPS', 'INVALID_IMU', 'INSUFFICIENT_IMU', 'INSUFFICIENT_OVERLAP_TIME_SERIES', 'IMU_DATA_GAP', 'UNSUPPORTED_CAMERA', 'NOT_OUTDOORS', 'INSUFFICIENT_VIDEO_FRAMES', 'INSUFFICIENT_MOVEMENT', 'MAST_DOWN', 'CAMERA_COVERED')")
        return value

    @field_validator('gps_source')
    def gps_source_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PHOTO_SEQUENCE', 'CAMERA_MOTION_METADATA_TRACK']):
            raise ValueError("must be one of enum values ('PHOTO_SEQUENCE', 'CAMERA_MOTION_METADATA_TRACK')")
        return value

    @field_validator('processing_state')
    def processing_state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PROCESSING_STATE_UNSPECIFIED', 'PENDING', 'PROCESSING', 'PROCESSED', 'FAILED']):
            raise ValueError("must be one of enum values ('PROCESSING_STATE_UNSPECIFIED', 'PENDING', 'PROCESSING', 'PROCESSED', 'FAILED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PhotoSequence from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "distance_meters",
            "failure_reason",
            "filename",
            "id",
            "photos",
            "processing_state",
            "upload_time",
            "view_count",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of failure_details
        if self.failure_details:
            _dict['failureDetails'] = self.failure_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of imu
        if self.imu:
            _dict['imu'] = self.imu.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in photos (list)
        _items = []
        if self.photos:
            for _item_photos in self.photos:
                if _item_photos:
                    _items.append(_item_photos.to_dict())
            _dict['photos'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in raw_gps_timeline (list)
        _items = []
        if self.raw_gps_timeline:
            for _item_raw_gps_timeline in self.raw_gps_timeline:
                if _item_raw_gps_timeline:
                    _items.append(_item_raw_gps_timeline.to_dict())
            _dict['rawGpsTimeline'] = _items
        # override the default output from pydantic by calling `to_dict()` of sequence_bounds
        if self.sequence_bounds:
            _dict['sequenceBounds'] = self.sequence_bounds.to_dict()
        # override the default output from pydantic by calling `to_dict()` of upload_reference
        if self.upload_reference:
            _dict['uploadReference'] = self.upload_reference.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PhotoSequence from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "captureTimeOverride": obj.get("captureTimeOverride"),
            "distanceMeters": obj.get("distanceMeters"),
            "failureDetails": ProcessingFailureDetails.from_dict(obj["failureDetails"]) if obj.get("failureDetails") is not None else None,
            "failureReason": obj.get("failureReason"),
            "filename": obj.get("filename"),
            "gpsSource": obj.get("gpsSource"),
            "id": obj.get("id"),
            "imu": Imu.from_dict(obj["imu"]) if obj.get("imu") is not None else None,
            "photos": [Photo.from_dict(_item) for _item in obj["photos"]] if obj.get("photos") is not None else None,
            "processingState": obj.get("processingState"),
            "rawGpsTimeline": [Pose.from_dict(_item) for _item in obj["rawGpsTimeline"]] if obj.get("rawGpsTimeline") is not None else None,
            "sequenceBounds": LatLngBounds.from_dict(obj["sequenceBounds"]) if obj.get("sequenceBounds") is not None else None,
            "uploadReference": UploadRef.from_dict(obj["uploadReference"]) if obj.get("uploadReference") is not None else None,
            "uploadTime": obj.get("uploadTime"),
            "viewCount": obj.get("viewCount")
        })
        return _obj


