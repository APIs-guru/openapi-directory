# coding: utf-8

"""
    Cloud SQL Admin API

    API for Cloud SQL database instance management

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.database_instance_failover_replica import DatabaseInstanceFailoverReplica
from openapi_client.models.disk_encryption_configuration import DiskEncryptionConfiguration
from openapi_client.models.disk_encryption_status import DiskEncryptionStatus
from openapi_client.models.ip_mapping import IpMapping
from openapi_client.models.on_premises_configuration import OnPremisesConfiguration
from openapi_client.models.replica_configuration import ReplicaConfiguration
from openapi_client.models.settings import Settings
from openapi_client.models.sql_out_of_disk_report import SqlOutOfDiskReport
from openapi_client.models.sql_scheduled_maintenance import SqlScheduledMaintenance
from openapi_client.models.ssl_cert import SslCert
from typing import Optional, Set
from typing_extensions import Self

class DatabaseInstance(BaseModel):
    """
    A Cloud SQL instance resource.
    """ # noqa: E501
    available_maintenance_versions: Optional[List[StrictStr]] = Field(default=None, description="Output only. List all maintenance versions applicable on the instance", alias="availableMaintenanceVersions")
    backend_type: Optional[StrictStr] = Field(default=None, description="The backend type. `SECOND_GEN`: Cloud SQL database instance. `EXTERNAL`: A database server that is not managed by Google. This property is read-only; use the `tier` property in the `settings` object to determine the database type.", alias="backendType")
    connection_name: Optional[StrictStr] = Field(default=None, description="Connection name of the Cloud SQL instance used in connection strings.", alias="connectionName")
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. The time when the instance was created in [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example `2012-11-15T16:19:00.094Z`.", alias="createTime")
    current_disk_size: Optional[StrictStr] = Field(default=None, description="The current disk usage of the instance in bytes. This property has been deprecated. Use the \"cloudsql.googleapis.com/database/disk/bytes_used\" metric in Cloud Monitoring API instead. Please see [this announcement](https://groups.google.com/d/msg/google-cloud-sql-announce/I_7-F9EBhT0/BtvFtdFeAgAJ) for details.", alias="currentDiskSize")
    database_installed_version: Optional[StrictStr] = Field(default=None, description="Output only. Stores the current database version running on the instance including minor version such as `MYSQL_8_0_18`.", alias="databaseInstalledVersion")
    database_version: Optional[StrictStr] = Field(default=None, description="The database engine type and version. The `databaseVersion` field cannot be changed after instance creation.", alias="databaseVersion")
    disk_encryption_configuration: Optional[DiskEncryptionConfiguration] = Field(default=None, alias="diskEncryptionConfiguration")
    disk_encryption_status: Optional[DiskEncryptionStatus] = Field(default=None, alias="diskEncryptionStatus")
    dns_name: Optional[StrictStr] = Field(default=None, description="Output only. The dns name of the instance.", alias="dnsName")
    etag: Optional[StrictStr] = Field(default=None, description="This field is deprecated and will be removed from a future version of the API. Use the `settings.settingsVersion` field instead.")
    failover_replica: Optional[DatabaseInstanceFailoverReplica] = Field(default=None, alias="failoverReplica")
    gce_zone: Optional[StrictStr] = Field(default=None, description="The Compute Engine zone that the instance is currently serving from. This value could be different from the zone that was specified when the instance was created if the instance has failed over to its secondary zone. WARNING: Changing this might restart the instance.", alias="gceZone")
    instance_type: Optional[StrictStr] = Field(default=None, description="The instance type.", alias="instanceType")
    ip_addresses: Optional[List[IpMapping]] = Field(default=None, description="The assigned IP addresses for the instance.", alias="ipAddresses")
    ipv6_address: Optional[StrictStr] = Field(default=None, description="The IPv6 address assigned to the instance. (Deprecated) This property was applicable only to First Generation instances.", alias="ipv6Address")
    kind: Optional[StrictStr] = Field(default=None, description="This is always `sql#instance`.")
    maintenance_version: Optional[StrictStr] = Field(default=None, description="The current software version on the instance.", alias="maintenanceVersion")
    master_instance_name: Optional[StrictStr] = Field(default=None, description="The name of the instance which will act as primary in the replication setup.", alias="masterInstanceName")
    max_disk_size: Optional[StrictStr] = Field(default=None, description="The maximum disk size of the instance in bytes.", alias="maxDiskSize")
    name: Optional[StrictStr] = Field(default=None, description="Name of the Cloud SQL instance. This does not include the project ID.")
    on_premises_configuration: Optional[OnPremisesConfiguration] = Field(default=None, alias="onPremisesConfiguration")
    out_of_disk_report: Optional[SqlOutOfDiskReport] = Field(default=None, alias="outOfDiskReport")
    primary_dns_name: Optional[StrictStr] = Field(default=None, description="Output only. DEPRECATED: please use write_endpoint instead.", alias="primaryDnsName")
    project: Optional[StrictStr] = Field(default=None, description="The project ID of the project containing the Cloud SQL instance. The Google apps domain is prefixed if applicable.")
    psc_service_attachment_link: Optional[StrictStr] = Field(default=None, description="Output only. The link to service attachment of PSC instance.", alias="pscServiceAttachmentLink")
    region: Optional[StrictStr] = Field(default=None, description="The geographical region of the Cloud SQL instance. It can be one of the [regions](https://cloud.google.com/sql/docs/mysql/locations#location-r) where Cloud SQL operates: For example, `asia-east1`, `europe-west1`, and `us-central1`. The default value is `us-central1`.")
    replica_configuration: Optional[ReplicaConfiguration] = Field(default=None, alias="replicaConfiguration")
    replica_names: Optional[List[StrictStr]] = Field(default=None, description="The replicas of the instance.", alias="replicaNames")
    root_password: Optional[StrictStr] = Field(default=None, description="Initial root password. Use only on creation. You must set root passwords before you can connect to PostgreSQL instances.", alias="rootPassword")
    satisfies_pzs: Optional[StrictBool] = Field(default=None, description="The status indicating if instance satisfiesPzs. Reserved for future use.", alias="satisfiesPzs")
    scheduled_maintenance: Optional[SqlScheduledMaintenance] = Field(default=None, alias="scheduledMaintenance")
    secondary_gce_zone: Optional[StrictStr] = Field(default=None, description="The Compute Engine zone that the failover instance is currently serving from for a regional instance. This value could be different from the zone that was specified when the instance was created if the instance has failed over to its secondary/failover zone.", alias="secondaryGceZone")
    self_link: Optional[StrictStr] = Field(default=None, description="The URI of this resource.", alias="selfLink")
    server_ca_cert: Optional[SslCert] = Field(default=None, alias="serverCaCert")
    service_account_email_address: Optional[StrictStr] = Field(default=None, description="The service account email address assigned to the instance.\\This property is read-only.", alias="serviceAccountEmailAddress")
    settings: Optional[Settings] = None
    sql_network_architecture: Optional[StrictStr] = Field(default=None, alias="sqlNetworkArchitecture")
    state: Optional[StrictStr] = Field(default=None, description="The current serving state of the Cloud SQL instance.")
    suspension_reason: Optional[List[StrictStr]] = Field(default=None, description="If the instance state is SUSPENDED, the reason for the suspension.", alias="suspensionReason")
    write_endpoint: Optional[StrictStr] = Field(default=None, description="Output only. The dns name of the primary instance in a replication group.", alias="writeEndpoint")
    __properties: ClassVar[List[str]] = ["availableMaintenanceVersions", "backendType", "connectionName", "createTime", "currentDiskSize", "databaseInstalledVersion", "databaseVersion", "diskEncryptionConfiguration", "diskEncryptionStatus", "dnsName", "etag", "failoverReplica", "gceZone", "instanceType", "ipAddresses", "ipv6Address", "kind", "maintenanceVersion", "masterInstanceName", "maxDiskSize", "name", "onPremisesConfiguration", "outOfDiskReport", "primaryDnsName", "project", "pscServiceAttachmentLink", "region", "replicaConfiguration", "replicaNames", "rootPassword", "satisfiesPzs", "scheduledMaintenance", "secondaryGceZone", "selfLink", "serverCaCert", "serviceAccountEmailAddress", "settings", "sqlNetworkArchitecture", "state", "suspensionReason", "writeEndpoint"]

    @field_validator('backend_type')
    def backend_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SQL_BACKEND_TYPE_UNSPECIFIED', 'FIRST_GEN', 'SECOND_GEN', 'EXTERNAL']):
            raise ValueError("must be one of enum values ('SQL_BACKEND_TYPE_UNSPECIFIED', 'FIRST_GEN', 'SECOND_GEN', 'EXTERNAL')")
        return value

    @field_validator('database_version')
    def database_version_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SQL_DATABASE_VERSION_UNSPECIFIED', 'MYSQL_5_1', 'MYSQL_5_5', 'MYSQL_5_6', 'MYSQL_5_7', 'SQLSERVER_2017_STANDARD', 'SQLSERVER_2017_ENTERPRISE', 'SQLSERVER_2017_EXPRESS', 'SQLSERVER_2017_WEB', 'POSTGRES_9_6', 'POSTGRES_10', 'POSTGRES_11', 'POSTGRES_12', 'POSTGRES_13', 'POSTGRES_14', 'POSTGRES_15', 'MYSQL_8_0', 'MYSQL_8_0_18', 'MYSQL_8_0_26', 'MYSQL_8_0_27', 'MYSQL_8_0_28', 'MYSQL_8_0_29', 'MYSQL_8_0_30', 'MYSQL_8_0_31', 'MYSQL_8_0_32', 'MYSQL_8_0_33', 'MYSQL_8_0_34', 'MYSQL_8_0_35', 'MYSQL_8_0_36', 'SQLSERVER_2019_STANDARD', 'SQLSERVER_2019_ENTERPRISE', 'SQLSERVER_2019_EXPRESS', 'SQLSERVER_2019_WEB', 'SQLSERVER_2022_STANDARD', 'SQLSERVER_2022_ENTERPRISE', 'SQLSERVER_2022_EXPRESS', 'SQLSERVER_2022_WEB']):
            raise ValueError("must be one of enum values ('SQL_DATABASE_VERSION_UNSPECIFIED', 'MYSQL_5_1', 'MYSQL_5_5', 'MYSQL_5_6', 'MYSQL_5_7', 'SQLSERVER_2017_STANDARD', 'SQLSERVER_2017_ENTERPRISE', 'SQLSERVER_2017_EXPRESS', 'SQLSERVER_2017_WEB', 'POSTGRES_9_6', 'POSTGRES_10', 'POSTGRES_11', 'POSTGRES_12', 'POSTGRES_13', 'POSTGRES_14', 'POSTGRES_15', 'MYSQL_8_0', 'MYSQL_8_0_18', 'MYSQL_8_0_26', 'MYSQL_8_0_27', 'MYSQL_8_0_28', 'MYSQL_8_0_29', 'MYSQL_8_0_30', 'MYSQL_8_0_31', 'MYSQL_8_0_32', 'MYSQL_8_0_33', 'MYSQL_8_0_34', 'MYSQL_8_0_35', 'MYSQL_8_0_36', 'SQLSERVER_2019_STANDARD', 'SQLSERVER_2019_ENTERPRISE', 'SQLSERVER_2019_EXPRESS', 'SQLSERVER_2019_WEB', 'SQLSERVER_2022_STANDARD', 'SQLSERVER_2022_ENTERPRISE', 'SQLSERVER_2022_EXPRESS', 'SQLSERVER_2022_WEB')")
        return value

    @field_validator('instance_type')
    def instance_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SQL_INSTANCE_TYPE_UNSPECIFIED', 'CLOUD_SQL_INSTANCE', 'ON_PREMISES_INSTANCE', 'READ_REPLICA_INSTANCE']):
            raise ValueError("must be one of enum values ('SQL_INSTANCE_TYPE_UNSPECIFIED', 'CLOUD_SQL_INSTANCE', 'ON_PREMISES_INSTANCE', 'READ_REPLICA_INSTANCE')")
        return value

    @field_validator('sql_network_architecture')
    def sql_network_architecture_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SQL_NETWORK_ARCHITECTURE_UNSPECIFIED', 'NEW_NETWORK_ARCHITECTURE', 'OLD_NETWORK_ARCHITECTURE']):
            raise ValueError("must be one of enum values ('SQL_NETWORK_ARCHITECTURE_UNSPECIFIED', 'NEW_NETWORK_ARCHITECTURE', 'OLD_NETWORK_ARCHITECTURE')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SQL_INSTANCE_STATE_UNSPECIFIED', 'RUNNABLE', 'SUSPENDED', 'PENDING_DELETE', 'PENDING_CREATE', 'MAINTENANCE', 'FAILED', 'ONLINE_MAINTENANCE']):
            raise ValueError("must be one of enum values ('SQL_INSTANCE_STATE_UNSPECIFIED', 'RUNNABLE', 'SUSPENDED', 'PENDING_DELETE', 'PENDING_CREATE', 'MAINTENANCE', 'FAILED', 'ONLINE_MAINTENANCE')")
        return value

    @field_validator('suspension_reason')
    def suspension_reason_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['SQL_SUSPENSION_REASON_UNSPECIFIED', 'BILLING_ISSUE', 'LEGAL_ISSUE', 'OPERATIONAL_ISSUE', 'KMS_KEY_ISSUE']):
                raise ValueError("each list item must be one of ('SQL_SUSPENSION_REASON_UNSPECIFIED', 'BILLING_ISSUE', 'LEGAL_ISSUE', 'OPERATIONAL_ISSUE', 'KMS_KEY_ISSUE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DatabaseInstance from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "available_maintenance_versions",
            "create_time",
            "database_installed_version",
            "dns_name",
            "primary_dns_name",
            "psc_service_attachment_link",
            "write_endpoint",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of disk_encryption_configuration
        if self.disk_encryption_configuration:
            _dict['diskEncryptionConfiguration'] = self.disk_encryption_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of disk_encryption_status
        if self.disk_encryption_status:
            _dict['diskEncryptionStatus'] = self.disk_encryption_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of failover_replica
        if self.failover_replica:
            _dict['failoverReplica'] = self.failover_replica.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in ip_addresses (list)
        _items = []
        if self.ip_addresses:
            for _item_ip_addresses in self.ip_addresses:
                if _item_ip_addresses:
                    _items.append(_item_ip_addresses.to_dict())
            _dict['ipAddresses'] = _items
        # override the default output from pydantic by calling `to_dict()` of on_premises_configuration
        if self.on_premises_configuration:
            _dict['onPremisesConfiguration'] = self.on_premises_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of out_of_disk_report
        if self.out_of_disk_report:
            _dict['outOfDiskReport'] = self.out_of_disk_report.to_dict()
        # override the default output from pydantic by calling `to_dict()` of replica_configuration
        if self.replica_configuration:
            _dict['replicaConfiguration'] = self.replica_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of scheduled_maintenance
        if self.scheduled_maintenance:
            _dict['scheduledMaintenance'] = self.scheduled_maintenance.to_dict()
        # override the default output from pydantic by calling `to_dict()` of server_ca_cert
        if self.server_ca_cert:
            _dict['serverCaCert'] = self.server_ca_cert.to_dict()
        # override the default output from pydantic by calling `to_dict()` of settings
        if self.settings:
            _dict['settings'] = self.settings.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DatabaseInstance from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "availableMaintenanceVersions": obj.get("availableMaintenanceVersions"),
            "backendType": obj.get("backendType"),
            "connectionName": obj.get("connectionName"),
            "createTime": obj.get("createTime"),
            "currentDiskSize": obj.get("currentDiskSize"),
            "databaseInstalledVersion": obj.get("databaseInstalledVersion"),
            "databaseVersion": obj.get("databaseVersion"),
            "diskEncryptionConfiguration": DiskEncryptionConfiguration.from_dict(obj["diskEncryptionConfiguration"]) if obj.get("diskEncryptionConfiguration") is not None else None,
            "diskEncryptionStatus": DiskEncryptionStatus.from_dict(obj["diskEncryptionStatus"]) if obj.get("diskEncryptionStatus") is not None else None,
            "dnsName": obj.get("dnsName"),
            "etag": obj.get("etag"),
            "failoverReplica": DatabaseInstanceFailoverReplica.from_dict(obj["failoverReplica"]) if obj.get("failoverReplica") is not None else None,
            "gceZone": obj.get("gceZone"),
            "instanceType": obj.get("instanceType"),
            "ipAddresses": [IpMapping.from_dict(_item) for _item in obj["ipAddresses"]] if obj.get("ipAddresses") is not None else None,
            "ipv6Address": obj.get("ipv6Address"),
            "kind": obj.get("kind"),
            "maintenanceVersion": obj.get("maintenanceVersion"),
            "masterInstanceName": obj.get("masterInstanceName"),
            "maxDiskSize": obj.get("maxDiskSize"),
            "name": obj.get("name"),
            "onPremisesConfiguration": OnPremisesConfiguration.from_dict(obj["onPremisesConfiguration"]) if obj.get("onPremisesConfiguration") is not None else None,
            "outOfDiskReport": SqlOutOfDiskReport.from_dict(obj["outOfDiskReport"]) if obj.get("outOfDiskReport") is not None else None,
            "primaryDnsName": obj.get("primaryDnsName"),
            "project": obj.get("project"),
            "pscServiceAttachmentLink": obj.get("pscServiceAttachmentLink"),
            "region": obj.get("region"),
            "replicaConfiguration": ReplicaConfiguration.from_dict(obj["replicaConfiguration"]) if obj.get("replicaConfiguration") is not None else None,
            "replicaNames": obj.get("replicaNames"),
            "rootPassword": obj.get("rootPassword"),
            "satisfiesPzs": obj.get("satisfiesPzs"),
            "scheduledMaintenance": SqlScheduledMaintenance.from_dict(obj["scheduledMaintenance"]) if obj.get("scheduledMaintenance") is not None else None,
            "secondaryGceZone": obj.get("secondaryGceZone"),
            "selfLink": obj.get("selfLink"),
            "serverCaCert": SslCert.from_dict(obj["serverCaCert"]) if obj.get("serverCaCert") is not None else None,
            "serviceAccountEmailAddress": obj.get("serviceAccountEmailAddress"),
            "settings": Settings.from_dict(obj["settings"]) if obj.get("settings") is not None else None,
            "sqlNetworkArchitecture": obj.get("sqlNetworkArchitecture"),
            "state": obj.get("state"),
            "suspensionReason": obj.get("suspensionReason"),
            "writeEndpoint": obj.get("writeEndpoint")
        })
        return _obj


