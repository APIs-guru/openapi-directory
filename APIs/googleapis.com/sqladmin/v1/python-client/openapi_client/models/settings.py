# coding: utf-8

"""
    Cloud SQL Admin API

    API for Cloud SQL database instance management

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.advanced_machine_features import AdvancedMachineFeatures
from openapi_client.models.backup_configuration import BackupConfiguration
from openapi_client.models.data_cache_config import DataCacheConfig
from openapi_client.models.database_flags import DatabaseFlags
from openapi_client.models.deny_maintenance_period import DenyMaintenancePeriod
from openapi_client.models.insights_config import InsightsConfig
from openapi_client.models.ip_configuration import IpConfiguration
from openapi_client.models.location_preference import LocationPreference
from openapi_client.models.maintenance_window import MaintenanceWindow
from openapi_client.models.password_validation_policy import PasswordValidationPolicy
from openapi_client.models.sql_active_directory_config import SqlActiveDirectoryConfig
from openapi_client.models.sql_server_audit_config import SqlServerAuditConfig
from typing import Optional, Set
from typing_extensions import Self

class Settings(BaseModel):
    """
    Database instance settings.
    """ # noqa: E501
    activation_policy: Optional[StrictStr] = Field(default=None, description="The activation policy specifies when the instance is activated; it is applicable only when the instance state is RUNNABLE. Valid values: * `ALWAYS`: The instance is on, and remains so even in the absence of connection requests. * `NEVER`: The instance is off; it is not activated, even if a connection request arrives.", alias="activationPolicy")
    active_directory_config: Optional[SqlActiveDirectoryConfig] = Field(default=None, alias="activeDirectoryConfig")
    advanced_machine_features: Optional[AdvancedMachineFeatures] = Field(default=None, alias="advancedMachineFeatures")
    authorized_gae_applications: Optional[List[StrictStr]] = Field(default=None, description="The App Engine app IDs that can access this instance. (Deprecated) Applied to First Generation instances only.", alias="authorizedGaeApplications")
    availability_type: Optional[StrictStr] = Field(default=None, description="Availability type. Potential values: * `ZONAL`: The instance serves data from only one zone. Outages in that zone affect data accessibility. * `REGIONAL`: The instance can serve data from more than one zone in a region (it is highly available)./ For more information, see [Overview of the High Availability Configuration](https://cloud.google.com/sql/docs/mysql/high-availability).", alias="availabilityType")
    backup_configuration: Optional[BackupConfiguration] = Field(default=None, alias="backupConfiguration")
    collation: Optional[StrictStr] = Field(default=None, description="The name of server Instance collation.")
    connector_enforcement: Optional[StrictStr] = Field(default=None, description="Specifies if connections must use Cloud SQL connectors. Option values include the following: `NOT_REQUIRED` (Cloud SQL instances can be connected without Cloud SQL Connectors) and `REQUIRED` (Only allow connections that use Cloud SQL Connectors). Note that using REQUIRED disables all existing authorized networks. If this field is not specified when creating a new instance, NOT_REQUIRED is used. If this field is not specified when patching or updating an existing instance, it is left unchanged in the instance.", alias="connectorEnforcement")
    crash_safe_replication_enabled: Optional[StrictBool] = Field(default=None, description="Configuration specific to read replica instances. Indicates whether database flags for crash-safe replication are enabled. This property was only applicable to First Generation instances.", alias="crashSafeReplicationEnabled")
    data_cache_config: Optional[DataCacheConfig] = Field(default=None, alias="dataCacheConfig")
    data_disk_size_gb: Optional[StrictStr] = Field(default=None, description="The size of data disk, in GB. The data disk size minimum is 10GB.", alias="dataDiskSizeGb")
    data_disk_type: Optional[StrictStr] = Field(default=None, description="The type of data disk: `PD_SSD` (default) or `PD_HDD`. Not used for First Generation instances.", alias="dataDiskType")
    database_flags: Optional[List[DatabaseFlags]] = Field(default=None, description="The database flags passed to the instance at startup.", alias="databaseFlags")
    database_replication_enabled: Optional[StrictBool] = Field(default=None, description="Configuration specific to read replica instances. Indicates whether replication is enabled or not. WARNING: Changing this restarts the instance.", alias="databaseReplicationEnabled")
    deletion_protection_enabled: Optional[StrictBool] = Field(default=None, description="Configuration to protect against accidental instance deletion.", alias="deletionProtectionEnabled")
    deny_maintenance_periods: Optional[List[DenyMaintenancePeriod]] = Field(default=None, description="Deny maintenance periods", alias="denyMaintenancePeriods")
    edition: Optional[StrictStr] = Field(default=None, description="Optional. The edition of the instance.")
    insights_config: Optional[InsightsConfig] = Field(default=None, alias="insightsConfig")
    ip_configuration: Optional[IpConfiguration] = Field(default=None, alias="ipConfiguration")
    kind: Optional[StrictStr] = Field(default=None, description="This is always `sql#settings`.")
    location_preference: Optional[LocationPreference] = Field(default=None, alias="locationPreference")
    maintenance_window: Optional[MaintenanceWindow] = Field(default=None, alias="maintenanceWindow")
    password_validation_policy: Optional[PasswordValidationPolicy] = Field(default=None, alias="passwordValidationPolicy")
    pricing_plan: Optional[StrictStr] = Field(default=None, description="The pricing plan for this instance. This can be either `PER_USE` or `PACKAGE`. Only `PER_USE` is supported for Second Generation instances.", alias="pricingPlan")
    replication_type: Optional[StrictStr] = Field(default=None, description="The type of replication this instance uses. This can be either `ASYNCHRONOUS` or `SYNCHRONOUS`. (Deprecated) This property was only applicable to First Generation instances.", alias="replicationType")
    settings_version: Optional[StrictStr] = Field(default=None, description="The version of instance settings. This is a required field for update method to make sure concurrent updates are handled properly. During update, use the most recent settingsVersion value for this instance and do not try to update this value.", alias="settingsVersion")
    sql_server_audit_config: Optional[SqlServerAuditConfig] = Field(default=None, alias="sqlServerAuditConfig")
    storage_auto_resize: Optional[StrictBool] = Field(default=None, description="Configuration to increase storage size automatically. The default value is true.", alias="storageAutoResize")
    storage_auto_resize_limit: Optional[StrictStr] = Field(default=None, description="The maximum size to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.", alias="storageAutoResizeLimit")
    tier: Optional[StrictStr] = Field(default=None, description="The tier (or machine type) for this instance, for example `db-custom-1-3840`. WARNING: Changing this restarts the instance.")
    time_zone: Optional[StrictStr] = Field(default=None, description="Server timezone, relevant only for Cloud SQL for SQL Server.", alias="timeZone")
    user_labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="User-provided labels, represented as a dictionary where each label is a single key value pair.", alias="userLabels")
    __properties: ClassVar[List[str]] = ["activationPolicy", "activeDirectoryConfig", "advancedMachineFeatures", "authorizedGaeApplications", "availabilityType", "backupConfiguration", "collation", "connectorEnforcement", "crashSafeReplicationEnabled", "dataCacheConfig", "dataDiskSizeGb", "dataDiskType", "databaseFlags", "databaseReplicationEnabled", "deletionProtectionEnabled", "denyMaintenancePeriods", "edition", "insightsConfig", "ipConfiguration", "kind", "locationPreference", "maintenanceWindow", "passwordValidationPolicy", "pricingPlan", "replicationType", "settingsVersion", "sqlServerAuditConfig", "storageAutoResize", "storageAutoResizeLimit", "tier", "timeZone", "userLabels"]

    @field_validator('activation_policy')
    def activation_policy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SQL_ACTIVATION_POLICY_UNSPECIFIED', 'ALWAYS', 'NEVER', 'ON_DEMAND']):
            raise ValueError("must be one of enum values ('SQL_ACTIVATION_POLICY_UNSPECIFIED', 'ALWAYS', 'NEVER', 'ON_DEMAND')")
        return value

    @field_validator('availability_type')
    def availability_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SQL_AVAILABILITY_TYPE_UNSPECIFIED', 'ZONAL', 'REGIONAL']):
            raise ValueError("must be one of enum values ('SQL_AVAILABILITY_TYPE_UNSPECIFIED', 'ZONAL', 'REGIONAL')")
        return value

    @field_validator('connector_enforcement')
    def connector_enforcement_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CONNECTOR_ENFORCEMENT_UNSPECIFIED', 'NOT_REQUIRED', 'REQUIRED']):
            raise ValueError("must be one of enum values ('CONNECTOR_ENFORCEMENT_UNSPECIFIED', 'NOT_REQUIRED', 'REQUIRED')")
        return value

    @field_validator('data_disk_type')
    def data_disk_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SQL_DATA_DISK_TYPE_UNSPECIFIED', 'PD_SSD', 'PD_HDD', 'OBSOLETE_LOCAL_SSD']):
            raise ValueError("must be one of enum values ('SQL_DATA_DISK_TYPE_UNSPECIFIED', 'PD_SSD', 'PD_HDD', 'OBSOLETE_LOCAL_SSD')")
        return value

    @field_validator('edition')
    def edition_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['EDITION_UNSPECIFIED', 'ENTERPRISE', 'ENTERPRISE_PLUS']):
            raise ValueError("must be one of enum values ('EDITION_UNSPECIFIED', 'ENTERPRISE', 'ENTERPRISE_PLUS')")
        return value

    @field_validator('pricing_plan')
    def pricing_plan_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SQL_PRICING_PLAN_UNSPECIFIED', 'PACKAGE', 'PER_USE']):
            raise ValueError("must be one of enum values ('SQL_PRICING_PLAN_UNSPECIFIED', 'PACKAGE', 'PER_USE')")
        return value

    @field_validator('replication_type')
    def replication_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SQL_REPLICATION_TYPE_UNSPECIFIED', 'SYNCHRONOUS', 'ASYNCHRONOUS']):
            raise ValueError("must be one of enum values ('SQL_REPLICATION_TYPE_UNSPECIFIED', 'SYNCHRONOUS', 'ASYNCHRONOUS')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Settings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of active_directory_config
        if self.active_directory_config:
            _dict['activeDirectoryConfig'] = self.active_directory_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of advanced_machine_features
        if self.advanced_machine_features:
            _dict['advancedMachineFeatures'] = self.advanced_machine_features.to_dict()
        # override the default output from pydantic by calling `to_dict()` of backup_configuration
        if self.backup_configuration:
            _dict['backupConfiguration'] = self.backup_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of data_cache_config
        if self.data_cache_config:
            _dict['dataCacheConfig'] = self.data_cache_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in database_flags (list)
        _items = []
        if self.database_flags:
            for _item_database_flags in self.database_flags:
                if _item_database_flags:
                    _items.append(_item_database_flags.to_dict())
            _dict['databaseFlags'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in deny_maintenance_periods (list)
        _items = []
        if self.deny_maintenance_periods:
            for _item_deny_maintenance_periods in self.deny_maintenance_periods:
                if _item_deny_maintenance_periods:
                    _items.append(_item_deny_maintenance_periods.to_dict())
            _dict['denyMaintenancePeriods'] = _items
        # override the default output from pydantic by calling `to_dict()` of insights_config
        if self.insights_config:
            _dict['insightsConfig'] = self.insights_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ip_configuration
        if self.ip_configuration:
            _dict['ipConfiguration'] = self.ip_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of location_preference
        if self.location_preference:
            _dict['locationPreference'] = self.location_preference.to_dict()
        # override the default output from pydantic by calling `to_dict()` of maintenance_window
        if self.maintenance_window:
            _dict['maintenanceWindow'] = self.maintenance_window.to_dict()
        # override the default output from pydantic by calling `to_dict()` of password_validation_policy
        if self.password_validation_policy:
            _dict['passwordValidationPolicy'] = self.password_validation_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sql_server_audit_config
        if self.sql_server_audit_config:
            _dict['sqlServerAuditConfig'] = self.sql_server_audit_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Settings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "activationPolicy": obj.get("activationPolicy"),
            "activeDirectoryConfig": SqlActiveDirectoryConfig.from_dict(obj["activeDirectoryConfig"]) if obj.get("activeDirectoryConfig") is not None else None,
            "advancedMachineFeatures": AdvancedMachineFeatures.from_dict(obj["advancedMachineFeatures"]) if obj.get("advancedMachineFeatures") is not None else None,
            "authorizedGaeApplications": obj.get("authorizedGaeApplications"),
            "availabilityType": obj.get("availabilityType"),
            "backupConfiguration": BackupConfiguration.from_dict(obj["backupConfiguration"]) if obj.get("backupConfiguration") is not None else None,
            "collation": obj.get("collation"),
            "connectorEnforcement": obj.get("connectorEnforcement"),
            "crashSafeReplicationEnabled": obj.get("crashSafeReplicationEnabled"),
            "dataCacheConfig": DataCacheConfig.from_dict(obj["dataCacheConfig"]) if obj.get("dataCacheConfig") is not None else None,
            "dataDiskSizeGb": obj.get("dataDiskSizeGb"),
            "dataDiskType": obj.get("dataDiskType"),
            "databaseFlags": [DatabaseFlags.from_dict(_item) for _item in obj["databaseFlags"]] if obj.get("databaseFlags") is not None else None,
            "databaseReplicationEnabled": obj.get("databaseReplicationEnabled"),
            "deletionProtectionEnabled": obj.get("deletionProtectionEnabled"),
            "denyMaintenancePeriods": [DenyMaintenancePeriod.from_dict(_item) for _item in obj["denyMaintenancePeriods"]] if obj.get("denyMaintenancePeriods") is not None else None,
            "edition": obj.get("edition"),
            "insightsConfig": InsightsConfig.from_dict(obj["insightsConfig"]) if obj.get("insightsConfig") is not None else None,
            "ipConfiguration": IpConfiguration.from_dict(obj["ipConfiguration"]) if obj.get("ipConfiguration") is not None else None,
            "kind": obj.get("kind"),
            "locationPreference": LocationPreference.from_dict(obj["locationPreference"]) if obj.get("locationPreference") is not None else None,
            "maintenanceWindow": MaintenanceWindow.from_dict(obj["maintenanceWindow"]) if obj.get("maintenanceWindow") is not None else None,
            "passwordValidationPolicy": PasswordValidationPolicy.from_dict(obj["passwordValidationPolicy"]) if obj.get("passwordValidationPolicy") is not None else None,
            "pricingPlan": obj.get("pricingPlan"),
            "replicationType": obj.get("replicationType"),
            "settingsVersion": obj.get("settingsVersion"),
            "sqlServerAuditConfig": SqlServerAuditConfig.from_dict(obj["sqlServerAuditConfig"]) if obj.get("sqlServerAuditConfig") is not None else None,
            "storageAutoResize": obj.get("storageAutoResize"),
            "storageAutoResizeLimit": obj.get("storageAutoResizeLimit"),
            "tier": obj.get("tier"),
            "timeZone": obj.get("timeZone"),
            "userLabels": obj.get("userLabels")
        })
        return _obj


