# coding: utf-8

"""
    YouTube Analytics API

    Retrieves your YouTube Analytics data.

    The version of the OpenAPI document: v2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ErrorProto(BaseModel):
    """
    Describes one specific error.
    """ # noqa: E501
    argument: Optional[List[StrictStr]] = Field(default=None, description="Error arguments, to be used when building user-friendly error messages given the error domain and code. Different error codes require different arguments.")
    code: Optional[StrictStr] = Field(default=None, description="Error code in the error domain. This should correspond to a value of the enum type whose name is in domain. See the core error domain in error_domain.proto.")
    debug_info: Optional[StrictStr] = Field(default=None, description="Debugging information, which should not be shared externally.", alias="debugInfo")
    domain: Optional[StrictStr] = Field(default=None, description="Error domain. RoSy services can define their own domain and error codes. This should normally be the name of an enum type, such as: gdata.CoreErrorDomain")
    external_error_message: Optional[StrictStr] = Field(default=None, description="A short explanation for the error, which can be shared outside Google. Please set domain, code and arguments whenever possible instead of this error message so that external APIs can build safe error messages themselves. External messages built in a RoSy interface will most likely refer to information and concepts that are not available externally and should not be exposed. It is safer if external APIs can understand the errors and decide what the error message should look like.", alias="externalErrorMessage")
    location: Optional[StrictStr] = Field(default=None, description="Location of the error, as specified by the location type. If location_type is PATH, this should be a path to a field that's relative to the request, using FieldPath notation (net/proto2/util/public/field_path.h). Examples: authenticated_user.gaia_id resource.address[2].country")
    location_type: Optional[StrictStr] = Field(default=None, alias="locationType")
    __properties: ClassVar[List[str]] = ["argument", "code", "debugInfo", "domain", "externalErrorMessage", "location", "locationType"]

    @field_validator('location_type')
    def location_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['PATH', 'OTHER', 'PARAMETER']):
            raise ValueError("must be one of enum values ('PATH', 'OTHER', 'PARAMETER')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ErrorProto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ErrorProto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "argument": obj.get("argument"),
            "code": obj.get("code"),
            "debugInfo": obj.get("debugInfo"),
            "domain": obj.get("domain"),
            "externalErrorMessage": obj.get("externalErrorMessage"),
            "location": obj.get("location"),
            "locationType": obj.get("locationType")
        })
        return _obj


