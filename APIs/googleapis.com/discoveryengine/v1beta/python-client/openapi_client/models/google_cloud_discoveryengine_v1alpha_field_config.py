# coding: utf-8

"""
    Discovery Engine API

    Discovery Engine API.

    The version of the OpenAPI document: v1beta
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class GoogleCloudDiscoveryengineV1alphaFieldConfig(BaseModel):
    """
    Configurations for fields of a schema. For example, configuring a field is indexable, or searchable.
    """ # noqa: E501
    completable_option: Optional[StrictStr] = Field(default=None, description="If completable_option is COMPLETABLE_ENABLED, field values are directly used and returned as suggestions for Autocomplete in CompletionService.CompleteQuery. If completable_option is unset, the server behavior defaults to COMPLETABLE_DISABLED for fields that support setting completable options, which are just `string` fields. For those fields that do not support setting completable options, the server will skip completable option setting, and setting completable_option for those fields will throw `INVALID_ARGUMENT` error.", alias="completableOption")
    dynamic_facetable_option: Optional[StrictStr] = Field(default=None, description="If dynamic_facetable_option is DYNAMIC_FACETABLE_ENABLED, field values are available for dynamic facet. Could only be DYNAMIC_FACETABLE_DISABLED if FieldConfig.indexable_option is INDEXABLE_DISABLED. Otherwise, an `INVALID_ARGUMENT` error will be returned. If dynamic_facetable_option is unset, the server behavior defaults to DYNAMIC_FACETABLE_DISABLED for fields that support setting dynamic facetable options. For those fields that do not support setting dynamic facetable options, such as `object` and `boolean`, the server will skip dynamic facetable option setting, and setting dynamic_facetable_option for those fields will throw `INVALID_ARGUMENT` error.", alias="dynamicFacetableOption")
    field_path: Optional[StrictStr] = Field(default=None, description="Required. Field path of the schema field. For example: `title`, `description`, `release_info.release_year`.", alias="fieldPath")
    field_type: Optional[StrictStr] = Field(default=None, description="Output only. Raw type of the field.", alias="fieldType")
    indexable_option: Optional[StrictStr] = Field(default=None, description="If indexable_option is INDEXABLE_ENABLED, field values are indexed so that it can be filtered or faceted in SearchService.Search. If indexable_option is unset, the server behavior defaults to INDEXABLE_DISABLED for fields that support setting indexable options. For those fields that do not support setting indexable options, such as `object` and `boolean` and key properties, the server will skip indexable_option setting, and setting indexable_option for those fields will throw `INVALID_ARGUMENT` error.", alias="indexableOption")
    key_property_type: Optional[StrictStr] = Field(default=None, description="Output only. Type of the key property that this field is mapped to. Empty string if this is not annotated as mapped to a key property. Example types are `title`, `description`. Full list is defined by `keyPropertyMapping` in the schema field annotation. If the schema field has a `KeyPropertyMapping` annotation, `indexable_option` and `searchable_option` of this field cannot be modified.", alias="keyPropertyType")
    recs_filterable_option: Optional[StrictStr] = Field(default=None, description="If recs_filterable_option is FILTERABLE_ENABLED, field values are filterable by filter expression in RecommendationService.Recommend. If FILTERABLE_ENABLED but the field type is numerical, field values are not filterable by text queries in RecommendationService.Recommend. Only textual fields are supported. If recs_filterable_option is unset, the default setting is FILTERABLE_DISABLED for fields that support setting filterable options. When a field set to [FILTERABLE_DISABLED] is filtered, a warning is generated and an empty result is returned.", alias="recsFilterableOption")
    retrievable_option: Optional[StrictStr] = Field(default=None, description="If retrievable_option is RETRIEVABLE_ENABLED, field values are included in the search results. If retrievable_option is unset, the server behavior defaults to RETRIEVABLE_DISABLED for fields that support setting retrievable options. For those fields that do not support setting retrievable options, such as `object` and `boolean`, the server will skip retrievable option setting, and setting retrievable_option for those fields will throw `INVALID_ARGUMENT` error.", alias="retrievableOption")
    searchable_option: Optional[StrictStr] = Field(default=None, description="If searchable_option is SEARCHABLE_ENABLED, field values are searchable by text queries in SearchService.Search. If SEARCHABLE_ENABLED but field type is numerical, field values will not be searchable by text queries in SearchService.Search, as there are no text values associated to numerical fields. If searchable_option is unset, the server behavior defaults to SEARCHABLE_DISABLED for fields that support setting searchable options. Only `string` fields that have no key property mapping support setting searchable_option. For those fields that do not support setting searchable options, the server will skip searchable option setting, and setting searchable_option for those fields will throw `INVALID_ARGUMENT` error.", alias="searchableOption")
    __properties: ClassVar[List[str]] = ["completableOption", "dynamicFacetableOption", "fieldPath", "fieldType", "indexableOption", "keyPropertyType", "recsFilterableOption", "retrievableOption", "searchableOption"]

    @field_validator('completable_option')
    def completable_option_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['COMPLETABLE_OPTION_UNSPECIFIED', 'COMPLETABLE_ENABLED', 'COMPLETABLE_DISABLED']):
            raise ValueError("must be one of enum values ('COMPLETABLE_OPTION_UNSPECIFIED', 'COMPLETABLE_ENABLED', 'COMPLETABLE_DISABLED')")
        return value

    @field_validator('dynamic_facetable_option')
    def dynamic_facetable_option_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['DYNAMIC_FACETABLE_OPTION_UNSPECIFIED', 'DYNAMIC_FACETABLE_ENABLED', 'DYNAMIC_FACETABLE_DISABLED']):
            raise ValueError("must be one of enum values ('DYNAMIC_FACETABLE_OPTION_UNSPECIFIED', 'DYNAMIC_FACETABLE_ENABLED', 'DYNAMIC_FACETABLE_DISABLED')")
        return value

    @field_validator('field_type')
    def field_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['FIELD_TYPE_UNSPECIFIED', 'OBJECT', 'STRING', 'NUMBER', 'INTEGER', 'BOOLEAN', 'GEOLOCATION', 'DATETIME']):
            raise ValueError("must be one of enum values ('FIELD_TYPE_UNSPECIFIED', 'OBJECT', 'STRING', 'NUMBER', 'INTEGER', 'BOOLEAN', 'GEOLOCATION', 'DATETIME')")
        return value

    @field_validator('indexable_option')
    def indexable_option_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['INDEXABLE_OPTION_UNSPECIFIED', 'INDEXABLE_ENABLED', 'INDEXABLE_DISABLED']):
            raise ValueError("must be one of enum values ('INDEXABLE_OPTION_UNSPECIFIED', 'INDEXABLE_ENABLED', 'INDEXABLE_DISABLED')")
        return value

    @field_validator('recs_filterable_option')
    def recs_filterable_option_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['FILTERABLE_OPTION_UNSPECIFIED', 'FILTERABLE_ENABLED', 'FILTERABLE_DISABLED']):
            raise ValueError("must be one of enum values ('FILTERABLE_OPTION_UNSPECIFIED', 'FILTERABLE_ENABLED', 'FILTERABLE_DISABLED')")
        return value

    @field_validator('retrievable_option')
    def retrievable_option_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['RETRIEVABLE_OPTION_UNSPECIFIED', 'RETRIEVABLE_ENABLED', 'RETRIEVABLE_DISABLED']):
            raise ValueError("must be one of enum values ('RETRIEVABLE_OPTION_UNSPECIFIED', 'RETRIEVABLE_ENABLED', 'RETRIEVABLE_DISABLED')")
        return value

    @field_validator('searchable_option')
    def searchable_option_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SEARCHABLE_OPTION_UNSPECIFIED', 'SEARCHABLE_ENABLED', 'SEARCHABLE_DISABLED']):
            raise ValueError("must be one of enum values ('SEARCHABLE_OPTION_UNSPECIFIED', 'SEARCHABLE_ENABLED', 'SEARCHABLE_DISABLED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GoogleCloudDiscoveryengineV1alphaFieldConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "field_type",
            "key_property_type",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GoogleCloudDiscoveryengineV1alphaFieldConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "completableOption": obj.get("completableOption"),
            "dynamicFacetableOption": obj.get("dynamicFacetableOption"),
            "fieldPath": obj.get("fieldPath"),
            "fieldType": obj.get("fieldType"),
            "indexableOption": obj.get("indexableOption"),
            "keyPropertyType": obj.get("keyPropertyType"),
            "recsFilterableOption": obj.get("recsFilterableOption"),
            "retrievableOption": obj.get("retrievableOption"),
            "searchableOption": obj.get("searchableOption")
        })
        return _obj


