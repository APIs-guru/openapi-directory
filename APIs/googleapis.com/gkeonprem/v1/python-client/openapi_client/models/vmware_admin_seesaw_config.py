# coding: utf-8

"""
    Anthos On-Prem API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.vmware_ip_block import VmwareIpBlock
from typing import Optional, Set
from typing_extensions import Self

class VmwareAdminSeesawConfig(BaseModel):
    """
    VmwareSeesawConfig represents configuration parameters for an already existing Seesaw load balancer. IMPORTANT: Please note that the Anthos On-Prem API will not generate or update Seesaw configurations it can only bind a pre-existing configuration to a new user cluster. IMPORTANT: When attempting to create a user cluster with a pre-existing Seesaw load balancer you will need to follow some preparation steps before calling the 'CreateVmwareCluster' API method. First you will need to create the user cluster's namespace via kubectl. The namespace will need to use the following naming convention : -gke-onprem-mgmt or -gke-onprem-mgmt depending on whether you used the 'VmwareCluster.local_name' to disambiguate collisions; for more context see the documentation of 'VmwareCluster.local_name'. Once the namespace is created you will need to create a secret resource via kubectl. This secret will contain copies of your Seesaw credentials. The Secret must be called 'user-cluster-creds' and contain Seesaw's SSH and Cert credentials. The credentials must be keyed with the following names: 'seesaw-ssh-private-key', 'seesaw-ssh-public-key', 'seesaw-ssh-ca-key', 'seesaw-ssh-ca-cert'.
    """ # noqa: E501
    enable_ha: Optional[StrictBool] = Field(default=None, description="Enable two load balancer VMs to achieve a highly-available Seesaw load balancer.", alias="enableHa")
    group: Optional[StrictStr] = Field(default=None, description="In general the following format should be used for the Seesaw group name: seesaw-for-[cluster_name].")
    ip_blocks: Optional[List[VmwareIpBlock]] = Field(default=None, description="The IP Blocks to be used by the Seesaw load balancer", alias="ipBlocks")
    master_ip: Optional[StrictStr] = Field(default=None, description="MasterIP is the IP announced by the master of Seesaw group.", alias="masterIp")
    stackdriver_name: Optional[StrictStr] = Field(default=None, description="Name to be used by Stackdriver.", alias="stackdriverName")
    vms: Optional[List[StrictStr]] = Field(default=None, description="Names of the VMs created for this Seesaw group.")
    __properties: ClassVar[List[str]] = ["enableHa", "group", "ipBlocks", "masterIp", "stackdriverName", "vms"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VmwareAdminSeesawConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in ip_blocks (list)
        _items = []
        if self.ip_blocks:
            for _item_ip_blocks in self.ip_blocks:
                if _item_ip_blocks:
                    _items.append(_item_ip_blocks.to_dict())
            _dict['ipBlocks'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VmwareAdminSeesawConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "enableHa": obj.get("enableHa"),
            "group": obj.get("group"),
            "ipBlocks": [VmwareIpBlock.from_dict(_item) for _item in obj["ipBlocks"]] if obj.get("ipBlocks") is not None else None,
            "masterIp": obj.get("masterIp"),
            "stackdriverName": obj.get("stackdriverName"),
            "vms": obj.get("vms")
        })
        return _obj


