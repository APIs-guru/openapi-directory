# coding: utf-8

"""
    Anthos On-Prem API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.node_taint import NodeTaint
from openapi_client.models.vmware_vsphere_config import VmwareVsphereConfig
from typing import Optional, Set
from typing_extensions import Self

class VmwareNodeConfig(BaseModel):
    """
    Parameters that describe the configuration of all nodes within a given node pool.
    """ # noqa: E501
    boot_disk_size_gb: Optional[StrictStr] = Field(default=None, description="VMware disk size to be used during creation.", alias="bootDiskSizeGb")
    cpus: Optional[StrictStr] = Field(default=None, description="The number of CPUs for each node in the node pool.")
    enable_load_balancer: Optional[StrictBool] = Field(default=None, description="Allow node pool traffic to be load balanced. Only works for clusters with MetalLB load balancers.", alias="enableLoadBalancer")
    image: Optional[StrictStr] = Field(default=None, description="The OS image name in vCenter, only valid when using Windows.")
    image_type: Optional[StrictStr] = Field(default=None, description="Required. The OS image to be used for each node in a node pool. Currently `cos`, `ubuntu`, `ubuntu_containerd` and `windows` are supported.", alias="imageType")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it's best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/")
    memory_mb: Optional[StrictStr] = Field(default=None, description="The megabytes of memory for each node in the node pool.", alias="memoryMb")
    replicas: Optional[StrictStr] = Field(default=None, description="The number of nodes in the node pool.")
    taints: Optional[List[NodeTaint]] = Field(default=None, description="The initial taints assigned to nodes of this node pool.")
    vsphere_config: Optional[VmwareVsphereConfig] = Field(default=None, alias="vsphereConfig")
    __properties: ClassVar[List[str]] = ["bootDiskSizeGb", "cpus", "enableLoadBalancer", "image", "imageType", "labels", "memoryMb", "replicas", "taints", "vsphereConfig"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VmwareNodeConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in taints (list)
        _items = []
        if self.taints:
            for _item_taints in self.taints:
                if _item_taints:
                    _items.append(_item_taints.to_dict())
            _dict['taints'] = _items
        # override the default output from pydantic by calling `to_dict()` of vsphere_config
        if self.vsphere_config:
            _dict['vsphereConfig'] = self.vsphere_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VmwareNodeConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "bootDiskSizeGb": obj.get("bootDiskSizeGb"),
            "cpus": obj.get("cpus"),
            "enableLoadBalancer": obj.get("enableLoadBalancer"),
            "image": obj.get("image"),
            "imageType": obj.get("imageType"),
            "labels": obj.get("labels"),
            "memoryMb": obj.get("memoryMb"),
            "replicas": obj.get("replicas"),
            "taints": [NodeTaint.from_dict(_item) for _item in obj["taints"]] if obj.get("taints") is not None else None,
            "vsphereConfig": VmwareVsphereConfig.from_dict(obj["vsphereConfig"]) if obj.get("vsphereConfig") is not None else None
        })
        return _obj


