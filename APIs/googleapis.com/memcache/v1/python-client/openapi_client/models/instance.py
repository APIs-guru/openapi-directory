# coding: utf-8

"""
    Cloud Memorystore for Memcached API

    Google Cloud Memorystore for Memcached API is used for creating and managing Memcached instances in GCP.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.google_cloud_memcache_v1_maintenance_policy import GoogleCloudMemcacheV1MaintenancePolicy
from openapi_client.models.instance_message import InstanceMessage
from openapi_client.models.maintenance_schedule import MaintenanceSchedule
from openapi_client.models.memcache_parameters import MemcacheParameters
from openapi_client.models.node import Node
from openapi_client.models.node_config import NodeConfig
from typing import Optional, Set
from typing_extensions import Self

class Instance(BaseModel):
    """
    A Memorystore for Memcached instance
    """ # noqa: E501
    authorized_network: Optional[StrictStr] = Field(default=None, description="The full name of the Google Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to which the instance is connected. If left unspecified, the `default` network will be used.", alias="authorizedNetwork")
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. The time the instance was created.", alias="createTime")
    discovery_endpoint: Optional[StrictStr] = Field(default=None, description="Output only. Endpoint for the Discovery API.", alias="discoveryEndpoint")
    display_name: Optional[StrictStr] = Field(default=None, description="User provided name for the instance, which is only used for display purposes. Cannot be more than 80 characters.", alias="displayName")
    instance_messages: Optional[List[InstanceMessage]] = Field(default=None, description="List of messages that describe the current state of the Memcached instance.", alias="instanceMessages")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources")
    maintenance_policy: Optional[GoogleCloudMemcacheV1MaintenancePolicy] = Field(default=None, alias="maintenancePolicy")
    maintenance_schedule: Optional[MaintenanceSchedule] = Field(default=None, alias="maintenanceSchedule")
    memcache_full_version: Optional[StrictStr] = Field(default=None, description="Output only. The full version of memcached server running on this instance. System automatically determines the full memcached version for an instance based on the input MemcacheVersion. The full version format will be \"memcached-1.5.16\".", alias="memcacheFullVersion")
    memcache_nodes: Optional[List[Node]] = Field(default=None, description="Output only. List of Memcached nodes. Refer to Node message for more details.", alias="memcacheNodes")
    memcache_version: Optional[StrictStr] = Field(default=None, description="The major version of Memcached software. If not provided, latest supported version will be used. Currently the latest supported major version is `MEMCACHE_1_5`. The minor version will be automatically determined by our system based on the latest supported minor version.", alias="memcacheVersion")
    name: Optional[StrictStr] = Field(default=None, description="Required. Unique name of the resource in this scope including project and location using the form: `projects/{project_id}/locations/{location_id}/instances/{instance_id}` Note: Memcached instances are managed and addressed at the regional level so `location_id` here refers to a Google Cloud region; however, users may choose which zones Memcached nodes should be provisioned in within an instance. Refer to zones field for more details.")
    node_config: Optional[NodeConfig] = Field(default=None, alias="nodeConfig")
    node_count: Optional[StrictInt] = Field(default=None, description="Required. Number of nodes in the Memcached instance.", alias="nodeCount")
    parameters: Optional[MemcacheParameters] = None
    reserved_ip_range_id: Optional[List[StrictStr]] = Field(default=None, description="Optional. Contains the id of allocated IP address ranges associated with the private service access connection for example, \"test-default\" associated with IP range 10.0.0.0/29.", alias="reservedIpRangeId")
    state: Optional[StrictStr] = Field(default=None, description="Output only. The state of this Memcached instance.")
    update_time: Optional[StrictStr] = Field(default=None, description="Output only. The time the instance was updated.", alias="updateTime")
    zones: Optional[List[StrictStr]] = Field(default=None, description="Zones in which Memcached nodes should be provisioned. Memcached nodes will be equally distributed across these zones. If not provided, the service will by default create nodes in all zones in the region for the instance.")
    __properties: ClassVar[List[str]] = ["authorizedNetwork", "createTime", "discoveryEndpoint", "displayName", "instanceMessages", "labels", "maintenancePolicy", "maintenanceSchedule", "memcacheFullVersion", "memcacheNodes", "memcacheVersion", "name", "nodeConfig", "nodeCount", "parameters", "reservedIpRangeId", "state", "updateTime", "zones"]

    @field_validator('memcache_version')
    def memcache_version_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MEMCACHE_VERSION_UNSPECIFIED', 'MEMCACHE_1_5', 'MEMCACHE_1_6_15']):
            raise ValueError("must be one of enum values ('MEMCACHE_VERSION_UNSPECIFIED', 'MEMCACHE_1_5', 'MEMCACHE_1_6_15')")
        return value

    @field_validator('state')
    def state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['STATE_UNSPECIFIED', 'CREATING', 'READY', 'UPDATING', 'DELETING', 'PERFORMING_MAINTENANCE', 'MEMCACHE_VERSION_UPGRADING']):
            raise ValueError("must be one of enum values ('STATE_UNSPECIFIED', 'CREATING', 'READY', 'UPDATING', 'DELETING', 'PERFORMING_MAINTENANCE', 'MEMCACHE_VERSION_UPGRADING')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Instance from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "discovery_endpoint",
            "memcache_full_version",
            "memcache_nodes",
            "state",
            "update_time",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in instance_messages (list)
        _items = []
        if self.instance_messages:
            for _item_instance_messages in self.instance_messages:
                if _item_instance_messages:
                    _items.append(_item_instance_messages.to_dict())
            _dict['instanceMessages'] = _items
        # override the default output from pydantic by calling `to_dict()` of maintenance_policy
        if self.maintenance_policy:
            _dict['maintenancePolicy'] = self.maintenance_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of maintenance_schedule
        if self.maintenance_schedule:
            _dict['maintenanceSchedule'] = self.maintenance_schedule.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in memcache_nodes (list)
        _items = []
        if self.memcache_nodes:
            for _item_memcache_nodes in self.memcache_nodes:
                if _item_memcache_nodes:
                    _items.append(_item_memcache_nodes.to_dict())
            _dict['memcacheNodes'] = _items
        # override the default output from pydantic by calling `to_dict()` of node_config
        if self.node_config:
            _dict['nodeConfig'] = self.node_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of parameters
        if self.parameters:
            _dict['parameters'] = self.parameters.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Instance from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "authorizedNetwork": obj.get("authorizedNetwork"),
            "createTime": obj.get("createTime"),
            "discoveryEndpoint": obj.get("discoveryEndpoint"),
            "displayName": obj.get("displayName"),
            "instanceMessages": [InstanceMessage.from_dict(_item) for _item in obj["instanceMessages"]] if obj.get("instanceMessages") is not None else None,
            "labels": obj.get("labels"),
            "maintenancePolicy": GoogleCloudMemcacheV1MaintenancePolicy.from_dict(obj["maintenancePolicy"]) if obj.get("maintenancePolicy") is not None else None,
            "maintenanceSchedule": MaintenanceSchedule.from_dict(obj["maintenanceSchedule"]) if obj.get("maintenanceSchedule") is not None else None,
            "memcacheFullVersion": obj.get("memcacheFullVersion"),
            "memcacheNodes": [Node.from_dict(_item) for _item in obj["memcacheNodes"]] if obj.get("memcacheNodes") is not None else None,
            "memcacheVersion": obj.get("memcacheVersion"),
            "name": obj.get("name"),
            "nodeConfig": NodeConfig.from_dict(obj["nodeConfig"]) if obj.get("nodeConfig") is not None else None,
            "nodeCount": obj.get("nodeCount"),
            "parameters": MemcacheParameters.from_dict(obj["parameters"]) if obj.get("parameters") is not None else None,
            "reservedIpRangeId": obj.get("reservedIpRangeId"),
            "state": obj.get("state"),
            "updateTime": obj.get("updateTime"),
            "zones": obj.get("zones")
        })
        return _obj


