# coding: utf-8

"""
    Google Play Developer Reporting API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1alpha1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from openapi_client.models.google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request import GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetRequest
from openapi_client.models.google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_response import GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetResponse
from openapi_client.models.google_play_developer_reporting_v1alpha1_search_error_issues_response import GooglePlayDeveloperReportingV1alpha1SearchErrorIssuesResponse
from openapi_client.models.google_play_developer_reporting_v1alpha1_search_error_reports_response import GooglePlayDeveloperReportingV1alpha1SearchErrorReportsResponse
from openapi_client.models.google_play_developer_reporting_v1alpha1_stuck_background_wakelock_rate_metric_set import GooglePlayDeveloperReportingV1alpha1StuckBackgroundWakelockRateMetricSet

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class VitalsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def playdeveloperreporting_vitals_errors_issues_search(
        self,
        parent: Annotated[StrictStr, Field(description="Required. Parent resource of the error issues, indicating the application for which they were received. Format: apps/{app}")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="A selection predicate to retrieve only a subset of the issues. Counts in the returned error issues will only reflect occurrences that matched the filter. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error issues that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error issues that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error issues that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error issues of the requested types only. Valid candidates: `CRASH`, `ANR`. Example: `errorIssueType = CRASH OR errorIssueType = ANR`. * `appProcessState`: Matches error issues on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error issues that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR errorIssueType = ANR` is not a valid filter. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`")] = None,
        interval_end_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_end_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_end_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_end_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_end_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_end_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_end_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_end_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_end_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_end_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        interval_start_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_start_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_start_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_start_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_start_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_start_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_start_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_start_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_start_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_start_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Specifies a field that will be used to order the results. ** Supported dimensions:** * `errorReportCount`: Orders issues by number of error reports. * `distinctUsers`: Orders issues by number of unique affected users. ** Supported operations:** * `asc` for ascending order. * `desc` for descending order. Format: A field and an operation, e.g., `errorReportCount desc` *Note:* currently only one field is supported at a time.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="The maximum number of error issues to return. The service may return fewer than this value. If unspecified, at most 50 error issues will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A page token, received from a previous call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to the request must match the call that provided the page token.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GooglePlayDeveloperReportingV1alpha1SearchErrorIssuesResponse:
        """playdeveloperreporting_vitals_errors_issues_search

        Searches all error issues in which reports have been grouped.

        :param parent: Required. Parent resource of the error issues, indicating the application for which they were received. Format: apps/{app} (required)
        :type parent: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param filter: A selection predicate to retrieve only a subset of the issues. Counts in the returned error issues will only reflect occurrences that matched the filter. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error issues that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error issues that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error issues that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error issues of the requested types only. Valid candidates: `CRASH`, `ANR`. Example: `errorIssueType = CRASH OR errorIssueType = ANR`. * `appProcessState`: Matches error issues on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error issues that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR errorIssueType = ANR` is not a valid filter. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`
        :type filter: str
        :param interval_end_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_end_time_day: int
        :param interval_end_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_end_time_hours: int
        :param interval_end_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_end_time_minutes: int
        :param interval_end_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_end_time_month: int
        :param interval_end_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_end_time_nanos: int
        :param interval_end_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_end_time_seconds: int
        :param interval_end_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_end_time_time_zone_id: str
        :param interval_end_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_end_time_time_zone_version: str
        :param interval_end_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_end_time_utc_offset: str
        :param interval_end_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_end_time_year: int
        :param interval_start_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_start_time_day: int
        :param interval_start_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_start_time_hours: int
        :param interval_start_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_start_time_minutes: int
        :param interval_start_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_start_time_month: int
        :param interval_start_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_start_time_nanos: int
        :param interval_start_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_start_time_seconds: int
        :param interval_start_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_start_time_time_zone_id: str
        :param interval_start_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_start_time_time_zone_version: str
        :param interval_start_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_start_time_utc_offset: str
        :param interval_start_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_start_time_year: int
        :param order_by: Specifies a field that will be used to order the results. ** Supported dimensions:** * `errorReportCount`: Orders issues by number of error reports. * `distinctUsers`: Orders issues by number of unique affected users. ** Supported operations:** * `asc` for ascending order. * `desc` for descending order. Format: A field and an operation, e.g., `errorReportCount desc` *Note:* currently only one field is supported at a time.
        :type order_by: str
        :param page_size: The maximum number of error issues to return. The service may return fewer than this value. If unspecified, at most 50 error issues will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :type page_size: int
        :param page_token: A page token, received from a previous call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to the request must match the call that provided the page token.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_errors_issues_search_serialize(
            parent=parent,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            filter=filter,
            interval_end_time_day=interval_end_time_day,
            interval_end_time_hours=interval_end_time_hours,
            interval_end_time_minutes=interval_end_time_minutes,
            interval_end_time_month=interval_end_time_month,
            interval_end_time_nanos=interval_end_time_nanos,
            interval_end_time_seconds=interval_end_time_seconds,
            interval_end_time_time_zone_id=interval_end_time_time_zone_id,
            interval_end_time_time_zone_version=interval_end_time_time_zone_version,
            interval_end_time_utc_offset=interval_end_time_utc_offset,
            interval_end_time_year=interval_end_time_year,
            interval_start_time_day=interval_start_time_day,
            interval_start_time_hours=interval_start_time_hours,
            interval_start_time_minutes=interval_start_time_minutes,
            interval_start_time_month=interval_start_time_month,
            interval_start_time_nanos=interval_start_time_nanos,
            interval_start_time_seconds=interval_start_time_seconds,
            interval_start_time_time_zone_id=interval_start_time_time_zone_id,
            interval_start_time_time_zone_version=interval_start_time_time_zone_version,
            interval_start_time_utc_offset=interval_start_time_utc_offset,
            interval_start_time_year=interval_start_time_year,
            order_by=order_by,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1SearchErrorIssuesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def playdeveloperreporting_vitals_errors_issues_search_with_http_info(
        self,
        parent: Annotated[StrictStr, Field(description="Required. Parent resource of the error issues, indicating the application for which they were received. Format: apps/{app}")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="A selection predicate to retrieve only a subset of the issues. Counts in the returned error issues will only reflect occurrences that matched the filter. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error issues that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error issues that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error issues that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error issues of the requested types only. Valid candidates: `CRASH`, `ANR`. Example: `errorIssueType = CRASH OR errorIssueType = ANR`. * `appProcessState`: Matches error issues on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error issues that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR errorIssueType = ANR` is not a valid filter. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`")] = None,
        interval_end_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_end_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_end_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_end_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_end_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_end_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_end_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_end_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_end_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_end_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        interval_start_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_start_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_start_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_start_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_start_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_start_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_start_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_start_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_start_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_start_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Specifies a field that will be used to order the results. ** Supported dimensions:** * `errorReportCount`: Orders issues by number of error reports. * `distinctUsers`: Orders issues by number of unique affected users. ** Supported operations:** * `asc` for ascending order. * `desc` for descending order. Format: A field and an operation, e.g., `errorReportCount desc` *Note:* currently only one field is supported at a time.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="The maximum number of error issues to return. The service may return fewer than this value. If unspecified, at most 50 error issues will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A page token, received from a previous call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to the request must match the call that provided the page token.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GooglePlayDeveloperReportingV1alpha1SearchErrorIssuesResponse]:
        """playdeveloperreporting_vitals_errors_issues_search

        Searches all error issues in which reports have been grouped.

        :param parent: Required. Parent resource of the error issues, indicating the application for which they were received. Format: apps/{app} (required)
        :type parent: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param filter: A selection predicate to retrieve only a subset of the issues. Counts in the returned error issues will only reflect occurrences that matched the filter. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error issues that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error issues that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error issues that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error issues of the requested types only. Valid candidates: `CRASH`, `ANR`. Example: `errorIssueType = CRASH OR errorIssueType = ANR`. * `appProcessState`: Matches error issues on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error issues that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR errorIssueType = ANR` is not a valid filter. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`
        :type filter: str
        :param interval_end_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_end_time_day: int
        :param interval_end_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_end_time_hours: int
        :param interval_end_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_end_time_minutes: int
        :param interval_end_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_end_time_month: int
        :param interval_end_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_end_time_nanos: int
        :param interval_end_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_end_time_seconds: int
        :param interval_end_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_end_time_time_zone_id: str
        :param interval_end_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_end_time_time_zone_version: str
        :param interval_end_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_end_time_utc_offset: str
        :param interval_end_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_end_time_year: int
        :param interval_start_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_start_time_day: int
        :param interval_start_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_start_time_hours: int
        :param interval_start_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_start_time_minutes: int
        :param interval_start_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_start_time_month: int
        :param interval_start_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_start_time_nanos: int
        :param interval_start_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_start_time_seconds: int
        :param interval_start_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_start_time_time_zone_id: str
        :param interval_start_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_start_time_time_zone_version: str
        :param interval_start_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_start_time_utc_offset: str
        :param interval_start_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_start_time_year: int
        :param order_by: Specifies a field that will be used to order the results. ** Supported dimensions:** * `errorReportCount`: Orders issues by number of error reports. * `distinctUsers`: Orders issues by number of unique affected users. ** Supported operations:** * `asc` for ascending order. * `desc` for descending order. Format: A field and an operation, e.g., `errorReportCount desc` *Note:* currently only one field is supported at a time.
        :type order_by: str
        :param page_size: The maximum number of error issues to return. The service may return fewer than this value. If unspecified, at most 50 error issues will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :type page_size: int
        :param page_token: A page token, received from a previous call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to the request must match the call that provided the page token.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_errors_issues_search_serialize(
            parent=parent,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            filter=filter,
            interval_end_time_day=interval_end_time_day,
            interval_end_time_hours=interval_end_time_hours,
            interval_end_time_minutes=interval_end_time_minutes,
            interval_end_time_month=interval_end_time_month,
            interval_end_time_nanos=interval_end_time_nanos,
            interval_end_time_seconds=interval_end_time_seconds,
            interval_end_time_time_zone_id=interval_end_time_time_zone_id,
            interval_end_time_time_zone_version=interval_end_time_time_zone_version,
            interval_end_time_utc_offset=interval_end_time_utc_offset,
            interval_end_time_year=interval_end_time_year,
            interval_start_time_day=interval_start_time_day,
            interval_start_time_hours=interval_start_time_hours,
            interval_start_time_minutes=interval_start_time_minutes,
            interval_start_time_month=interval_start_time_month,
            interval_start_time_nanos=interval_start_time_nanos,
            interval_start_time_seconds=interval_start_time_seconds,
            interval_start_time_time_zone_id=interval_start_time_time_zone_id,
            interval_start_time_time_zone_version=interval_start_time_time_zone_version,
            interval_start_time_utc_offset=interval_start_time_utc_offset,
            interval_start_time_year=interval_start_time_year,
            order_by=order_by,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1SearchErrorIssuesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def playdeveloperreporting_vitals_errors_issues_search_without_preload_content(
        self,
        parent: Annotated[StrictStr, Field(description="Required. Parent resource of the error issues, indicating the application for which they were received. Format: apps/{app}")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="A selection predicate to retrieve only a subset of the issues. Counts in the returned error issues will only reflect occurrences that matched the filter. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error issues that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error issues that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error issues that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error issues of the requested types only. Valid candidates: `CRASH`, `ANR`. Example: `errorIssueType = CRASH OR errorIssueType = ANR`. * `appProcessState`: Matches error issues on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error issues that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR errorIssueType = ANR` is not a valid filter. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`")] = None,
        interval_end_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_end_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_end_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_end_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_end_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_end_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_end_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_end_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_end_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_end_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        interval_start_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_start_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_start_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_start_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_start_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_start_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_start_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_start_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_start_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_start_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Specifies a field that will be used to order the results. ** Supported dimensions:** * `errorReportCount`: Orders issues by number of error reports. * `distinctUsers`: Orders issues by number of unique affected users. ** Supported operations:** * `asc` for ascending order. * `desc` for descending order. Format: A field and an operation, e.g., `errorReportCount desc` *Note:* currently only one field is supported at a time.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="The maximum number of error issues to return. The service may return fewer than this value. If unspecified, at most 50 error issues will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A page token, received from a previous call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to the request must match the call that provided the page token.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """playdeveloperreporting_vitals_errors_issues_search

        Searches all error issues in which reports have been grouped.

        :param parent: Required. Parent resource of the error issues, indicating the application for which they were received. Format: apps/{app} (required)
        :type parent: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param filter: A selection predicate to retrieve only a subset of the issues. Counts in the returned error issues will only reflect occurrences that matched the filter. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error issues that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error issues that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error issues that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error issues of the requested types only. Valid candidates: `CRASH`, `ANR`. Example: `errorIssueType = CRASH OR errorIssueType = ANR`. * `appProcessState`: Matches error issues on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error issues that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR errorIssueType = ANR` is not a valid filter. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`
        :type filter: str
        :param interval_end_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_end_time_day: int
        :param interval_end_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_end_time_hours: int
        :param interval_end_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_end_time_minutes: int
        :param interval_end_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_end_time_month: int
        :param interval_end_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_end_time_nanos: int
        :param interval_end_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_end_time_seconds: int
        :param interval_end_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_end_time_time_zone_id: str
        :param interval_end_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_end_time_time_zone_version: str
        :param interval_end_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_end_time_utc_offset: str
        :param interval_end_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_end_time_year: int
        :param interval_start_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_start_time_day: int
        :param interval_start_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_start_time_hours: int
        :param interval_start_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_start_time_minutes: int
        :param interval_start_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_start_time_month: int
        :param interval_start_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_start_time_nanos: int
        :param interval_start_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_start_time_seconds: int
        :param interval_start_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_start_time_time_zone_id: str
        :param interval_start_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_start_time_time_zone_version: str
        :param interval_start_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_start_time_utc_offset: str
        :param interval_start_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_start_time_year: int
        :param order_by: Specifies a field that will be used to order the results. ** Supported dimensions:** * `errorReportCount`: Orders issues by number of error reports. * `distinctUsers`: Orders issues by number of unique affected users. ** Supported operations:** * `asc` for ascending order. * `desc` for descending order. Format: A field and an operation, e.g., `errorReportCount desc` *Note:* currently only one field is supported at a time.
        :type order_by: str
        :param page_size: The maximum number of error issues to return. The service may return fewer than this value. If unspecified, at most 50 error issues will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :type page_size: int
        :param page_token: A page token, received from a previous call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to the request must match the call that provided the page token.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_errors_issues_search_serialize(
            parent=parent,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            filter=filter,
            interval_end_time_day=interval_end_time_day,
            interval_end_time_hours=interval_end_time_hours,
            interval_end_time_minutes=interval_end_time_minutes,
            interval_end_time_month=interval_end_time_month,
            interval_end_time_nanos=interval_end_time_nanos,
            interval_end_time_seconds=interval_end_time_seconds,
            interval_end_time_time_zone_id=interval_end_time_time_zone_id,
            interval_end_time_time_zone_version=interval_end_time_time_zone_version,
            interval_end_time_utc_offset=interval_end_time_utc_offset,
            interval_end_time_year=interval_end_time_year,
            interval_start_time_day=interval_start_time_day,
            interval_start_time_hours=interval_start_time_hours,
            interval_start_time_minutes=interval_start_time_minutes,
            interval_start_time_month=interval_start_time_month,
            interval_start_time_nanos=interval_start_time_nanos,
            interval_start_time_seconds=interval_start_time_seconds,
            interval_start_time_time_zone_id=interval_start_time_time_zone_id,
            interval_start_time_time_zone_version=interval_start_time_time_zone_version,
            interval_start_time_utc_offset=interval_start_time_utc_offset,
            interval_start_time_year=interval_start_time_year,
            order_by=order_by,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1SearchErrorIssuesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _playdeveloperreporting_vitals_errors_issues_search_serialize(
        self,
        parent,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        filter,
        interval_end_time_day,
        interval_end_time_hours,
        interval_end_time_minutes,
        interval_end_time_month,
        interval_end_time_nanos,
        interval_end_time_seconds,
        interval_end_time_time_zone_id,
        interval_end_time_time_zone_version,
        interval_end_time_utc_offset,
        interval_end_time_year,
        interval_start_time_day,
        interval_start_time_hours,
        interval_start_time_minutes,
        interval_start_time_month,
        interval_start_time_nanos,
        interval_start_time_seconds,
        interval_start_time_time_zone_id,
        interval_start_time_time_zone_version,
        interval_start_time_utc_offset,
        interval_start_time_year,
        order_by,
        page_size,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if parent is not None:
            _path_params['parent'] = parent
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if interval_end_time_day is not None:
            
            _query_params.append(('interval.endTime.day', interval_end_time_day))
            
        if interval_end_time_hours is not None:
            
            _query_params.append(('interval.endTime.hours', interval_end_time_hours))
            
        if interval_end_time_minutes is not None:
            
            _query_params.append(('interval.endTime.minutes', interval_end_time_minutes))
            
        if interval_end_time_month is not None:
            
            _query_params.append(('interval.endTime.month', interval_end_time_month))
            
        if interval_end_time_nanos is not None:
            
            _query_params.append(('interval.endTime.nanos', interval_end_time_nanos))
            
        if interval_end_time_seconds is not None:
            
            _query_params.append(('interval.endTime.seconds', interval_end_time_seconds))
            
        if interval_end_time_time_zone_id is not None:
            
            _query_params.append(('interval.endTime.timeZone.id', interval_end_time_time_zone_id))
            
        if interval_end_time_time_zone_version is not None:
            
            _query_params.append(('interval.endTime.timeZone.version', interval_end_time_time_zone_version))
            
        if interval_end_time_utc_offset is not None:
            
            _query_params.append(('interval.endTime.utcOffset', interval_end_time_utc_offset))
            
        if interval_end_time_year is not None:
            
            _query_params.append(('interval.endTime.year', interval_end_time_year))
            
        if interval_start_time_day is not None:
            
            _query_params.append(('interval.startTime.day', interval_start_time_day))
            
        if interval_start_time_hours is not None:
            
            _query_params.append(('interval.startTime.hours', interval_start_time_hours))
            
        if interval_start_time_minutes is not None:
            
            _query_params.append(('interval.startTime.minutes', interval_start_time_minutes))
            
        if interval_start_time_month is not None:
            
            _query_params.append(('interval.startTime.month', interval_start_time_month))
            
        if interval_start_time_nanos is not None:
            
            _query_params.append(('interval.startTime.nanos', interval_start_time_nanos))
            
        if interval_start_time_seconds is not None:
            
            _query_params.append(('interval.startTime.seconds', interval_start_time_seconds))
            
        if interval_start_time_time_zone_id is not None:
            
            _query_params.append(('interval.startTime.timeZone.id', interval_start_time_time_zone_id))
            
        if interval_start_time_time_zone_version is not None:
            
            _query_params.append(('interval.startTime.timeZone.version', interval_start_time_time_zone_version))
            
        if interval_start_time_utc_offset is not None:
            
            _query_params.append(('interval.startTime.utcOffset', interval_start_time_utc_offset))
            
        if interval_start_time_year is not None:
            
            _query_params.append(('interval.startTime.year', interval_start_time_year))
            
        if order_by is not None:
            
            _query_params.append(('orderBy', order_by))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1alpha1/{parent}/errorIssues:search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def playdeveloperreporting_vitals_errors_reports_search(
        self,
        parent: Annotated[StrictStr, Field(description="Required. Parent resource of the reports, indicating the application for which they were received. Format: apps/{app}")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="A selection predicate to retrieve only a subset of the reports. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error reports that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error reports that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error reports that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error reports of the requested types only. Valid candidates: `JAVA_CRASH`, `NATIVE_CRASH`, `ANR`. Example: `errorIssueType = JAVA_CRASH OR errorIssueType = NATIVE_CRASH`. * `errorIssueId`: Matches error reports belonging to the requested error issue ids only. Example: `errorIssueId = 1234 OR errorIssueId = 4567`. * `appProcessState`: Matches error reports on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error reports that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR versionCode = ANR`. The filter expression `versionCode = 123 OR errorIssueType = ANR` is not valid. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`")] = None,
        interval_end_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_end_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_end_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_end_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_end_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_end_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_end_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_end_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_end_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_end_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        interval_start_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_start_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_start_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_start_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_start_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_start_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_start_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_start_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_start_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_start_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="The maximum number of reports to return. The service may return fewer than this value. If unspecified, at most 50 reports will be returned. The maximum value is 100; values above 100 will be coerced to 100.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A page token, received from a previous `SearchErrorReports` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `SearchErrorReports` must match the call that provided the page token.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GooglePlayDeveloperReportingV1alpha1SearchErrorReportsResponse:
        """playdeveloperreporting_vitals_errors_reports_search

        Searches all error reports received for an app.

        :param parent: Required. Parent resource of the reports, indicating the application for which they were received. Format: apps/{app} (required)
        :type parent: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param filter: A selection predicate to retrieve only a subset of the reports. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error reports that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error reports that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error reports that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error reports of the requested types only. Valid candidates: `JAVA_CRASH`, `NATIVE_CRASH`, `ANR`. Example: `errorIssueType = JAVA_CRASH OR errorIssueType = NATIVE_CRASH`. * `errorIssueId`: Matches error reports belonging to the requested error issue ids only. Example: `errorIssueId = 1234 OR errorIssueId = 4567`. * `appProcessState`: Matches error reports on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error reports that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR versionCode = ANR`. The filter expression `versionCode = 123 OR errorIssueType = ANR` is not valid. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`
        :type filter: str
        :param interval_end_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_end_time_day: int
        :param interval_end_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_end_time_hours: int
        :param interval_end_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_end_time_minutes: int
        :param interval_end_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_end_time_month: int
        :param interval_end_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_end_time_nanos: int
        :param interval_end_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_end_time_seconds: int
        :param interval_end_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_end_time_time_zone_id: str
        :param interval_end_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_end_time_time_zone_version: str
        :param interval_end_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_end_time_utc_offset: str
        :param interval_end_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_end_time_year: int
        :param interval_start_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_start_time_day: int
        :param interval_start_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_start_time_hours: int
        :param interval_start_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_start_time_minutes: int
        :param interval_start_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_start_time_month: int
        :param interval_start_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_start_time_nanos: int
        :param interval_start_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_start_time_seconds: int
        :param interval_start_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_start_time_time_zone_id: str
        :param interval_start_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_start_time_time_zone_version: str
        :param interval_start_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_start_time_utc_offset: str
        :param interval_start_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_start_time_year: int
        :param page_size: The maximum number of reports to return. The service may return fewer than this value. If unspecified, at most 50 reports will be returned. The maximum value is 100; values above 100 will be coerced to 100.
        :type page_size: int
        :param page_token: A page token, received from a previous `SearchErrorReports` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `SearchErrorReports` must match the call that provided the page token.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_errors_reports_search_serialize(
            parent=parent,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            filter=filter,
            interval_end_time_day=interval_end_time_day,
            interval_end_time_hours=interval_end_time_hours,
            interval_end_time_minutes=interval_end_time_minutes,
            interval_end_time_month=interval_end_time_month,
            interval_end_time_nanos=interval_end_time_nanos,
            interval_end_time_seconds=interval_end_time_seconds,
            interval_end_time_time_zone_id=interval_end_time_time_zone_id,
            interval_end_time_time_zone_version=interval_end_time_time_zone_version,
            interval_end_time_utc_offset=interval_end_time_utc_offset,
            interval_end_time_year=interval_end_time_year,
            interval_start_time_day=interval_start_time_day,
            interval_start_time_hours=interval_start_time_hours,
            interval_start_time_minutes=interval_start_time_minutes,
            interval_start_time_month=interval_start_time_month,
            interval_start_time_nanos=interval_start_time_nanos,
            interval_start_time_seconds=interval_start_time_seconds,
            interval_start_time_time_zone_id=interval_start_time_time_zone_id,
            interval_start_time_time_zone_version=interval_start_time_time_zone_version,
            interval_start_time_utc_offset=interval_start_time_utc_offset,
            interval_start_time_year=interval_start_time_year,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1SearchErrorReportsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def playdeveloperreporting_vitals_errors_reports_search_with_http_info(
        self,
        parent: Annotated[StrictStr, Field(description="Required. Parent resource of the reports, indicating the application for which they were received. Format: apps/{app}")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="A selection predicate to retrieve only a subset of the reports. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error reports that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error reports that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error reports that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error reports of the requested types only. Valid candidates: `JAVA_CRASH`, `NATIVE_CRASH`, `ANR`. Example: `errorIssueType = JAVA_CRASH OR errorIssueType = NATIVE_CRASH`. * `errorIssueId`: Matches error reports belonging to the requested error issue ids only. Example: `errorIssueId = 1234 OR errorIssueId = 4567`. * `appProcessState`: Matches error reports on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error reports that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR versionCode = ANR`. The filter expression `versionCode = 123 OR errorIssueType = ANR` is not valid. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`")] = None,
        interval_end_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_end_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_end_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_end_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_end_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_end_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_end_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_end_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_end_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_end_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        interval_start_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_start_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_start_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_start_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_start_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_start_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_start_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_start_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_start_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_start_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="The maximum number of reports to return. The service may return fewer than this value. If unspecified, at most 50 reports will be returned. The maximum value is 100; values above 100 will be coerced to 100.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A page token, received from a previous `SearchErrorReports` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `SearchErrorReports` must match the call that provided the page token.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GooglePlayDeveloperReportingV1alpha1SearchErrorReportsResponse]:
        """playdeveloperreporting_vitals_errors_reports_search

        Searches all error reports received for an app.

        :param parent: Required. Parent resource of the reports, indicating the application for which they were received. Format: apps/{app} (required)
        :type parent: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param filter: A selection predicate to retrieve only a subset of the reports. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error reports that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error reports that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error reports that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error reports of the requested types only. Valid candidates: `JAVA_CRASH`, `NATIVE_CRASH`, `ANR`. Example: `errorIssueType = JAVA_CRASH OR errorIssueType = NATIVE_CRASH`. * `errorIssueId`: Matches error reports belonging to the requested error issue ids only. Example: `errorIssueId = 1234 OR errorIssueId = 4567`. * `appProcessState`: Matches error reports on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error reports that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR versionCode = ANR`. The filter expression `versionCode = 123 OR errorIssueType = ANR` is not valid. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`
        :type filter: str
        :param interval_end_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_end_time_day: int
        :param interval_end_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_end_time_hours: int
        :param interval_end_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_end_time_minutes: int
        :param interval_end_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_end_time_month: int
        :param interval_end_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_end_time_nanos: int
        :param interval_end_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_end_time_seconds: int
        :param interval_end_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_end_time_time_zone_id: str
        :param interval_end_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_end_time_time_zone_version: str
        :param interval_end_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_end_time_utc_offset: str
        :param interval_end_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_end_time_year: int
        :param interval_start_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_start_time_day: int
        :param interval_start_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_start_time_hours: int
        :param interval_start_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_start_time_minutes: int
        :param interval_start_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_start_time_month: int
        :param interval_start_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_start_time_nanos: int
        :param interval_start_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_start_time_seconds: int
        :param interval_start_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_start_time_time_zone_id: str
        :param interval_start_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_start_time_time_zone_version: str
        :param interval_start_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_start_time_utc_offset: str
        :param interval_start_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_start_time_year: int
        :param page_size: The maximum number of reports to return. The service may return fewer than this value. If unspecified, at most 50 reports will be returned. The maximum value is 100; values above 100 will be coerced to 100.
        :type page_size: int
        :param page_token: A page token, received from a previous `SearchErrorReports` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `SearchErrorReports` must match the call that provided the page token.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_errors_reports_search_serialize(
            parent=parent,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            filter=filter,
            interval_end_time_day=interval_end_time_day,
            interval_end_time_hours=interval_end_time_hours,
            interval_end_time_minutes=interval_end_time_minutes,
            interval_end_time_month=interval_end_time_month,
            interval_end_time_nanos=interval_end_time_nanos,
            interval_end_time_seconds=interval_end_time_seconds,
            interval_end_time_time_zone_id=interval_end_time_time_zone_id,
            interval_end_time_time_zone_version=interval_end_time_time_zone_version,
            interval_end_time_utc_offset=interval_end_time_utc_offset,
            interval_end_time_year=interval_end_time_year,
            interval_start_time_day=interval_start_time_day,
            interval_start_time_hours=interval_start_time_hours,
            interval_start_time_minutes=interval_start_time_minutes,
            interval_start_time_month=interval_start_time_month,
            interval_start_time_nanos=interval_start_time_nanos,
            interval_start_time_seconds=interval_start_time_seconds,
            interval_start_time_time_zone_id=interval_start_time_time_zone_id,
            interval_start_time_time_zone_version=interval_start_time_time_zone_version,
            interval_start_time_utc_offset=interval_start_time_utc_offset,
            interval_start_time_year=interval_start_time_year,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1SearchErrorReportsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def playdeveloperreporting_vitals_errors_reports_search_without_preload_content(
        self,
        parent: Annotated[StrictStr, Field(description="Required. Parent resource of the reports, indicating the application for which they were received. Format: apps/{app}")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="A selection predicate to retrieve only a subset of the reports. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error reports that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error reports that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error reports that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error reports of the requested types only. Valid candidates: `JAVA_CRASH`, `NATIVE_CRASH`, `ANR`. Example: `errorIssueType = JAVA_CRASH OR errorIssueType = NATIVE_CRASH`. * `errorIssueId`: Matches error reports belonging to the requested error issue ids only. Example: `errorIssueId = 1234 OR errorIssueId = 4567`. * `appProcessState`: Matches error reports on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error reports that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR versionCode = ANR`. The filter expression `versionCode = 123 OR errorIssueType = ANR` is not valid. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`")] = None,
        interval_end_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_end_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_end_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_end_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_end_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_end_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_end_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_end_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_end_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_end_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        interval_start_time_day: Annotated[Optional[StrictInt], Field(description="Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.")] = None,
        interval_start_time_hours: Annotated[Optional[StrictInt], Field(description="Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")] = None,
        interval_start_time_minutes: Annotated[Optional[StrictInt], Field(description="Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.")] = None,
        interval_start_time_month: Annotated[Optional[StrictInt], Field(description="Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.")] = None,
        interval_start_time_nanos: Annotated[Optional[StrictInt], Field(description="Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.")] = None,
        interval_start_time_seconds: Annotated[Optional[StrictInt], Field(description="Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.")] = None,
        interval_start_time_time_zone_id: Annotated[Optional[StrictStr], Field(description="IANA Time Zone Database time zone, e.g. \"America/New_York\".")] = None,
        interval_start_time_time_zone_version: Annotated[Optional[StrictStr], Field(description="Optional. IANA Time Zone Database version number, e.g. \"2019a\".")] = None,
        interval_start_time_utc_offset: Annotated[Optional[StrictStr], Field(description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")] = None,
        interval_start_time_year: Annotated[Optional[StrictInt], Field(description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="The maximum number of reports to return. The service may return fewer than this value. If unspecified, at most 50 reports will be returned. The maximum value is 100; values above 100 will be coerced to 100.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="A page token, received from a previous `SearchErrorReports` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `SearchErrorReports` must match the call that provided the page token.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """playdeveloperreporting_vitals_errors_reports_search

        Searches all error reports received for an app.

        :param parent: Required. Parent resource of the reports, indicating the application for which they were received. Format: apps/{app} (required)
        :type parent: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param filter: A selection predicate to retrieve only a subset of the reports. For filtering basics, please check [AIP-160](https://google.aip.dev/160). ** Supported field names:** * `apiLevel`: Matches error reports that occurred in the requested Android versions (specified as the numeric API level) only. Example: `apiLevel = 28 OR apiLevel = 29`. * `versionCode`: Matches error reports that occurred in the requested app version codes only. Example: `versionCode = 123 OR versionCode = 456`. * `deviceModel`: Matches error issues that occurred in the requested devices. Example: `deviceModel = \"google/walleye\" OR deviceModel = \"google/marlin\"`. * `deviceBrand`: Matches error issues that occurred in the requested device brands. Example: `deviceBrand = \"Google\". * `deviceType`: Matches error reports that occurred in the requested device types. Example: `deviceType = \"PHONE\"`. * `errorIssueType`: Matches error reports of the requested types only. Valid candidates: `JAVA_CRASH`, `NATIVE_CRASH`, `ANR`. Example: `errorIssueType = JAVA_CRASH OR errorIssueType = NATIVE_CRASH`. * `errorIssueId`: Matches error reports belonging to the requested error issue ids only. Example: `errorIssueId = 1234 OR errorIssueId = 4567`. * `appProcessState`: Matches error reports on the process state of an app, indicating whether an app runs in the foreground (user-visible) or background. Valid candidates: `FOREGROUND`, `BACKGROUND`. Example: `appProcessState = FOREGROUND`. * `isUserPerceived`: Matches error reports that are user-perceived. It is not accompanied by any operators. Example: `isUserPerceived`. ** Supported operators:** * Comparison operators: The only supported comparison operator is equality. The filtered field must appear on the left hand side of the comparison. * Logical Operators: Logical operators `AND` and `OR` can be used to build complex filters following a conjunctive normal form (CNF), i.e., conjunctions of disjunctions. The `OR` operator takes precedence over `AND` so the use of parenthesis is not necessary when building CNF. The `OR` operator is only supported to build disjunctions that apply to the same field, e.g., `versionCode = 123 OR versionCode = ANR`. The filter expression `versionCode = 123 OR errorIssueType = ANR` is not valid. ** Examples ** Some valid filtering expressions: * `versionCode = 123 AND errorIssueType = ANR` * `versionCode = 123 AND errorIssueType = OR errorIssueType = CRASH` * `versionCode = 123 AND (errorIssueType = OR errorIssueType = CRASH)`
        :type filter: str
        :param interval_end_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_end_time_day: int
        :param interval_end_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_end_time_hours: int
        :param interval_end_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_end_time_minutes: int
        :param interval_end_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_end_time_month: int
        :param interval_end_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_end_time_nanos: int
        :param interval_end_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_end_time_seconds: int
        :param interval_end_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_end_time_time_zone_id: str
        :param interval_end_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_end_time_time_zone_version: str
        :param interval_end_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_end_time_utc_offset: str
        :param interval_end_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_end_time_year: int
        :param interval_start_time_day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :type interval_start_time_day: int
        :param interval_start_time_hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.
        :type interval_start_time_hours: int
        :param interval_start_time_minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :type interval_start_time_minutes: int
        :param interval_start_time_month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :type interval_start_time_month: int
        :param interval_start_time_nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :type interval_start_time_nanos: int
        :param interval_start_time_seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :type interval_start_time_seconds: int
        :param interval_start_time_time_zone_id: IANA Time Zone Database time zone, e.g. \"America/New_York\".
        :type interval_start_time_time_zone_id: str
        :param interval_start_time_time_zone_version: Optional. IANA Time Zone Database version number, e.g. \"2019a\".
        :type interval_start_time_time_zone_version: str
        :param interval_start_time_utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :type interval_start_time_utc_offset: str
        :param interval_start_time_year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        :type interval_start_time_year: int
        :param page_size: The maximum number of reports to return. The service may return fewer than this value. If unspecified, at most 50 reports will be returned. The maximum value is 100; values above 100 will be coerced to 100.
        :type page_size: int
        :param page_token: A page token, received from a previous `SearchErrorReports` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `SearchErrorReports` must match the call that provided the page token.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_errors_reports_search_serialize(
            parent=parent,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            filter=filter,
            interval_end_time_day=interval_end_time_day,
            interval_end_time_hours=interval_end_time_hours,
            interval_end_time_minutes=interval_end_time_minutes,
            interval_end_time_month=interval_end_time_month,
            interval_end_time_nanos=interval_end_time_nanos,
            interval_end_time_seconds=interval_end_time_seconds,
            interval_end_time_time_zone_id=interval_end_time_time_zone_id,
            interval_end_time_time_zone_version=interval_end_time_time_zone_version,
            interval_end_time_utc_offset=interval_end_time_utc_offset,
            interval_end_time_year=interval_end_time_year,
            interval_start_time_day=interval_start_time_day,
            interval_start_time_hours=interval_start_time_hours,
            interval_start_time_minutes=interval_start_time_minutes,
            interval_start_time_month=interval_start_time_month,
            interval_start_time_nanos=interval_start_time_nanos,
            interval_start_time_seconds=interval_start_time_seconds,
            interval_start_time_time_zone_id=interval_start_time_time_zone_id,
            interval_start_time_time_zone_version=interval_start_time_time_zone_version,
            interval_start_time_utc_offset=interval_start_time_utc_offset,
            interval_start_time_year=interval_start_time_year,
            page_size=page_size,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1SearchErrorReportsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _playdeveloperreporting_vitals_errors_reports_search_serialize(
        self,
        parent,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        filter,
        interval_end_time_day,
        interval_end_time_hours,
        interval_end_time_minutes,
        interval_end_time_month,
        interval_end_time_nanos,
        interval_end_time_seconds,
        interval_end_time_time_zone_id,
        interval_end_time_time_zone_version,
        interval_end_time_utc_offset,
        interval_end_time_year,
        interval_start_time_day,
        interval_start_time_hours,
        interval_start_time_minutes,
        interval_start_time_month,
        interval_start_time_nanos,
        interval_start_time_seconds,
        interval_start_time_time_zone_id,
        interval_start_time_time_zone_version,
        interval_start_time_utc_offset,
        interval_start_time_year,
        page_size,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if parent is not None:
            _path_params['parent'] = parent
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if interval_end_time_day is not None:
            
            _query_params.append(('interval.endTime.day', interval_end_time_day))
            
        if interval_end_time_hours is not None:
            
            _query_params.append(('interval.endTime.hours', interval_end_time_hours))
            
        if interval_end_time_minutes is not None:
            
            _query_params.append(('interval.endTime.minutes', interval_end_time_minutes))
            
        if interval_end_time_month is not None:
            
            _query_params.append(('interval.endTime.month', interval_end_time_month))
            
        if interval_end_time_nanos is not None:
            
            _query_params.append(('interval.endTime.nanos', interval_end_time_nanos))
            
        if interval_end_time_seconds is not None:
            
            _query_params.append(('interval.endTime.seconds', interval_end_time_seconds))
            
        if interval_end_time_time_zone_id is not None:
            
            _query_params.append(('interval.endTime.timeZone.id', interval_end_time_time_zone_id))
            
        if interval_end_time_time_zone_version is not None:
            
            _query_params.append(('interval.endTime.timeZone.version', interval_end_time_time_zone_version))
            
        if interval_end_time_utc_offset is not None:
            
            _query_params.append(('interval.endTime.utcOffset', interval_end_time_utc_offset))
            
        if interval_end_time_year is not None:
            
            _query_params.append(('interval.endTime.year', interval_end_time_year))
            
        if interval_start_time_day is not None:
            
            _query_params.append(('interval.startTime.day', interval_start_time_day))
            
        if interval_start_time_hours is not None:
            
            _query_params.append(('interval.startTime.hours', interval_start_time_hours))
            
        if interval_start_time_minutes is not None:
            
            _query_params.append(('interval.startTime.minutes', interval_start_time_minutes))
            
        if interval_start_time_month is not None:
            
            _query_params.append(('interval.startTime.month', interval_start_time_month))
            
        if interval_start_time_nanos is not None:
            
            _query_params.append(('interval.startTime.nanos', interval_start_time_nanos))
            
        if interval_start_time_seconds is not None:
            
            _query_params.append(('interval.startTime.seconds', interval_start_time_seconds))
            
        if interval_start_time_time_zone_id is not None:
            
            _query_params.append(('interval.startTime.timeZone.id', interval_start_time_time_zone_id))
            
        if interval_start_time_time_zone_version is not None:
            
            _query_params.append(('interval.startTime.timeZone.version', interval_start_time_time_zone_version))
            
        if interval_start_time_utc_offset is not None:
            
            _query_params.append(('interval.startTime.utcOffset', interval_start_time_utc_offset))
            
        if interval_start_time_year is not None:
            
            _query_params.append(('interval.startTime.year', interval_start_time_year))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1alpha1/{parent}/errorReports:search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def playdeveloperreporting_vitals_stuckbackgroundwakelockrate_get(
        self,
        name: Annotated[StrictStr, Field(description="Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GooglePlayDeveloperReportingV1alpha1StuckBackgroundWakelockRateMetricSet:
        """playdeveloperreporting_vitals_stuckbackgroundwakelockrate_get

        Describes the properties of the metric set.

        :param name: Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_stuckbackgroundwakelockrate_get_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1StuckBackgroundWakelockRateMetricSet",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def playdeveloperreporting_vitals_stuckbackgroundwakelockrate_get_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GooglePlayDeveloperReportingV1alpha1StuckBackgroundWakelockRateMetricSet]:
        """playdeveloperreporting_vitals_stuckbackgroundwakelockrate_get

        Describes the properties of the metric set.

        :param name: Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_stuckbackgroundwakelockrate_get_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1StuckBackgroundWakelockRateMetricSet",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def playdeveloperreporting_vitals_stuckbackgroundwakelockrate_get_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """playdeveloperreporting_vitals_stuckbackgroundwakelockrate_get

        Describes the properties of the metric set.

        :param name: Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_stuckbackgroundwakelockrate_get_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1StuckBackgroundWakelockRateMetricSet",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _playdeveloperreporting_vitals_stuckbackgroundwakelockrate_get_serialize(
        self,
        name,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1alpha1/{name}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def playdeveloperreporting_vitals_stuckbackgroundwakelockrate_query(
        self,
        name: Annotated[StrictStr, Field(description="Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request: Optional[GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetResponse:
        """playdeveloperreporting_vitals_stuckbackgroundwakelockrate_query

        Queries the metrics in the metric set.

        :param name: Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request:
        :type google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request: GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_stuckbackgroundwakelockrate_query_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request=google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def playdeveloperreporting_vitals_stuckbackgroundwakelockrate_query_with_http_info(
        self,
        name: Annotated[StrictStr, Field(description="Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request: Optional[GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetResponse]:
        """playdeveloperreporting_vitals_stuckbackgroundwakelockrate_query

        Queries the metrics in the metric set.

        :param name: Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request:
        :type google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request: GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_stuckbackgroundwakelockrate_query_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request=google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def playdeveloperreporting_vitals_stuckbackgroundwakelockrate_query_without_preload_content(
        self,
        name: Annotated[StrictStr, Field(description="Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request: Optional[GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """playdeveloperreporting_vitals_stuckbackgroundwakelockrate_query

        Queries the metrics in the metric set.

        :param name: Required. The resource name. Format: apps/{app}/stuckBackgroundWakelockRateMetricSet (required)
        :type name: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request:
        :type google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request: GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._playdeveloperreporting_vitals_stuckbackgroundwakelockrate_query_serialize(
            name=name,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request=google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GooglePlayDeveloperReportingV1alpha1QueryStuckBackgroundWakelockRateMetricSetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _playdeveloperreporting_vitals_stuckbackgroundwakelockrate_query_serialize(
        self,
        name,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if name is not None:
            _path_params['name'] = name
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request is not None:
            _body_params = google_play_developer_reporting_v1alpha1_query_stuck_background_wakelock_rate_metric_set_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1alpha1/{name}:query',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


