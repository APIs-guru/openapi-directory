# coding: utf-8

"""
    Service Networking API

    Provides automatic management of network configurations necessary for certain services.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.subnetwork import Subnetwork
from typing import Optional, Set
from typing_extensions import Self

class RangeReservation(BaseModel):
    """
    Represents a range reservation.
    """ # noqa: E501
    ip_prefix_length: Optional[StrictInt] = Field(default=None, description="Required. The size of the desired subnet. Use usual CIDR range notation. For example, '29' to find unused x.x.x.x/29 CIDR range. The goal is to determine if one of the allocated ranges has enough free space for a subnet of the requested size. GCE disallows subnets with prefix_length > 29", alias="ipPrefixLength")
    requested_ranges: Optional[List[StrictStr]] = Field(default=None, description="Optional. The name of one or more allocated IP address ranges associated with this private service access connection. If no range names are provided all ranges associated with this connection will be considered. If a CIDR range with the specified IP prefix length is not available within these ranges the validation fails.", alias="requestedRanges")
    secondary_range_ip_prefix_lengths: Optional[List[StrictInt]] = Field(default=None, description="Optional. The size of the desired secondary ranges for the subnet. Use usual CIDR range notation. For example, '29' to find unused x.x.x.x/29 CIDR range. The goal is to determine that the allocated ranges have enough free space for all the requested secondary ranges. GCE disallows subnets with prefix_length > 29", alias="secondaryRangeIpPrefixLengths")
    subnetwork_candidates: Optional[List[Subnetwork]] = Field(default=None, description="Optional. List of subnetwork candidates to validate. The required input fields are `name`, `network`, and `region`. Subnetworks from this list which exist will be returned in the response with the `ip_cidr_range`, `secondary_ip_cider_ranges`, and `outside_allocation` fields set.", alias="subnetworkCandidates")
    __properties: ClassVar[List[str]] = ["ipPrefixLength", "requestedRanges", "secondaryRangeIpPrefixLengths", "subnetworkCandidates"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RangeReservation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in subnetwork_candidates (list)
        _items = []
        if self.subnetwork_candidates:
            for _item_subnetwork_candidates in self.subnetwork_candidates:
                if _item_subnetwork_candidates:
                    _items.append(_item_subnetwork_candidates.to_dict())
            _dict['subnetworkCandidates'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RangeReservation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ipPrefixLength": obj.get("ipPrefixLength"),
            "requestedRanges": obj.get("requestedRanges"),
            "secondaryRangeIpPrefixLengths": obj.get("secondaryRangeIpPrefixLengths"),
            "subnetworkCandidates": [Subnetwork.from_dict(_item) for _item in obj["subnetworkCandidates"]] if obj.get("subnetworkCandidates") is not None else None
        })
        return _obj


