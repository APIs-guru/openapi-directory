# coding: utf-8

"""
    Cloud Pub/Sub API

    Provides reliable, many-to-many, asynchronous messaging between applications. 

    The version of the OpenAPI document: v1beta1a
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, Dict, Optional
from typing_extensions import Annotated
from openapi_client.models.acknowledge_request import AcknowledgeRequest
from openapi_client.models.list_subscriptions_response import ListSubscriptionsResponse
from openapi_client.models.modify_ack_deadline_request import ModifyAckDeadlineRequest
from openapi_client.models.modify_push_config_request import ModifyPushConfigRequest
from openapi_client.models.pull_batch_request import PullBatchRequest
from openapi_client.models.pull_batch_response import PullBatchResponse
from openapi_client.models.pull_request import PullRequest
from openapi_client.models.pull_response import PullResponse
from openapi_client.models.subscription import Subscription

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class SubscriptionsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def pubsub_subscriptions_acknowledge(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        acknowledge_request: Optional[AcknowledgeRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """pubsub_subscriptions_acknowledge

        Acknowledges a particular received message: the Pub/Sub system can remove the given message from the subscription. Acknowledging a message whose Ack deadline has expired may succeed, but the message could have been already redelivered. Acknowledging a message more than once will not result in an error. This is only used for messages received via pull.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param acknowledge_request:
        :type acknowledge_request: AcknowledgeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_acknowledge_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            acknowledge_request=acknowledge_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pubsub_subscriptions_acknowledge_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        acknowledge_request: Optional[AcknowledgeRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """pubsub_subscriptions_acknowledge

        Acknowledges a particular received message: the Pub/Sub system can remove the given message from the subscription. Acknowledging a message whose Ack deadline has expired may succeed, but the message could have been already redelivered. Acknowledging a message more than once will not result in an error. This is only used for messages received via pull.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param acknowledge_request:
        :type acknowledge_request: AcknowledgeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_acknowledge_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            acknowledge_request=acknowledge_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pubsub_subscriptions_acknowledge_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        acknowledge_request: Optional[AcknowledgeRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pubsub_subscriptions_acknowledge

        Acknowledges a particular received message: the Pub/Sub system can remove the given message from the subscription. Acknowledging a message whose Ack deadline has expired may succeed, but the message could have been already redelivered. Acknowledging a message more than once will not result in an error. This is only used for messages received via pull.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param acknowledge_request:
        :type acknowledge_request: AcknowledgeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_acknowledge_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            acknowledge_request=acknowledge_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pubsub_subscriptions_acknowledge_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        acknowledge_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if acknowledge_request is not None:
            _body_params = acknowledge_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1beta1a/subscriptions/acknowledge',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pubsub_subscriptions_create(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        subscription: Optional[Subscription] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Subscription:
        """pubsub_subscriptions_create

        Creates a subscription on a given topic for a given subscriber. If the subscription already exists, returns ALREADY_EXISTS. If the corresponding topic doesn't exist, returns NOT_FOUND. If the name is not provided in the request, the server will assign a random name for this subscription on the same project as the topic.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param subscription:
        :type subscription: Subscription
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_create_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            subscription=subscription,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Subscription",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pubsub_subscriptions_create_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        subscription: Optional[Subscription] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Subscription]:
        """pubsub_subscriptions_create

        Creates a subscription on a given topic for a given subscriber. If the subscription already exists, returns ALREADY_EXISTS. If the corresponding topic doesn't exist, returns NOT_FOUND. If the name is not provided in the request, the server will assign a random name for this subscription on the same project as the topic.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param subscription:
        :type subscription: Subscription
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_create_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            subscription=subscription,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Subscription",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pubsub_subscriptions_create_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        subscription: Optional[Subscription] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pubsub_subscriptions_create

        Creates a subscription on a given topic for a given subscriber. If the subscription already exists, returns ALREADY_EXISTS. If the corresponding topic doesn't exist, returns NOT_FOUND. If the name is not provided in the request, the server will assign a random name for this subscription on the same project as the topic.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param subscription:
        :type subscription: Subscription
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_create_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            subscription=subscription,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Subscription",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pubsub_subscriptions_create_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        subscription,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if subscription is not None:
            _body_params = subscription


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1beta1a/subscriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pubsub_subscriptions_delete(
        self,
        subscription: Annotated[StrictStr, Field(description="The subscription to delete.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """pubsub_subscriptions_delete

        Deletes an existing subscription. All pending messages in the subscription are immediately dropped. Calls to Pull after deletion will return NOT_FOUND.

        :param subscription: The subscription to delete. (required)
        :type subscription: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_delete_serialize(
            subscription=subscription,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pubsub_subscriptions_delete_with_http_info(
        self,
        subscription: Annotated[StrictStr, Field(description="The subscription to delete.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """pubsub_subscriptions_delete

        Deletes an existing subscription. All pending messages in the subscription are immediately dropped. Calls to Pull after deletion will return NOT_FOUND.

        :param subscription: The subscription to delete. (required)
        :type subscription: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_delete_serialize(
            subscription=subscription,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pubsub_subscriptions_delete_without_preload_content(
        self,
        subscription: Annotated[StrictStr, Field(description="The subscription to delete.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pubsub_subscriptions_delete

        Deletes an existing subscription. All pending messages in the subscription are immediately dropped. Calls to Pull after deletion will return NOT_FOUND.

        :param subscription: The subscription to delete. (required)
        :type subscription: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_delete_serialize(
            subscription=subscription,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pubsub_subscriptions_delete_serialize(
        self,
        subscription,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription is not None:
            _path_params['subscription'] = subscription
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1beta1a/subscriptions/{subscription}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pubsub_subscriptions_get(
        self,
        subscription: Annotated[StrictStr, Field(description="The name of the subscription to get.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Subscription:
        """pubsub_subscriptions_get

        Gets the configuration details of a subscription.

        :param subscription: The name of the subscription to get. (required)
        :type subscription: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_get_serialize(
            subscription=subscription,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Subscription",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pubsub_subscriptions_get_with_http_info(
        self,
        subscription: Annotated[StrictStr, Field(description="The name of the subscription to get.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Subscription]:
        """pubsub_subscriptions_get

        Gets the configuration details of a subscription.

        :param subscription: The name of the subscription to get. (required)
        :type subscription: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_get_serialize(
            subscription=subscription,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Subscription",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pubsub_subscriptions_get_without_preload_content(
        self,
        subscription: Annotated[StrictStr, Field(description="The name of the subscription to get.")],
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pubsub_subscriptions_get

        Gets the configuration details of a subscription.

        :param subscription: The name of the subscription to get. (required)
        :type subscription: str
        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_get_serialize(
            subscription=subscription,
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Subscription",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pubsub_subscriptions_get_serialize(
        self,
        subscription,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if subscription is not None:
            _path_params['subscription'] = subscription
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1beta1a/subscriptions/{subscription}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pubsub_subscriptions_list(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        max_results: Annotated[Optional[StrictInt], Field(description="Maximum number of subscriptions to return.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The value obtained in the last ListSubscriptionsResponse for continuation.")] = None,
        query: Annotated[Optional[StrictStr], Field(description="A valid label query expression.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListSubscriptionsResponse:
        """pubsub_subscriptions_list

        Lists matching subscriptions.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param max_results: Maximum number of subscriptions to return.
        :type max_results: int
        :param page_token: The value obtained in the last ListSubscriptionsResponse for continuation.
        :type page_token: str
        :param query: A valid label query expression.
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_list_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            max_results=max_results,
            page_token=page_token,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSubscriptionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pubsub_subscriptions_list_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        max_results: Annotated[Optional[StrictInt], Field(description="Maximum number of subscriptions to return.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The value obtained in the last ListSubscriptionsResponse for continuation.")] = None,
        query: Annotated[Optional[StrictStr], Field(description="A valid label query expression.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListSubscriptionsResponse]:
        """pubsub_subscriptions_list

        Lists matching subscriptions.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param max_results: Maximum number of subscriptions to return.
        :type max_results: int
        :param page_token: The value obtained in the last ListSubscriptionsResponse for continuation.
        :type page_token: str
        :param query: A valid label query expression.
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_list_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            max_results=max_results,
            page_token=page_token,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSubscriptionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pubsub_subscriptions_list_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        max_results: Annotated[Optional[StrictInt], Field(description="Maximum number of subscriptions to return.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The value obtained in the last ListSubscriptionsResponse for continuation.")] = None,
        query: Annotated[Optional[StrictStr], Field(description="A valid label query expression.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pubsub_subscriptions_list

        Lists matching subscriptions.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param max_results: Maximum number of subscriptions to return.
        :type max_results: int
        :param page_token: The value obtained in the last ListSubscriptionsResponse for continuation.
        :type page_token: str
        :param query: A valid label query expression.
        :type query: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_list_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            max_results=max_results,
            page_token=page_token,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSubscriptionsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pubsub_subscriptions_list_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        max_results,
        page_token,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        if max_results is not None:
            
            _query_params.append(('maxResults', max_results))
            
        if page_token is not None:
            
            _query_params.append(('pageToken', page_token))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1beta1a/subscriptions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pubsub_subscriptions_modify_ack_deadline(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        modify_ack_deadline_request: Optional[ModifyAckDeadlineRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """pubsub_subscriptions_modify_ack_deadline

        Modifies the Ack deadline for a message received from a pull request.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param modify_ack_deadline_request:
        :type modify_ack_deadline_request: ModifyAckDeadlineRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_modify_ack_deadline_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            modify_ack_deadline_request=modify_ack_deadline_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pubsub_subscriptions_modify_ack_deadline_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        modify_ack_deadline_request: Optional[ModifyAckDeadlineRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """pubsub_subscriptions_modify_ack_deadline

        Modifies the Ack deadline for a message received from a pull request.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param modify_ack_deadline_request:
        :type modify_ack_deadline_request: ModifyAckDeadlineRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_modify_ack_deadline_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            modify_ack_deadline_request=modify_ack_deadline_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pubsub_subscriptions_modify_ack_deadline_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        modify_ack_deadline_request: Optional[ModifyAckDeadlineRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pubsub_subscriptions_modify_ack_deadline

        Modifies the Ack deadline for a message received from a pull request.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param modify_ack_deadline_request:
        :type modify_ack_deadline_request: ModifyAckDeadlineRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_modify_ack_deadline_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            modify_ack_deadline_request=modify_ack_deadline_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pubsub_subscriptions_modify_ack_deadline_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        modify_ack_deadline_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if modify_ack_deadline_request is not None:
            _body_params = modify_ack_deadline_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1beta1a/subscriptions/modifyAckDeadline',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pubsub_subscriptions_modify_push_config(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        modify_push_config_request: Optional[ModifyPushConfigRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """pubsub_subscriptions_modify_push_config

        Modifies the PushConfig for a specified subscription. This method can be used to suspend the flow of messages to an endpoint by clearing the PushConfig field in the request. Messages will be accumulated for delivery even if no push configuration is defined or while the configuration is modified.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param modify_push_config_request:
        :type modify_push_config_request: ModifyPushConfigRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_modify_push_config_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            modify_push_config_request=modify_push_config_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pubsub_subscriptions_modify_push_config_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        modify_push_config_request: Optional[ModifyPushConfigRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """pubsub_subscriptions_modify_push_config

        Modifies the PushConfig for a specified subscription. This method can be used to suspend the flow of messages to an endpoint by clearing the PushConfig field in the request. Messages will be accumulated for delivery even if no push configuration is defined or while the configuration is modified.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param modify_push_config_request:
        :type modify_push_config_request: ModifyPushConfigRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_modify_push_config_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            modify_push_config_request=modify_push_config_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pubsub_subscriptions_modify_push_config_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        modify_push_config_request: Optional[ModifyPushConfigRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pubsub_subscriptions_modify_push_config

        Modifies the PushConfig for a specified subscription. This method can be used to suspend the flow of messages to an endpoint by clearing the PushConfig field in the request. Messages will be accumulated for delivery even if no push configuration is defined or while the configuration is modified.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param modify_push_config_request:
        :type modify_push_config_request: ModifyPushConfigRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_modify_push_config_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            modify_push_config_request=modify_push_config_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pubsub_subscriptions_modify_push_config_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        modify_push_config_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if modify_push_config_request is not None:
            _body_params = modify_push_config_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1beta1a/subscriptions/modifyPushConfig',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pubsub_subscriptions_pull(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        pull_request: Optional[PullRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PullResponse:
        """pubsub_subscriptions_pull

        Pulls a single message from the server. If return_immediately is true, and no messages are available in the subscription, this method returns FAILED_PRECONDITION. The system is free to return an UNAVAILABLE error if no messages are available in a reasonable amount of time (to reduce system load).

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param pull_request:
        :type pull_request: PullRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_pull_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            pull_request=pull_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pubsub_subscriptions_pull_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        pull_request: Optional[PullRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PullResponse]:
        """pubsub_subscriptions_pull

        Pulls a single message from the server. If return_immediately is true, and no messages are available in the subscription, this method returns FAILED_PRECONDITION. The system is free to return an UNAVAILABLE error if no messages are available in a reasonable amount of time (to reduce system load).

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param pull_request:
        :type pull_request: PullRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_pull_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            pull_request=pull_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pubsub_subscriptions_pull_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        pull_request: Optional[PullRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pubsub_subscriptions_pull

        Pulls a single message from the server. If return_immediately is true, and no messages are available in the subscription, this method returns FAILED_PRECONDITION. The system is free to return an UNAVAILABLE error if no messages are available in a reasonable amount of time (to reduce system load).

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param pull_request:
        :type pull_request: PullRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_pull_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            pull_request=pull_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pubsub_subscriptions_pull_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        pull_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if pull_request is not None:
            _body_params = pull_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1beta1a/subscriptions/pull',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def pubsub_subscriptions_pull_batch(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        pull_batch_request: Optional[PullBatchRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PullBatchResponse:
        """pubsub_subscriptions_pull_batch

        Pulls messages from the server. Returns an empty list if there are no messages available in the backlog. The system is free to return UNAVAILABLE if there are too many pull requests outstanding for the given subscription.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param pull_batch_request:
        :type pull_batch_request: PullBatchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_pull_batch_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            pull_batch_request=pull_batch_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PullBatchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def pubsub_subscriptions_pull_batch_with_http_info(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        pull_batch_request: Optional[PullBatchRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PullBatchResponse]:
        """pubsub_subscriptions_pull_batch

        Pulls messages from the server. Returns an empty list if there are no messages available in the backlog. The system is free to return UNAVAILABLE if there are too many pull requests outstanding for the given subscription.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param pull_batch_request:
        :type pull_batch_request: PullBatchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_pull_batch_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            pull_batch_request=pull_batch_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PullBatchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def pubsub_subscriptions_pull_batch_without_preload_content(
        self,
        xgafv: Annotated[Optional[StrictStr], Field(description="V1 error format.")] = None,
        access_token: Annotated[Optional[StrictStr], Field(description="OAuth access token.")] = None,
        alt: Annotated[Optional[StrictStr], Field(description="Data format for response.")] = None,
        param_callback: Annotated[Optional[StrictStr], Field(description="JSONP")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Selector specifying which fields to include in a partial response.")] = None,
        key: Annotated[Optional[StrictStr], Field(description="API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.")] = None,
        oauth_token: Annotated[Optional[StrictStr], Field(description="OAuth 2.0 token for the current user.")] = None,
        pretty_print: Annotated[Optional[StrictBool], Field(description="Returns response with indentations and line breaks.")] = None,
        quota_user: Annotated[Optional[StrictStr], Field(description="Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.")] = None,
        upload_protocol: Annotated[Optional[StrictStr], Field(description="Upload protocol for media (e.g. \"raw\", \"multipart\").")] = None,
        upload_type: Annotated[Optional[StrictStr], Field(description="Legacy upload protocol for media (e.g. \"media\", \"multipart\").")] = None,
        pull_batch_request: Optional[PullBatchRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pubsub_subscriptions_pull_batch

        Pulls messages from the server. Returns an empty list if there are no messages available in the backlog. The system is free to return UNAVAILABLE if there are too many pull requests outstanding for the given subscription.

        :param xgafv: V1 error format.
        :type xgafv: str
        :param access_token: OAuth access token.
        :type access_token: str
        :param alt: Data format for response.
        :type alt: str
        :param param_callback: JSONP
        :type param_callback: str
        :param fields: Selector specifying which fields to include in a partial response.
        :type fields: str
        :param key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :type key: str
        :param oauth_token: OAuth 2.0 token for the current user.
        :type oauth_token: str
        :param pretty_print: Returns response with indentations and line breaks.
        :type pretty_print: bool
        :param quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :type quota_user: str
        :param upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :type upload_protocol: str
        :param upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :type upload_type: str
        :param pull_batch_request:
        :type pull_batch_request: PullBatchRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pubsub_subscriptions_pull_batch_serialize(
            xgafv=xgafv,
            access_token=access_token,
            alt=alt,
            param_callback=param_callback,
            fields=fields,
            key=key,
            oauth_token=oauth_token,
            pretty_print=pretty_print,
            quota_user=quota_user,
            upload_protocol=upload_protocol,
            upload_type=upload_type,
            pull_batch_request=pull_batch_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PullBatchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pubsub_subscriptions_pull_batch_serialize(
        self,
        xgafv,
        access_token,
        alt,
        param_callback,
        fields,
        key,
        oauth_token,
        pretty_print,
        quota_user,
        upload_protocol,
        upload_type,
        pull_batch_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if xgafv is not None:
            
            _query_params.append(('$.xgafv', xgafv))
            
        if access_token is not None:
            
            _query_params.append(('access_token', access_token))
            
        if alt is not None:
            
            _query_params.append(('alt', alt))
            
        if param_callback is not None:
            
            _query_params.append(('callback', param_callback))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if key is not None:
            
            _query_params.append(('key', key))
            
        if oauth_token is not None:
            
            _query_params.append(('oauth_token', oauth_token))
            
        if pretty_print is not None:
            
            _query_params.append(('prettyPrint', pretty_print))
            
        if quota_user is not None:
            
            _query_params.append(('quotaUser', quota_user))
            
        if upload_protocol is not None:
            
            _query_params.append(('upload_protocol', upload_protocol))
            
        if upload_type is not None:
            
            _query_params.append(('uploadType', upload_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if pull_batch_request is not None:
            _body_params = pull_batch_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Oauth2c', 
            'Oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1beta1a/subscriptions/pullBatch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


