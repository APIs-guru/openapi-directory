# coding: utf-8

"""
    Gmail Postmaster Tools API

    The Postmaster Tools API is a RESTful API that provides programmatic access to email traffic metrics (like spam reports, delivery errors etc) otherwise available through the Gmail Postmaster Tools UI currently.

    The version of the OpenAPI document: v1beta1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.delivery_error import DeliveryError
from openapi_client.models.feedback_loop import FeedbackLoop
from openapi_client.models.ip_reputation import IpReputation
from typing import Optional, Set
from typing_extensions import Self

class TrafficStats(BaseModel):
    """
    Email traffic statistics pertaining to a specific date.
    """ # noqa: E501
    delivery_errors: Optional[List[DeliveryError]] = Field(default=None, description="Delivery errors for the domain. This metric only pertains to traffic that passed [SPF](http://www.openspf.org/) or [DKIM](http://www.dkim.org/).", alias="deliveryErrors")
    dkim_success_ratio: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The ratio of mail that successfully authenticated with DKIM vs. all mail that attempted to authenticate with [DKIM](http://www.dkim.org/). Spoofed mail is excluded.", alias="dkimSuccessRatio")
    dmarc_success_ratio: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The ratio of mail that passed [DMARC](https://dmarc.org/) alignment checks vs all mail received from the domain that successfully authenticated with either of [SPF](http://www.openspf.org/) or [DKIM](http://www.dkim.org/).", alias="dmarcSuccessRatio")
    domain_reputation: Optional[StrictStr] = Field(default=None, description="Reputation of the domain.", alias="domainReputation")
    inbound_encryption_ratio: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The ratio of incoming mail (to Gmail), that passed secure transport (TLS) vs all mail received from that domain. This metric only pertains to traffic that passed [SPF](http://www.openspf.org/) or [DKIM](http://www.dkim.org/).", alias="inboundEncryptionRatio")
    ip_reputations: Optional[List[IpReputation]] = Field(default=None, description="Reputation information pertaining to the IP addresses of the email servers for the domain. There is exactly one entry for each reputation category except REPUTATION_CATEGORY_UNSPECIFIED.", alias="ipReputations")
    name: Optional[StrictStr] = Field(default=None, description="The resource name of the traffic statistics. Traffic statistic names have the form `domains/{domain}/trafficStats/{date}`, where domain_name is the fully qualified domain name (i.e., mymail.mydomain.com) of the domain this traffic statistics pertains to and date is the date in yyyymmdd format that these statistics corresponds to. For example: domains/mymail.mydomain.com/trafficStats/20160807")
    outbound_encryption_ratio: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The ratio of outgoing mail (from Gmail) that was accepted over secure transport (TLS).", alias="outboundEncryptionRatio")
    spammy_feedback_loops: Optional[List[FeedbackLoop]] = Field(default=None, description="Spammy [Feedback loop identifiers] (https://support.google.com/mail/answer/6254652) with their individual spam rates. This metric only pertains to traffic that is authenticated by [DKIM](http://www.dkim.org/).", alias="spammyFeedbackLoops")
    spf_success_ratio: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The ratio of mail that successfully authenticated with SPF vs. all mail that attempted to authenticate with [SPF](http://www.openspf.org/). Spoofed mail is excluded.", alias="spfSuccessRatio")
    user_reported_spam_ratio: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The ratio of user-report spam vs. email that was sent to the inbox. This is potentially inexact -- users may want to refer to the description of the interval fields userReportedSpamRatioLowerBound and userReportedSpamRatioUpperBound for more explicit accuracy guarantees. This metric only pertains to emails authenticated by [DKIM](http://www.dkim.org/).", alias="userReportedSpamRatio")
    user_reported_spam_ratio_lower_bound: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The lower bound of the confidence interval for the user reported spam ratio. If this field is set, then the value of userReportedSpamRatio is set to the midpoint of this interval and is thus inexact. However, the true ratio is guaranteed to be in between this lower bound and the corresponding upper bound 95% of the time. This metric only pertains to emails authenticated by [DKIM](http://www.dkim.org/).", alias="userReportedSpamRatioLowerBound")
    user_reported_spam_ratio_upper_bound: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The upper bound of the confidence interval for the user reported spam ratio. If this field is set, then the value of userReportedSpamRatio is set to the midpoint of this interval and is thus inexact. However, the true ratio is guaranteed to be in between this upper bound and the corresponding lower bound 95% of the time. This metric only pertains to emails authenticated by [DKIM](http://www.dkim.org/).", alias="userReportedSpamRatioUpperBound")
    __properties: ClassVar[List[str]] = ["deliveryErrors", "dkimSuccessRatio", "dmarcSuccessRatio", "domainReputation", "inboundEncryptionRatio", "ipReputations", "name", "outboundEncryptionRatio", "spammyFeedbackLoops", "spfSuccessRatio", "userReportedSpamRatio", "userReportedSpamRatioLowerBound", "userReportedSpamRatioUpperBound"]

    @field_validator('domain_reputation')
    def domain_reputation_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['REPUTATION_CATEGORY_UNSPECIFIED', 'HIGH', 'MEDIUM', 'LOW', 'BAD']):
            raise ValueError("must be one of enum values ('REPUTATION_CATEGORY_UNSPECIFIED', 'HIGH', 'MEDIUM', 'LOW', 'BAD')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TrafficStats from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in delivery_errors (list)
        _items = []
        if self.delivery_errors:
            for _item_delivery_errors in self.delivery_errors:
                if _item_delivery_errors:
                    _items.append(_item_delivery_errors.to_dict())
            _dict['deliveryErrors'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in ip_reputations (list)
        _items = []
        if self.ip_reputations:
            for _item_ip_reputations in self.ip_reputations:
                if _item_ip_reputations:
                    _items.append(_item_ip_reputations.to_dict())
            _dict['ipReputations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in spammy_feedback_loops (list)
        _items = []
        if self.spammy_feedback_loops:
            for _item_spammy_feedback_loops in self.spammy_feedback_loops:
                if _item_spammy_feedback_loops:
                    _items.append(_item_spammy_feedback_loops.to_dict())
            _dict['spammyFeedbackLoops'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TrafficStats from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "deliveryErrors": [DeliveryError.from_dict(_item) for _item in obj["deliveryErrors"]] if obj.get("deliveryErrors") is not None else None,
            "dkimSuccessRatio": obj.get("dkimSuccessRatio"),
            "dmarcSuccessRatio": obj.get("dmarcSuccessRatio"),
            "domainReputation": obj.get("domainReputation"),
            "inboundEncryptionRatio": obj.get("inboundEncryptionRatio"),
            "ipReputations": [IpReputation.from_dict(_item) for _item in obj["ipReputations"]] if obj.get("ipReputations") is not None else None,
            "name": obj.get("name"),
            "outboundEncryptionRatio": obj.get("outboundEncryptionRatio"),
            "spammyFeedbackLoops": [FeedbackLoop.from_dict(_item) for _item in obj["spammyFeedbackLoops"]] if obj.get("spammyFeedbackLoops") is not None else None,
            "spfSuccessRatio": obj.get("spfSuccessRatio"),
            "userReportedSpamRatio": obj.get("userReportedSpamRatio"),
            "userReportedSpamRatioLowerBound": obj.get("userReportedSpamRatioLowerBound"),
            "userReportedSpamRatioUpperBound": obj.get("userReportedSpamRatioUpperBound")
        })
        return _obj


