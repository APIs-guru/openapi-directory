# coding: utf-8

"""
    Android Management API

    The Android Management API provides remote enterprise management of Android devices and apps.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.clear_apps_data_params import ClearAppsDataParams
from openapi_client.models.clear_apps_data_status import ClearAppsDataStatus
from openapi_client.models.start_lost_mode_params import StartLostModeParams
from openapi_client.models.start_lost_mode_status import StartLostModeStatus
from openapi_client.models.stop_lost_mode_status import StopLostModeStatus
from typing import Optional, Set
from typing_extensions import Self

class Command(BaseModel):
    """
    A command.
    """ # noqa: E501
    clear_apps_data_params: Optional[ClearAppsDataParams] = Field(default=None, alias="clearAppsDataParams")
    clear_apps_data_status: Optional[ClearAppsDataStatus] = Field(default=None, alias="clearAppsDataStatus")
    create_time: Optional[StrictStr] = Field(default=None, description="The timestamp at which the command was created. The timestamp is automatically generated by the server.", alias="createTime")
    duration: Optional[StrictStr] = Field(default=None, description="The duration for which the command is valid. The command will expire if not executed by the device during this time. The default duration if unspecified is ten minutes. There is no maximum duration.")
    error_code: Optional[StrictStr] = Field(default=None, description="If the command failed, an error code explaining the failure. This is not set when the command is cancelled by the caller.", alias="errorCode")
    new_password: Optional[StrictStr] = Field(default=None, description="For commands of type RESET_PASSWORD, optionally specifies the new password. Note: The new password must be at least 6 characters long if it is numeric in case of Android 14 devices. Else the command will fail with INVALID_VALUE.", alias="newPassword")
    reset_password_flags: Optional[List[StrictStr]] = Field(default=None, description="For commands of type RESET_PASSWORD, optionally specifies flags.", alias="resetPasswordFlags")
    start_lost_mode_params: Optional[StartLostModeParams] = Field(default=None, alias="startLostModeParams")
    start_lost_mode_status: Optional[StartLostModeStatus] = Field(default=None, alias="startLostModeStatus")
    stop_lost_mode_params: Optional[Dict[str, Any]] = Field(default=None, description="Parameters associated with the STOP_LOST_MODE command to take the device out of lost mode.", alias="stopLostModeParams")
    stop_lost_mode_status: Optional[StopLostModeStatus] = Field(default=None, alias="stopLostModeStatus")
    type: Optional[StrictStr] = Field(default=None, description="The type of the command.")
    user_name: Optional[StrictStr] = Field(default=None, description="The resource name of the user that owns the device in the form enterprises/{enterpriseId}/users/{userId}. This is automatically generated by the server based on the device the command is sent to.", alias="userName")
    __properties: ClassVar[List[str]] = ["clearAppsDataParams", "clearAppsDataStatus", "createTime", "duration", "errorCode", "newPassword", "resetPasswordFlags", "startLostModeParams", "startLostModeStatus", "stopLostModeParams", "stopLostModeStatus", "type", "userName"]

    @field_validator('error_code')
    def error_code_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['COMMAND_ERROR_CODE_UNSPECIFIED', 'UNKNOWN', 'API_LEVEL', 'MANAGEMENT_MODE', 'INVALID_VALUE', 'UNSUPPORTED']):
            raise ValueError("must be one of enum values ('COMMAND_ERROR_CODE_UNSPECIFIED', 'UNKNOWN', 'API_LEVEL', 'MANAGEMENT_MODE', 'INVALID_VALUE', 'UNSUPPORTED')")
        return value

    @field_validator('reset_password_flags')
    def reset_password_flags_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['RESET_PASSWORD_FLAG_UNSPECIFIED', 'REQUIRE_ENTRY', 'DO_NOT_ASK_CREDENTIALS_ON_BOOT', 'LOCK_NOW']):
                raise ValueError("each list item must be one of ('RESET_PASSWORD_FLAG_UNSPECIFIED', 'REQUIRE_ENTRY', 'DO_NOT_ASK_CREDENTIALS_ON_BOOT', 'LOCK_NOW')")
        return value

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['COMMAND_TYPE_UNSPECIFIED', 'LOCK', 'RESET_PASSWORD', 'REBOOT', 'RELINQUISH_OWNERSHIP', 'CLEAR_APP_DATA', 'START_LOST_MODE', 'STOP_LOST_MODE']):
            raise ValueError("must be one of enum values ('COMMAND_TYPE_UNSPECIFIED', 'LOCK', 'RESET_PASSWORD', 'REBOOT', 'RELINQUISH_OWNERSHIP', 'CLEAR_APP_DATA', 'START_LOST_MODE', 'STOP_LOST_MODE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Command from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of clear_apps_data_params
        if self.clear_apps_data_params:
            _dict['clearAppsDataParams'] = self.clear_apps_data_params.to_dict()
        # override the default output from pydantic by calling `to_dict()` of clear_apps_data_status
        if self.clear_apps_data_status:
            _dict['clearAppsDataStatus'] = self.clear_apps_data_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of start_lost_mode_params
        if self.start_lost_mode_params:
            _dict['startLostModeParams'] = self.start_lost_mode_params.to_dict()
        # override the default output from pydantic by calling `to_dict()` of start_lost_mode_status
        if self.start_lost_mode_status:
            _dict['startLostModeStatus'] = self.start_lost_mode_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stop_lost_mode_status
        if self.stop_lost_mode_status:
            _dict['stopLostModeStatus'] = self.stop_lost_mode_status.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Command from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "clearAppsDataParams": ClearAppsDataParams.from_dict(obj["clearAppsDataParams"]) if obj.get("clearAppsDataParams") is not None else None,
            "clearAppsDataStatus": ClearAppsDataStatus.from_dict(obj["clearAppsDataStatus"]) if obj.get("clearAppsDataStatus") is not None else None,
            "createTime": obj.get("createTime"),
            "duration": obj.get("duration"),
            "errorCode": obj.get("errorCode"),
            "newPassword": obj.get("newPassword"),
            "resetPasswordFlags": obj.get("resetPasswordFlags"),
            "startLostModeParams": StartLostModeParams.from_dict(obj["startLostModeParams"]) if obj.get("startLostModeParams") is not None else None,
            "startLostModeStatus": StartLostModeStatus.from_dict(obj["startLostModeStatus"]) if obj.get("startLostModeStatus") is not None else None,
            "stopLostModeParams": obj.get("stopLostModeParams"),
            "stopLostModeStatus": StopLostModeStatus.from_dict(obj["stopLostModeStatus"]) if obj.get("stopLostModeStatus") is not None else None,
            "type": obj.get("type"),
            "userName": obj.get("userName")
        })
        return _obj


