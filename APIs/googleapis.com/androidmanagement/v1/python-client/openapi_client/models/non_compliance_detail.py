# coding: utf-8

"""
    Android Management API

    The Android Management API provides remote enterprise management of Android devices and apps.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.specific_non_compliance_context import SpecificNonComplianceContext
from typing import Optional, Set
from typing_extensions import Self

class NonComplianceDetail(BaseModel):
    """
    Provides detail about non-compliance with a policy setting.
    """ # noqa: E501
    current_value: Optional[Any] = Field(default=None, description="If the policy setting could not be applied, the current value of the setting on the device.", alias="currentValue")
    field_path: Optional[StrictStr] = Field(default=None, description="For settings with nested fields, if a particular nested field is out of compliance, this specifies the full path to the offending field. The path is formatted in the same way the policy JSON field would be referenced in JavaScript, that is: 1) For object-typed fields, the field name is followed by a dot then by a subfield name. 2) For array-typed fields, the field name is followed by the array index enclosed in brackets. For example, to indicate a problem with the url field in the externalData field in the 3rd application, the path would be applications[2].externalData.url", alias="fieldPath")
    installation_failure_reason: Optional[StrictStr] = Field(default=None, description="If package_name is set and the non-compliance reason is APP_NOT_INSTALLED or APP_NOT_UPDATED, the detailed reason the app can't be installed or updated.", alias="installationFailureReason")
    non_compliance_reason: Optional[StrictStr] = Field(default=None, description="The reason the device is not in compliance with the setting.", alias="nonComplianceReason")
    package_name: Optional[StrictStr] = Field(default=None, description="The package name indicating which app is out of compliance, if applicable.", alias="packageName")
    setting_name: Optional[StrictStr] = Field(default=None, description="The name of the policy setting. This is the JSON field name of a top-level Policy field.", alias="settingName")
    specific_non_compliance_context: Optional[SpecificNonComplianceContext] = Field(default=None, alias="specificNonComplianceContext")
    specific_non_compliance_reason: Optional[StrictStr] = Field(default=None, description="The policy-specific reason the device is not in compliance with the setting.", alias="specificNonComplianceReason")
    __properties: ClassVar[List[str]] = ["currentValue", "fieldPath", "installationFailureReason", "nonComplianceReason", "packageName", "settingName", "specificNonComplianceContext", "specificNonComplianceReason"]

    @field_validator('installation_failure_reason')
    def installation_failure_reason_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['INSTALLATION_FAILURE_REASON_UNSPECIFIED', 'INSTALLATION_FAILURE_REASON_UNKNOWN', 'IN_PROGRESS', 'NOT_FOUND', 'NOT_COMPATIBLE_WITH_DEVICE', 'NOT_APPROVED', 'PERMISSIONS_NOT_ACCEPTED', 'NOT_AVAILABLE_IN_COUNTRY', 'NO_LICENSES_REMAINING', 'NOT_ENROLLED', 'USER_INVALID', 'NETWORK_ERROR_UNRELIABLE_CONNECTION', 'INSUFFICIENT_STORAGE']):
            raise ValueError("must be one of enum values ('INSTALLATION_FAILURE_REASON_UNSPECIFIED', 'INSTALLATION_FAILURE_REASON_UNKNOWN', 'IN_PROGRESS', 'NOT_FOUND', 'NOT_COMPATIBLE_WITH_DEVICE', 'NOT_APPROVED', 'PERMISSIONS_NOT_ACCEPTED', 'NOT_AVAILABLE_IN_COUNTRY', 'NO_LICENSES_REMAINING', 'NOT_ENROLLED', 'USER_INVALID', 'NETWORK_ERROR_UNRELIABLE_CONNECTION', 'INSUFFICIENT_STORAGE')")
        return value

    @field_validator('non_compliance_reason')
    def non_compliance_reason_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['NON_COMPLIANCE_REASON_UNSPECIFIED', 'API_LEVEL', 'MANAGEMENT_MODE', 'USER_ACTION', 'INVALID_VALUE', 'APP_NOT_INSTALLED', 'UNSUPPORTED', 'APP_INSTALLED', 'PENDING', 'APP_INCOMPATIBLE', 'APP_NOT_UPDATED', 'DEVICE_INCOMPATIBLE']):
            raise ValueError("must be one of enum values ('NON_COMPLIANCE_REASON_UNSPECIFIED', 'API_LEVEL', 'MANAGEMENT_MODE', 'USER_ACTION', 'INVALID_VALUE', 'APP_NOT_INSTALLED', 'UNSUPPORTED', 'APP_INSTALLED', 'PENDING', 'APP_INCOMPATIBLE', 'APP_NOT_UPDATED', 'DEVICE_INCOMPATIBLE')")
        return value

    @field_validator('specific_non_compliance_reason')
    def specific_non_compliance_reason_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SPECIFIC_NON_COMPLIANCE_REASON_UNSPECIFIED', 'PASSWORD_POLICIES_USER_CREDENTIALS_CONFIRMATION_REQUIRED', 'PASSWORD_POLICIES_PASSWORD_EXPIRED', 'PASSWORD_POLICIES_PASSWORD_NOT_SUFFICIENT', 'ONC_WIFI_INVALID_VALUE', 'ONC_WIFI_API_LEVEL', 'ONC_WIFI_INVALID_ENTERPRISE_CONFIG', 'ONC_WIFI_USER_SHOULD_REMOVE_NETWORK', 'ONC_WIFI_KEY_PAIR_ALIAS_NOT_CORRESPONDING_TO_EXISTING_KEY']):
            raise ValueError("must be one of enum values ('SPECIFIC_NON_COMPLIANCE_REASON_UNSPECIFIED', 'PASSWORD_POLICIES_USER_CREDENTIALS_CONFIRMATION_REQUIRED', 'PASSWORD_POLICIES_PASSWORD_EXPIRED', 'PASSWORD_POLICIES_PASSWORD_NOT_SUFFICIENT', 'ONC_WIFI_INVALID_VALUE', 'ONC_WIFI_API_LEVEL', 'ONC_WIFI_INVALID_ENTERPRISE_CONFIG', 'ONC_WIFI_USER_SHOULD_REMOVE_NETWORK', 'ONC_WIFI_KEY_PAIR_ALIAS_NOT_CORRESPONDING_TO_EXISTING_KEY')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of NonComplianceDetail from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of specific_non_compliance_context
        if self.specific_non_compliance_context:
            _dict['specificNonComplianceContext'] = self.specific_non_compliance_context.to_dict()
        # set to None if current_value (nullable) is None
        # and model_fields_set contains the field
        if self.current_value is None and "current_value" in self.model_fields_set:
            _dict['currentValue'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of NonComplianceDetail from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "currentValue": obj.get("currentValue"),
            "fieldPath": obj.get("fieldPath"),
            "installationFailureReason": obj.get("installationFailureReason"),
            "nonComplianceReason": obj.get("nonComplianceReason"),
            "packageName": obj.get("packageName"),
            "settingName": obj.get("settingName"),
            "specificNonComplianceContext": SpecificNonComplianceContext.from_dict(obj["specificNonComplianceContext"]) if obj.get("specificNonComplianceContext") is not None else None,
            "specificNonComplianceReason": obj.get("specificNonComplianceReason")
        })
        return _obj


