# coding: utf-8

"""
    Google Chat API

    The Google Chat API lets you build Chat apps to integrate your services with Google Chat and manage Chat resources such as spaces, members, and messages.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.inputs import Inputs
from openapi_client.models.time_zone import TimeZone
from typing import Optional, Set
from typing_extensions import Self

class CommonEventObject(BaseModel):
    """
    Represents information about the user's client, such as locale, host app, and platform. For Chat apps, `CommonEventObject` includes data submitted by users interacting with cards, like data entered in [dialogs](https://developers.google.com/chat/how-tos/dialogs).
    """ # noqa: E501
    form_inputs: Optional[Dict[str, Inputs]] = Field(default=None, description="A map containing the values that a user inputs in a widget from a card or dialog. The map keys are the string IDs assigned to each widget, and the values represent inputs to the widget. For details, see [Process information inputted by users](https://developers.google.com/chat/ui/read-form-data).", alias="formInputs")
    host_app: Optional[StrictStr] = Field(default=None, description="The hostApp enum which indicates the app the add-on is invoked from. Always `CHAT` for Chat apps.", alias="hostApp")
    invoked_function: Optional[StrictStr] = Field(default=None, description="Name of the invoked function associated with the widget. Only set for Chat apps.", alias="invokedFunction")
    parameters: Optional[Dict[str, StrictStr]] = Field(default=None, description="Custom [parameters](/chat/api/reference/rest/v1/cards#ActionParameter) passed to the invoked function. Both keys and values must be strings.")
    platform: Optional[StrictStr] = Field(default=None, description="The platform enum which indicates the platform where the event originates (`WEB`, `IOS`, or `ANDROID`). Not supported by Chat apps.")
    time_zone: Optional[TimeZone] = Field(default=None, alias="timeZone")
    user_locale: Optional[StrictStr] = Field(default=None, description="The full `locale.displayName` in the format of [ISO 639 language code]-[ISO 3166 country/region code] such as \"en-US\".", alias="userLocale")
    __properties: ClassVar[List[str]] = ["formInputs", "hostApp", "invokedFunction", "parameters", "platform", "timeZone", "userLocale"]

    @field_validator('host_app')
    def host_app_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNSPECIFIED_HOST_APP', 'GMAIL', 'CALENDAR', 'DRIVE', 'DEMO', 'DOCS', 'MEET', 'SHEETS', 'SLIDES', 'DRAWINGS', 'CHAT', 'CHAT_IN_GMAIL']):
            raise ValueError("must be one of enum values ('UNSPECIFIED_HOST_APP', 'GMAIL', 'CALENDAR', 'DRIVE', 'DEMO', 'DOCS', 'MEET', 'SHEETS', 'SLIDES', 'DRAWINGS', 'CHAT', 'CHAT_IN_GMAIL')")
        return value

    @field_validator('platform')
    def platform_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNKNOWN_PLATFORM', 'WEB', 'IOS', 'ANDROID']):
            raise ValueError("must be one of enum values ('UNKNOWN_PLATFORM', 'WEB', 'IOS', 'ANDROID')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CommonEventObject from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in form_inputs (dict)
        _field_dict = {}
        if self.form_inputs:
            for _key_form_inputs in self.form_inputs:
                if self.form_inputs[_key_form_inputs]:
                    _field_dict[_key_form_inputs] = self.form_inputs[_key_form_inputs].to_dict()
            _dict['formInputs'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of time_zone
        if self.time_zone:
            _dict['timeZone'] = self.time_zone.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CommonEventObject from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "formInputs": dict(
                (_k, Inputs.from_dict(_v))
                for _k, _v in obj["formInputs"].items()
            )
            if obj.get("formInputs") is not None
            else None,
            "hostApp": obj.get("hostApp"),
            "invokedFunction": obj.get("invokedFunction"),
            "parameters": obj.get("parameters"),
            "platform": obj.get("platform"),
            "timeZone": TimeZone.from_dict(obj["timeZone"]) if obj.get("timeZone") is not None else None,
            "userLocale": obj.get("userLocale")
        })
        return _obj


