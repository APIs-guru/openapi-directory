# coding: utf-8

"""
    Google Chat API

    The Google Chat API lets you build Chat apps to integrate your services with Google Chat and manage Chat resources such as spaces, members, and messages.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.space_details import SpaceDetails
from typing import Optional, Set
from typing_extensions import Self

class Space(BaseModel):
    """
    A space in Google Chat. Spaces are conversations between two or more users or 1:1 messages between a user and a Chat app.
    """ # noqa: E501
    admin_installed: Optional[StrictBool] = Field(default=None, description="Output only. Whether the Chat app was installed by a Google Workspace administrator. Administrators can install a Chat app for their domain, organizational unit, or a group of users. Administrators can only install Chat apps for direct messaging between users and the app. To support admin install, your app must feature direct messaging.", alias="adminInstalled")
    create_time: Optional[StrictStr] = Field(default=None, description="Optional. Immutable. For spaces created in Chat, the time the space was created. This field is output only, except when used in import mode spaces. For import mode spaces, set this field to the historical timestamp at which the space was created in the source in order to preserve the original creation time. Only populated in the output when `spaceType` is `GROUP_CHAT` or `SPACE`.", alias="createTime")
    display_name: Optional[StrictStr] = Field(default=None, description="The space's display name. Required when [creating a space](https://developers.google.com/chat/api/reference/rest/v1/spaces/create). If you receive the error message `ALREADY_EXISTS` when creating a space or updating the `displayName`, try a different `displayName`. An existing space within the Google Workspace organization might already use this display name. For direct messages, this field might be empty. Supports up to 128 characters.", alias="displayName")
    external_user_allowed: Optional[StrictBool] = Field(default=None, description="Immutable. Whether this space permits any Google Chat user as a member. Input when creating a space in a Google Workspace organization. Omit this field when creating spaces in the following conditions: * The authenticated user uses a Google Account. By default, the space permits any Google Chat user. * The space is used to [import data to Google Chat] (https://developers.google.com/chat/api/guides/import-data-overview). Import mode spaces must only permit members from the same Google Workspace organization. For existing spaces, this field is output only.", alias="externalUserAllowed")
    import_mode: Optional[StrictBool] = Field(default=None, description="Optional. Whether this space is created in `Import Mode` as part of a data migration into Google Workspace. While spaces are being imported, they aren't visible to users until the import is complete.", alias="importMode")
    name: Optional[StrictStr] = Field(default=None, description="Resource name of the space. Format: `spaces/{space}`")
    single_user_bot_dm: Optional[StrictBool] = Field(default=None, description="Optional. Whether the space is a DM between a Chat app and a single human.", alias="singleUserBotDm")
    space_details: Optional[SpaceDetails] = Field(default=None, alias="spaceDetails")
    space_history_state: Optional[StrictStr] = Field(default=None, description="The message history state for messages and threads in this space.", alias="spaceHistoryState")
    space_threading_state: Optional[StrictStr] = Field(default=None, description="Output only. The threading state in the Chat space.", alias="spaceThreadingState")
    space_type: Optional[StrictStr] = Field(default=None, description="The type of space. Required when creating a space or updating the space type of a space. Output only for other usage.", alias="spaceType")
    threaded: Optional[StrictBool] = Field(default=None, description="Output only. Deprecated: Use `spaceThreadingState` instead. Whether messages are threaded in this space.")
    type: Optional[StrictStr] = Field(default=None, description="Output only. Deprecated: Use `space_type` instead. The type of a space.")
    __properties: ClassVar[List[str]] = ["adminInstalled", "createTime", "displayName", "externalUserAllowed", "importMode", "name", "singleUserBotDm", "spaceDetails", "spaceHistoryState", "spaceThreadingState", "spaceType", "threaded", "type"]

    @field_validator('space_history_state')
    def space_history_state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['HISTORY_STATE_UNSPECIFIED', 'HISTORY_OFF', 'HISTORY_ON']):
            raise ValueError("must be one of enum values ('HISTORY_STATE_UNSPECIFIED', 'HISTORY_OFF', 'HISTORY_ON')")
        return value

    @field_validator('space_threading_state')
    def space_threading_state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SPACE_THREADING_STATE_UNSPECIFIED', 'THREADED_MESSAGES', 'GROUPED_MESSAGES', 'UNTHREADED_MESSAGES']):
            raise ValueError("must be one of enum values ('SPACE_THREADING_STATE_UNSPECIFIED', 'THREADED_MESSAGES', 'GROUPED_MESSAGES', 'UNTHREADED_MESSAGES')")
        return value

    @field_validator('space_type')
    def space_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SPACE_TYPE_UNSPECIFIED', 'SPACE', 'GROUP_CHAT', 'DIRECT_MESSAGE']):
            raise ValueError("must be one of enum values ('SPACE_TYPE_UNSPECIFIED', 'SPACE', 'GROUP_CHAT', 'DIRECT_MESSAGE')")
        return value

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['TYPE_UNSPECIFIED', 'ROOM', 'DM']):
            raise ValueError("must be one of enum values ('TYPE_UNSPECIFIED', 'ROOM', 'DM')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Space from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "admin_installed",
            "space_threading_state",
            "threaded",
            "type",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of space_details
        if self.space_details:
            _dict['spaceDetails'] = self.space_details.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Space from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "adminInstalled": obj.get("adminInstalled"),
            "createTime": obj.get("createTime"),
            "displayName": obj.get("displayName"),
            "externalUserAllowed": obj.get("externalUserAllowed"),
            "importMode": obj.get("importMode"),
            "name": obj.get("name"),
            "singleUserBotDm": obj.get("singleUserBotDm"),
            "spaceDetails": SpaceDetails.from_dict(obj["spaceDetails"]) if obj.get("spaceDetails") is not None else None,
            "spaceHistoryState": obj.get("spaceHistoryState"),
            "spaceThreadingState": obj.get("spaceThreadingState"),
            "spaceType": obj.get("spaceType"),
            "threaded": obj.get("threaded"),
            "type": obj.get("type")
        })
        return _obj


