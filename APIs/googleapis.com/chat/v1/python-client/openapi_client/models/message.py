# coding: utf-8

"""
    Google Chat API

    The Google Chat API lets you build Chat apps to integrate your services with Google Chat and manage Chat resources such as spaces, members, and messages.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.action_response import ActionResponse
from openapi_client.models.annotation import Annotation
from openapi_client.models.attached_gif import AttachedGif
from openapi_client.models.attachment import Attachment
from openapi_client.models.card import Card
from openapi_client.models.card_with_id import CardWithId
from openapi_client.models.deletion_metadata import DeletionMetadata
from openapi_client.models.emoji_reaction_summary import EmojiReactionSummary
from openapi_client.models.matched_url import MatchedUrl
from openapi_client.models.quoted_message_metadata import QuotedMessageMetadata
from openapi_client.models.slash_command import SlashCommand
from openapi_client.models.space import Space
from openapi_client.models.thread import Thread
from openapi_client.models.user import User
from typing import Optional, Set
from typing_extensions import Self

class Message(BaseModel):
    """
    A message in a Google Chat space.
    """ # noqa: E501
    action_response: Optional[ActionResponse] = Field(default=None, alias="actionResponse")
    annotations: Optional[List[Annotation]] = Field(default=None, description="Output only. Annotations associated with the `text` in this message.")
    argument_text: Optional[StrictStr] = Field(default=None, description="Output only. Plain-text body of the message with all Chat app mentions stripped out.", alias="argumentText")
    attached_gifs: Optional[List[AttachedGif]] = Field(default=None, description="Output only. GIF images that are attached to the message.", alias="attachedGifs")
    attachment: Optional[List[Attachment]] = Field(default=None, description="User-uploaded attachment.")
    cards: Optional[List[Card]] = Field(default=None, description="Deprecated: Use `cards_v2` instead. Rich, formatted, and interactive cards that you can use to display UI elements such as: formatted texts, buttons, and clickable images. Cards are normally displayed below the plain-text body of the message. `cards` and `cards_v2` can have a maximum size of 32 KB.")
    cards_v2: Optional[List[CardWithId]] = Field(default=None, description="An array of [cards](https://developers.google.com/chat/api/reference/rest/v1/cards). Only Chat apps can create cards. If your Chat app [authenticates as a user](https://developers.google.com/chat/api/guides/auth/users), the messages can't contain cards. To learn about cards and how to create them, see [Design dynamic, interactive, and consistent UIs with cards](https://developers.google.com/chat/ui). [Card builder](https://addons.gsuite.google.com/uikit/builder)", alias="cardsV2")
    client_assigned_message_id: Optional[StrictStr] = Field(default=None, description="Optional. A custom ID for the message. You can use field to identify a message, or to get, delete, or update a message. To set a custom ID, specify the [`messageId`](https://developers.google.com/chat/api/reference/rest/v1/spaces.messages/create#body.QUERY_PARAMETERS.message_id) field when you create the message. For details, see [Name a message](https://developers.google.com/chat/api/guides/v1/messages/create#name_a_created_message).", alias="clientAssignedMessageId")
    create_time: Optional[StrictStr] = Field(default=None, description="Optional. Immutable. For spaces created in Chat, the time at which the message was created. This field is output only, except when used in import mode spaces. For import mode spaces, set this field to the historical timestamp at which the message was created in the source in order to preserve the original creation time.", alias="createTime")
    delete_time: Optional[StrictStr] = Field(default=None, description="Output only. The time at which the message was deleted in Google Chat. If the message is never deleted, this field is empty.", alias="deleteTime")
    deletion_metadata: Optional[DeletionMetadata] = Field(default=None, alias="deletionMetadata")
    emoji_reaction_summaries: Optional[List[EmojiReactionSummary]] = Field(default=None, description="Output only. The list of emoji reaction summaries on the message.", alias="emojiReactionSummaries")
    fallback_text: Optional[StrictStr] = Field(default=None, description="A plain-text description of the message's cards, used when the actual cards can't be displayed—for example, mobile notifications.", alias="fallbackText")
    formatted_text: Optional[StrictStr] = Field(default=None, description="Output only. Contains the message `text` with markups added to communicate formatting. This field might not capture all formatting visible in the UI, but includes the following: * [Markup syntax](https://developers.google.com/chat/format-messages) for bold, italic, strikethrough, monospace, and monospace block. * [User mentions](https://developers.google.com/chat/format-messages#messages-@mention) using the format ``. * Custom hyperlinks using the format `<{url}|{rendered_text}>` where the first string is the URL and the second is the rendered text—for example, ``. * Custom emoji using the format `:{emoji_name}:`—for example, `:smile:`. This doesn't apply to Unicode emoji, such as `U+1F600` for a grinning face emoji. For more information, see [View text formatting sent in a message](https://developers.google.com/chat/format-messages#view_text_formatting_sent_in_a_message)", alias="formattedText")
    last_update_time: Optional[StrictStr] = Field(default=None, description="Output only. The time at which the message was last edited by a user. If the message has never been edited, this field is empty.", alias="lastUpdateTime")
    matched_url: Optional[MatchedUrl] = Field(default=None, alias="matchedUrl")
    name: Optional[StrictStr] = Field(default=None, description="Resource name of the message. Format: `spaces/{space}/messages/{message}` Where `{space}` is the ID of the space where the message is posted and `{message}` is a system-assigned ID for the message. For example, `spaces/AAAAAAAAAAA/messages/BBBBBBBBBBB.BBBBBBBBBBB`. If you set a custom ID when you create a message, you can use this ID to specify the message in a request by replacing `{message}` with the value from the `clientAssignedMessageId` field. For example, `spaces/AAAAAAAAAAA/messages/client-custom-name`. For details, see [Name a message](https://developers.google.com/chat/api/guides/v1/messages/create#name_a_created_message).")
    private_message_viewer: Optional[User] = Field(default=None, alias="privateMessageViewer")
    quoted_message_metadata: Optional[QuotedMessageMetadata] = Field(default=None, alias="quotedMessageMetadata")
    sender: Optional[User] = None
    slash_command: Optional[SlashCommand] = Field(default=None, alias="slashCommand")
    space: Optional[Space] = None
    text: Optional[StrictStr] = Field(default=None, description="Plain-text body of the message. The first link to an image, video, or web page generates a [preview chip](https://developers.google.com/chat/how-tos/preview-links). You can also [@mention a Google Chat user](https://developers.google.com/chat/format-messages#messages-@mention), or everyone in the space. To learn about creating text messages, see [Send a text message](https://developers.google.com/chat/api/guides/v1/messages/create#create-text-messages).")
    thread: Optional[Thread] = None
    thread_reply: Optional[StrictBool] = Field(default=None, description="Output only. When `true`, the message is a response in a reply thread. When `false`, the message is visible in the space's top-level conversation as either the first message of a thread or a message with no threaded replies. If the space doesn't support reply in threads, this field is always `false`.", alias="threadReply")
    __properties: ClassVar[List[str]] = ["actionResponse", "annotations", "argumentText", "attachedGifs", "attachment", "cards", "cardsV2", "clientAssignedMessageId", "createTime", "deleteTime", "deletionMetadata", "emojiReactionSummaries", "fallbackText", "formattedText", "lastUpdateTime", "matchedUrl", "name", "privateMessageViewer", "quotedMessageMetadata", "sender", "slashCommand", "space", "text", "thread", "threadReply"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Message from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "annotations",
            "argument_text",
            "attached_gifs",
            "delete_time",
            "emoji_reaction_summaries",
            "formatted_text",
            "last_update_time",
            "thread_reply",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of action_response
        if self.action_response:
            _dict['actionResponse'] = self.action_response.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in annotations (list)
        _items = []
        if self.annotations:
            for _item_annotations in self.annotations:
                if _item_annotations:
                    _items.append(_item_annotations.to_dict())
            _dict['annotations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in attached_gifs (list)
        _items = []
        if self.attached_gifs:
            for _item_attached_gifs in self.attached_gifs:
                if _item_attached_gifs:
                    _items.append(_item_attached_gifs.to_dict())
            _dict['attachedGifs'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in attachment (list)
        _items = []
        if self.attachment:
            for _item_attachment in self.attachment:
                if _item_attachment:
                    _items.append(_item_attachment.to_dict())
            _dict['attachment'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in cards (list)
        _items = []
        if self.cards:
            for _item_cards in self.cards:
                if _item_cards:
                    _items.append(_item_cards.to_dict())
            _dict['cards'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in cards_v2 (list)
        _items = []
        if self.cards_v2:
            for _item_cards_v2 in self.cards_v2:
                if _item_cards_v2:
                    _items.append(_item_cards_v2.to_dict())
            _dict['cardsV2'] = _items
        # override the default output from pydantic by calling `to_dict()` of deletion_metadata
        if self.deletion_metadata:
            _dict['deletionMetadata'] = self.deletion_metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in emoji_reaction_summaries (list)
        _items = []
        if self.emoji_reaction_summaries:
            for _item_emoji_reaction_summaries in self.emoji_reaction_summaries:
                if _item_emoji_reaction_summaries:
                    _items.append(_item_emoji_reaction_summaries.to_dict())
            _dict['emojiReactionSummaries'] = _items
        # override the default output from pydantic by calling `to_dict()` of matched_url
        if self.matched_url:
            _dict['matchedUrl'] = self.matched_url.to_dict()
        # override the default output from pydantic by calling `to_dict()` of private_message_viewer
        if self.private_message_viewer:
            _dict['privateMessageViewer'] = self.private_message_viewer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of quoted_message_metadata
        if self.quoted_message_metadata:
            _dict['quotedMessageMetadata'] = self.quoted_message_metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sender
        if self.sender:
            _dict['sender'] = self.sender.to_dict()
        # override the default output from pydantic by calling `to_dict()` of slash_command
        if self.slash_command:
            _dict['slashCommand'] = self.slash_command.to_dict()
        # override the default output from pydantic by calling `to_dict()` of space
        if self.space:
            _dict['space'] = self.space.to_dict()
        # override the default output from pydantic by calling `to_dict()` of thread
        if self.thread:
            _dict['thread'] = self.thread.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Message from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "actionResponse": ActionResponse.from_dict(obj["actionResponse"]) if obj.get("actionResponse") is not None else None,
            "annotations": [Annotation.from_dict(_item) for _item in obj["annotations"]] if obj.get("annotations") is not None else None,
            "argumentText": obj.get("argumentText"),
            "attachedGifs": [AttachedGif.from_dict(_item) for _item in obj["attachedGifs"]] if obj.get("attachedGifs") is not None else None,
            "attachment": [Attachment.from_dict(_item) for _item in obj["attachment"]] if obj.get("attachment") is not None else None,
            "cards": [Card.from_dict(_item) for _item in obj["cards"]] if obj.get("cards") is not None else None,
            "cardsV2": [CardWithId.from_dict(_item) for _item in obj["cardsV2"]] if obj.get("cardsV2") is not None else None,
            "clientAssignedMessageId": obj.get("clientAssignedMessageId"),
            "createTime": obj.get("createTime"),
            "deleteTime": obj.get("deleteTime"),
            "deletionMetadata": DeletionMetadata.from_dict(obj["deletionMetadata"]) if obj.get("deletionMetadata") is not None else None,
            "emojiReactionSummaries": [EmojiReactionSummary.from_dict(_item) for _item in obj["emojiReactionSummaries"]] if obj.get("emojiReactionSummaries") is not None else None,
            "fallbackText": obj.get("fallbackText"),
            "formattedText": obj.get("formattedText"),
            "lastUpdateTime": obj.get("lastUpdateTime"),
            "matchedUrl": MatchedUrl.from_dict(obj["matchedUrl"]) if obj.get("matchedUrl") is not None else None,
            "name": obj.get("name"),
            "privateMessageViewer": User.from_dict(obj["privateMessageViewer"]) if obj.get("privateMessageViewer") is not None else None,
            "quotedMessageMetadata": QuotedMessageMetadata.from_dict(obj["quotedMessageMetadata"]) if obj.get("quotedMessageMetadata") is not None else None,
            "sender": User.from_dict(obj["sender"]) if obj.get("sender") is not None else None,
            "slashCommand": SlashCommand.from_dict(obj["slashCommand"]) if obj.get("slashCommand") is not None else None,
            "space": Space.from_dict(obj["space"]) if obj.get("space") is not None else None,
            "text": obj.get("text"),
            "thread": Thread.from_dict(obj["thread"]) if obj.get("thread") is not None else None,
            "threadReply": obj.get("threadReply")
        })
        return _obj


