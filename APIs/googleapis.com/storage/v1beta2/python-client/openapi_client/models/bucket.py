# coding: utf-8

"""
    Cloud Storage JSON API

    Lets you store and retrieve potentially-large, immutable data objects.

    The version of the OpenAPI document: v1beta2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.bucket_access_control import BucketAccessControl
from openapi_client.models.bucket_cors_inner import BucketCorsInner
from openapi_client.models.bucket_lifecycle import BucketLifecycle
from openapi_client.models.bucket_logging import BucketLogging
from openapi_client.models.bucket_owner import BucketOwner
from openapi_client.models.bucket_versioning import BucketVersioning
from openapi_client.models.bucket_website import BucketWebsite
from openapi_client.models.object_access_control import ObjectAccessControl
from typing import Optional, Set
from typing_extensions import Self

class Bucket(BaseModel):
    """
    A bucket.
    """ # noqa: E501
    acl: Optional[List[BucketAccessControl]] = Field(default=None, description="Access controls on the bucket.")
    cors: Optional[List[BucketCorsInner]] = Field(default=None, description="The bucket's Cross-Origin Resource Sharing (CORS) configuration.")
    default_object_acl: Optional[List[ObjectAccessControl]] = Field(default=None, description="Default access controls to apply to new objects when no ACL is provided.", alias="defaultObjectAcl")
    etag: Optional[StrictStr] = Field(default=None, description="HTTP 1.1 Entity tag for the bucket.")
    id: Optional[StrictStr] = Field(default=None, description="The ID of the bucket.")
    kind: Optional[StrictStr] = Field(default='storage#bucket', description="The kind of item this is. For buckets, this is always storage#bucket.")
    lifecycle: Optional[BucketLifecycle] = None
    location: Optional[StrictStr] = Field(default=None, description="The location of the bucket. Object data for objects in the bucket resides in physical storage within this region. Typical values are US and EU. Defaults to US. See the developer's guide for the authoritative list.")
    logging: Optional[BucketLogging] = None
    metageneration: Optional[StrictStr] = Field(default=None, description="The metadata generation of this bucket.")
    name: Optional[StrictStr] = Field(default=None, description="The name of the bucket.")
    owner: Optional[BucketOwner] = None
    self_link: Optional[StrictStr] = Field(default=None, description="The URI of this bucket.", alias="selfLink")
    storage_class: Optional[StrictStr] = Field(default=None, description="The bucket's storage class. This defines how objects in the bucket are stored and determines the SLA and the cost of storage. Typical values are STANDARD and DURABLE_REDUCED_AVAILABILITY. Defaults to STANDARD. See the developer's guide for the authoritative list.", alias="storageClass")
    time_created: Optional[datetime] = Field(default=None, description="Creation time of the bucket in RFC 3339 format.", alias="timeCreated")
    versioning: Optional[BucketVersioning] = None
    website: Optional[BucketWebsite] = None
    __properties: ClassVar[List[str]] = ["acl", "cors", "defaultObjectAcl", "etag", "id", "kind", "lifecycle", "location", "logging", "metageneration", "name", "owner", "selfLink", "storageClass", "timeCreated", "versioning", "website"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Bucket from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in acl (list)
        _items = []
        if self.acl:
            for _item_acl in self.acl:
                if _item_acl:
                    _items.append(_item_acl.to_dict())
            _dict['acl'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in cors (list)
        _items = []
        if self.cors:
            for _item_cors in self.cors:
                if _item_cors:
                    _items.append(_item_cors.to_dict())
            _dict['cors'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in default_object_acl (list)
        _items = []
        if self.default_object_acl:
            for _item_default_object_acl in self.default_object_acl:
                if _item_default_object_acl:
                    _items.append(_item_default_object_acl.to_dict())
            _dict['defaultObjectAcl'] = _items
        # override the default output from pydantic by calling `to_dict()` of lifecycle
        if self.lifecycle:
            _dict['lifecycle'] = self.lifecycle.to_dict()
        # override the default output from pydantic by calling `to_dict()` of logging
        if self.logging:
            _dict['logging'] = self.logging.to_dict()
        # override the default output from pydantic by calling `to_dict()` of owner
        if self.owner:
            _dict['owner'] = self.owner.to_dict()
        # override the default output from pydantic by calling `to_dict()` of versioning
        if self.versioning:
            _dict['versioning'] = self.versioning.to_dict()
        # override the default output from pydantic by calling `to_dict()` of website
        if self.website:
            _dict['website'] = self.website.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Bucket from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "acl": [BucketAccessControl.from_dict(_item) for _item in obj["acl"]] if obj.get("acl") is not None else None,
            "cors": [BucketCorsInner.from_dict(_item) for _item in obj["cors"]] if obj.get("cors") is not None else None,
            "defaultObjectAcl": [ObjectAccessControl.from_dict(_item) for _item in obj["defaultObjectAcl"]] if obj.get("defaultObjectAcl") is not None else None,
            "etag": obj.get("etag"),
            "id": obj.get("id"),
            "kind": obj.get("kind") if obj.get("kind") is not None else 'storage#bucket',
            "lifecycle": BucketLifecycle.from_dict(obj["lifecycle"]) if obj.get("lifecycle") is not None else None,
            "location": obj.get("location"),
            "logging": BucketLogging.from_dict(obj["logging"]) if obj.get("logging") is not None else None,
            "metageneration": obj.get("metageneration"),
            "name": obj.get("name"),
            "owner": BucketOwner.from_dict(obj["owner"]) if obj.get("owner") is not None else None,
            "selfLink": obj.get("selfLink"),
            "storageClass": obj.get("storageClass"),
            "timeCreated": obj.get("timeCreated"),
            "versioning": BucketVersioning.from_dict(obj["versioning"]) if obj.get("versioning") is not None else None,
            "website": BucketWebsite.from_dict(obj["website"]) if obj.get("website") is not None else None
        })
        return _obj


