# coding: utf-8

"""
    Cloud Storage JSON API

    Stores and retrieves potentially large, immutable data objects.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.bucket_access_control import BucketAccessControl
from openapi_client.models.bucket_autoclass import BucketAutoclass
from openapi_client.models.bucket_billing import BucketBilling
from openapi_client.models.bucket_cors_inner import BucketCorsInner
from openapi_client.models.bucket_custom_placement_config import BucketCustomPlacementConfig
from openapi_client.models.bucket_encryption import BucketEncryption
from openapi_client.models.bucket_hierarchical_namespace import BucketHierarchicalNamespace
from openapi_client.models.bucket_iam_configuration import BucketIamConfiguration
from openapi_client.models.bucket_lifecycle import BucketLifecycle
from openapi_client.models.bucket_logging import BucketLogging
from openapi_client.models.bucket_object_retention import BucketObjectRetention
from openapi_client.models.bucket_owner import BucketOwner
from openapi_client.models.bucket_retention_policy import BucketRetentionPolicy
from openapi_client.models.bucket_soft_delete_policy import BucketSoftDeletePolicy
from openapi_client.models.bucket_versioning import BucketVersioning
from openapi_client.models.bucket_website import BucketWebsite
from openapi_client.models.object_access_control import ObjectAccessControl
from typing import Optional, Set
from typing_extensions import Self

class Bucket(BaseModel):
    """
    A bucket.
    """ # noqa: E501
    acl: Optional[List[BucketAccessControl]] = Field(default=None, description="Access controls on the bucket.")
    autoclass: Optional[BucketAutoclass] = None
    billing: Optional[BucketBilling] = None
    cors: Optional[List[BucketCorsInner]] = Field(default=None, description="The bucket's Cross-Origin Resource Sharing (CORS) configuration.")
    custom_placement_config: Optional[BucketCustomPlacementConfig] = Field(default=None, alias="customPlacementConfig")
    default_event_based_hold: Optional[StrictBool] = Field(default=None, description="The default value for event-based hold on newly created objects in this bucket. Event-based hold is a way to retain objects indefinitely until an event occurs, signified by the hold's release. After being released, such objects will be subject to bucket-level retention (if any). One sample use case of this flag is for banks to hold loan documents for at least 3 years after loan is paid in full. Here, bucket-level retention is 3 years and the event is loan being paid in full. In this example, these objects will be held intact for any number of years until the event has occurred (event-based hold on the object is released) and then 3 more years after that. That means retention duration of the objects begins from the moment event-based hold transitioned from true to false. Objects under event-based hold cannot be deleted, overwritten or archived until the hold is removed.", alias="defaultEventBasedHold")
    default_object_acl: Optional[List[ObjectAccessControl]] = Field(default=None, description="Default access controls to apply to new objects when no ACL is provided.", alias="defaultObjectAcl")
    encryption: Optional[BucketEncryption] = None
    etag: Optional[StrictStr] = Field(default=None, description="HTTP 1.1 Entity tag for the bucket.")
    hierarchical_namespace: Optional[BucketHierarchicalNamespace] = Field(default=None, alias="hierarchicalNamespace")
    iam_configuration: Optional[BucketIamConfiguration] = Field(default=None, alias="iamConfiguration")
    id: Optional[StrictStr] = Field(default=None, description="The ID of the bucket. For buckets, the id and name properties are the same.")
    kind: Optional[StrictStr] = Field(default='storage#bucket', description="The kind of item this is. For buckets, this is always storage#bucket.")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="User-provided labels, in key/value pairs.")
    lifecycle: Optional[BucketLifecycle] = None
    location: Optional[StrictStr] = Field(default=None, description="The location of the bucket. Object data for objects in the bucket resides in physical storage within this region. Defaults to US. See the developer's guide for the authoritative list.")
    location_type: Optional[StrictStr] = Field(default=None, description="The type of the bucket location.", alias="locationType")
    logging: Optional[BucketLogging] = None
    metageneration: Optional[StrictStr] = Field(default=None, description="The metadata generation of this bucket.")
    name: Optional[StrictStr] = Field(default=None, description="The name of the bucket.")
    object_retention: Optional[BucketObjectRetention] = Field(default=None, alias="objectRetention")
    owner: Optional[BucketOwner] = None
    project_number: Optional[StrictStr] = Field(default=None, description="The project number of the project the bucket belongs to.", alias="projectNumber")
    retention_policy: Optional[BucketRetentionPolicy] = Field(default=None, alias="retentionPolicy")
    rpo: Optional[StrictStr] = Field(default=None, description="The Recovery Point Objective (RPO) of this bucket. Set to ASYNC_TURBO to turn on Turbo Replication on a bucket.")
    satisfies_pzs: Optional[StrictBool] = Field(default=None, description="Reserved for future use.", alias="satisfiesPZS")
    self_link: Optional[StrictStr] = Field(default=None, description="The URI of this bucket.", alias="selfLink")
    soft_delete_policy: Optional[BucketSoftDeletePolicy] = Field(default=None, alias="softDeletePolicy")
    storage_class: Optional[StrictStr] = Field(default=None, description="The bucket's default storage class, used whenever no storageClass is specified for a newly-created object. This defines how objects in the bucket are stored and determines the SLA and the cost of storage. Values include MULTI_REGIONAL, REGIONAL, STANDARD, NEARLINE, COLDLINE, ARCHIVE, and DURABLE_REDUCED_AVAILABILITY. If this value is not specified when the bucket is created, it will default to STANDARD. For more information, see storage classes.", alias="storageClass")
    time_created: Optional[datetime] = Field(default=None, description="The creation time of the bucket in RFC 3339 format.", alias="timeCreated")
    updated: Optional[datetime] = Field(default=None, description="The modification time of the bucket in RFC 3339 format.")
    versioning: Optional[BucketVersioning] = None
    website: Optional[BucketWebsite] = None
    __properties: ClassVar[List[str]] = ["acl", "autoclass", "billing", "cors", "customPlacementConfig", "defaultEventBasedHold", "defaultObjectAcl", "encryption", "etag", "hierarchicalNamespace", "iamConfiguration", "id", "kind", "labels", "lifecycle", "location", "locationType", "logging", "metageneration", "name", "objectRetention", "owner", "projectNumber", "retentionPolicy", "rpo", "satisfiesPZS", "selfLink", "softDeletePolicy", "storageClass", "timeCreated", "updated", "versioning", "website"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Bucket from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in acl (list)
        _items = []
        if self.acl:
            for _item_acl in self.acl:
                if _item_acl:
                    _items.append(_item_acl.to_dict())
            _dict['acl'] = _items
        # override the default output from pydantic by calling `to_dict()` of autoclass
        if self.autoclass:
            _dict['autoclass'] = self.autoclass.to_dict()
        # override the default output from pydantic by calling `to_dict()` of billing
        if self.billing:
            _dict['billing'] = self.billing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in cors (list)
        _items = []
        if self.cors:
            for _item_cors in self.cors:
                if _item_cors:
                    _items.append(_item_cors.to_dict())
            _dict['cors'] = _items
        # override the default output from pydantic by calling `to_dict()` of custom_placement_config
        if self.custom_placement_config:
            _dict['customPlacementConfig'] = self.custom_placement_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in default_object_acl (list)
        _items = []
        if self.default_object_acl:
            for _item_default_object_acl in self.default_object_acl:
                if _item_default_object_acl:
                    _items.append(_item_default_object_acl.to_dict())
            _dict['defaultObjectAcl'] = _items
        # override the default output from pydantic by calling `to_dict()` of encryption
        if self.encryption:
            _dict['encryption'] = self.encryption.to_dict()
        # override the default output from pydantic by calling `to_dict()` of hierarchical_namespace
        if self.hierarchical_namespace:
            _dict['hierarchicalNamespace'] = self.hierarchical_namespace.to_dict()
        # override the default output from pydantic by calling `to_dict()` of iam_configuration
        if self.iam_configuration:
            _dict['iamConfiguration'] = self.iam_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of lifecycle
        if self.lifecycle:
            _dict['lifecycle'] = self.lifecycle.to_dict()
        # override the default output from pydantic by calling `to_dict()` of logging
        if self.logging:
            _dict['logging'] = self.logging.to_dict()
        # override the default output from pydantic by calling `to_dict()` of object_retention
        if self.object_retention:
            _dict['objectRetention'] = self.object_retention.to_dict()
        # override the default output from pydantic by calling `to_dict()` of owner
        if self.owner:
            _dict['owner'] = self.owner.to_dict()
        # override the default output from pydantic by calling `to_dict()` of retention_policy
        if self.retention_policy:
            _dict['retentionPolicy'] = self.retention_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of soft_delete_policy
        if self.soft_delete_policy:
            _dict['softDeletePolicy'] = self.soft_delete_policy.to_dict()
        # override the default output from pydantic by calling `to_dict()` of versioning
        if self.versioning:
            _dict['versioning'] = self.versioning.to_dict()
        # override the default output from pydantic by calling `to_dict()` of website
        if self.website:
            _dict['website'] = self.website.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Bucket from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "acl": [BucketAccessControl.from_dict(_item) for _item in obj["acl"]] if obj.get("acl") is not None else None,
            "autoclass": BucketAutoclass.from_dict(obj["autoclass"]) if obj.get("autoclass") is not None else None,
            "billing": BucketBilling.from_dict(obj["billing"]) if obj.get("billing") is not None else None,
            "cors": [BucketCorsInner.from_dict(_item) for _item in obj["cors"]] if obj.get("cors") is not None else None,
            "customPlacementConfig": BucketCustomPlacementConfig.from_dict(obj["customPlacementConfig"]) if obj.get("customPlacementConfig") is not None else None,
            "defaultEventBasedHold": obj.get("defaultEventBasedHold"),
            "defaultObjectAcl": [ObjectAccessControl.from_dict(_item) for _item in obj["defaultObjectAcl"]] if obj.get("defaultObjectAcl") is not None else None,
            "encryption": BucketEncryption.from_dict(obj["encryption"]) if obj.get("encryption") is not None else None,
            "etag": obj.get("etag"),
            "hierarchicalNamespace": BucketHierarchicalNamespace.from_dict(obj["hierarchicalNamespace"]) if obj.get("hierarchicalNamespace") is not None else None,
            "iamConfiguration": BucketIamConfiguration.from_dict(obj["iamConfiguration"]) if obj.get("iamConfiguration") is not None else None,
            "id": obj.get("id"),
            "kind": obj.get("kind") if obj.get("kind") is not None else 'storage#bucket',
            "labels": obj.get("labels"),
            "lifecycle": BucketLifecycle.from_dict(obj["lifecycle"]) if obj.get("lifecycle") is not None else None,
            "location": obj.get("location"),
            "locationType": obj.get("locationType"),
            "logging": BucketLogging.from_dict(obj["logging"]) if obj.get("logging") is not None else None,
            "metageneration": obj.get("metageneration"),
            "name": obj.get("name"),
            "objectRetention": BucketObjectRetention.from_dict(obj["objectRetention"]) if obj.get("objectRetention") is not None else None,
            "owner": BucketOwner.from_dict(obj["owner"]) if obj.get("owner") is not None else None,
            "projectNumber": obj.get("projectNumber"),
            "retentionPolicy": BucketRetentionPolicy.from_dict(obj["retentionPolicy"]) if obj.get("retentionPolicy") is not None else None,
            "rpo": obj.get("rpo"),
            "satisfiesPZS": obj.get("satisfiesPZS"),
            "selfLink": obj.get("selfLink"),
            "softDeletePolicy": BucketSoftDeletePolicy.from_dict(obj["softDeletePolicy"]) if obj.get("softDeletePolicy") is not None else None,
            "storageClass": obj.get("storageClass"),
            "timeCreated": obj.get("timeCreated"),
            "updated": obj.get("updated"),
            "versioning": BucketVersioning.from_dict(obj["versioning"]) if obj.get("versioning") is not None else None,
            "website": BucketWebsite.from_dict(obj["website"]) if obj.get("website") is not None else None
        })
        return _obj


